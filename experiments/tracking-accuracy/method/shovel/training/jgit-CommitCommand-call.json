{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "H:\\Projects\\eclipse\\jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "CommitCommand.java",
  "functionName": "call",
  "functionId": "call",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
  "functionStartLine": 161,
  "functionEndLine": 315,
  "numCommitsSeen": 64,
  "timeTaken": 4886,
  "changeHistory": [
    "9441508682b7d7c935dd976e4082cacff4a5efeb",
    "57a263f1823d164142235a72072154f0568cb61c",
    "4c236ff4bbf664fd177a33f42517b0eef52510c8",
    "36a53d1a3cdd66c40b6db241a75a28293f22f5e1",
    "da43d8d79890e561a993a4d90e6a2724a04cd60f",
    "1ed5382b37453309580e11a11cf4c3bb134813fa",
    "d726f0c1e02c196e2dd87de53b54338be15503f1",
    "efeb02bf2bed32ef94d5c4891404f551cdc6957f",
    "26fd56f167e6377777e6d46c14779183e4bcb55a",
    "494e893c541b5cf465b362c69354c08d7a81c249",
    "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
    "a2b33a8ac33c63eea82f300b802a26af54a3d61d",
    "c93a59330249677cd990820b59558a39f747009f",
    "65027d8bb429581635f51d0c588493e5c458cc25",
    "1f51aecf95d61e48618d478a693f73dcf1ec1146",
    "549034500a55ffc8f401fd73a74d8dc55f096d2f",
    "315f1cfa5c63f4d3355704c80d00ac1323a36171",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
    "79f33419ec073edf31a1db16ae9b11e69ee997a1",
    "c96b40d5921d68edb96afad38b9c171388af4e05",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
    "2539b1ee096266b7fcca64545f93d7c08ab30f53",
    "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
    "6e10aa42e90a25b82f00f0c27574f57ffa9e4a25",
    "fd963a9180af73b6a05a5c1a2af6dd7168899170",
    "9830baf48dd5b3feb9780a3cc1d83b79e1d4c46b",
    "a490afedba12676a53338bc52b729b9bb779f3a1",
    "cda64073fd45d3056486b96877e4ff6dd12dbaa5",
    "6df5d3397c5c9354409d21a8e207a061f2e6efc2",
    "22b285695a2980824c15363ef5fec709ebc3d434",
    "b46b635c0389e01a55b2f9c490e5b6c54a8ce640",
    "ab57af08e83d5d042bb954ad280389b34ca36d0e",
    "94207f0a43a44261b8170d3cdba3028059775d9d",
    "a1d5f5b6b526d086a0963c634a38edb6789a4594",
    "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
    "ffe0614d4db653cbcd48c19e9f599fd87cdcfaba",
    "88530a179e2ddfa81de5cc441a27d66521334608",
    "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
    "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d",
    "f3fb5824ba45197787bc4ffb81fafcd576c60291"
  ],
  "changeHistoryShort": {
    "9441508682b7d7c935dd976e4082cacff4a5efeb": "Ybodychange",
    "57a263f1823d164142235a72072154f0568cb61c": "Ybodychange",
    "4c236ff4bbf664fd177a33f42517b0eef52510c8": "Ybodychange",
    "36a53d1a3cdd66c40b6db241a75a28293f22f5e1": "Ybodychange",
    "da43d8d79890e561a993a4d90e6a2724a04cd60f": "Ybodychange",
    "1ed5382b37453309580e11a11cf4c3bb134813fa": "Ybodychange",
    "d726f0c1e02c196e2dd87de53b54338be15503f1": "Ybodychange",
    "efeb02bf2bed32ef94d5c4891404f551cdc6957f": "Ybodychange",
    "26fd56f167e6377777e6d46c14779183e4bcb55a": "Ymultichange(Yexceptionschange,Ybodychange)",
    "494e893c541b5cf465b362c69354c08d7a81c249": "Ymultichange(Yexceptionschange,Ybodychange)",
    "e0fbae5dc3fc2345383ec373b384fcca10e64f24": "Ybodychange",
    "a2b33a8ac33c63eea82f300b802a26af54a3d61d": "Ybodychange",
    "c93a59330249677cd990820b59558a39f747009f": "Ybodychange",
    "65027d8bb429581635f51d0c588493e5c458cc25": "Ybodychange",
    "1f51aecf95d61e48618d478a693f73dcf1ec1146": "Ybodychange",
    "549034500a55ffc8f401fd73a74d8dc55f096d2f": "Ybodychange",
    "315f1cfa5c63f4d3355704c80d00ac1323a36171": "Ybodychange",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": "Ybodychange",
    "79f33419ec073edf31a1db16ae9b11e69ee997a1": "Ybodychange",
    "c96b40d5921d68edb96afad38b9c171388af4e05": "Ybodychange",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": "Ymultichange(Yexceptionschange,Ybodychange)",
    "2539b1ee096266b7fcca64545f93d7c08ab30f53": "Ybodychange",
    "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f": "Ybodychange",
    "6e10aa42e90a25b82f00f0c27574f57ffa9e4a25": "Ybodychange",
    "fd963a9180af73b6a05a5c1a2af6dd7168899170": "Ybodychange",
    "9830baf48dd5b3feb9780a3cc1d83b79e1d4c46b": "Ybodychange",
    "a490afedba12676a53338bc52b729b9bb779f3a1": "Ybodychange",
    "cda64073fd45d3056486b96877e4ff6dd12dbaa5": "Ybodychange",
    "6df5d3397c5c9354409d21a8e207a061f2e6efc2": "Ybodychange",
    "22b285695a2980824c15363ef5fec709ebc3d434": "Ybodychange",
    "b46b635c0389e01a55b2f9c490e5b6c54a8ce640": "Ybodychange",
    "ab57af08e83d5d042bb954ad280389b34ca36d0e": "Ybodychange",
    "94207f0a43a44261b8170d3cdba3028059775d9d": "Ybodychange",
    "a1d5f5b6b526d086a0963c634a38edb6789a4594": "Ybodychange",
    "515deaf7e503738b4c53c3c2dfd6d7acab3bef18": "Ybodychange",
    "ffe0614d4db653cbcd48c19e9f599fd87cdcfaba": "Ybodychange",
    "88530a179e2ddfa81de5cc441a27d66521334608": "Ybodychange",
    "6ca9843f3ebbea152969a8b795efce1d4ff15dbf": "Ymultichange(Yexceptionschange,Ybodychange)",
    "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d": "Ybodychange",
    "f3fb5824ba45197787bc4ffb81fafcd576c60291": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9441508682b7d7c935dd976e4082cacff4a5efeb": {
      "type": "Ybodychange",
      "commitMessage": "Fix misspelled class name: EmtpyCommitException -\u003e EmptyCommitException\n\nChange-Id: I55196020146f26951988988c14ac9a6f85061ae2\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018-03-10, 1:40 p.m.",
      "commitName": "9441508682b7d7c935dd976e4082cacff4a5efeb",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2018-03-05, 7:48 p.m.",
      "commitNameOld": "3393f78210862b3ccd954f029d831ef783b35c89",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 4.74,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n\t\t\tAbortedByHookException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\n\t\t\tif (!noVerify) {\n\t\t\t\tHooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME))\n\t\t\t\t\t\t.call();\n\t\t\t}\n\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare()) {\n\t\t\t\ttry (Git git \u003d new Git(repo)) {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\tif (!noVerify) {\n\t\t\t\tmessage \u003d Hooks\n\t\t\t\t\t\t.commitMsg(repo,\n\t\t\t\t\t\t\t\thookOutRedirect.get(CommitMsgHook.NAME))\n\t\t\t\t\t\t.setCommitMessage(message).call();\n\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t// (unresolved conflicts)\n\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\tif (insertChangeId)\n\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t// Check for empty commits\n\t\t\t\tif (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n\t\t\t\t\tRevCommit headCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\theadCommit.getTree();\n\t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n\t\t\t\t\t\tthrow new EmptyCommitException(\n\t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\todi.flush();\n\n\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tif (!useDefaultReflogMessage) {\n\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t} else {\n\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n\t\t\t\t\t\t\tfalse);\n\t\t\t\t}\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\telse\n\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\tswitch (rc) {\n\t\t\t\tcase NEW:\n\t\t\t\tcase FORCED:\n\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t}\n\t\t\t\t\tHooks.postCommit(repo,\n\t\t\t\t\t\t\thookOutRedirect.get(PostCommitHook.NAME)).call();\n\n\t\t\t\t\treturn revCommit;\n\t\t\t\t}\n\t\t\t\tcase REJECTED:\n\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 161,
      "functionName": "call",
      "diff": "@@ -1,155 +1,155 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME))\n \t\t\t\t\t\t.call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all \u0026\u0026 !repo.isBare()) {\n \t\t\t\ttry (Git git \u003d new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n \t\t\t\tmessage \u003d Hooks\n \t\t\t\t\t\t.commitMsg(repo,\n \t\t\t\t\t\t\t\thookOutRedirect.get(CommitMsgHook.NAME))\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\tif (insertChangeId)\n \t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t// Check for empty commits\n \t\t\t\tif (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n \t\t\t\t\tRevCommit headCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\theadCommit.getTree();\n \t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n-\t\t\t\t\t\tthrow new EmtpyCommitException(\n+\t\t\t\t\t\tthrow new EmptyCommitException(\n \t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \n \t\t\t\tcommit.setParentIds(parents);\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\todi.flush();\n \n \t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tif (!useDefaultReflogMessage) {\n \t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t} else {\n \t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n \t\t\t\t\t\t\tfalse);\n \t\t\t\t}\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\telse\n \t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FORCED:\n \t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n \t\t\t\t\tHooks.postCommit(repo,\n \t\t\t\t\t\t\thookOutRedirect.get(PostCommitHook.NAME)).call();\n \n \t\t\t\t\treturn revCommit;\n \t\t\t\t}\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n \t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "57a263f1823d164142235a72072154f0568cb61c": {
      "type": "Ybodychange",
      "commitMessage": "Add support for post-commit hooks\n\nChange-Id: I6691b454404dd4db3c690ecfc7515de765bc2ef7\nSigned-off-by: Martin Goellnitz \u003cm.goellnitz@outlook.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016-09-13, 11:13 a.m.",
      "commitName": "57a263f1823d164142235a72072154f0568cb61c",
      "commitAuthor": "Martin Goellnitz",
      "commitDateOld": "2016-05-30, 6:11 p.m.",
      "commitNameOld": "4c236ff4bbf664fd177a33f42517b0eef52510c8",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 105.71,
      "commitsBetweenForRepo": 136,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n\t\t\tAbortedByHookException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\n\t\t\tif (!noVerify) {\n\t\t\t\tHooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME))\n\t\t\t\t\t\t.call();\n\t\t\t}\n\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare()) {\n\t\t\t\ttry (Git git \u003d new Git(repo)) {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\tif (!noVerify) {\n\t\t\t\tmessage \u003d Hooks\n\t\t\t\t\t\t.commitMsg(repo,\n\t\t\t\t\t\t\t\thookOutRedirect.get(CommitMsgHook.NAME))\n\t\t\t\t\t\t.setCommitMessage(message).call();\n\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t// (unresolved conflicts)\n\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\tif (insertChangeId)\n\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t// Check for empty commits\n\t\t\t\tif (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n\t\t\t\t\tRevCommit headCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\theadCommit.getTree();\n\t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n\t\t\t\t\t\tthrow new EmtpyCommitException(\n\t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\todi.flush();\n\n\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tif (!useDefaultReflogMessage) {\n\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t} else {\n\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n\t\t\t\t\t\t\tfalse);\n\t\t\t\t}\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\telse\n\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\tswitch (rc) {\n\t\t\t\tcase NEW:\n\t\t\t\tcase FORCED:\n\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t}\n\t\t\t\t\tHooks.postCommit(repo,\n\t\t\t\t\t\t\thookOutRedirect.get(PostCommitHook.NAME)).call();\n\n\t\t\t\t\treturn revCommit;\n\t\t\t\t}\n\t\t\t\tcase REJECTED:\n\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 171,
      "functionName": "call",
      "diff": "@@ -1,149 +1,155 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n-\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n+\t\t\t\tHooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME))\n+\t\t\t\t\t\t.call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all \u0026\u0026 !repo.isBare()) {\n \t\t\t\ttry (Git git \u003d new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n-\t\t\t\tmessage \u003d Hooks.commitMsg(repo, hookOutRedirect)\n+\t\t\t\tmessage \u003d Hooks\n+\t\t\t\t\t\t.commitMsg(repo,\n+\t\t\t\t\t\t\t\thookOutRedirect.get(CommitMsgHook.NAME))\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\tif (insertChangeId)\n \t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t// Check for empty commits\n \t\t\t\tif (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n \t\t\t\t\tRevCommit headCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\theadCommit.getTree();\n \t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n \t\t\t\t\t\tthrow new EmtpyCommitException(\n \t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \n \t\t\t\tcommit.setParentIds(parents);\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\todi.flush();\n \n \t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tif (!useDefaultReflogMessage) {\n \t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t} else {\n \t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n \t\t\t\t\t\t\tfalse);\n \t\t\t\t}\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\telse\n \t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FORCED:\n \t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n+\t\t\t\t\tHooks.postCommit(repo,\n+\t\t\t\t\t\t\thookOutRedirect.get(PostCommitHook.NAME)).call();\n+\n \t\t\t\t\treturn revCommit;\n \t\t\t\t}\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n \t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4c236ff4bbf664fd177a33f42517b0eef52510c8": {
      "type": "Ybodychange",
      "commitMessage": "Replace use of deprecated method Repository.getRef()\n\nChange-Id: Iecf2b8deafc4991cc3333702fb9fa0638be7b914\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016-05-30, 6:11 p.m.",
      "commitName": "4c236ff4bbf664fd177a33f42517b0eef52510c8",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2016-04-11, 2:58 a.m.",
      "commitNameOld": "36a53d1a3cdd66c40b6db241a75a28293f22f5e1",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 49.63,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n\t\t\tAbortedByHookException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\n\t\t\tif (!noVerify) {\n\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n\t\t\t}\n\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare()) {\n\t\t\t\ttry (Git git \u003d new Git(repo)) {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\tif (!noVerify) {\n\t\t\t\tmessage \u003d Hooks.commitMsg(repo, hookOutRedirect)\n\t\t\t\t\t\t.setCommitMessage(message).call();\n\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t// (unresolved conflicts)\n\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\tif (insertChangeId)\n\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t// Check for empty commits\n\t\t\t\tif (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n\t\t\t\t\tRevCommit headCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\theadCommit.getTree();\n\t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n\t\t\t\t\t\tthrow new EmtpyCommitException(\n\t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\todi.flush();\n\n\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tif (!useDefaultReflogMessage) {\n\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t} else {\n\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n\t\t\t\t\t\t\tfalse);\n\t\t\t\t}\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\telse\n\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\tswitch (rc) {\n\t\t\t\tcase NEW:\n\t\t\t\tcase FORCED:\n\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t}\n\t\t\t\t\treturn revCommit;\n\t\t\t\t}\n\t\t\t\tcase REJECTED:\n\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 167,
      "functionName": "call",
      "diff": "@@ -1,149 +1,149 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all \u0026\u0026 !repo.isBare()) {\n \t\t\t\ttry (Git git \u003d new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n+\t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n \t\t\t\tmessage \u003d Hooks.commitMsg(repo, hookOutRedirect)\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\tif (insertChangeId)\n \t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t// Check for empty commits\n \t\t\t\tif (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n \t\t\t\t\tRevCommit headCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\theadCommit.getTree();\n \t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n \t\t\t\t\t\tthrow new EmtpyCommitException(\n \t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \n \t\t\t\tcommit.setParentIds(parents);\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\todi.flush();\n \n \t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tif (!useDefaultReflogMessage) {\n \t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t} else {\n \t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n \t\t\t\t\t\t\tfalse);\n \t\t\t\t}\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\telse\n \t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FORCED:\n \t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n \t\t\t\t\treturn revCommit;\n \t\t\t\t}\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n \t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "36a53d1a3cdd66c40b6db241a75a28293f22f5e1": {
      "type": "Ybodychange",
      "commitMessage": "Fix CommitCommand to be able to skip writing to RefLog\n\nCommitCommand already provided a method to set the comment which should\nbe written into the reflog. The underlying RefUpdate class supported to\nskip writing a reflog entry. But through the CommitCommand API it was\nnot possible to prevent writing a reflog entry. Fix this and allow\ncreating commits which don\u0027t occur in the reflog.\n\nChange-Id: I193c53de71fb5958ea749c4bfa8360a51acc9b58\n",
      "commitDate": "2016-04-11, 2:58 a.m.",
      "commitName": "36a53d1a3cdd66c40b6db241a75a28293f22f5e1",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2016-02-02, 4:27 a.m.",
      "commitNameOld": "521f513d6d5d43bbf27b976434a4b75c4798d718",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 68.9,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n\t\t\tAbortedByHookException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\n\t\t\tif (!noVerify) {\n\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n\t\t\t}\n\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare()) {\n\t\t\t\ttry (Git git \u003d new Git(repo)) {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\tif (!noVerify) {\n\t\t\t\tmessage \u003d Hooks.commitMsg(repo, hookOutRedirect)\n\t\t\t\t\t\t.setCommitMessage(message).call();\n\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t// (unresolved conflicts)\n\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\tif (insertChangeId)\n\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t// Check for empty commits\n\t\t\t\tif (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n\t\t\t\t\tRevCommit headCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\theadCommit.getTree();\n\t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n\t\t\t\t\t\tthrow new EmtpyCommitException(\n\t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\todi.flush();\n\n\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tif (!useDefaultReflogMessage) {\n\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t} else {\n\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n\t\t\t\t\t\t\tfalse);\n\t\t\t\t}\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\telse\n\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\tswitch (rc) {\n\t\t\t\tcase NEW:\n\t\t\t\tcase FORCED:\n\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t}\n\t\t\t\t\treturn revCommit;\n\t\t\t\t}\n\t\t\t\tcase REJECTED:\n\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 167,
      "functionName": "call",
      "diff": "@@ -1,149 +1,149 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all \u0026\u0026 !repo.isBare()) {\n \t\t\t\ttry (Git git \u003d new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n \t\t\t\tmessage \u003d Hooks.commitMsg(repo, hookOutRedirect)\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\tif (insertChangeId)\n \t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t// Check for empty commits\n \t\t\t\tif (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n \t\t\t\t\tRevCommit headCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\theadCommit.getTree();\n \t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n \t\t\t\t\t\tthrow new EmtpyCommitException(\n \t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \n \t\t\t\tcommit.setParentIds(parents);\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\todi.flush();\n \n \t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\tif (reflogComment !\u003d null) {\n+\t\t\t\tif (!useDefaultReflogMessage) {\n \t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t} else {\n \t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n \t\t\t\t\t\t\tfalse);\n \t\t\t\t}\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\telse\n \t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FORCED:\n \t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n \t\t\t\t\treturn revCommit;\n \t\t\t\t}\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n \t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "da43d8d79890e561a993a4d90e6a2724a04cd60f": {
      "type": "Ybodychange",
      "commitMessage": "Add option to allow empty commits to CommitCommand\n\nCommitCommand should allow to specify whether empty commits (commits\nhaving the same tree as the sole predecessor commit) are allowed or not.\nSimilar to native git\u0027s \"--allow-empty\" flag.\n\nThe defaults differ between JGit and native git even after this change.\nWhen not specifying paths then by default JGit allows to create empty\ncommits while native git does not. It would be API breaking to change\nthis now.\n\nBug: 460301\nChange-Id: I88feb0c3ffb2c686b1d0594e669729b065cda4cb\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016-01-20, 5:14 a.m.",
      "commitName": "da43d8d79890e561a993a4d90e6a2724a04cd60f",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2016-01-19, 7:45 p.m.",
      "commitNameOld": "aca07fac464834611bab83b91e828308838f361c",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.39,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n\t\t\tAbortedByHookException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\n\t\t\tif (!noVerify) {\n\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n\t\t\t}\n\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare()) {\n\t\t\t\ttry (Git git \u003d new Git(repo)) {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\tif (!noVerify) {\n\t\t\t\tmessage \u003d Hooks.commitMsg(repo, hookOutRedirect)\n\t\t\t\t\t\t.setCommitMessage(message).call();\n\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t// (unresolved conflicts)\n\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\tif (insertChangeId)\n\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t// Check for empty commits\n\t\t\t\tif (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n\t\t\t\t\tRevCommit headCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\theadCommit.getTree();\n\t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n\t\t\t\t\t\tthrow new EmtpyCommitException(\n\t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\todi.flush();\n\n\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t} else {\n\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n\t\t\t\t\t\t\tfalse);\n\t\t\t\t}\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\telse\n\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\tswitch (rc) {\n\t\t\t\tcase NEW:\n\t\t\t\tcase FORCED:\n\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t}\n\t\t\t\t\treturn revCommit;\n\t\t\t\t}\n\t\t\t\tcase REJECTED:\n\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 165,
      "functionName": "call",
      "diff": "@@ -1,139 +1,149 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all \u0026\u0026 !repo.isBare()) {\n \t\t\t\ttry (Git git \u003d new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n \t\t\t\tmessage \u003d Hooks.commitMsg(repo, hookOutRedirect)\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\tif (insertChangeId)\n \t\t\t\t\tinsertChangeId(indexTreeId);\n \n+\t\t\t\t// Check for empty commits\n+\t\t\t\tif (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n+\t\t\t\t\tRevCommit headCommit \u003d rw.parseCommit(headId);\n+\t\t\t\t\theadCommit.getTree();\n+\t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n+\t\t\t\t\t\tthrow new EmtpyCommitException(\n+\t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \n \t\t\t\tcommit.setParentIds(parents);\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\todi.flush();\n \n \t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t} else {\n \t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n \t\t\t\t\t\t\tfalse);\n \t\t\t\t}\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\telse\n \t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FORCED:\n \t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n \t\t\t\t\treturn revCommit;\n \t\t\t\t}\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n \t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1ed5382b37453309580e11a11cf4c3bb134813fa": {
      "type": "Ybodychange",
      "commitMessage": "CommitCommand: Remove redundant null check\n\nRepository.getWorkTree is annotated as @NonNull, so the check\nfor it returning null is redundant.\n\nChange-Id: I597b0f774ff857b8900519f14a1a17a904cf7c6f\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@sonymobile.com\u003e\n",
      "commitDate": "2016-01-14, 1:04 a.m.",
      "commitName": "1ed5382b37453309580e11a11cf4c3bb134813fa",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2015-11-27, 5:23 p.m.",
      "commitNameOld": "5d9f595eb87fba31c2253051102116fc7876e6c0",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 47.32,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n\t\t\tAbortedByHookException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\n\t\t\tif (!noVerify) {\n\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n\t\t\t}\n\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare()) {\n\t\t\t\ttry (Git git \u003d new Git(repo)) {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\tif (!noVerify) {\n\t\t\t\tmessage \u003d Hooks.commitMsg(repo, hookOutRedirect)\n\t\t\t\t\t\t.setCommitMessage(message).call();\n\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t// (unresolved conflicts)\n\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\tif (insertChangeId)\n\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\todi.flush();\n\n\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t} else {\n\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n\t\t\t\t\t\t\tfalse);\n\t\t\t\t}\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\telse\n\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\tswitch (rc) {\n\t\t\t\tcase NEW:\n\t\t\t\tcase FORCED:\n\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t}\n\t\t\t\t\treturn revCommit;\n\t\t\t\t}\n\t\t\t\tcase REJECTED:\n\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 162,
      "functionName": "call",
      "diff": "@@ -1,139 +1,139 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n-\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n+\t\t\tif (all \u0026\u0026 !repo.isBare()) {\n \t\t\t\ttry (Git git \u003d new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n \t\t\t\tmessage \u003d Hooks.commitMsg(repo, hookOutRedirect)\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\tif (insertChangeId)\n \t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \n \t\t\t\tcommit.setParentIds(parents);\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\todi.flush();\n \n \t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t} else {\n \t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n \t\t\t\t\t\t\tfalse);\n \t\t\t\t}\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\telse\n \t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FORCED:\n \t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n \t\t\t\t\treturn revCommit;\n \t\t\t\t}\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n \t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d726f0c1e02c196e2dd87de53b54338be15503f1": {
      "type": "Ybodychange",
      "commitMessage": "Use try-with-resource to close resources in CommitCommand\n\nChange-Id: Ibbbc74acfd050f28e68f318970660b5959caf7e3\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015-04-08, 4:53 p.m.",
      "commitName": "d726f0c1e02c196e2dd87de53b54338be15503f1",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2015-03-02, 11:45 a.m.",
      "commitNameOld": "efeb02bf2bed32ef94d5c4891404f551cdc6957f",
      "commitAuthorOld": "Laurent Delaigue",
      "daysBetweenCommits": 37.17,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n\t\t\tAbortedByHookException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\n\t\t\tif (!noVerify) {\n\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n\t\t\t}\n\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\ttry (Git git \u003d new Git(repo)) {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\tif (!noVerify) {\n\t\t\t\tmessage \u003d Hooks.commitMsg(repo, hookOutRedirect)\n\t\t\t\t\t\t.setCommitMessage(message).call();\n\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t// (unresolved conflicts)\n\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\tif (insertChangeId)\n\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\todi.flush();\n\n\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t} else {\n\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n\t\t\t\t\t\t\tfalse);\n\t\t\t\t}\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\telse\n\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\tswitch (rc) {\n\t\t\t\tcase NEW:\n\t\t\t\tcase FORCED:\n\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t}\n\t\t\t\t\treturn revCommit;\n\t\t\t\t}\n\t\t\t\tcase REJECTED:\n\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 161,
      "functionName": "call",
      "diff": "@@ -1,150 +1,139 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n-\t\tRevWalk rw \u003d new RevWalk(repo);\n-\n-\t\ttry {\n+\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n-\t\t\t\tGit git \u003d new Git(repo);\n-\t\t\t\ttry {\n+\t\t\t\ttry (Git git \u003d new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n \t\t\t\tmessage \u003d Hooks.commitMsg(repo, hookOutRedirect)\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n-\t\t\ttry {\n+\t\t\ttry (ObjectInserter odi \u003d repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n-\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n-\t\t\t\ttry {\n-\t\t\t\t\t// Write the index as tree to the object database. This may\n-\t\t\t\t\t// fail for example when the index contains unmerged paths\n-\t\t\t\t\t// (unresolved conflicts)\n-\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n+\t\t\t\t// Write the index as tree to the object database. This may\n+\t\t\t\t// fail for example when the index contains unmerged paths\n+\t\t\t\t// (unresolved conflicts)\n+\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n-\t\t\t\t\tif (insertChangeId)\n-\t\t\t\t\t\tinsertChangeId(indexTreeId);\n+\t\t\t\tif (insertChangeId)\n+\t\t\t\t\tinsertChangeId(indexTreeId);\n \n-\t\t\t\t\t// Create a Commit object, populate it and write it\n-\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n-\t\t\t\t\tcommit.setCommitter(committer);\n-\t\t\t\t\tcommit.setAuthor(author);\n-\t\t\t\t\tcommit.setMessage(message);\n+\t\t\t\t// Create a Commit object, populate it and write it\n+\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n+\t\t\t\tcommit.setCommitter(committer);\n+\t\t\t\tcommit.setAuthor(author);\n+\t\t\t\tcommit.setMessage(message);\n \n-\t\t\t\t\tcommit.setParentIds(parents);\n-\t\t\t\t\tcommit.setTreeId(indexTreeId);\n-\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n-\t\t\t\t\todi.flush();\n+\t\t\t\tcommit.setParentIds(parents);\n+\t\t\t\tcommit.setTreeId(indexTreeId);\n+\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n+\t\t\t\todi.flush();\n \n-\t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n-\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n-\t\t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\t\tif (reflogComment !\u003d null) {\n-\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n-\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n-\t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n-\t\t\t\t\t\tru.setRefLogMessage(\n-\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n+\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n+\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+\t\t\t\tru.setNewObjectId(commitId);\n+\t\t\t\tif (reflogComment !\u003d null) {\n+\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n+\t\t\t\t} else {\n+\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n+\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n+\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n+\t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n+\t\t\t\t\t\t\tfalse);\n+\t\t\t\t}\n+\t\t\t\tif (headId !\u003d null)\n+\t\t\t\t\tru.setExpectedOldObjectId(headId);\n+\t\t\t\telse\n+\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n+\t\t\t\tResult rc \u003d ru.forceUpdate();\n+\t\t\t\tswitch (rc) {\n+\t\t\t\tcase NEW:\n+\t\t\t\tcase FORCED:\n+\t\t\t\tcase FAST_FORWARD: {\n+\t\t\t\t\tsetCallable(false);\n+\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n+\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n+\t\t\t\t\t\t// Commit was successful. Now delete the files\n+\t\t\t\t\t\t// used for merge commits\n+\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\trepo.writeMergeHeads(null);\n+\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n+\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\trepo.writeCherryPickHead(null);\n+\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n+\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n-\t\t\t\t\tif (headId !\u003d null)\n-\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n-\t\t\t\t\telse\n-\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n-\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n-\t\t\t\t\tswitch (rc) {\n-\t\t\t\t\tcase NEW:\n-\t\t\t\t\tcase FORCED:\n-\t\t\t\t\tcase FAST_FORWARD: {\n-\t\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n-\t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n-\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n-\t\t\t\t\t\t\t// used for merge commits\n-\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n-\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n-\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n-\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n-\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n-\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n-\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n-\t\t\t\t\t\t\trepo.writeRevertHead(null);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\treturn revCommit;\n-\t\t\t\t\t}\n-\t\t\t\t\tcase REJECTED:\n-\t\t\t\t\tcase LOCK_FAILURE:\n-\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n-\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n-\t\t\t\t\t\t\t\trc);\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n-\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n-\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n-\t\t\t\t\t}\n-\t\t\t\t} finally {\n-\t\t\t\t\todi.release();\n+\t\t\t\t\treturn revCommit;\n+\t\t\t\t}\n+\t\t\t\tcase REJECTED:\n+\t\t\t\tcase LOCK_FAILURE:\n+\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n+\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n+\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n-\t\t} finally {\n-\t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "efeb02bf2bed32ef94d5c4891404f551cdc6957f": {
      "type": "Ybodychange",
      "commitMessage": "Support for the commit-msg hook.\n\nThis hook uses the file .git/COMMIT_EDITMSG to receive and potentially\nmodify the commit message.\n\nChange-Id: Ibe2faadfb5d3932a5a3da2252d8156c4c04856c7\nSigned-off-by: Laurent Delaigue \u003claurent.delaigue@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015-03-02, 11:45 a.m.",
      "commitName": "efeb02bf2bed32ef94d5c4891404f551cdc6957f",
      "commitAuthor": "Laurent Delaigue",
      "commitDateOld": "2015-03-02, 9:33 a.m.",
      "commitNameOld": "26fd56f167e6377777e6d46c14779183e4bcb55a",
      "commitAuthorOld": "Laurent Delaigue",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n\t\t\tAbortedByHookException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\tRevWalk rw \u003d new RevWalk(repo);\n\n\t\ttry {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\n\t\t\tif (!noVerify) {\n\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n\t\t\t}\n\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\tif (!noVerify) {\n\t\t\t\tmessage \u003d Hooks.commitMsg(repo, hookOutRedirect)\n\t\t\t\t\t\t.setCommitMessage(message).call();\n\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t}\n\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\telse\n\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t}\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t} finally {\n\t\t\trw.dispose();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 161,
      "functionName": "call",
      "diff": "@@ -1,145 +1,150 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw \u003d new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n+\t\t\tif (!noVerify) {\n+\t\t\t\tmessage \u003d Hooks.commitMsg(repo, hookOutRedirect)\n+\t\t\t\t\t\t.setCommitMessage(message).call();\n+\t\t\t}\n+\n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "26fd56f167e6377777e6d46c14779183e4bcb55a": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Refactored pre-commit hook to make it less invasive.\n\nHooks are now obtained via a convenient API like git commands, and\ncallers don\u0027t have to check for their existence.\nThe pre-commit hook has been updated accordingly.\n\nChange-Id: I3383ffb10e2f3b588d7367b9139b606ec7f62758\nSigned-off-by: Laurent Delaigue \u003claurent.delaigue@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015-03-02, 9:33 a.m.",
      "commitName": "26fd56f167e6377777e6d46c14779183e4bcb55a",
      "commitAuthor": "Laurent Delaigue",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Refactored pre-commit hook to make it less invasive.\n\nHooks are now obtained via a convenient API like git commands, and\ncallers don\u0027t have to check for their existence.\nThe pre-commit hook has been updated accordingly.\n\nChange-Id: I3383ffb10e2f3b588d7367b9139b606ec7f62758\nSigned-off-by: Laurent Delaigue \u003claurent.delaigue@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015-03-02, 9:33 a.m.",
          "commitName": "26fd56f167e6377777e6d46c14779183e4bcb55a",
          "commitAuthor": "Laurent Delaigue",
          "commitDateOld": "2015-02-02, 3:23 p.m.",
          "commitNameOld": "494e893c541b5cf465b362c69354c08d7a81c249",
          "commitAuthorOld": "Laurent Goubet",
          "daysBetweenCommits": 27.76,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n\t\t\tAbortedByHookException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\tRevWalk rw \u003d new RevWalk(repo);\n\n\t\ttry {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\n\t\t\tif (!noVerify) {\n\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n\t\t\t}\n\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t}\n\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\telse\n\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t}\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t} finally {\n\t\t\trw.dispose();\n\t\t}\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 161,
          "functionName": "call",
          "diff": "@@ -1,157 +1,145 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n-\t\t\tRejectCommitException {\n+\t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw \u003d new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n-\t\t\t\tfinal ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n-\t\t\t\tfinal PrintStream hookErrRedirect \u003d new PrintStream(\n-\t\t\t\t\t\terrorByteArray);\n-\t\t\t\tProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(\n-\t\t\t\t\t\trepo, Hook.PRE_COMMIT, new String[0], hookOutRedirect,\n-\t\t\t\t\t\thookErrRedirect, null);\n-\t\t\t\tif (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK\n-\t\t\t\t\t\t\u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n-\t\t\t\t\tString errorMessage \u003d MessageFormat.format(\n-\t\t\t\t\t\t\tJGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(),\n-\t\t\t\t\t\t\terrorByteArray.toString());\n-\t\t\t\t\tthrow new RejectCommitException(errorMessage);\n-\t\t\t\t}\n+\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException]",
            "newValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Refactored pre-commit hook to make it less invasive.\n\nHooks are now obtained via a convenient API like git commands, and\ncallers don\u0027t have to check for their existence.\nThe pre-commit hook has been updated accordingly.\n\nChange-Id: I3383ffb10e2f3b588d7367b9139b606ec7f62758\nSigned-off-by: Laurent Delaigue \u003claurent.delaigue@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015-03-02, 9:33 a.m.",
          "commitName": "26fd56f167e6377777e6d46c14779183e4bcb55a",
          "commitAuthor": "Laurent Delaigue",
          "commitDateOld": "2015-02-02, 3:23 p.m.",
          "commitNameOld": "494e893c541b5cf465b362c69354c08d7a81c249",
          "commitAuthorOld": "Laurent Goubet",
          "daysBetweenCommits": 27.76,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n\t\t\tAbortedByHookException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\tRevWalk rw \u003d new RevWalk(repo);\n\n\t\ttry {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\n\t\t\tif (!noVerify) {\n\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n\t\t\t}\n\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t}\n\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\telse\n\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t}\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t} finally {\n\t\t\trw.dispose();\n\t\t}\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 161,
          "functionName": "call",
          "diff": "@@ -1,157 +1,145 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n-\t\t\tRejectCommitException {\n+\t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw \u003d new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n-\t\t\t\tfinal ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n-\t\t\t\tfinal PrintStream hookErrRedirect \u003d new PrintStream(\n-\t\t\t\t\t\terrorByteArray);\n-\t\t\t\tProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(\n-\t\t\t\t\t\trepo, Hook.PRE_COMMIT, new String[0], hookOutRedirect,\n-\t\t\t\t\t\thookErrRedirect, null);\n-\t\t\t\tif (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK\n-\t\t\t\t\t\t\u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n-\t\t\t\t\tString errorMessage \u003d MessageFormat.format(\n-\t\t\t\t\t\t\tJGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(),\n-\t\t\t\t\t\t\terrorByteArray.toString());\n-\t\t\t\t\tthrow new RejectCommitException(errorMessage);\n-\t\t\t\t}\n+\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "494e893c541b5cf465b362c69354c08d7a81c249": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Support for the pre-commit hook\n\nIntroduce support for the pre-commit hook into JGit, along with the\n--no-verify commit command option to bypass it when rebasing /\ncherry-picking.\n\nChange-Id: If86df98577fa56c5c03d783579c895a38bee9d18\nSigned-off-by: Laurent Goubet \u003claurent.goubet@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015-02-02, 3:23 p.m.",
      "commitName": "494e893c541b5cf465b362c69354c08d7a81c249",
      "commitAuthor": "Laurent Goubet",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Support for the pre-commit hook\n\nIntroduce support for the pre-commit hook into JGit, along with the\n--no-verify commit command option to bypass it when rebasing /\ncherry-picking.\n\nChange-Id: If86df98577fa56c5c03d783579c895a38bee9d18\nSigned-off-by: Laurent Goubet \u003claurent.goubet@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015-02-02, 3:23 p.m.",
          "commitName": "494e893c541b5cf465b362c69354c08d7a81c249",
          "commitAuthor": "Laurent Goubet",
          "commitDateOld": "2014-07-15, 7:00 p.m.",
          "commitNameOld": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
          "commitAuthorOld": "Konrad Kgler",
          "daysBetweenCommits": 201.89,
          "commitsBetweenForRepo": 227,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n\t\t\tRejectCommitException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\tRevWalk rw \u003d new RevWalk(repo);\n\n\t\ttry {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\n\t\t\tif (!noVerify) {\n\t\t\t\tfinal ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n\t\t\t\tfinal PrintStream hookErrRedirect \u003d new PrintStream(\n\t\t\t\t\t\terrorByteArray);\n\t\t\t\tProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(\n\t\t\t\t\t\trepo, Hook.PRE_COMMIT, new String[0], hookOutRedirect,\n\t\t\t\t\t\thookErrRedirect, null);\n\t\t\t\tif (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK\n\t\t\t\t\t\t\u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n\t\t\t\t\tString errorMessage \u003d MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(),\n\t\t\t\t\t\t\terrorByteArray.toString());\n\t\t\t\t\tthrow new RejectCommitException(errorMessage);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t}\n\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\telse\n\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t}\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t} finally {\n\t\t\trw.dispose();\n\t\t}\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 166,
          "functionName": "call",
          "diff": "@@ -1,140 +1,157 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n-\t\t\tConcurrentRefUpdateException,\n-\t\t\tWrongRepositoryStateException {\n+\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n+\t\t\tRejectCommitException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw \u003d new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n+\n+\t\t\tif (!noVerify) {\n+\t\t\t\tfinal ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n+\t\t\t\tfinal PrintStream hookErrRedirect \u003d new PrintStream(\n+\t\t\t\t\t\terrorByteArray);\n+\t\t\t\tProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(\n+\t\t\t\t\t\trepo, Hook.PRE_COMMIT, new String[0], hookOutRedirect,\n+\t\t\t\t\t\thookErrRedirect, null);\n+\t\t\t\tif (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK\n+\t\t\t\t\t\t\u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n+\t\t\t\t\tString errorMessage \u003d MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(),\n+\t\t\t\t\t\t\terrorByteArray.toString());\n+\t\t\t\t\tthrow new RejectCommitException(errorMessage);\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException]",
            "newValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Support for the pre-commit hook\n\nIntroduce support for the pre-commit hook into JGit, along with the\n--no-verify commit command option to bypass it when rebasing /\ncherry-picking.\n\nChange-Id: If86df98577fa56c5c03d783579c895a38bee9d18\nSigned-off-by: Laurent Goubet \u003claurent.goubet@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015-02-02, 3:23 p.m.",
          "commitName": "494e893c541b5cf465b362c69354c08d7a81c249",
          "commitAuthor": "Laurent Goubet",
          "commitDateOld": "2014-07-15, 7:00 p.m.",
          "commitNameOld": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
          "commitAuthorOld": "Konrad Kgler",
          "daysBetweenCommits": 201.89,
          "commitsBetweenForRepo": 227,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n\t\t\tRejectCommitException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\tRevWalk rw \u003d new RevWalk(repo);\n\n\t\ttry {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\n\t\t\tif (!noVerify) {\n\t\t\t\tfinal ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n\t\t\t\tfinal PrintStream hookErrRedirect \u003d new PrintStream(\n\t\t\t\t\t\terrorByteArray);\n\t\t\t\tProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(\n\t\t\t\t\t\trepo, Hook.PRE_COMMIT, new String[0], hookOutRedirect,\n\t\t\t\t\t\thookErrRedirect, null);\n\t\t\t\tif (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK\n\t\t\t\t\t\t\u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n\t\t\t\t\tString errorMessage \u003d MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(),\n\t\t\t\t\t\t\terrorByteArray.toString());\n\t\t\t\t\tthrow new RejectCommitException(errorMessage);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t}\n\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\telse\n\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t}\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t} finally {\n\t\t\trw.dispose();\n\t\t}\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 166,
          "functionName": "call",
          "diff": "@@ -1,140 +1,157 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n-\t\t\tConcurrentRefUpdateException,\n-\t\t\tWrongRepositoryStateException {\n+\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n+\t\t\tRejectCommitException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw \u003d new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n+\n+\t\t\tif (!noVerify) {\n+\t\t\t\tfinal ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n+\t\t\t\tfinal PrintStream hookErrRedirect \u003d new PrintStream(\n+\t\t\t\t\t\terrorByteArray);\n+\t\t\t\tProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(\n+\t\t\t\t\t\trepo, Hook.PRE_COMMIT, new String[0], hookOutRedirect,\n+\t\t\t\t\t\thookErrRedirect, null);\n+\t\t\t\tif (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK\n+\t\t\t\t\t\t\u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n+\t\t\t\t\tString errorMessage \u003d MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(),\n+\t\t\t\t\t\t\terrorByteArray.toString());\n+\t\t\t\t\tthrow new RejectCommitException(errorMessage);\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "e0fbae5dc3fc2345383ec373b384fcca10e64f24": {
      "type": "Ybodychange",
      "commitMessage": "Rebase: Add --preserve-merges support\n\nWith --preserve-merges C Git re-does merges using the rewritten merge\nparents, discarding the old merge commit. For the common use-case of\npull with rebase this is unfortunate, as it loses the merge conflict\nresolution (and other fixes in the merge), which may have taken quite\nsome time to get right in the first place.\n\nTo overcome this we use a two-fold approach:\nIf any of the (non-first) merge parents of a merge were rewritten, we\nalso redo the merge, to include the (potential) new changes in those\ncommits.\nIf only the first parent was rewritten, i.e. we are merging a branch\nthat is otherwise unaffected by the rebase, we instead cherry-pick the\nmerge commit at hand. This is done with the --mainline 1 and --no-commit\noptions to apply the changes introduced by the merge. Then we set up an\nappropriate MERGE_HEAD and commit the result, thus effectively forging a\nmerge.\n\nApart from the approach taken to rebase merge commits, this\nimplementation closely follows C Git. As a result, both Git\nimplementations can continue rebases of each other.\n\nPreserving merges works for both interactive and non-interactive rebase,\nbut as in C Git it is easy do get undesired outcomes with interactive\nrebase.\n\nCommitCommand supports committing merges during rebase now.\n\nBug: 439421\nChange-Id: I4cf69b9d4ec6109d130ab8e3f42fcbdac25a13b2\nSigned-off-by: Konrad Kgler \u003cswamblumat-eclipsebugs@yahoo.de\u003e\n",
      "commitDate": "2014-07-15, 7:00 p.m.",
      "commitName": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
      "commitAuthor": "Konrad Kgler",
      "commitDateOld": "2013-11-15, 1:20 p.m.",
      "commitNameOld": "97b8115be4fd5c8901ce39e53e11b3b425697574",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 242.2,
      "commitsBetweenForRepo": 290,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException,\n\t\t\tWrongRepositoryStateException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\tRevWalk rw \u003d new RevWalk(repo);\n\n\t\ttry {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t}\n\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\telse\n\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t}\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t} finally {\n\t\t\trw.dispose();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 148,
      "functionName": "call",
      "diff": "@@ -1,139 +1,140 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw \u003d new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n+\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n+\t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2b33a8ac33c63eea82f300b802a26af54a3d61d": {
      "type": "Ybodychange",
      "commitMessage": "Add NON-NLS comments for some obviously untranslatable strings\n\nChange-Id: I2d1076b46695dac84961b8ae663bfc5cb123b3a3\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2013-07-21, 11:06 p.m.",
      "commitName": "a2b33a8ac33c63eea82f300b802a26af54a3d61d",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013-05-11, 4:45 p.m.",
      "commitNameOld": "c93a59330249677cd990820b59558a39f747009f",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 71.26,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException,\n\t\t\tWrongRepositoryStateException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\tRevWalk rw \u003d new RevWalk(repo);\n\n\t\ttry {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t}\n\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\telse\n\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t}\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t} finally {\n\t\t\trw.dispose();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 148,
      "functionName": "call",
      "diff": "@@ -1,139 +1,139 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw \u003d new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n-\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \"\n-\t\t\t\t\t\t\t\t\t\t: \"commit: \";\n+\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \" //$NON-NLS-1$\n+\t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c93a59330249677cd990820b59558a39f747009f": {
      "type": "Ybodychange",
      "commitMessage": "Fix CommitCommand not to destroy repo\n\nThere was a severe bug in CommitCommand which could corrupt\nrepos. When merging an annotated tag the JGit MergeCommand writes\ncorrectly the ID of the tag (and not the id of the commit the tag was\npointing to) into MERGE_HEAD. Native git does the same. But\nCommitCommand was reading this file and trusting blindly that it will\ncontain only IDs of commits. Then the CommitCommand created a\ncommit which has as parent a non-commit object (the tag object). That\u0027s\nso corrupt that even native git gives up when you call \"git log\" in\nsuch a repo.\n\nTo reproduce that with EGit simply right-click on a tag in the\nRepository View and select Merge. The result was a corrupt repo!\n\nBug: 336291\nChange-Id: I24cd5de19ce6ca7b68b4052c9e73dcc6d207b57c\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2013-05-11, 4:45 p.m.",
      "commitName": "c93a59330249677cd990820b59558a39f747009f",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2013-04-02, 3:57 p.m.",
      "commitNameOld": "65027d8bb429581635f51d0c588493e5c458cc25",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 39.03,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException,\n\t\t\tWrongRepositoryStateException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\tRevWalk rw \u003d new RevWalk(repo);\n\n\t\ttry {\n\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\t\tif (!state.canCommit())\n\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n\t\t\t\t\t\tstate.name()));\n\t\t\tprocessOptions(state, rw);\n\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \"\n\t\t\t\t\t\t\t\t\t\t: \"commit: \";\n\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t}\n\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\telse\n\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t}\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t} finally {\n\t\t\trw.dispose();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 148,
      "functionName": "call",
      "diff": "@@ -1,140 +1,139 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n-\t\tRepositoryState state \u003d repo.getRepositoryState();\n-\t\tif (!state.canCommit())\n-\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n-\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n-\t\tprocessOptions(state);\n+\t\tRevWalk rw \u003d new RevWalk(repo);\n \n \t\ttry {\n+\t\t\tRepositoryState state \u003d repo.getRepositoryState();\n+\t\t\tif (!state.canCommit())\n+\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n+\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n+\t\t\t\t\t\tstate.name()));\n+\t\t\tprocessOptions(state, rw);\n+\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n-\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n-\t\t\t\t\t\t\t.parseCommit(headId);\n+\t\t\t\t\tRevCommit previousCommit \u003d rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n-\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n+\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n-\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n-\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n-\t\t\t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\t\t\tif (reflogComment !\u003d null) {\n-\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n-\t\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \"\n-\t\t\t\t\t\t\t\t\t\t\t: \"commit: \";\n-\t\t\t\t\t\t\tru.setRefLogMessage(\n-\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n+\t\t\t\t\tRevCommit revCommit \u003d rw.parseCommit(commitId);\n+\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+\t\t\t\t\tru.setNewObjectId(commitId);\n+\t\t\t\t\tif (reflogComment !\u003d null) {\n+\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n+\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \"\n+\t\t\t\t\t\t\t\t\t\t: \"commit: \";\n+\t\t\t\t\t\tru.setRefLogMessage(\n+\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n+\t\t\t\t\t}\n+\t\t\t\t\tif (headId !\u003d null)\n+\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n+\t\t\t\t\telse\n+\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n+\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n+\t\t\t\t\tswitch (rc) {\n+\t\t\t\t\tcase NEW:\n+\t\t\t\t\tcase FORCED:\n+\t\t\t\t\tcase FAST_FORWARD: {\n+\t\t\t\t\t\tsetCallable(false);\n+\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n+\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n+\t\t\t\t\t\t\t// used for merge commits\n+\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n+\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n+\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n+\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n+\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tif (headId !\u003d null)\n-\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n-\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n-\t\t\t\t\t\tswitch (rc) {\n-\t\t\t\t\t\tcase NEW:\n-\t\t\t\t\t\tcase FORCED:\n-\t\t\t\t\t\tcase FAST_FORWARD: {\n-\t\t\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n-\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n-\t\t\t\t\t\t\t\t// used for merge commits\n-\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n-\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n-\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n-\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n-\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n-\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n-\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n-\t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\treturn revCommit;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcase REJECTED:\n-\t\t\t\t\t\tcase LOCK_FAILURE:\n-\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n-\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n-\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n-\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n-\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} finally {\n-\t\t\t\t\t\trevWalk.release();\n+\t\t\t\t\t\treturn revCommit;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase REJECTED:\n+\t\t\t\t\tcase LOCK_FAILURE:\n+\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n+\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n+\t\t\t\t\t\t\t\trc);\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n+\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n+\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n+\t\t} finally {\n+\t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "65027d8bb429581635f51d0c588493e5c458cc25": {
      "type": "Ybodychange",
      "commitMessage": "Indicate initial commit on a branch in the reflog\n\nBug: 393463\nChange-Id: I4733d6f719bc0dc694e7a6a6ad2092de6364898c\n",
      "commitDate": "2013-04-02, 3:57 p.m.",
      "commitName": "65027d8bb429581635f51d0c588493e5c458cc25",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013-03-28, 1:58 p.m.",
      "commitNameOld": "1f51aecf95d61e48618d478a693f73dcf1ec1146",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 5.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException,\n\t\t\tWrongRepositoryStateException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \"\n\t\t\t\t\t\t\t\t\t\t\t: \"commit: \";\n\t\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 146,
      "functionName": "call",
      "diff": "@@ -1,139 +1,140 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n-\t\t\t\t\t\t\t\t\t: \"commit: \";\n+\t\t\t\t\t\t\t\t\t: parents.size() \u003d\u003d 0 ? \"commit (initial): \"\n+\t\t\t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1f51aecf95d61e48618d478a693f73dcf1ec1146": {
      "type": "Ybodychange",
      "commitMessage": "Fix CommitCommand amend mode to preserve parent order\n\nChange-Id: I476921ff8dfa6a357932d42ee59340873502b582\n",
      "commitDate": "2013-03-28, 1:58 p.m.",
      "commitName": "1f51aecf95d61e48618d478a693f73dcf1ec1146",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013-01-06, 7:08 p.m.",
      "commitNameOld": "549034500a55ffc8f401fd73a74d8dc55f096d2f",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 80.74,
      "commitsBetweenForRepo": 127,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException,\n\t\t\tWrongRepositoryStateException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n\t\t\t\t\t\tparents.add(p.getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t: \"commit: \";\n\t\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 146,
      "functionName": "call",
      "diff": "@@ -1,140 +1,139 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n-\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n-\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n-\t\t\t\t\t\tparents.add(0, p[i].getId());\n+\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n+\t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "549034500a55ffc8f401fd73a74d8dc55f096d2f": {
      "type": "Ybodychange",
      "commitMessage": "Speed up handling of \"only\" paths in the CommitCommand\n\nUse binary search to reduce the number of lookups for very large number\nof paths.\n\nChange-Id: I76a16594b756bffd95298897414485a9cd637819\n",
      "commitDate": "2013-01-06, 7:08 p.m.",
      "commitName": "549034500a55ffc8f401fd73a74d8dc55f096d2f",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012-12-28, 5:44 p.m.",
      "commitNameOld": "315f1cfa5c63f4d3355704c80d00ac1323a36171",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 9.06,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException,\n\t\t\tWrongRepositoryStateException {\n\t\tcheckCallable();\n\t\tCollections.sort(only);\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t: \"commit: \";\n\t\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 146,
      "functionName": "call",
      "diff": "@@ -1,139 +1,140 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n+\t\tCollections.sort(only);\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n \t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "315f1cfa5c63f4d3355704c80d00ac1323a36171": {
      "type": "Ybodychange",
      "commitMessage": "Update the revert command and things relating to revert\n\nCherry-pick has been fixed, but even though revert does\nbasically the same thing, the fixes were not carried over here.\n\n- Recognize the revert-states, analogous to the cherry picking states\n- Make reset handle a revert-in-progress\n- Update REVERT_HEAD and MERGE_MSG when revert fails due to conflicts\n- Clear revert state on commit and reset\n- Format the message similarily to how cherry-pick does. This is\n  not exactly how C Git does it.\n\nThe interface is still not the same as for cherry-picking.\n\nChange-Id: I8ea956fcbc9526d62a2365360feea23a9280eba3\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2012-12-28, 5:44 p.m.",
      "commitName": "315f1cfa5c63f4d3355704c80d00ac1323a36171",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012-12-27, 10:57 a.m.",
      "commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 1.28,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException,\n\t\t\tWrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t: \"commit: \";\n\t\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 145,
      "functionName": "call",
      "diff": "@@ -1,136 +1,139 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n \t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n+\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n+\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": {
      "type": "Ybodychange",
      "commitMessage": "Mark non-externalizable strings as such\n\nA few classes such as Constanrs are marked with @SuppressWarnings, as are\ntoString() methods with many liternal, but otherwise $NLS-n$ is used for\nstring containing text that should not be translated. A few literals may\nfall into the gray zone, but mostly I\u0027ve tried to only tag the obvious\nones.\n\nChange-Id: I22e50a77e2bf9e0b842a66bdf674e8fa1692f590\n",
      "commitDate": "2012-12-27, 10:57 a.m.",
      "commitName": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012-11-12, 4:51 p.m.",
      "commitNameOld": "0f88d7b72ff09297954930cbe2a23cf8feff9382",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 44.75,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException,\n\t\t\tWrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t: \"commit: \";\n\t\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 145,
      "functionName": "call",
      "diff": "@@ -1,136 +1,136 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n-\t\t\t\t\t\t\t.addFilepattern(\".\")\n+\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n-\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n \t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \"\n+\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "79f33419ec073edf31a1db16ae9b11e69ee997a1": {
      "type": "Ybodychange",
      "commitMessage": "CommitCommand: Use original author on amend if author is not set\n\nThis way, callers don\u0027t have to parse author ident of HEAD themselves.\n\nBug: 362391\nChange-Id: I383a817e6ed4707d637c52c007bc7b57728e6c85\n",
      "commitDate": "2012-10-07, 6:31 p.m.",
      "commitName": "79f33419ec073edf31a1db16ae9b11e69ee997a1",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2012-10-07, 6:31 p.m.",
      "commitNameOld": "c96b40d5921d68edb96afad38b9c171388af4e05",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException,\n\t\t\tWrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \"\n\t\t\t\t\t\t\t\t\t: \"commit: \";\n\t\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 147,
      "functionName": "call",
      "diff": "@@ -1,134 +1,136 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n \t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n+\t\t\t\t\tif (author \u003d\u003d null)\n+\t\t\t\t\t\tauthor \u003d previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \"\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c96b40d5921d68edb96afad38b9c171388af4e05": {
      "type": "Ybodychange",
      "commitMessage": "CommitCommand: Don\u0027t allow amending on initial commit\n\nChange-Id: I27b13510eb6756da21d0d359d76031da4a875e28\n",
      "commitDate": "2012-10-07, 6:31 p.m.",
      "commitName": "c96b40d5921d68edb96afad38b9c171388af4e05",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2012-06-15, 2:59 a.m.",
      "commitNameOld": "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 114.65,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException,\n\t\t\tWrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n\t\t\t\tthrow new WrongRepositoryStateException(\n\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \"\n\t\t\t\t\t\t\t\t\t: \"commit: \";\n\t\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 147,
      "functionName": "call",
      "diff": "@@ -1,130 +1,134 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+\t\t\tif (headId \u003d\u003d null \u0026\u0026 amend)\n+\t\t\t\tthrow new WrongRepositoryStateException(\n+\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n+\n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n \t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \"\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2012-05-30, 4:08 p.m.",
      "commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "commitAuthor": "Robin Rosenberg",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
          "commitDate": "2012-05-30, 4:08 p.m.",
          "commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2012-03-26, 6:47 p.m.",
          "commitNameOld": "3f4725c179c176560937d756682fcd6cfbf685fe",
          "commitAuthorOld": "Robin Rosenberg",
          "daysBetweenCommits": 64.89,
          "commitsBetweenForRepo": 48,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException,\n\t\t\tWrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \"\n\t\t\t\t\t\t\t\t\t: \"commit: \";\n\t\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 147,
          "functionName": "call",
          "diff": "@@ -1,132 +1,130 @@\n-\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n-\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n-\t\t\tJGitInternalException, WrongRepositoryStateException {\n+\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n+\t\t\tNoMessageException, UnmergedPathsException,\n+\t\t\tConcurrentRefUpdateException,\n+\t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n \t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \"\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n-\t\t\t// since UnmergedPathException is a subclass of IOException\n-\t\t\t// which should not be wrapped by a JGitInternalException we\n-\t\t\t// have to catch and re-throw it here\n-\t\t\tthrow e;\n+\t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException]",
            "newValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
          "commitDate": "2012-05-30, 4:08 p.m.",
          "commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2012-03-26, 6:47 p.m.",
          "commitNameOld": "3f4725c179c176560937d756682fcd6cfbf685fe",
          "commitAuthorOld": "Robin Rosenberg",
          "daysBetweenCommits": 64.89,
          "commitsBetweenForRepo": 48,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n\t\t\tNoMessageException, UnmergedPathsException,\n\t\t\tConcurrentRefUpdateException,\n\t\t\tWrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \"\n\t\t\t\t\t\t\t\t\t: \"commit: \";\n\t\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\tthrow new UnmergedPathsException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 147,
          "functionName": "call",
          "diff": "@@ -1,132 +1,130 @@\n-\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n-\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n-\t\t\tJGitInternalException, WrongRepositoryStateException {\n+\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n+\t\t\tNoMessageException, UnmergedPathsException,\n+\t\t\tConcurrentRefUpdateException,\n+\t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n \t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \"\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId !\u003d null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n-\t\t\t// since UnmergedPathException is a subclass of IOException\n-\t\t\t// which should not be wrapped by a JGitInternalException we\n-\t\t\t// have to catch and re-throw it here\n-\t\t\tthrow e;\n+\t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "2539b1ee096266b7fcca64545f93d7c08ab30f53": {
      "type": "Ybodychange",
      "commitMessage": "Set expected old object id to all zeros when head id is null\n\nThis will be the case on the initial commit to a repository\nand the ref update should expect a non-existent ref\n\nChange-Id: Iaa06e47e6e8cc4a0281c7683b367d4806dd980ea\n",
      "commitDate": "2011-12-06, 9:02 p.m.",
      "commitName": "2539b1ee096266b7fcca64545f93d7c08ab30f53",
      "commitAuthor": "Kevin Sawicki",
      "commitDateOld": "2011-09-21, 5:36 p.m.",
      "commitNameOld": "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 76.18,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \"\n\t\t\t\t\t\t\t\t\t: \"commit: \";\n\t\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 149,
      "functionName": "call",
      "diff": "@@ -1,129 +1,132 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n \t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment !\u003d null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \"\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n+\t\t\t\t\t\tif (headId !\u003d null)\n+\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f": {
      "type": "Ybodychange",
      "commitMessage": "Fix the reflog prefix for cherry-pick, revert and merge commands\n\nWe should see whether the commit was a regular commit or something\nelse.\n\nChange-Id: I82d8300cf3c53cb2bdcb6495386aadb803e0c6f7\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2011-09-21, 5:36 p.m.",
      "commitName": "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2011-09-08, 10:46 a.m.",
      "commitNameOld": "a7d3c680151aa27608c6381db0983b51828c2358",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 13.28,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tif (reflogComment !\u003d null) {\n\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \"\n\t\t\t\t\t\t\t\t\t: \"commit: \";\n\t\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 149,
      "functionName": "call",
      "diff": "@@ -1,125 +1,129 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n \t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n-\t\t\t\t\t\tru.setRefLogMessage(\n-\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n-\n+\t\t\t\t\t\tif (reflogComment !\u003d null) {\n+\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \"\n+\t\t\t\t\t\t\t\t\t: \"commit: \";\n+\t\t\t\t\t\t\tru.setRefLogMessage(\n+\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e10aa42e90a25b82f00f0c27574f57ffa9e4a25": {
      "type": "Ybodychange",
      "commitMessage": "Add CHERRY_PICK_HEAD for cherry-pick conflicts\n\nAdd handling of CHERRY_PICK_HEAD file in .git (similar to MERGE_HEAD),\nwhich is written in case of a conflicting cherry-pick merge.\n\nIt is used so that Repository.getRepositoryState can return the new\nstates CHERRY_PICKING and CHERRY_PICKING_RESOLVED. These states, as well\nas CHERRY_PICK_HEAD can be used in EGit to properly show the merge tool.\n\nAlso, in case of a conflict, MERGE_MSG is written with the original\ncommit message and a \"Conflicts\" section appended. This way, the\ncherry-picked message is not lost and can later be re-used in the commit\ndialog.\n\nBug: 339092\nChange-Id: I947967fdc2f1d55016c95106b104c2afcc9797a1\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011-04-06, 2:28 p.m.",
      "commitName": "6e10aa42e90a25b82f00f0c27574f57ffa9e4a25",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2011-03-17, 1:15 p.m.",
      "commitNameOld": "fd963a9180af73b6a05a5c1a2af6dd7168899170",
      "commitAuthorOld": "Jens Baumgart",
      "daysBetweenCommits": 20.05,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 146,
      "functionName": "call",
      "diff": "@@ -1,122 +1,125 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n \t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n+\t\t\t\t\t\t\t} else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n+\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd963a9180af73b6a05a5c1a2af6dd7168899170": {
      "type": "Ybodychange",
      "commitMessage": "CommitCommand: add option to insert a change id\n\nAn option to insert a change id into the commit message was added\nto CommitCommand.\nThis change is a prerequisite for removing GitIndex from EGit.\n\nChange-Id: Iff9e26a8aaf21d8224bfd6ce3c98821c077bcd82\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\nSigned-off-by: Philipp Thun \u003cphilipp.thun@sap.com\u003e\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e",
      "commitDate": "2011-03-17, 1:15 p.m.",
      "commitName": "fd963a9180af73b6a05a5c1a2af6dd7168899170",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2011-03-15, 8:55 a.m.",
      "commitNameOld": "79ad15924acc2ba2412d5114c85db27f0f4aca22",
      "commitAuthorOld": "Philipp Thun",
      "daysBetweenCommits": 2.18,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\tif (insertChangeId)\n\t\t\t\t\t\tinsertChangeId(indexTreeId);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 146,
      "functionName": "call",
      "diff": "@@ -1,119 +1,122 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n \t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n+\t\t\t\t\tif (insertChangeId)\n+\t\t\t\t\t\tinsertChangeId(indexTreeId);\n+\n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9830baf48dd5b3feb9780a3cc1d83b79e1d4c46b": {
      "type": "Ybodychange",
      "commitMessage": "CommitCommand: set correct Reflog message when amending\n\nChange-Id: I2322d31b09ca63bdcee50e90340e326467dc5021\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011-03-14, 4:51 p.m.",
      "commitName": "9830baf48dd5b3feb9780a3cc1d83b79e1d4c46b",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2011-03-11, 8:25 a.m.",
      "commitNameOld": "a490afedba12676a53338bc52b729b9bb779f3a1",
      "commitAuthorOld": "Philipp Thun",
      "daysBetweenCommits": 3.31,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n\t\t\t\t\t\tru.setRefLogMessage(\n\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 143,
      "functionName": "call",
      "diff": "@@ -1,118 +1,119 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n \t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n-\t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n+\t\t\t\t\t\tString prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n+\t\t\t\t\t\tru.setRefLogMessage(\n+\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a490afedba12676a53338bc52b729b9bb779f3a1": {
      "type": "Ybodychange",
      "commitMessage": "Add -o option to commit command\n\nThis change adds the --only/ -o option to the commit command.\n\nChange-Id: I44352d56877f8204d985cb7a35a2e0faffb7d341\nSigned-off-by: Philipp Thun \u003cphilipp.thun@sap.com\u003e\n",
      "commitDate": "2011-03-11, 8:25 a.m.",
      "commitName": "a490afedba12676a53338bc52b729b9bb779f3a1",
      "commitAuthor": "Philipp Thun",
      "commitDateOld": "2011-03-07, 11:19 a.m.",
      "commitNameOld": "cda64073fd45d3056486b96877e4ff6dd12dbaa5",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 3.88,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tif (!only.isEmpty())\n\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n\t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 143,
      "functionName": "call",
      "diff": "@@ -1,115 +1,118 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n \t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n+\t\t\t\tif (!only.isEmpty())\n+\t\t\t\t\tindex \u003d createTemporaryIndex(headId, index);\n+\n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cda64073fd45d3056486b96877e4ff6dd12dbaa5": {
      "type": "Ybodychange",
      "commitMessage": "Allow to amend a commit with CommitCommand\n\nBug: 339088\nChange-Id: I57dc727688c4bb6968ac076b176661c857c05afa\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011-03-07, 11:19 a.m.",
      "commitName": "cda64073fd45d3056486b96877e4ff6dd12dbaa5",
      "commitAuthor": "Tomasz Zarna",
      "commitDateOld": "2011-01-17, 4:04 p.m.",
      "commitNameOld": "e43887b69e27672b80e55391e0ee255efe715ab9",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 48.8,
      "commitsBetweenForRepo": 134,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tif (amend) {\n\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(headId);\n\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n\t\t\t\t\t\tparents.add(0, p[i].getId());\n\t\t\t\t} else {\n\t\t\t\t\tparents.add(0, headId);\n\t\t\t\t}\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n\t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FORCED:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 128,
      "functionName": "call",
      "diff": "@@ -1,106 +1,115 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n-\t\t\t\tparents.add(0, headId);\n+\t\t\t\tif (amend) {\n+\t\t\t\t\tRevCommit previousCommit \u003d new RevWalk(repo)\n+\t\t\t\t\t\t\t.parseCommit(headId);\n+\t\t\t\t\tRevCommit[] p \u003d previousCommit.getParents();\n+\t\t\t\t\tfor (int i \u003d 0; i \u003c p.length; i++)\n+\t\t\t\t\t\tparents.add(0, p[i].getId());\n+\t\t\t\t} else {\n+\t\t\t\t\tparents.add(0, headId);\n+\t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n-\t\t\t\t\t\tResult rc \u003d ru.update();\n+\t\t\t\t\t\tResult rc \u003d ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n+\t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6df5d3397c5c9354409d21a8e207a061f2e6efc2": {
      "type": "Ybodychange",
      "commitMessage": "Move commit and tag formatting to CommitBuilder, TagBuilder\n\nThese objects should be responsible for their own formatting,\nrather than delegating it to some obtuse type called ObjectInserter.\n\nWhile we are at it, simplify the way we insert these into a database.\nPassing in the type and calling format in application code turned\nout to be a huge mistake in terms of ease-of-use of the insert API.\n\nChange-Id: Id5bb95ee56aa2a002243e9b7853b84ec8df1d7bf\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-08-23, 1:13 p.m.",
      "commitName": "6df5d3397c5c9354409d21a8e207a061f2e6efc2",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-08-23, 12:46 p.m.",
      "commitNameOld": "22b285695a2980824c15363ef5fec709ebc3d434",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tparents.add(0, headId);\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n\t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\tResult rc \u003d ru.update();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 120,
      "functionName": "call",
      "diff": "@@ -1,107 +1,106 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n-\t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n-\t\t\t\t\t\t\t.format(commit));\n+\t\t\t\t\tObjectId commitId \u003d odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc \u003d ru.update();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "22b285695a2980824c15363ef5fec709ebc3d434": {
      "type": "Ybodychange",
      "commitMessage": "Rename Commit, Tag to CommitBuilder, TagBuilder\n\nSince these types no longer support reading, calling them a Builder\nis a better description of what they do.  They help the caller to\nbuild a commit or a tag object.\n\nChange-Id: I53cae5a800a66ea1721b0fe5e702599df31da05d\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-08-23, 12:46 p.m.",
      "commitName": "22b285695a2980824c15363ef5fec709ebc3d434",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-08-23, 4:20 a.m.",
      "commitNameOld": "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 0.35,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tparents.add(0, headId);\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n\t\t\t\t\t\t\t.format(commit));\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n\t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\tResult rc \u003d ru.update();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 120,
      "functionName": "call",
      "diff": "@@ -1,107 +1,107 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n-\t\t\t\t\tCommit commit \u003d new Commit();\n+\t\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc \u003d ru.update();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b46b635c0389e01a55b2f9c490e5b6c54a8ce640": {
      "type": "Ybodychange",
      "commitMessage": "Make Commit class only for writing\n\nThe Commit class now only supports the creation of a commit object.\nTo read a commit, applictions should use RevCommit.  This permits\nus to have exactly one implementation, and RevCommit\u0027s is faster\nand more bug-free.\n\nChange-Id: Ib573f7e15f36855112815269385c21dea532e2cf\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-08-20, 8:38 p.m.",
      "commitName": "b46b635c0389e01a55b2f9c490e5b6c54a8ce640",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-08-04, 7:53 a.m.",
      "commitNameOld": "ab57af08e83d5d042bb954ad280389b34ca36d0e",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 16.53,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tparents.add(0, headId);\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommit commit \u003d new Commit();\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents);\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n\t\t\t\t\t\t\t.format(commit));\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n\t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\tResult rc \u003d ru.update();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 120,
      "functionName": "call",
      "diff": "@@ -1,107 +1,107 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n \t\t\t\tGit git \u003d new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n-\t\t\t\t\tCommit commit \u003d new Commit(repo);\n+\t\t\t\t\tCommit commit \u003d new Commit();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n-\t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n+\t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc \u003d ru.update();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ab57af08e83d5d042bb954ad280389b34ca36d0e": {
      "type": "Ybodychange",
      "commitMessage": "Add \"all\" parameter to the commit Command\n\nWhen the add parameter is set all modified and deleted files\nare staged prior to commit.\n\nChange-Id: Id23bc25730fcdd151386cd495a7cdc0935cbc00b\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\n",
      "commitDate": "2010-08-04, 7:53 a.m.",
      "commitName": "ab57af08e83d5d042bb954ad280389b34ca36d0e",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2010-07-29, 9:12 a.m.",
      "commitNameOld": "94207f0a43a44261b8170d3cdba3028059775d9d",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 5.95,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n\t\t\t\tGit git \u003d new Git(repo);\n\t\t\t\ttry {\n\t\t\t\t\tgit.add()\n\t\t\t\t\t\t\t.addFilepattern(\".\")\n\t\t\t\t\t\t\t.setUpdate(true).call();\n\t\t\t\t} catch (NoFilepatternException e) {\n\t\t\t\t\t// should really not happen\n\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tparents.add(0, headId);\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommit commit \u003d new Commit(repo);\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n\t\t\t\t\t\t\t.format(commit));\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n\t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\tResult rc \u003d ru.update();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 120,
      "functionName": "call",
      "diff": "@@ -1,95 +1,107 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n+\t\t\tif (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n+\t\t\t\tGit git \u003d new Git(repo);\n+\t\t\t\ttry {\n+\t\t\t\t\tgit.add()\n+\t\t\t\t\t\t\t.addFilepattern(\".\")\n+\t\t\t\t\t\t\t.setUpdate(true).call();\n+\t\t\t\t} catch (NoFilepatternException e) {\n+\t\t\t\t\t// should really not happen\n+\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommit commit \u003d new Commit(repo);\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc \u003d ru.update();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "94207f0a43a44261b8170d3cdba3028059775d9d": {
      "type": "Ybodychange",
      "commitMessage": "Make use of Repository.writeMerge...()\n\nThe CommitCommand should not use java.io to delete MERGE_HEAD and MERGE_MSG\nfiles since Repository already has utility methods for that.\n\nChange-Id: If66a419349b95510e5b5c2237a91f06c1d5ba0d4\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2010-07-29, 9:12 a.m.",
      "commitName": "94207f0a43a44261b8170d3cdba3028059775d9d",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2010-06-30, 1:39 p.m.",
      "commitNameOld": "a1d5f5b6b526d086a0963c634a38edb6789a4594",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 28.81,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tparents.add(0, headId);\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommit commit \u003d new Commit(repo);\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n\t\t\t\t\t\t\t.format(commit));\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n\t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\tResult rc \u003d ru.update();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 118,
      "functionName": "call",
      "diff": "@@ -1,97 +1,95 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommit commit \u003d new Commit(repo);\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc \u003d ru.update();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\t\t\tFile meta \u003d repo.getDirectory();\n-\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n-\t\t\t\t\t\t\t\t\t\u0026\u0026 meta !\u003d null) {\n+\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n-\t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_HEAD).delete();\n-\t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_MSG).delete();\n+\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a1d5f5b6b526d086a0963c634a38edb6789a4594": {
      "type": "Ybodychange",
      "commitMessage": "Move DirCache factory methods to Repository\n\nInstead of creating the DirCache from a static factory method, use\nan instance method on Repository, permitting the implementation to\noverride the method with a completely different type of DirCache\nreading and writing.  This would better support a repository in the\ncloud strategy, or even just an in-memory unit test environment.\n\nChange-Id: I6399894b12d6480c4b3ac84d10775dfd1b8d13e7\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-06-30, 1:39 p.m.",
      "commitName": "a1d5f5b6b526d086a0963c634a38edb6789a4594",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-06-29, 6:12 p.m.",
      "commitNameOld": "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.81,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tparents.add(0, headId);\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d repo.lockDirCache();\n\t\t\ttry {\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommit commit \u003d new Commit(repo);\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n\t\t\t\t\t\t\t.format(commit));\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n\t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\tResult rc \u003d ru.update();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tFile meta \u003d repo.getDirectory();\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t\t\t\u0026\u0026 meta !\u003d null) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_HEAD).delete();\n\t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_MSG).delete();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 119,
      "functionName": "call",
      "diff": "@@ -1,97 +1,97 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n-\t\t\tDirCache index \u003d DirCache.lock(repo);\n+\t\t\tDirCache index \u003d repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommit commit \u003d new Commit(repo);\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc \u003d ru.update();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tFile meta \u003d repo.getDirectory();\n \t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t\t\t\u0026\u0026 meta !\u003d null) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_HEAD).delete();\n \t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_MSG).delete();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "515deaf7e503738b4c53c3c2dfd6d7acab3bef18": {
      "type": "Ybodychange",
      "commitMessage": "Ensure RevWalk is released when done\n\nUpdate a number of calling sites of RevWalk to ensure the walker\u0027s\ninternal ObjectReader is released after the walk is no longer used.\nBecause the ObjectReader is likely to hold onto a native resource\nlike an Inflater, we don\u0027t want to leak them outside of their\nuseful scope.\n\nWhere possible we also try to share ObjectReaders across several\nwalk pools, or between a walker and a PackWriter.  This permits\nthe ObjectReader to actually do some caching if it felt inclined\nto do so.\n\nNot everything was updated, we\u0027ll probably need to come back and\nupdate even more call sites, but these are some of the biggest\noffenders.  Test cases in particular aren\u0027t updated.  My plan is to\nmove most storage-agnostic tests onto some purely in-memory storage\nsolution that doesn\u0027t do compression.\n\nChange-Id: I04087ec79faeea208b19848939898ad7172b6672\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-06-29, 6:12 p.m.",
      "commitName": "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-06-25, 9:03 p.m.",
      "commitNameOld": "ffe0614d4db653cbcd48c19e9f599fd87cdcfaba",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 3.88,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tparents.add(0, headId);\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d DirCache.lock(repo);\n\t\t\ttry {\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommit commit \u003d new Commit(repo);\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n\t\t\t\t\t\t\t.format(commit));\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n\t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n\n\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\t\tResult rc \u003d ru.update();\n\t\t\t\t\t\tswitch (rc) {\n\t\t\t\t\t\tcase NEW:\n\t\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\t\tFile meta \u003d repo.getDirectory();\n\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t\t\t\u0026\u0026 meta !\u003d null) {\n\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_HEAD).delete();\n\t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_MSG).delete();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REJECTED:\n\t\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\trevWalk.release();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 119,
      "functionName": "call",
      "diff": "@@ -1,93 +1,97 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d DirCache.lock(repo);\n \t\t\ttry {\n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommit commit \u003d new Commit(repo);\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n-\t\t\t\t\tRevCommit revCommit \u003d new RevWalk(repo)\n-\t\t\t\t\t\t\t.parseCommit(commitId);\n-\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n-\t\t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n-\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n+\t\t\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tRevCommit revCommit \u003d revWalk.parseCommit(commitId);\n+\t\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+\t\t\t\t\t\tru.setNewObjectId(commitId);\n+\t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n+\t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n-\t\t\t\t\tru.setExpectedOldObjectId(headId);\n-\t\t\t\t\tResult rc \u003d ru.update();\n-\t\t\t\t\tswitch (rc) {\n-\t\t\t\t\tcase NEW:\n-\t\t\t\t\tcase FAST_FORWARD: {\n-\t\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\t\tFile meta \u003d repo.getDirectory();\n-\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n-\t\t\t\t\t\t\t\t\u0026\u0026 meta !\u003d null) {\n-\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n-\t\t\t\t\t\t\t// used for merge commits\n-\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_HEAD).delete();\n-\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_MSG).delete();\n+\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n+\t\t\t\t\t\tResult rc \u003d ru.update();\n+\t\t\t\t\t\tswitch (rc) {\n+\t\t\t\t\t\tcase NEW:\n+\t\t\t\t\t\tcase FAST_FORWARD: {\n+\t\t\t\t\t\t\tsetCallable(false);\n+\t\t\t\t\t\t\tFile meta \u003d repo.getDirectory();\n+\t\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n+\t\t\t\t\t\t\t\t\t\u0026\u0026 meta !\u003d null) {\n+\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n+\t\t\t\t\t\t\t\t// used for merge commits\n+\t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_HEAD).delete();\n+\t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_MSG).delete();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\treturn revCommit;\n-\t\t\t\t\t}\n-\t\t\t\t\tcase REJECTED:\n-\t\t\t\t\tcase LOCK_FAILURE:\n-\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n-\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n-\t\t\t\t\t\t\t\trc);\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n-\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n-\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n+\t\t\t\t\t\tcase REJECTED:\n+\t\t\t\t\t\tcase LOCK_FAILURE:\n+\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n+\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n+\t\t\t\t\t\tdefault:\n+\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n+\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n+\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n+\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} finally {\n+\t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ffe0614d4db653cbcd48c19e9f599fd87cdcfaba": {
      "type": "Ybodychange",
      "commitMessage": "Allow Repository.getDirectory() to be null\n\nSome types of repositories might not be stored on local disk.  For\nthese, they will most likely return null for getDirectory() as the\njava.io.File type cannot describe where their storage is, its not\nin the host\u0027s filesystem.\n\nDocument that getDirectory() can return null now, and update all\ncurrent non-test callers in JGit that might run into problems on\nsuch repositories.  For the most part, just act like its bare.\n\nChange-Id: I061236a691372a267fd7d41f0550650e165d2066\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-06-25, 9:03 p.m.",
      "commitName": "ffe0614d4db653cbcd48c19e9f599fd87cdcfaba",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-06-25, 8:46 p.m.",
      "commitNameOld": "88530a179e2ddfa81de5cc441a27d66521334608",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tparents.add(0, headId);\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d DirCache.lock(repo);\n\t\t\ttry {\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommit commit \u003d new Commit(repo);\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n\t\t\t\t\t\t\t.format(commit));\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevCommit revCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(commitId);\n\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n\n\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\tResult rc \u003d ru.update();\n\t\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FAST_FORWARD: {\n\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\tFile meta \u003d repo.getDirectory();\n\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n\t\t\t\t\t\t\t\t\u0026\u0026 meta !\u003d null) {\n\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_HEAD).delete();\n\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_MSG).delete();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\t}\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 119,
      "functionName": "call",
      "diff": "@@ -1,92 +1,93 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d DirCache.lock(repo);\n \t\t\ttry {\n \t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommit commit \u003d new Commit(repo);\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit \u003d new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\tResult rc \u003d ru.update();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n-\t\t\t\t\tcase FAST_FORWARD:\n+\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n+\t\t\t\t\t\tFile meta \u003d repo.getDirectory();\n+\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED\n+\t\t\t\t\t\t\t\t\u0026\u0026 meta !\u003d null) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n-\t\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_HEAD)\n-\t\t\t\t\t\t\t\t\t.delete();\n-\t\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_MSG)\n-\t\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_HEAD).delete();\n+\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_MSG).delete();\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n+\t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "88530a179e2ddfa81de5cc441a27d66521334608": {
      "type": "Ybodychange",
      "commitMessage": "Start using ObjectInserter instead of ObjectWriter\n\nSome newer style APIs are updated to use the newer ObjectInserter\ninterface instead of the now deprecated ObjectWriter.  In many of\nthe unit tests we don\u0027t bother to release the inserter, these are\ntypically using the file backend which doesn\u0027t need a release,\nbut in the future should use an in-memory HashMap based store,\nwhich really wouldn\u0027t need it either.\n\nChange-Id: I91a15e1dc42da68e6715397814e30fbd87fa2e73\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-06-25, 8:46 p.m.",
      "commitName": "88530a179e2ddfa81de5cc441a27d66521334608",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-05-20, 7:49 p.m.",
      "commitNameOld": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 36.04,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tparents.add(0, headId);\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d DirCache.lock(repo);\n\t\t\ttry {\n\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n\t\t\t\ttry {\n\t\t\t\t\t// Write the index as tree to the object database. This may\n\t\t\t\t\t// fail for example when the index contains unmerged paths\n\t\t\t\t\t// (unresolved conflicts)\n\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n\n\t\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\t\tCommit commit \u003d new Commit(repo);\n\t\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\t\tcommit.setAuthor(author);\n\t\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n\t\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n\t\t\t\t\t\t\t.format(commit));\n\t\t\t\t\todi.flush();\n\n\t\t\t\t\tRevCommit revCommit \u003d new RevWalk(repo)\n\t\t\t\t\t\t\t.parseCommit(commitId);\n\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n\n\t\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\t\tResult rc \u003d ru.update();\n\t\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\tsetCallable(false);\n\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_HEAD)\n\t\t\t\t\t\t\t\t\t.delete();\n\t\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_MSG)\n\t\t\t\t\t\t\t\t\t.delete();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn revCommit;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\todi.release();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 119,
      "functionName": "call",
      "diff": "@@ -1,85 +1,92 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state \u003d repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId !\u003d null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d DirCache.lock(repo);\n \t\t\ttry {\n-\t\t\t\tObjectWriter repoWriter \u003d new ObjectWriter(repo);\n+\t\t\t\tObjectInserter odi \u003d repo.newObjectInserter();\n+\t\t\t\ttry {\n+\t\t\t\t\t// Write the index as tree to the object database. This may\n+\t\t\t\t\t// fail for example when the index contains unmerged paths\n+\t\t\t\t\t// (unresolved conflicts)\n+\t\t\t\t\tObjectId indexTreeId \u003d index.writeTree(odi);\n \n-\t\t\t\t// Write the index as tree to the object database. This may fail\n-\t\t\t\t// for example when the index contains unmerged pathes\n-\t\t\t\t// (unresolved conflicts)\n-\t\t\t\tObjectId indexTreeId \u003d index.writeTree(repoWriter);\n+\t\t\t\t\t// Create a Commit object, populate it and write it\n+\t\t\t\t\tCommit commit \u003d new Commit(repo);\n+\t\t\t\t\tcommit.setCommitter(committer);\n+\t\t\t\t\tcommit.setAuthor(author);\n+\t\t\t\t\tcommit.setMessage(message);\n \n-\t\t\t\t// Create a Commit object, populate it and write it\n-\t\t\t\tCommit commit \u003d new Commit(repo);\n-\t\t\t\tcommit.setCommitter(committer);\n-\t\t\t\tcommit.setAuthor(author);\n-\t\t\t\tcommit.setMessage(message);\n+\t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n+\t\t\t\t\tcommit.setTreeId(indexTreeId);\n+\t\t\t\t\tObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi\n+\t\t\t\t\t\t\t.format(commit));\n+\t\t\t\t\todi.flush();\n \n-\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[]{}));\n-\t\t\t\tcommit.setTreeId(indexTreeId);\n-\t\t\t\tObjectId commitId \u003d repoWriter.writeCommit(commit);\n+\t\t\t\t\tRevCommit revCommit \u003d new RevWalk(repo)\n+\t\t\t\t\t\t\t.parseCommit(commitId);\n+\t\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+\t\t\t\t\tru.setNewObjectId(commitId);\n+\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n+\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n-\t\t\t\tRevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n-\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n-\t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\tru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(),\n-\t\t\t\t\t\tfalse);\n-\n-\t\t\t\tru.setExpectedOldObjectId(headId);\n-\t\t\t\tResult rc \u003d ru.update();\n-\t\t\t\tswitch (rc) {\n-\t\t\t\tcase NEW:\n-\t\t\t\tcase FAST_FORWARD:\n-\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n-\t\t\t\t\t\t// Commit was successful. Now delete the files\n-\t\t\t\t\t\t// used for merge commits\n-\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_HEAD)\n-\t\t\t\t\t\t\t\t.delete();\n-\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_MSG)\n-\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\tru.setExpectedOldObjectId(headId);\n+\t\t\t\t\tResult rc \u003d ru.update();\n+\t\t\t\t\tswitch (rc) {\n+\t\t\t\t\tcase NEW:\n+\t\t\t\t\tcase FAST_FORWARD:\n+\t\t\t\t\t\tsetCallable(false);\n+\t\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n+\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n+\t\t\t\t\t\t\t// used for merge commits\n+\t\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_HEAD)\n+\t\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_MSG)\n+\t\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn revCommit;\n+\t\t\t\t\tcase REJECTED:\n+\t\t\t\t\tcase LOCK_FAILURE:\n+\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n+\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n+\t\t\t\t\t\t\t\trc);\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n+\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n+\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n-\t\t\t\t\treturn revCommit;\n-\t\t\t\tcase REJECTED:\n-\t\t\t\tcase LOCK_FAILURE:\n-\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n-\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n-\t\t\t\tdefault:\n-\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n-\t\t\t\t\t\t\tJGitText.get().updatingRefFailed\n-\t\t\t\t\t\t\t, Constants.HEAD, commitId.toString(), rc));\n+\t\t\t\t} finally {\n+\t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6ca9843f3ebbea152969a8b795efce1d4ff15dbf": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Added merge support to CommitCommand\n\nThe CommitCommand should take care to create a merge commit if the file\n$GIT_DIR/MERGE_HEAD exists. It should then read the parents for the merge\ncommit out of this file. It should also take care that when commiting\na merge and no commit message was specified to read the message from\n$GIT_DIR/MERGE_MSG.\nFinally the CommitCommand should remove these files if the commit\nsucceeded.\n\nChange-Id: \tI4e292115085099d5b86546d2021680cb1454266c\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2010-05-20, 7:49 p.m.",
      "commitName": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
      "commitAuthor": "Christian Halstrick",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Added merge support to CommitCommand\n\nThe CommitCommand should take care to create a merge commit if the file\n$GIT_DIR/MERGE_HEAD exists. It should then read the parents for the merge\ncommit out of this file. It should also take care that when commiting\na merge and no commit message was specified to read the message from\n$GIT_DIR/MERGE_MSG.\nFinally the CommitCommand should remove these files if the commit\nsucceeded.\n\nChange-Id: \tI4e292115085099d5b86546d2021680cb1454266c\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
          "commitDate": "2010-05-20, 7:49 p.m.",
          "commitName": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
          "commitAuthor": "Christian Halstrick",
          "commitDateOld": "2010-05-19, 5:37 p.m.",
          "commitNameOld": "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d",
          "commitAuthorOld": "Sasa Zivkov",
          "daysBetweenCommits": 1.09,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tparents.add(0, headId);\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d DirCache.lock(repo);\n\t\t\ttry {\n\t\t\t\tObjectWriter repoWriter \u003d new ObjectWriter(repo);\n\n\t\t\t\t// Write the index as tree to the object database. This may fail\n\t\t\t\t// for example when the index contains unmerged pathes\n\t\t\t\t// (unresolved conflicts)\n\t\t\t\tObjectId indexTreeId \u003d index.writeTree(repoWriter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tCommit commit \u003d new Commit(repo);\n\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[]{}));\n\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\tObjectId commitId \u003d repoWriter.writeCommit(commit);\n\n\t\t\t\tRevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(),\n\t\t\t\t\t\tfalse);\n\n\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\tResult rc \u003d ru.update();\n\t\t\t\tswitch (rc) {\n\t\t\t\tcase NEW:\n\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_HEAD)\n\t\t\t\t\t\t\t\t.delete();\n\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_MSG)\n\t\t\t\t\t\t\t\t.delete();\n\t\t\t\t\t}\n\t\t\t\t\treturn revCommit;\n\t\t\t\tcase REJECTED:\n\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().updatingRefFailed\n\t\t\t\t\t\t\t, Constants.HEAD, commitId.toString(), rc));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 119,
          "functionName": "call",
          "diff": "@@ -1,70 +1,85 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n-\t\t\tJGitInternalException {\n+\t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n-\t\tprocessOptions();\n+\n+\t\tRepositoryState state \u003d repo.getRepositoryState();\n+\t\tif (!state.canCommit())\n+\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n+\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n+\t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n-\t\t\tObjectId parentID \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+\t\t\tif (headId !\u003d null)\n+\t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d DirCache.lock(repo);\n \t\t\ttry {\n \t\t\t\tObjectWriter repoWriter \u003d new ObjectWriter(repo);\n \n \t\t\t\t// Write the index as tree to the object database. This may fail\n \t\t\t\t// for example when the index contains unmerged pathes\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId \u003d index.writeTree(repoWriter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommit commit \u003d new Commit(repo);\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n-\t\t\t\tif (parentID !\u003d null)\n-\t\t\t\t\tcommit.setParentIds(new ObjectId[] { parentID });\n+\n+\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[]{}));\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId \u003d repoWriter.writeCommit(commit);\n \n \t\t\t\tRevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(),\n \t\t\t\t\t\tfalse);\n \n-\t\t\t\tru.setExpectedOldObjectId(parentID);\n+\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\tResult rc \u003d ru.update();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tsetCallable(false);\n+\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n+\t\t\t\t\t\t// Commit was successful. Now delete the files\n+\t\t\t\t\t\t// used for merge commits\n+\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_HEAD)\n+\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_MSG)\n+\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t}\n \t\t\t\t\treturn revCommit;\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed\n \t\t\t\t\t\t\t, Constants.HEAD, commitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException]",
            "newValue": "[NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Added merge support to CommitCommand\n\nThe CommitCommand should take care to create a merge commit if the file\n$GIT_DIR/MERGE_HEAD exists. It should then read the parents for the merge\ncommit out of this file. It should also take care that when commiting\na merge and no commit message was specified to read the message from\n$GIT_DIR/MERGE_MSG.\nFinally the CommitCommand should remove these files if the commit\nsucceeded.\n\nChange-Id: \tI4e292115085099d5b86546d2021680cb1454266c\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
          "commitDate": "2010-05-20, 7:49 p.m.",
          "commitName": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
          "commitAuthor": "Christian Halstrick",
          "commitDateOld": "2010-05-19, 5:37 p.m.",
          "commitNameOld": "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d",
          "commitAuthorOld": "Sasa Zivkov",
          "daysBetweenCommits": 1.09,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException, WrongRepositoryStateException {\n\t\tcheckCallable();\n\n\t\tRepositoryState state \u003d repo.getRepositoryState();\n\t\tif (!state.canCommit())\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n\t\tprocessOptions(state);\n\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\t\t\tif (headId !\u003d null)\n\t\t\t\tparents.add(0, headId);\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d DirCache.lock(repo);\n\t\t\ttry {\n\t\t\t\tObjectWriter repoWriter \u003d new ObjectWriter(repo);\n\n\t\t\t\t// Write the index as tree to the object database. This may fail\n\t\t\t\t// for example when the index contains unmerged pathes\n\t\t\t\t// (unresolved conflicts)\n\t\t\t\tObjectId indexTreeId \u003d index.writeTree(repoWriter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tCommit commit \u003d new Commit(repo);\n\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setMessage(message);\n\n\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[]{}));\n\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\tObjectId commitId \u003d repoWriter.writeCommit(commit);\n\n\t\t\t\tRevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(),\n\t\t\t\t\t\tfalse);\n\n\t\t\t\tru.setExpectedOldObjectId(headId);\n\t\t\t\tResult rc \u003d ru.update();\n\t\t\t\tswitch (rc) {\n\t\t\t\tcase NEW:\n\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n\t\t\t\t\t\t// Commit was successful. Now delete the files\n\t\t\t\t\t\t// used for merge commits\n\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_HEAD)\n\t\t\t\t\t\t\t\t.delete();\n\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_MSG)\n\t\t\t\t\t\t\t\t.delete();\n\t\t\t\t\t}\n\t\t\t\t\treturn revCommit;\n\t\t\t\tcase REJECTED:\n\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().updatingRefFailed\n\t\t\t\t\t\t\t, Constants.HEAD, commitId.toString(), rc));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 119,
          "functionName": "call",
          "diff": "@@ -1,70 +1,85 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n-\t\t\tJGitInternalException {\n+\t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n-\t\tprocessOptions();\n+\n+\t\tRepositoryState state \u003d repo.getRepositoryState();\n+\t\tif (!state.canCommit())\n+\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n+\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n+\t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n-\t\t\tObjectId parentID \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+\t\t\tif (headId !\u003d null)\n+\t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d DirCache.lock(repo);\n \t\t\ttry {\n \t\t\t\tObjectWriter repoWriter \u003d new ObjectWriter(repo);\n \n \t\t\t\t// Write the index as tree to the object database. This may fail\n \t\t\t\t// for example when the index contains unmerged pathes\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId \u003d index.writeTree(repoWriter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommit commit \u003d new Commit(repo);\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n-\t\t\t\tif (parentID !\u003d null)\n-\t\t\t\t\tcommit.setParentIds(new ObjectId[] { parentID });\n+\n+\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[]{}));\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId \u003d repoWriter.writeCommit(commit);\n \n \t\t\t\tRevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(),\n \t\t\t\t\t\tfalse);\n \n-\t\t\t\tru.setExpectedOldObjectId(parentID);\n+\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\tResult rc \u003d ru.update();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tsetCallable(false);\n+\t\t\t\t\tif (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n+\t\t\t\t\t\t// Commit was successful. Now delete the files\n+\t\t\t\t\t\t// used for merge commits\n+\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_HEAD)\n+\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_MSG)\n+\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t}\n \t\t\t\t\treturn revCommit;\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed\n \t\t\t\t\t\t\t, Constants.HEAD, commitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d": {
      "type": "Ybodychange",
      "commitMessage": "Externalize strings from JGit\n\nThe strings are externalized into the root resource bundles.\nThe resource bundles are stored under the new \"resources\" source\nfolder to get proper maven build.\n\nStrings from tests are, in general, not externalized. Only in\ncases where it was necessary to make the test pass the strings\nwere externalized. This was typically necessary in cases where\ne.getMessage() was used in assert and the exception message was\nslightly changed due to reuse of the externalized strings.\n\nChange-Id: Ic0f29c80b9a54fcec8320d8539a3e112852a1f7b\nSigned-off-by: Sasa Zivkov \u003csasa.zivkov@sap.com\u003e\n",
      "commitDate": "2010-05-19, 5:37 p.m.",
      "commitName": "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d",
      "commitAuthor": "Sasa Zivkov",
      "commitDateOld": "2010-05-10, 9:17 a.m.",
      "commitNameOld": "f3fb5824ba45197787bc4ffb81fafcd576c60291",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 9.35,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException {\n\t\tcheckCallable();\n\t\tprocessOptions();\n\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId parentID \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d DirCache.lock(repo);\n\t\t\ttry {\n\t\t\t\tObjectWriter repoWriter \u003d new ObjectWriter(repo);\n\n\t\t\t\t// Write the index as tree to the object database. This may fail\n\t\t\t\t// for example when the index contains unmerged pathes\n\t\t\t\t// (unresolved conflicts)\n\t\t\t\tObjectId indexTreeId \u003d index.writeTree(repoWriter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tCommit commit \u003d new Commit(repo);\n\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setMessage(message);\n\t\t\t\tif (parentID !\u003d null)\n\t\t\t\t\tcommit.setParentIds(new ObjectId[] { parentID });\n\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\tObjectId commitId \u003d repoWriter.writeCommit(commit);\n\n\t\t\t\tRevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(),\n\t\t\t\t\t\tfalse);\n\n\t\t\t\tru.setExpectedOldObjectId(parentID);\n\t\t\t\tResult rc \u003d ru.update();\n\t\t\t\tswitch (rc) {\n\t\t\t\tcase NEW:\n\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\treturn revCommit;\n\t\t\t\tcase REJECTED:\n\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().updatingRefFailed\n\t\t\t\t\t\t\t, Constants.HEAD, commitId.toString(), rc));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 107,
      "functionName": "call",
      "diff": "@@ -1,74 +1,70 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException {\n \t\tcheckCallable();\n \t\tprocessOptions();\n \n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n-\t\t\t\t\t\t\"Commit on repo without HEAD currently not supported\");\n+\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId parentID \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n \n \t\t\t// lock the index\n \t\t\tDirCache index \u003d DirCache.lock(repo);\n \t\t\ttry {\n \t\t\t\tObjectWriter repoWriter \u003d new ObjectWriter(repo);\n \n \t\t\t\t// Write the index as tree to the object database. This may fail\n \t\t\t\t// for example when the index contains unmerged pathes\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId \u003d index.writeTree(repoWriter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommit commit \u003d new Commit(repo);\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \t\t\t\tif (parentID !\u003d null)\n \t\t\t\t\tcommit.setParentIds(new ObjectId[] { parentID });\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId \u003d repoWriter.writeCommit(commit);\n \n \t\t\t\tRevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(),\n \t\t\t\t\t\tfalse);\n \n \t\t\t\tru.setExpectedOldObjectId(parentID);\n \t\t\t\tResult rc \u003d ru.update();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\treturn revCommit;\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n-\t\t\t\t\t\t\t\"Could lock HEAD during commit\", ru.getRef(), rc);\n+\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n-\t\t\t\t\tthrow new JGitInternalException(\n-\t\t\t\t\t\t\t\"Updating the ref \"\n-\t\t\t\t\t\t\t\t\t+ Constants.HEAD\n-\t\t\t\t\t\t\t\t\t+ \" to \"\n-\t\t\t\t\t\t\t\t\t+ commitId.toString()\n-\t\t\t\t\t\t\t\t\t+ \" failed. ReturnCode from RefUpdate.update() was \"\n-\t\t\t\t\t\t\t\t\t+ rc);\n+\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().updatingRefFailed\n+\t\t\t\t\t\t\t, Constants.HEAD, commitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n-\t\t\t\t\t\"Exception caught during execution of commit command\", e);\n+\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f3fb5824ba45197787bc4ffb81fafcd576c60291": {
      "type": "Yintroduced",
      "commitMessage": "Add builder-style API to jgit and Commit \u0026 Log cmd\n\nAdded a new package org.eclipse.jgit.api and a builder-style API for\njgit. Added also the first implementation for two git commands: Commit\nand Log.\n\nThis API is intended to be used by external components when\nfunctionalities of the standard git commands are required. It will also\nhelp to ease writing JGit tests.\n\nFor internal usages this API may often not be optimal because the git\ncommands are doing much more than required or they expect parameters of\nan unappropriate type.\n\nChange-Id: I71ac4839ab9d2f848307eba9252090c586b4146b\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2010-05-10, 9:17 a.m.",
      "commitName": "f3fb5824ba45197787bc4ffb81fafcd576c60291",
      "commitAuthor": "Christian Halstrick",
      "diff": "@@ -0,0 +1,74 @@\n+\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n+\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n+\t\t\tJGitInternalException {\n+\t\tcheckCallable();\n+\t\tprocessOptions();\n+\n+\t\ttry {\n+\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n+\t\t\tif (head \u003d\u003d null)\n+\t\t\t\tthrow new NoHeadException(\n+\t\t\t\t\t\t\"Commit on repo without HEAD currently not supported\");\n+\n+\t\t\t// determine the current HEAD and the commit it is referring to\n+\t\t\tObjectId parentID \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+\n+\t\t\t// lock the index\n+\t\t\tDirCache index \u003d DirCache.lock(repo);\n+\t\t\ttry {\n+\t\t\t\tObjectWriter repoWriter \u003d new ObjectWriter(repo);\n+\n+\t\t\t\t// Write the index as tree to the object database. This may fail\n+\t\t\t\t// for example when the index contains unmerged pathes\n+\t\t\t\t// (unresolved conflicts)\n+\t\t\t\tObjectId indexTreeId \u003d index.writeTree(repoWriter);\n+\n+\t\t\t\t// Create a Commit object, populate it and write it\n+\t\t\t\tCommit commit \u003d new Commit(repo);\n+\t\t\t\tcommit.setCommitter(committer);\n+\t\t\t\tcommit.setAuthor(author);\n+\t\t\t\tcommit.setMessage(message);\n+\t\t\t\tif (parentID !\u003d null)\n+\t\t\t\t\tcommit.setParentIds(new ObjectId[] { parentID });\n+\t\t\t\tcommit.setTreeId(indexTreeId);\n+\t\t\t\tObjectId commitId \u003d repoWriter.writeCommit(commit);\n+\n+\t\t\t\tRevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n+\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+\t\t\t\tru.setNewObjectId(commitId);\n+\t\t\t\tru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(),\n+\t\t\t\t\t\tfalse);\n+\n+\t\t\t\tru.setExpectedOldObjectId(parentID);\n+\t\t\t\tResult rc \u003d ru.update();\n+\t\t\t\tswitch (rc) {\n+\t\t\t\tcase NEW:\n+\t\t\t\tcase FAST_FORWARD:\n+\t\t\t\t\tsetCallable(false);\n+\t\t\t\t\treturn revCommit;\n+\t\t\t\tcase REJECTED:\n+\t\t\t\tcase LOCK_FAILURE:\n+\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n+\t\t\t\t\t\t\t\"Could lock HEAD during commit\", ru.getRef(), rc);\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new JGitInternalException(\n+\t\t\t\t\t\t\t\"Updating the ref \"\n+\t\t\t\t\t\t\t\t\t+ Constants.HEAD\n+\t\t\t\t\t\t\t\t\t+ \" to \"\n+\t\t\t\t\t\t\t\t\t+ commitId.toString()\n+\t\t\t\t\t\t\t\t\t+ \" failed. ReturnCode from RefUpdate.update() was \"\n+\t\t\t\t\t\t\t\t\t+ rc);\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\tindex.unlock();\n+\t\t\t}\n+\t\t} catch (UnmergedPathException e) {\n+\t\t\t// since UnmergedPathException is a subclass of IOException\n+\t\t\t// which should not be wrapped by a JGitInternalException we\n+\t\t\t// have to catch and re-throw it here\n+\t\t\tthrow e;\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new JGitInternalException(\n+\t\t\t\t\t\"Exception caught during execution of commit command\", e);\n+\t\t}\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n\t\t\tJGitInternalException {\n\t\tcheckCallable();\n\t\tprocessOptions();\n\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\"Commit on repo without HEAD currently not supported\");\n\n\t\t\t// determine the current HEAD and the commit it is referring to\n\t\t\tObjectId parentID \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n\n\t\t\t// lock the index\n\t\t\tDirCache index \u003d DirCache.lock(repo);\n\t\t\ttry {\n\t\t\t\tObjectWriter repoWriter \u003d new ObjectWriter(repo);\n\n\t\t\t\t// Write the index as tree to the object database. This may fail\n\t\t\t\t// for example when the index contains unmerged pathes\n\t\t\t\t// (unresolved conflicts)\n\t\t\t\tObjectId indexTreeId \u003d index.writeTree(repoWriter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tCommit commit \u003d new Commit(repo);\n\t\t\t\tcommit.setCommitter(committer);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setMessage(message);\n\t\t\t\tif (parentID !\u003d null)\n\t\t\t\t\tcommit.setParentIds(new ObjectId[] { parentID });\n\t\t\t\tcommit.setTreeId(indexTreeId);\n\t\t\t\tObjectId commitId \u003d repoWriter.writeCommit(commit);\n\n\t\t\t\tRevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(),\n\t\t\t\t\t\tfalse);\n\n\t\t\t\tru.setExpectedOldObjectId(parentID);\n\t\t\t\tResult rc \u003d ru.update();\n\t\t\t\tswitch (rc) {\n\t\t\t\tcase NEW:\n\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\treturn revCommit;\n\t\t\t\tcase REJECTED:\n\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\"Could lock HEAD during commit\", ru.getRef(), rc);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Updating the ref \"\n\t\t\t\t\t\t\t\t\t+ Constants.HEAD\n\t\t\t\t\t\t\t\t\t+ \" to \"\n\t\t\t\t\t\t\t\t\t+ commitId.toString()\n\t\t\t\t\t\t\t\t\t+ \" failed. ReturnCode from RefUpdate.update() was \"\n\t\t\t\t\t\t\t\t\t+ rc);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tindex.unlock();\n\t\t\t}\n\t\t} catch (UnmergedPathException e) {\n\t\t\t// since UnmergedPathException is a subclass of IOException\n\t\t\t// which should not be wrapped by a JGitInternalException we\n\t\t\t// have to catch and re-throw it here\n\t\t\tthrow e;\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\"Exception caught during execution of commit command\", e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 105,
      "functionName": "call"
    }
  }
}