{
  "origin": "codeshovel",
  "repositoryName": "flink",
  "repositoryPath": "H:\\Projects\\apache\\flink/.git",
  "startCommitName": "9e936a5f8198b0059e9b5fba33163c2bbe3efbdd",
  "sourceFileName": "KryoSerializer.java",
  "functionName": "checkKryoInitialized",
  "functionId": "checkKryoInitialized",
  "sourceFilePath": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java",
  "functionStartLine": 426,
  "functionEndLine": 453,
  "numCommitsSeen": 37,
  "timeTaken": 3853,
  "changeHistory": [
    "8aa5e05733655e7b3d1f11ed15f61672d61e5cb5",
    "f2143172feca2925832c8b26c3c9fbbb92ecd48f",
    "dc78a7470a5da086a08140b200a20d840460ef79",
    "21a715867d655bb61df9a9f7eef37e42b99e206a",
    "ed3810b1282dfba80d63b1f43a0c202925a3b11c",
    "cd899f3be39c5f052a2a3e90771111d1a7df1d47",
    "2cc5d98c690c1b1b1ff1f48628ca58b1b4f0c932",
    "354efec0f9da0fa03ea9b337b02a1a2a03a9ac16",
    "a0b6af20beed6d12d0f33f6f58f323b20cc12961",
    "2d4ed15e8d2aa1a1fcd7001fccea2ee70cc8a8b0",
    "8af6ef49fd84c309aeba0a3c8963ac83e0243c59",
    "a70aa67a0881afc5d66329d46fe536d7a0b89fa8",
    "f5898a01e7877afa3df06223713db211708eaf9a",
    "22203e75f8a0d193ce0187396d0b267e05e9b58e"
  ],
  "changeHistoryShort": {
    "8aa5e05733655e7b3d1f11ed15f61672d61e5cb5": "Ybodychange",
    "f2143172feca2925832c8b26c3c9fbbb92ecd48f": "Ybodychange",
    "dc78a7470a5da086a08140b200a20d840460ef79": "Ybodychange",
    "21a715867d655bb61df9a9f7eef37e42b99e206a": "Yfilerename",
    "ed3810b1282dfba80d63b1f43a0c202925a3b11c": "Ybodychange",
    "cd899f3be39c5f052a2a3e90771111d1a7df1d47": "Ybodychange",
    "2cc5d98c690c1b1b1ff1f48628ca58b1b4f0c932": "Ybodychange",
    "354efec0f9da0fa03ea9b337b02a1a2a03a9ac16": "Ymultichange(Yfilerename,Ybodychange)",
    "a0b6af20beed6d12d0f33f6f58f323b20cc12961": "Ybodychange",
    "2d4ed15e8d2aa1a1fcd7001fccea2ee70cc8a8b0": "Ybodychange",
    "8af6ef49fd84c309aeba0a3c8963ac83e0243c59": "Ybodychange",
    "a70aa67a0881afc5d66329d46fe536d7a0b89fa8": "Ybodychange",
    "f5898a01e7877afa3df06223713db211708eaf9a": "Ymodifierchange",
    "22203e75f8a0d193ce0187396d0b267e05e9b58e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8aa5e05733655e7b3d1f11ed15f61672d61e5cb5": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-6178] [core] Allow serializer upgrades for managed state\n\nThis commit adds the functionality of allowing serializer upgrades for\nFlink\u0027s managed state. It consists of 2 major changes: 1) new\nuser-facing API in `TypeSerializer`, and 2) activate serializer upgrades\nin state backends.\n\nFor 1) new user-facing API for `TypeSerializer`, the following is added:\n- new class: TypeSerializerConfigSnapshot\n- new class: CompatibilityResult\n- new method: TypeSerializer#snapshotConfiguration()\n- new method:\n  TypeSerializer#ensureCompatibility(TypeSerializerConfigSnapshot)\n\nGenerally speaking, configuration snapshots contains a point-in-time\nview of a serializer\u0027s state / configuration, and is persisted along\nwith checkpoints. On restore, the configuration is confronted with the\nnew serializer of the state to check for compatibility, which may\nintroduce reconfiguration of the new serializer to be compatible.\n\nThis compatibility check is integrated in the state backends\u0027 restore\nflow in 2). Currently, if the check results in the need to perform state\nmigration, the restore simply fails as the state migration feature isn\u0027t\nyet available.\n",
      "commitDate": "2017-05-07, 2:04 p.m.",
      "commitName": "8aa5e05733655e7b3d1f11ed15f61672d61e5cb5",
      "commitAuthor": "Tzu-Li (Gordon) Tai",
      "commitDateOld": "2017-03-24, 12:34 a.m.",
      "commitNameOld": "09164cf2388888bc2f92f0ca63bb1f15283e895c",
      "commitAuthorOld": "Aljoscha Krettek",
      "daysBetweenCommits": 44.56,
      "commitsBetweenForRepo": 296,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d getKryoInstance();\n\n\t\t\t// Enable reference tracking. \n\t\t\tkryo.setReferences(true);\n\t\t\t\n\t\t\t// Throwable and all subclasses should be serialized via java serialization\n\t\t\t// Note: the registered JavaSerializer is Flink\u0027s own implementation, and not Kryo\u0027s.\n\t\t\t//       This is due to a know issue with Kryo\u0027s JavaSerializer. See FLINK-6025 for details.\n\t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n\n\t\t\t// Add default serializers first, so that the type registrations without a serializer\n\t\t\t// are registered with a default serializer\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e entry: defaultSerializers.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n\t\t\t}\n\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e entry: defaultSerializerClasses.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n\t\t\t}\n\n\t\t\tKryoUtils.applyRegistrations(this.kryo, kryoRegistrations.values());\n\n\t\t\tkryo.setRegistrationRequired(false);\n\t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n\t\t}\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java",
      "functionStartLine": 342,
      "functionName": "checkKryoInitialized",
      "diff": "@@ -1,52 +1,28 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo \u003d\u003d null) {\n \t\t\tthis.kryo \u003d getKryoInstance();\n \n \t\t\t// Enable reference tracking. \n \t\t\tkryo.setReferences(true);\n \t\t\t\n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\t// Note: the registered JavaSerializer is Flink\u0027s own implementation, and not Kryo\u0027s.\n \t\t\t//       This is due to a know issue with Kryo\u0027s JavaSerializer. See FLINK-6025 for details.\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n-\t\t\t// Add default serializers first, so that they type registrations without a serializer\n+\t\t\t// Add default serializers first, so that the type registrations without a serializer\n \t\t\t// are registered with a default serializer\n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e entry: defaultSerializers.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n \t\t\t}\n \n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e entry: defaultSerializerClasses.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n \t\t\t}\n \n-\t\t\t// register the type of our class\n-\t\t\tkryo.register(type);\n-\n-\t\t\t// register given types. we do this first so that any registration of a\n-\t\t\t// more specific serializer overrides this\n-\t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n-\t\t\t\tkryo.register(type);\n-\t\t\t}\n-\n-\t\t\t// register given serializer classes\n-\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses.entrySet()) {\n-\t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n-\t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n-\n-\t\t\t\tSerializer\u003c?\u003e serializer \u003d\n-\t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n-\t\t\t\tkryo.register(typeClass, serializer);\n-\t\t\t}\n-\n-\t\t\t// register given serializers\n-\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e e : registeredTypesWithSerializers.entrySet()) {\n-\t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n-\t\t\t}\n-\t\t\t// this is needed for Avro but can not be added on demand.\n-\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n+\t\t\tKryoUtils.applyRegistrations(this.kryo, kryoRegistrations.values());\n \n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f2143172feca2925832c8b26c3c9fbbb92ecd48f": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-6025] [core] Add Flink\u0027s own JavaSerializer for Kryo serialization\n\nThis commit adds a reimplemented JavaSerializer to be registered with\nKryo. This is due to a know issue with Kryo\u0027s JavaSerializer that may\nuse the wrong classloader for deserialzation.\n\nInstead of registering Kryo\u0027s JavaSerializer for Throwables, it is now\nchanged to register the reimplemented JavaSerializer. Users who bump\ninto ClassNotFoundExceptions if they are using Kryo\u0027s JavaSerializer for\ntheir own types are also recommended to change to Flink\u0027s JavaSerializer.\n\nThis closes #3517.\n",
      "commitDate": "2017-03-13, 11:31 a.m.",
      "commitName": "f2143172feca2925832c8b26c3c9fbbb92ecd48f",
      "commitAuthor": "Tzu-Li (Gordon) Tai",
      "commitDateOld": "2016-04-15, 1:38 p.m.",
      "commitNameOld": "dc78a7470a5da086a08140b200a20d840460ef79",
      "commitAuthorOld": "Andrew Palumbo",
      "daysBetweenCommits": 331.91,
      "commitsBetweenForRepo": 1897,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d getKryoInstance();\n\n\t\t\t// Enable reference tracking. \n\t\t\tkryo.setReferences(true);\n\t\t\t\n\t\t\t// Throwable and all subclasses should be serialized via java serialization\n\t\t\t// Note: the registered JavaSerializer is Flink\u0027s own implementation, and not Kryo\u0027s.\n\t\t\t//       This is due to a know issue with Kryo\u0027s JavaSerializer. See FLINK-6025 for details.\n\t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n\n\t\t\t// Add default serializers first, so that they type registrations without a serializer\n\t\t\t// are registered with a default serializer\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e entry: defaultSerializers.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n\t\t\t}\n\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e entry: defaultSerializerClasses.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n\t\t\t}\n\n\t\t\t// register the type of our class\n\t\t\tkryo.register(type);\n\n\t\t\t// register given types. we do this first so that any registration of a\n\t\t\t// more specific serializer overrides this\n\t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n\t\t\t\tkryo.register(type);\n\t\t\t}\n\n\t\t\t// register given serializer classes\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses.entrySet()) {\n\t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n\t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n\n\t\t\t\tSerializer\u003c?\u003e serializer \u003d\n\t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n\t\t\t\tkryo.register(typeClass, serializer);\n\t\t\t}\n\n\t\t\t// register given serializers\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e e : registeredTypesWithSerializers.entrySet()) {\n\t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n\t\t\t}\n\t\t\t// this is needed for Avro but can not be added on demand.\n\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n\n\t\t\tkryo.setRegistrationRequired(false);\n\t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n\t\t}\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java",
      "functionStartLine": 325,
      "functionName": "checkKryoInitialized",
      "diff": "@@ -1,50 +1,52 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo \u003d\u003d null) {\n \t\t\tthis.kryo \u003d getKryoInstance();\n \n \t\t\t// Enable reference tracking. \n \t\t\tkryo.setReferences(true);\n \t\t\t\n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n+\t\t\t// Note: the registered JavaSerializer is Flink\u0027s own implementation, and not Kryo\u0027s.\n+\t\t\t//       This is due to a know issue with Kryo\u0027s JavaSerializer. See FLINK-6025 for details.\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n \t\t\t// Add default serializers first, so that they type registrations without a serializer\n \t\t\t// are registered with a default serializer\n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e entry: defaultSerializers.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n \t\t\t}\n \n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e entry: defaultSerializerClasses.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n \t\t\t}\n \n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n \n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n \n \t\t\t// register given serializer classes\n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses.entrySet()) {\n \t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n \t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n \n \t\t\t\tSerializer\u003c?\u003e serializer \u003d\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e e : registeredTypesWithSerializers.entrySet()) {\n \t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n \t\t\t}\n \t\t\t// this is needed for Avro but can not be added on demand.\n \t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n \n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dc78a7470a5da086a08140b200a20d840460ef79": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-3762] [core] Enable Kryo reference tracking\n\nThis closes #1891\n",
      "commitDate": "2016-04-15, 1:38 p.m.",
      "commitName": "dc78a7470a5da086a08140b200a20d840460ef79",
      "commitAuthor": "Andrew Palumbo",
      "commitDateOld": "2016-04-15, 1:38 p.m.",
      "commitNameOld": "760a0d9e7fd9fa88e9f7408b137d78df384d764f",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d getKryoInstance();\n\n\t\t\t// Enable reference tracking. \n\t\t\tkryo.setReferences(true);\n\t\t\t\n\t\t\t// Throwable and all subclasses should be serialized via java serialization\n\t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n\n\t\t\t// Add default serializers first, so that they type registrations without a serializer\n\t\t\t// are registered with a default serializer\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e entry: defaultSerializers.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n\t\t\t}\n\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e entry: defaultSerializerClasses.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n\t\t\t}\n\n\t\t\t// register the type of our class\n\t\t\tkryo.register(type);\n\n\t\t\t// register given types. we do this first so that any registration of a\n\t\t\t// more specific serializer overrides this\n\t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n\t\t\t\tkryo.register(type);\n\t\t\t}\n\n\t\t\t// register given serializer classes\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses.entrySet()) {\n\t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n\t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n\n\t\t\t\tSerializer\u003c?\u003e serializer \u003d\n\t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n\t\t\t\tkryo.register(typeClass, serializer);\n\t\t\t}\n\n\t\t\t// register given serializers\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e e : registeredTypesWithSerializers.entrySet()) {\n\t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n\t\t\t}\n\t\t\t// this is needed for Avro but can not be added on demand.\n\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n\n\t\t\tkryo.setRegistrationRequired(false);\n\t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n\t\t}\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java",
      "functionStartLine": 326,
      "functionName": "checkKryoInitialized",
      "diff": "@@ -1,51 +1,50 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo \u003d\u003d null) {\n \t\t\tthis.kryo \u003d getKryoInstance();\n \n-\t\t\t// disable reference tracking. reference tracking is costly, usually unnecessary, and\n-\t\t\t// inconsistent with Flink\u0027s own serialization (which does not do reference tracking)\n-\t\t\tkryo.setReferences(false);\n+\t\t\t// Enable reference tracking. \n+\t\t\tkryo.setReferences(true);\n \t\t\t\n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n \t\t\t// Add default serializers first, so that they type registrations without a serializer\n \t\t\t// are registered with a default serializer\n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e entry: defaultSerializers.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n \t\t\t}\n \n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e entry: defaultSerializerClasses.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n \t\t\t}\n \n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n \n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n \n \t\t\t// register given serializer classes\n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses.entrySet()) {\n \t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n \t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n \n \t\t\t\tSerializer\u003c?\u003e serializer \u003d\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e e : registeredTypesWithSerializers.entrySet()) {\n \t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n \t\t\t}\n \t\t\t// this is needed for Avro but can not be added on demand.\n \t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n \n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "21a715867d655bb61df9a9f7eef37e42b99e206a": {
      "type": "Yfilerename",
      "commitMessage": "[FLINK-3303] [core] Move all type utilities to flink-core\n",
      "commitDate": "2016-02-02, 10:55 a.m.",
      "commitName": "21a715867d655bb61df9a9f7eef37e42b99e206a",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2016-02-02, 10:55 a.m.",
      "commitNameOld": "7081836e0d640ee640687606bd73b6673d3f2a07",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d getKryoInstance();\n\n\t\t\t// disable reference tracking. reference tracking is costly, usually unnecessary, and\n\t\t\t// inconsistent with Flink\u0027s own serialization (which does not do reference tracking)\n\t\t\tkryo.setReferences(false);\n\t\t\t\n\t\t\t// Throwable and all subclasses should be serialized via java serialization\n\t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n\n\t\t\t// Add default serializers first, so that they type registrations without a serializer\n\t\t\t// are registered with a default serializer\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e entry: defaultSerializers.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n\t\t\t}\n\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e entry: defaultSerializerClasses.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n\t\t\t}\n\n\t\t\t// register the type of our class\n\t\t\tkryo.register(type);\n\n\t\t\t// register given types. we do this first so that any registration of a\n\t\t\t// more specific serializer overrides this\n\t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n\t\t\t\tkryo.register(type);\n\t\t\t}\n\n\t\t\t// register given serializer classes\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses.entrySet()) {\n\t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n\t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n\n\t\t\t\tSerializer\u003c?\u003e serializer \u003d\n\t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n\t\t\t\tkryo.register(typeClass, serializer);\n\t\t\t}\n\n\t\t\t// register given serializers\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e e : registeredTypesWithSerializers.entrySet()) {\n\t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n\t\t\t}\n\t\t\t// this is needed for Avro but can not be added on demand.\n\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n\n\t\t\tkryo.setRegistrationRequired(false);\n\t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n\t\t}\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java",
      "functionStartLine": 322,
      "functionName": "checkKryoInitialized",
      "diff": "",
      "extendedDetails": {
        "oldPath": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java",
        "newPath": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java"
      }
    },
    "ed3810b1282dfba80d63b1f43a0c202925a3b11c": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-3267] Disable reference tracking in Kryo fallback serializer\n\nBefore this commit, Kryo runs extra logic to track and resolve repeated references to\nthe same object (similar as JavaSerialization)\n\nThis disables reference tracking because\n  - reference tracking is costly\n  - it is virtually always unnecessary in the datatypes used in Flink\n  - it is inconsistent with Flink\u0027s own serialization (which does not do reference tracking)\n  - it may have problems if elements are read in a different order than they are written.\n\nThis closes #1528\n",
      "commitDate": "2016-01-25, 9:07 a.m.",
      "commitName": "ed3810b1282dfba80d63b1f43a0c202925a3b11c",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2016-01-21, 10:22 a.m.",
      "commitNameOld": "85ad491af66ad7c19401296af66edff2d2e3d6a1",
      "commitAuthorOld": "Maximilian Michels",
      "daysBetweenCommits": 3.95,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d getKryoInstance();\n\n\t\t\t// disable reference tracking. reference tracking is costly, usually unnecessary, and\n\t\t\t// inconsistent with Flink\u0027s own serialization (which does not do reference tracking)\n\t\t\tkryo.setReferences(false);\n\t\t\t\n\t\t\t// Throwable and all subclasses should be serialized via java serialization\n\t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n\n\t\t\t// Add default serializers first, so that they type registrations without a serializer\n\t\t\t// are registered with a default serializer\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e entry: defaultSerializers.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n\t\t\t}\n\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e entry: defaultSerializerClasses.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n\t\t\t}\n\n\t\t\t// register the type of our class\n\t\t\tkryo.register(type);\n\n\t\t\t// register given types. we do this first so that any registration of a\n\t\t\t// more specific serializer overrides this\n\t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n\t\t\t\tkryo.register(type);\n\t\t\t}\n\n\t\t\t// register given serializer classes\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses.entrySet()) {\n\t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n\t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n\n\t\t\t\tSerializer\u003c?\u003e serializer \u003d\n\t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n\t\t\t\tkryo.register(typeClass, serializer);\n\t\t\t}\n\n\t\t\t// register given serializers\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e e : registeredTypesWithSerializers.entrySet()) {\n\t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n\t\t\t}\n\t\t\t// this is needed for Avro but can not be added on demand.\n\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n\n\t\t\tkryo.setRegistrationRequired(false);\n\t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n\t\t}\n\t}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java",
      "functionStartLine": 322,
      "functionName": "checkKryoInitialized",
      "diff": "@@ -1,47 +1,51 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo \u003d\u003d null) {\n \t\t\tthis.kryo \u003d getKryoInstance();\n \n+\t\t\t// disable reference tracking. reference tracking is costly, usually unnecessary, and\n+\t\t\t// inconsistent with Flink\u0027s own serialization (which does not do reference tracking)\n+\t\t\tkryo.setReferences(false);\n+\t\t\t\n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n \t\t\t// Add default serializers first, so that they type registrations without a serializer\n \t\t\t// are registered with a default serializer\n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e entry: defaultSerializers.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n \t\t\t}\n \n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e entry: defaultSerializerClasses.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n \t\t\t}\n \n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n \n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n \n \t\t\t// register given serializer classes\n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses.entrySet()) {\n \t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n \t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n \n \t\t\t\tSerializer\u003c?\u003e serializer \u003d\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e e : registeredTypesWithSerializers.entrySet()) {\n \t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n \t\t\t}\n \t\t\t// this is needed for Avro but can not be added on demand.\n \t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n \n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cd899f3be39c5f052a2a3e90771111d1a7df1d47": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-2972] [JavaAPI] Remove Chill dependency from flink-java.\n\nThis closes #1331\n",
      "commitDate": "2015-11-30, 2:31 p.m.",
      "commitName": "cd899f3be39c5f052a2a3e90771111d1a7df1d47",
      "commitAuthor": "Fabian Hueske",
      "commitDateOld": "2015-10-29, 5:18 a.m.",
      "commitNameOld": "b654e989b60c6607f5f5bf757130c86bd0facd8c",
      "commitAuthorOld": "Till Rohrmann",
      "daysBetweenCommits": 32.43,
      "commitsBetweenForRepo": 175,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d getKryoInstance();\n\n\t\t\t// Throwable and all subclasses should be serialized via java serialization\n\t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n\n\t\t\t// Add default serializers first, so that they type registrations without a serializer\n\t\t\t// are registered with a default serializer\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e entry: defaultSerializers.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n\t\t\t}\n\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e entry: defaultSerializerClasses.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n\t\t\t}\n\n\t\t\t// register the type of our class\n\t\t\tkryo.register(type);\n\n\t\t\t// register given types. we do this first so that any registration of a\n\t\t\t// more specific serializer overrides this\n\t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n\t\t\t\tkryo.register(type);\n\t\t\t}\n\n\t\t\t// register given serializer classes\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses.entrySet()) {\n\t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n\t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n\n\t\t\t\tSerializer\u003c?\u003e serializer \u003d\n\t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n\t\t\t\tkryo.register(typeClass, serializer);\n\t\t\t}\n\n\t\t\t// register given serializers\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e e : registeredTypesWithSerializers.entrySet()) {\n\t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n\t\t\t}\n\t\t\t// this is needed for Avro but can not be added on demand.\n\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n\n\t\t\tkryo.setRegistrationRequired(false);\n\t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n\t\t}\n\t}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java",
      "functionStartLine": 305,
      "functionName": "checkKryoInitialized",
      "diff": "@@ -1,47 +1,47 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo \u003d\u003d null) {\n-\t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n+\t\t\tthis.kryo \u003d getKryoInstance();\n \n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n \t\t\t// Add default serializers first, so that they type registrations without a serializer\n \t\t\t// are registered with a default serializer\n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e entry: defaultSerializers.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n \t\t\t}\n \n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e entry: defaultSerializerClasses.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n \t\t\t}\n \n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n \n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n \n \t\t\t// register given serializer classes\n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses.entrySet()) {\n \t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n \t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n \n \t\t\t\tSerializer\u003c?\u003e serializer \u003d\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n \t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e e : registeredTypesWithSerializers.entrySet()) {\n \t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n \t\t\t}\n \t\t\t// this is needed for Avro but can not be added on demand.\n \t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n \n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2cc5d98c690c1b1b1ff1f48628ca58b1b4f0c932": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-2665] [api] [runtime] Makes ExecutionConfig serializable by forcing Kryo serializers to be Serializable\n\nThis closes #1128\n\n-----\nClosing PR:\nThis closes #867\n",
      "commitDate": "2015-09-15, 6:33 a.m.",
      "commitName": "2cc5d98c690c1b1b1ff1f48628ca58b1b4f0c932",
      "commitAuthor": "Till Rohrmann",
      "commitDateOld": "2015-05-26, 5:44 a.m.",
      "commitNameOld": "ae446388b91ecc0f08887da19400395b96b32f6c",
      "commitAuthorOld": "Till Rohrmann",
      "daysBetweenCommits": 112.03,
      "commitsBetweenForRepo": 594,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n\n\t\t\t// Throwable and all subclasses should be serialized via java serialization\n\t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n\n\t\t\t// Add default serializers first, so that they type registrations without a serializer\n\t\t\t// are registered with a default serializer\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e entry: defaultSerializers.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n\t\t\t}\n\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e entry: defaultSerializerClasses.entrySet()) {\n\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n\t\t\t}\n\n\t\t\t// register the type of our class\n\t\t\tkryo.register(type);\n\n\t\t\t// register given types. we do this first so that any registration of a\n\t\t\t// more specific serializer overrides this\n\t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n\t\t\t\tkryo.register(type);\n\t\t\t}\n\n\t\t\t// register given serializer classes\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses.entrySet()) {\n\t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n\t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n\n\t\t\t\tSerializer\u003c?\u003e serializer \u003d\n\t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n\t\t\t\tkryo.register(typeClass, serializer);\n\t\t\t}\n\n\t\t\t// register given serializers\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e e : registeredTypesWithSerializers.entrySet()) {\n\t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n\t\t\t}\n\t\t\t// this is needed for Avro but can not be added on demand.\n\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n\n\t\t\tkryo.setRegistrationRequired(false);\n\t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n\t\t}\n\t}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java",
      "functionStartLine": 259,
      "functionName": "checkKryoInitialized",
      "diff": "@@ -1,46 +1,47 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo \u003d\u003d null) {\n \t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n \n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n \t\t\t// Add default serializers first, so that they type registrations without a serializer\n \t\t\t// are registered with a default serializer\n-\t\t\tfor(ExecutionConfig.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e serializer : defaultSerializers) {\n-\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n+\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e entry: defaultSerializers.entrySet()) {\n+\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n \t\t\t}\n-\t\t\tfor(ExecutionConfig.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e serializer : defaultSerializerClasses) {\n-\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n+\n+\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e entry: defaultSerializerClasses.entrySet()) {\n+\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n \t\t\t}\n \n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n \n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n \n \t\t\t// register given serializer classes\n-\t\t\tfor (ExecutionConfig.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses) {\n+\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses.entrySet()) {\n \t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n \t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n \n \t\t\t\tSerializer\u003c?\u003e serializer \u003d\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n-\t\t\tfor (ExecutionConfig.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e e : registeredTypesWithSerializers) {\n-\t\t\t\tkryo.register(e.getKey(), e.getValue());\n+\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, ExecutionConfig.SerializableSerializer\u003c?\u003e\u003e e : registeredTypesWithSerializers.entrySet()) {\n+\t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n \t\t\t}\n \t\t\t// this is needed for Avro but can not be added on demand.\n \t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n \n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "354efec0f9da0fa03ea9b337b02a1a2a03a9ac16": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "[FLINK-1417] Automatically register types with Kryo\n",
      "commitDate": "2015-02-18, 9:52 a.m.",
      "commitName": "354efec0f9da0fa03ea9b337b02a1a2a03a9ac16",
      "commitAuthor": "Robert Metzger",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "[FLINK-1417] Automatically register types with Kryo\n",
          "commitDate": "2015-02-18, 9:52 a.m.",
          "commitName": "354efec0f9da0fa03ea9b337b02a1a2a03a9ac16",
          "commitAuthor": "Robert Metzger",
          "commitDateOld": "2015-02-18, 9:52 a.m.",
          "commitNameOld": "5015ab490f89d384ac93752c22caf201ceb43776",
          "commitAuthorOld": "Aljoscha Krettek",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n\n\t\t\t// Throwable and all subclasses should be serialized via java serialization\n\t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n\n\t\t\t// Add default serializers first, so that they type registrations without a serializer\n\t\t\t// are registered with a default serializer\n\t\t\tfor(ExecutionConfig.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e serializer : defaultSerializers) {\n\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n\t\t\t}\n\t\t\tfor(ExecutionConfig.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e serializer : defaultSerializerClasses) {\n\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n\t\t\t}\n\n\t\t\t// register the type of our class\n\t\t\tkryo.register(type);\n\n\t\t\t// register given types. we do this first so that any registration of a\n\t\t\t// more specific serializer overrides this\n\t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n\t\t\t\tkryo.register(type);\n\t\t\t}\n\n\t\t\t// register given serializer classes\n\t\t\tfor (ExecutionConfig.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses) {\n\t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n\t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n\n\t\t\t\tSerializer\u003c?\u003e serializer \u003d\n\t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n\t\t\t\tkryo.register(typeClass, serializer);\n\t\t\t}\n\n\t\t\t// register given serializers\n\t\t\tfor (ExecutionConfig.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e e : registeredTypesWithSerializers) {\n\t\t\t\tkryo.register(e.getKey(), e.getValue());\n\t\t\t}\n\t\t\t// this is needed for Avro but can not be added on demand.\n\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n\n\t\t\tkryo.setRegistrationRequired(false);\n\t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n\t\t}\n\t}",
          "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java",
          "functionStartLine": 257,
          "functionName": "checkKryoInitialized",
          "diff": "@@ -1,35 +1,46 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo \u003d\u003d null) {\n \t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n \n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n+\t\t\t// Add default serializers first, so that they type registrations without a serializer\n+\t\t\t// are registered with a default serializer\n+\t\t\tfor(ExecutionConfig.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e serializer : defaultSerializers) {\n+\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n+\t\t\t}\n+\t\t\tfor(ExecutionConfig.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e serializer : defaultSerializerClasses) {\n+\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n+\t\t\t}\n+\n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n-\t\t\t\n+\n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n-\t\t\t\n+\n \t\t\t// register given serializer classes\n-\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredSerializersClasses.entrySet()) {\n+\t\t\tfor (ExecutionConfig.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses) {\n \t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n \t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n-\t\t\t\t\n-\t\t\t\tSerializer\u003c?\u003e serializer \u003d \n+\n+\t\t\t\tSerializer\u003c?\u003e serializer \u003d\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n-\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e e : registeredSerializers.entrySet()) {\n+\t\t\tfor (ExecutionConfig.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e e : registeredTypesWithSerializers) {\n \t\t\t\tkryo.register(e.getKey(), e.getValue());\n \t\t\t}\n-\t\t\t\n+\t\t\t// this is needed for Avro but can not be added on demand.\n+\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n+\n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java",
            "newPath": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "[FLINK-1417] Automatically register types with Kryo\n",
          "commitDate": "2015-02-18, 9:52 a.m.",
          "commitName": "354efec0f9da0fa03ea9b337b02a1a2a03a9ac16",
          "commitAuthor": "Robert Metzger",
          "commitDateOld": "2015-02-18, 9:52 a.m.",
          "commitNameOld": "5015ab490f89d384ac93752c22caf201ceb43776",
          "commitAuthorOld": "Aljoscha Krettek",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n\n\t\t\t// Throwable and all subclasses should be serialized via java serialization\n\t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n\n\t\t\t// Add default serializers first, so that they type registrations without a serializer\n\t\t\t// are registered with a default serializer\n\t\t\tfor(ExecutionConfig.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e serializer : defaultSerializers) {\n\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n\t\t\t}\n\t\t\tfor(ExecutionConfig.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e serializer : defaultSerializerClasses) {\n\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n\t\t\t}\n\n\t\t\t// register the type of our class\n\t\t\tkryo.register(type);\n\n\t\t\t// register given types. we do this first so that any registration of a\n\t\t\t// more specific serializer overrides this\n\t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n\t\t\t\tkryo.register(type);\n\t\t\t}\n\n\t\t\t// register given serializer classes\n\t\t\tfor (ExecutionConfig.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses) {\n\t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n\t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n\n\t\t\t\tSerializer\u003c?\u003e serializer \u003d\n\t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n\t\t\t\tkryo.register(typeClass, serializer);\n\t\t\t}\n\n\t\t\t// register given serializers\n\t\t\tfor (ExecutionConfig.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e e : registeredTypesWithSerializers) {\n\t\t\t\tkryo.register(e.getKey(), e.getValue());\n\t\t\t}\n\t\t\t// this is needed for Avro but can not be added on demand.\n\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n\n\t\t\tkryo.setRegistrationRequired(false);\n\t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n\t\t}\n\t}",
          "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java",
          "functionStartLine": 257,
          "functionName": "checkKryoInitialized",
          "diff": "@@ -1,35 +1,46 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo \u003d\u003d null) {\n \t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n \n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n+\t\t\t// Add default serializers first, so that they type registrations without a serializer\n+\t\t\t// are registered with a default serializer\n+\t\t\tfor(ExecutionConfig.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e serializer : defaultSerializers) {\n+\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n+\t\t\t}\n+\t\t\tfor(ExecutionConfig.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e serializer : defaultSerializerClasses) {\n+\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n+\t\t\t}\n+\n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n-\t\t\t\n+\n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n-\t\t\t\n+\n \t\t\t// register given serializer classes\n-\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredSerializersClasses.entrySet()) {\n+\t\t\tfor (ExecutionConfig.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredTypesWithSerializerClasses) {\n \t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n \t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n-\t\t\t\t\n-\t\t\t\tSerializer\u003c?\u003e serializer \u003d \n+\n+\t\t\t\tSerializer\u003c?\u003e serializer \u003d\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n-\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e e : registeredSerializers.entrySet()) {\n+\t\t\tfor (ExecutionConfig.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e e : registeredTypesWithSerializers) {\n \t\t\t\tkryo.register(e.getKey(), e.getValue());\n \t\t\t}\n-\t\t\t\n+\t\t\t// this is needed for Avro but can not be added on demand.\n+\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n+\n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "a0b6af20beed6d12d0f33f6f58f323b20cc12961": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1399] Fix kryo registration of types and make sure that tags are assigned for registered types.\n",
      "commitDate": "2015-01-18, 4:59 p.m.",
      "commitName": "a0b6af20beed6d12d0f33f6f58f323b20cc12961",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2015-01-18, 4:26 p.m.",
      "commitNameOld": "2d4ed15e8d2aa1a1fcd7001fccea2ee70cc8a8b0",
      "commitAuthorOld": "Aljoscha Krettek",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n\n\t\t\t// Throwable and all subclasses should be serialized via java serialization\n\t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n\n\t\t\t// register the type of our class\n\t\t\tkryo.register(type);\n\t\t\t\n\t\t\t// register given types. we do this first so that any registration of a\n\t\t\t// more specific serializer overrides this\n\t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n\t\t\t\tkryo.register(type);\n\t\t\t}\n\t\t\t\n\t\t\t// register given serializer classes\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredSerializersClasses.entrySet()) {\n\t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n\t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n\t\t\t\t\n\t\t\t\tSerializer\u003c?\u003e serializer \u003d \n\t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n\t\t\t\tkryo.register(typeClass, serializer);\n\t\t\t}\n\n\t\t\t// register given serializers\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e e : registeredSerializers.entrySet()) {\n\t\t\t\tkryo.register(e.getKey(), e.getValue());\n\t\t\t}\n\t\t\t\n\t\t\tkryo.setRegistrationRequired(false);\n\t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n\t\t}\n\t}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java",
      "functionStartLine": 233,
      "functionName": "checkKryoInitialized",
      "diff": "@@ -1,19 +1,35 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo \u003d\u003d null) {\n \t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n-\t\t\tthis.kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n-\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e e: registeredSerializers.entrySet()) {\n-\t\t\t\tthis.kryo.addDefaultSerializer(e.getKey(), e.getValue());\n+\t\t\t// Throwable and all subclasses should be serialized via java serialization\n+\t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n+\n+\t\t\t// register the type of our class\n+\t\t\tkryo.register(type);\n+\t\t\t\n+\t\t\t// register given types. we do this first so that any registration of a\n+\t\t\t// more specific serializer overrides this\n+\t\t\tfor (Class\u003c?\u003e type : registeredTypes) {\n+\t\t\t\tkryo.register(type);\n+\t\t\t}\n+\t\t\t\n+\t\t\t// register given serializer classes\n+\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e : registeredSerializersClasses.entrySet()) {\n+\t\t\t\tClass\u003c?\u003e typeClass \u003d e.getKey();\n+\t\t\t\tClass\u003c? extends Serializer\u003c?\u003e\u003e serializerClass \u003d e.getValue();\n+\t\t\t\t\n+\t\t\t\tSerializer\u003c?\u003e serializer \u003d \n+\t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n+\t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n-\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e: registeredSerializersClasses.entrySet()) {\n-\t\t\t\tthis.kryo.addDefaultSerializer(e.getKey(), e.getValue());\n+\t\t\t// register given serializers\n+\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e e : registeredSerializers.entrySet()) {\n+\t\t\t\tkryo.register(e.getKey(), e.getValue());\n \t\t\t}\n-\n-\t\t\tthis.kryo.setRegistrationRequired(false);\n-\t\t\tthis.kryo.register(type);\n-\n-\t\t\tthis.kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n+\t\t\t\n+\t\t\tkryo.setRegistrationRequired(false);\n+\t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2d4ed15e8d2aa1a1fcd7001fccea2ee70cc8a8b0": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1399] Add support for registering Serializers with Kryo\n\nThis closes #305\n",
      "commitDate": "2015-01-18, 4:26 p.m.",
      "commitName": "2d4ed15e8d2aa1a1fcd7001fccea2ee70cc8a8b0",
      "commitAuthor": "Aljoscha Krettek",
      "commitDateOld": "2015-01-11, 3:09 p.m.",
      "commitNameOld": "8af6ef49fd84c309aeba0a3c8963ac83e0243c59",
      "commitAuthorOld": "Aljoscha Krettek",
      "daysBetweenCommits": 7.05,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n\t\t\tthis.kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e e: registeredSerializers.entrySet()) {\n\t\t\t\tthis.kryo.addDefaultSerializer(e.getKey(), e.getValue());\n\t\t\t}\n\n\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e: registeredSerializersClasses.entrySet()) {\n\t\t\t\tthis.kryo.addDefaultSerializer(e.getKey(), e.getValue());\n\t\t\t}\n\n\t\t\tthis.kryo.setRegistrationRequired(false);\n\t\t\tthis.kryo.register(type);\n\n\t\t\tthis.kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n\t\t}\n\t}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java",
      "functionStartLine": 193,
      "functionName": "checkKryoInitialized",
      "diff": "@@ -1,9 +1,19 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo \u003d\u003d null) {\n \t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n \t\t\tthis.kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n+\n+\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Serializer\u003c?\u003e\u003e e: registeredSerializers.entrySet()) {\n+\t\t\t\tthis.kryo.addDefaultSerializer(e.getKey(), e.getValue());\n+\t\t\t}\n+\n+\t\t\tfor (Map.Entry\u003cClass\u003c?\u003e, Class\u003c? extends Serializer\u003c?\u003e\u003e\u003e e: registeredSerializersClasses.entrySet()) {\n+\t\t\t\tthis.kryo.addDefaultSerializer(e.getKey(), e.getValue());\n+\t\t\t}\n+\n \t\t\tthis.kryo.setRegistrationRequired(false);\n \t\t\tthis.kryo.register(type);\n+\n \t\t\tthis.kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8af6ef49fd84c309aeba0a3c8963ac83e0243c59": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1378] Add support for Throwables in KryoSerializer\n",
      "commitDate": "2015-01-11, 3:09 p.m.",
      "commitName": "8af6ef49fd84c309aeba0a3c8963ac83e0243c59",
      "commitAuthor": "Aljoscha Krettek",
      "commitDateOld": "2015-01-08, 6:38 a.m.",
      "commitNameOld": "19066b520435528e104a69ccf372f56811123ee3",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 3.35,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n\t\t\tthis.kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n\t\t\tthis.kryo.setRegistrationRequired(false);\n\t\t\tthis.kryo.register(type);\n\t\t\tthis.kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n\t\t}\n\t}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java",
      "functionStartLine": 181,
      "functionName": "checkKryoInitialized",
      "diff": "@@ -1,8 +1,9 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo \u003d\u003d null) {\n \t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n+\t\t\tthis.kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \t\t\tthis.kryo.setRegistrationRequired(false);\n \t\t\tthis.kryo.register(type);\n \t\t\tthis.kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a70aa67a0881afc5d66329d46fe536d7a0b89fa8": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-610] Replace Avro by Kryo as the GenericType serializer\n\nThe performance of data-intensive jobs using Kryo is probably going to be slow.\n\nSet correct classloader\n\ntry to use Kryo.copy() with fallback to serialization copy\n",
      "commitDate": "2014-12-17, 2:44 p.m.",
      "commitName": "a70aa67a0881afc5d66329d46fe536d7a0b89fa8",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2014-10-31, 4:15 p.m.",
      "commitNameOld": "f5898a01e7877afa3df06223713db211708eaf9a",
      "commitAuthorOld": "Henry Saputra",
      "daysBetweenCommits": 46.98,
      "commitsBetweenForRepo": 219,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n\t\t\tthis.kryo.setRegistrationRequired(false);\n\t\t\tthis.kryo.register(type);\n\t\t\tthis.kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n\t\t}\n\t}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java",
      "functionStartLine": 165,
      "functionName": "checkKryoInitialized",
      "diff": "@@ -1,7 +1,8 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo \u003d\u003d null) {\n-\t\t\tthis.kryo \u003d new Kryo();\n-\t\t\tthis.kryo.setAsmEnabled(true);\n+\t\t\tthis.kryo \u003d new ScalaKryoInstantiator().newKryo();\n+\t\t\tthis.kryo.setRegistrationRequired(false);\n \t\t\tthis.kryo.register(type);\n+\t\t\tthis.kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f5898a01e7877afa3df06223713db211708eaf9a": {
      "type": "Ymodifierchange",
      "commitMessage": "Another round to remove final modifier to private methods because it is not needed\n\nRemove final modifier to private methods because it is not needed.\nThose methods are final by default.\n\nAuthor: Henry Saputra \u003chenry.saputra@gmail.com\u003e\n\nCloses #168 from hsaputra/remove_final_privatemethods_1 and squashes the following commits:\n\n860b512 [Henry Saputra] Remove final modifier to private methods because it is not needed. It is final by default.\n",
      "commitDate": "2014-10-31, 4:15 p.m.",
      "commitName": "f5898a01e7877afa3df06223713db211708eaf9a",
      "commitAuthor": "Henry Saputra",
      "commitDateOld": "2014-09-30, 9:10 a.m.",
      "commitNameOld": "76d4a75e823c31a899f2143fb6be185b90e55532",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 31.3,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d new Kryo();\n\t\t\tthis.kryo.setAsmEnabled(true);\n\t\t\tthis.kryo.register(type);\n\t\t}\n\t}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java",
      "functionStartLine": 154,
      "functionName": "checkKryoInitialized",
      "diff": "@@ -1,7 +1,7 @@\n-\tprivate final void checkKryoInitialized() {\n+\tprivate void checkKryoInitialized() {\n \t\tif (this.kryo \u003d\u003d null) {\n \t\t\tthis.kryo \u003d new Kryo();\n \t\t\tthis.kryo.setAsmEnabled(true);\n \t\t\tthis.kryo.register(type);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[private, final]",
        "newValue": "[private]"
      }
    },
    "22203e75f8a0d193ce0187396d0b267e05e9b58e": {
      "type": "Yintroduced",
      "commitMessage": "[FLINK-610] Added KryoSerializer\n\nThis closes #74\n",
      "commitDate": "2014-09-02, 10:35 a.m.",
      "commitName": "22203e75f8a0d193ce0187396d0b267e05e9b58e",
      "commitAuthor": "Till Rohrmann",
      "diff": "@@ -0,0 +1,7 @@\n+\tprivate final void checkKryoInitialized() {\n+\t\tif (this.kryo \u003d\u003d null) {\n+\t\t\tthis.kryo \u003d new Kryo();\n+\t\t\tthis.kryo.setAsmEnabled(true);\n+\t\t\tthis.kryo.register(type);\n+\t\t}\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tprivate final void checkKryoInitialized() {\n\t\tif (this.kryo \u003d\u003d null) {\n\t\t\tthis.kryo \u003d new Kryo();\n\t\t\tthis.kryo.setAsmEnabled(true);\n\t\t\tthis.kryo.register(type);\n\t\t}\n\t}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java",
      "functionStartLine": 113,
      "functionName": "checkKryoInitialized"
    }
  }
}