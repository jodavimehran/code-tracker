{
  "origin": "codeshovel",
  "repositoryName": "junit5",
  "repositoryPath": "H:\\Projects\\junit-team\\junit5/.git",
  "startCommitName": "77cfe71e7f787c59626198e25350545f41e968bd",
  "sourceFileName": "NodeTestTask.java",
  "functionName": "execute",
  "functionId": "execute",
  "sourceFilePath": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
  "functionStartLine": 100,
  "functionEndLine": 113,
  "numCommitsSeen": 79,
  "timeTaken": 3520,
  "changeHistory": [
    "137f831bba9d0f45085d64fad47947cbc91a30e9",
    "c1d682aee5da5738fc3be071df45330c005f4cf1",
    "2f3440e0f221255a83b28c42cf77407bde92a8b4",
    "1092538773cba2058658bc41515a4d05cb50f19e",
    "805d4dad6d3893b8e973019b824167d7b6f2cb8c",
    "e0a49d10ffb6505755fc8a0308e898382e3cc1eb",
    "a3e4b97efb03bd7b52d18c17b9dc185d112a04e8",
    "4b41518fa052b28a953e99b087d505603a22c175",
    "67f3391ab9887e5956a650c7a6b645ab04a62157",
    "62c433c14ce9d70fa5b82ef385a6e15c22cc0003",
    "5ca993afb2db6a2dd10e3fb4f0790cf30200a6ec",
    "4972eb58d680a30e8fbd1ffb6cdc6477bef83374",
    "4537bec58804c392a8bce296dced0337c8ec1a8d",
    "6b46df0ee35ef56021ca5f4dc9e41ac96b19de0e",
    "c8e52a7cde0579562c51c838ef1c83b68b0c31cf",
    "ac7bb522519cd8a600324aa909a5c17a110cb97f",
    "2d0b61d00defaa534532d5541cfcb818307ff0d0",
    "ebd537b73796d734739fa6aabb78b4e88bbdd907",
    "0d2aa7088f7a586113524ba74448febcf6c70c51",
    "742e38c48236556233c280ddafe8a55e570de1a2",
    "a02c0e24af370ced24d8fa9d758b1a1db396796f",
    "c54786d16f1c5f5ac5384a68893d069eba062e39",
    "0027ade00fd483e08714ece1021a7715bb1855da",
    "55a1054a3310fdbf6e7a0c03f9a6ba9366aa2ece",
    "cfefe1e65034c5e66e0fbcb503fe8ad1a4c086d2",
    "94bd5987b3b75c91a41fd70779bae83bb9b5fb9c",
    "f8a1c6b5ae5a144d1a3e85100a4d61b7f059822d",
    "fc86dab57883ffcc0c5e6b9ea0999abb98101137",
    "417fd0e92571ec0cc01987c03f3ff112e4d867fc",
    "3f9c11b9326b7d3051cb2a50568cd91113a0c0da",
    "57b31220d25f59bb4aa4903dfee4b8ec2be4525e",
    "28ffd5ee9d1e996133445cac2256407f28380e91"
  ],
  "changeHistoryShort": {
    "137f831bba9d0f45085d64fad47947cbc91a30e9": "Ybodychange",
    "c1d682aee5da5738fc3be071df45330c005f4cf1": "Ybodychange",
    "2f3440e0f221255a83b28c42cf77407bde92a8b4": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
    "1092538773cba2058658bc41515a4d05cb50f19e": "Ybodychange",
    "805d4dad6d3893b8e973019b824167d7b6f2cb8c": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "e0a49d10ffb6505755fc8a0308e898382e3cc1eb": "Ybodychange",
    "a3e4b97efb03bd7b52d18c17b9dc185d112a04e8": "Ymultichange(Yparameterchange,Ybodychange)",
    "4b41518fa052b28a953e99b087d505603a22c175": "Ybodychange",
    "67f3391ab9887e5956a650c7a6b645ab04a62157": "Ybodychange",
    "62c433c14ce9d70fa5b82ef385a6e15c22cc0003": "Ybodychange",
    "5ca993afb2db6a2dd10e3fb4f0790cf30200a6ec": "Ybodychange",
    "4972eb58d680a30e8fbd1ffb6cdc6477bef83374": "Yfilerename",
    "4537bec58804c392a8bce296dced0337c8ec1a8d": "Yfilerename",
    "6b46df0ee35ef56021ca5f4dc9e41ac96b19de0e": "Ybodychange",
    "c8e52a7cde0579562c51c838ef1c83b68b0c31cf": "Ymultichange(Yrename,Ybodychange)",
    "ac7bb522519cd8a600324aa909a5c17a110cb97f": "Ybodychange",
    "2d0b61d00defaa534532d5541cfcb818307ff0d0": "Ybodychange",
    "ebd537b73796d734739fa6aabb78b4e88bbdd907": "Ybodychange",
    "0d2aa7088f7a586113524ba74448febcf6c70c51": "Yfilerename",
    "742e38c48236556233c280ddafe8a55e570de1a2": "Ybodychange",
    "a02c0e24af370ced24d8fa9d758b1a1db396796f": "Ybodychange",
    "c54786d16f1c5f5ac5384a68893d069eba062e39": "Ybodychange",
    "0027ade00fd483e08714ece1021a7715bb1855da": "Ybodychange",
    "55a1054a3310fdbf6e7a0c03f9a6ba9366aa2ece": "Ybodychange",
    "cfefe1e65034c5e66e0fbcb503fe8ad1a4c086d2": "Ymultichange(Yfilerename,Ybodychange,Yparameterchange)",
    "94bd5987b3b75c91a41fd70779bae83bb9b5fb9c": "Ybodychange",
    "f8a1c6b5ae5a144d1a3e85100a4d61b7f059822d": "Ybodychange",
    "fc86dab57883ffcc0c5e6b9ea0999abb98101137": "Ybodychange",
    "417fd0e92571ec0cc01987c03f3ff112e4d867fc": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "3f9c11b9326b7d3051cb2a50568cd91113a0c0da": "Ymultichange(Yfilerename,Ybodychange)",
    "57b31220d25f59bb4aa4903dfee4b8ec2be4525e": "Ymultichange(Yparameterchange,Ybodychange)",
    "28ffd5ee9d1e996133445cac2256407f28380e91": "Yintroduced"
  },
  "changeHistoryDetails": {
    "137f831bba9d0f45085d64fad47947cbc91a30e9": {
      "type": "Ybodychange",
      "commitMessage": "Make ThrowableCollector configurable\n\nThis commit generalizes `ThrowableCollector` to take a predicate that\nis used to decide whether a `Throwable` is aborted or failed execution.\nThe Jupiter engines uses a specialized implementation that treats OTA\u0027s\n`TestAbortedExceptions` as aborting and everything else as failing:\n`OpenTest4JAwareThrowableCollector`.\n\nIn addition, this commit introduces `ThrowableCollector.Factory` and\nlets `HierarchicalTestEngines` create them in order to allow the engine\nto decide how to configure its `ThrowableCollectors`. For backwards\ncompatibility, the default implementation returns a factory that\nalways creates instances of `OpenTest4JAwareThrowableCollector`.\n\nIssue: #1313\n",
      "commitDate": "2018-07-07, 4:15 p.m.",
      "commitName": "137f831bba9d0f45085d64fad47947cbc91a30e9",
      "commitAuthor": "Marc Philipp",
      "commitDateOld": "2018-07-07, 4:15 p.m.",
      "commitNameOld": "c1d682aee5da5738fc3be071df45330c005f4cf1",
      "commitAuthorOld": "Marc Philipp",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void execute() {\n\t\tthrowableCollector \u003d throwableCollectorFactory.create();\n\t\tprepare();\n\t\tif (throwableCollector.isEmpty()) {\n\t\t\tcheckWhetherSkipped();\n\t\t}\n\t\tif (throwableCollector.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n\t\t\texecuteRecursively();\n\t\t}\n\t\tif (context !\u003d null) {\n\t\t\tcleanUp();\n\t\t}\n\t\treportCompletion();\n\t}",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
      "functionStartLine": 100,
      "functionName": "execute",
      "diff": "@@ -1,13 +1,14 @@\n \tpublic void execute() {\n+\t\tthrowableCollector \u003d throwableCollectorFactory.create();\n \t\tprepare();\n \t\tif (throwableCollector.isEmpty()) {\n \t\t\tcheckWhetherSkipped();\n \t\t}\n \t\tif (throwableCollector.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n \t\t\texecuteRecursively();\n \t\t}\n \t\tif (context !\u003d null) {\n \t\t\tcleanUp();\n \t\t}\n \t\treportCompletion();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c1d682aee5da5738fc3be071df45330c005f4cf1": {
      "type": "Ybodychange",
      "commitMessage": "Exceptions in `@AfterAll` methods fail aborted containers\n\nIssue: #1313\n",
      "commitDate": "2018-07-07, 4:15 p.m.",
      "commitName": "c1d682aee5da5738fc3be071df45330c005f4cf1",
      "commitAuthor": "Marc Philipp",
      "commitDateOld": "2018-06-28, 2:59 p.m.",
      "commitNameOld": "38e149f626bc7722922f87989fb9776d4fe325e9",
      "commitAuthorOld": "Sam Brannen",
      "daysBetweenCommits": 9.05,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void execute() {\n\t\tprepare();\n\t\tif (throwableCollector.isEmpty()) {\n\t\t\tcheckWhetherSkipped();\n\t\t}\n\t\tif (throwableCollector.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n\t\t\texecuteRecursively();\n\t\t}\n\t\tif (context !\u003d null) {\n\t\t\tcleanUp();\n\t\t}\n\t\treportCompletion();\n\t}",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
      "functionStartLine": 98,
      "functionName": "execute",
      "diff": "@@ -1,13 +1,13 @@\n \tpublic void execute() {\n \t\tprepare();\n-\t\tif (executionErrors.isEmpty()) {\n+\t\tif (throwableCollector.isEmpty()) {\n \t\t\tcheckWhetherSkipped();\n \t\t}\n-\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n+\t\tif (throwableCollector.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n \t\t\texecuteRecursively();\n \t\t}\n \t\tif (context !\u003d null) {\n \t\t\tcleanUp();\n \t\t}\n \t\treportCompletion();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2f3440e0f221255a83b28c42cf77407bde92a8b4": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
      "commitMessage": "Introduce support for parallel test execution\n\nThis commit adds opt-in support for parallel test execution and\ncapturing output to `System.out` and `System.err`. Both features are\ndisabled by default but can be enabled and configured using\nconfiguration parameters.\n\nThe implementation is based on the Fork/Join Framework and designed to\nbe reusable by other test engines that extend HierarchicalTestEngine.\n\nThe Jupiter API provides annotations to declare which shared resources a\ntest needs to access and in which way. Moreover, the execution mode of a\ntest can be influenced.\n\nIn addition, a number of TestExecutionListeners have been made\nthread-safe.\n\nThe documentation subproject is now configured to execute tests in\nparallel. All other subprojects will have to wait as Gradle currently\nblows up when used with parallel test execution.\n\nResolves #60. Closes #1461.\n\nCo-authored-by: Leonard Brünings \u003clord_damokles@gmx.net\u003e\nCo-authored-by: Christian Stein \u003csormuras@gmail.com\u003e\n",
      "commitDate": "2018-06-22, 1:55 p.m.",
      "commitName": "2f3440e0f221255a83b28c42cf77407bde92a8b4",
      "commitAuthor": "Marc Philipp",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Introduce support for parallel test execution\n\nThis commit adds opt-in support for parallel test execution and\ncapturing output to `System.out` and `System.err`. Both features are\ndisabled by default but can be enabled and configured using\nconfiguration parameters.\n\nThe implementation is based on the Fork/Join Framework and designed to\nbe reusable by other test engines that extend HierarchicalTestEngine.\n\nThe Jupiter API provides annotations to declare which shared resources a\ntest needs to access and in which way. Moreover, the execution mode of a\ntest can be influenced.\n\nIn addition, a number of TestExecutionListeners have been made\nthread-safe.\n\nThe documentation subproject is now configured to execute tests in\nparallel. All other subprojects will have to wait as Gradle currently\nblows up when used with parallel test execution.\n\nResolves #60. Closes #1461.\n\nCo-authored-by: Leonard Brünings \u003clord_damokles@gmx.net\u003e\nCo-authored-by: Christian Stein \u003csormuras@gmail.com\u003e\n",
          "commitDate": "2018-06-22, 1:55 p.m.",
          "commitName": "2f3440e0f221255a83b28c42cf77407bde92a8b4",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2018-06-22, 10:23 a.m.",
          "commitNameOld": "948841c03c646c98866d0121bc3c89ad4ddbf277",
          "commitAuthorOld": "Sam Brannen",
          "daysBetweenCommits": 0.15,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void execute() {\n\t\tprepare();\n\t\tif (executionErrors.isEmpty()) {\n\t\t\tcheckWhetherSkipped();\n\t\t}\n\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n\t\t\texecuteRecursively();\n\t\t}\n\t\tif (context !\u003d null) {\n\t\t\tcleanUp();\n\t\t}\n\t\treportCompletion();\n\t}",
          "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
          "functionStartLine": 103,
          "functionName": "execute",
          "diff": "@@ -1,14 +1,13 @@\n-\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n-\t\t\ttracker.markExecuted(testDescriptor);\n-\t\t\tprepare(parentContext);\n-\t\t\tif (executionErrors.isEmpty()) {\n-\t\t\t\tcheckWhetherSkipped();\n-\t\t\t}\n-\t\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n-\t\t\t\texecuteRecursively(tracker);\n-\t\t\t}\n-\t\t\tif (context !\u003d null) {\n-\t\t\t\tcleanUp();\n-\t\t\t}\n-\t\t\treportDone();\n-\t\t}\n\\ No newline at end of file\n+\tpublic void execute() {\n+\t\tprepare();\n+\t\tif (executionErrors.isEmpty()) {\n+\t\t\tcheckWhetherSkipped();\n+\t\t}\n+\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n+\t\t\texecuteRecursively();\n+\t\t}\n+\t\tif (context !\u003d null) {\n+\t\t\tcleanUp();\n+\t\t}\n+\t\treportCompletion();\n+\t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
            "newPath": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
            "oldMethodName": "execute",
            "newMethodName": "execute"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Introduce support for parallel test execution\n\nThis commit adds opt-in support for parallel test execution and\ncapturing output to `System.out` and `System.err`. Both features are\ndisabled by default but can be enabled and configured using\nconfiguration parameters.\n\nThe implementation is based on the Fork/Join Framework and designed to\nbe reusable by other test engines that extend HierarchicalTestEngine.\n\nThe Jupiter API provides annotations to declare which shared resources a\ntest needs to access and in which way. Moreover, the execution mode of a\ntest can be influenced.\n\nIn addition, a number of TestExecutionListeners have been made\nthread-safe.\n\nThe documentation subproject is now configured to execute tests in\nparallel. All other subprojects will have to wait as Gradle currently\nblows up when used with parallel test execution.\n\nResolves #60. Closes #1461.\n\nCo-authored-by: Leonard Brünings \u003clord_damokles@gmx.net\u003e\nCo-authored-by: Christian Stein \u003csormuras@gmail.com\u003e\n",
          "commitDate": "2018-06-22, 1:55 p.m.",
          "commitName": "2f3440e0f221255a83b28c42cf77407bde92a8b4",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2018-06-22, 10:23 a.m.",
          "commitNameOld": "948841c03c646c98866d0121bc3c89ad4ddbf277",
          "commitAuthorOld": "Sam Brannen",
          "daysBetweenCommits": 0.15,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void execute() {\n\t\tprepare();\n\t\tif (executionErrors.isEmpty()) {\n\t\t\tcheckWhetherSkipped();\n\t\t}\n\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n\t\t\texecuteRecursively();\n\t\t}\n\t\tif (context !\u003d null) {\n\t\t\tcleanUp();\n\t\t}\n\t\treportCompletion();\n\t}",
          "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
          "functionStartLine": 103,
          "functionName": "execute",
          "diff": "@@ -1,14 +1,13 @@\n-\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n-\t\t\ttracker.markExecuted(testDescriptor);\n-\t\t\tprepare(parentContext);\n-\t\t\tif (executionErrors.isEmpty()) {\n-\t\t\t\tcheckWhetherSkipped();\n-\t\t\t}\n-\t\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n-\t\t\t\texecuteRecursively(tracker);\n-\t\t\t}\n-\t\t\tif (context !\u003d null) {\n-\t\t\t\tcleanUp();\n-\t\t\t}\n-\t\t\treportDone();\n-\t\t}\n\\ No newline at end of file\n+\tpublic void execute() {\n+\t\tprepare();\n+\t\tif (executionErrors.isEmpty()) {\n+\t\t\tcheckWhetherSkipped();\n+\t\t}\n+\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n+\t\t\texecuteRecursively();\n+\t\t}\n+\t\tif (context !\u003d null) {\n+\t\t\tcleanUp();\n+\t\t}\n+\t\treportCompletion();\n+\t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Introduce support for parallel test execution\n\nThis commit adds opt-in support for parallel test execution and\ncapturing output to `System.out` and `System.err`. Both features are\ndisabled by default but can be enabled and configured using\nconfiguration parameters.\n\nThe implementation is based on the Fork/Join Framework and designed to\nbe reusable by other test engines that extend HierarchicalTestEngine.\n\nThe Jupiter API provides annotations to declare which shared resources a\ntest needs to access and in which way. Moreover, the execution mode of a\ntest can be influenced.\n\nIn addition, a number of TestExecutionListeners have been made\nthread-safe.\n\nThe documentation subproject is now configured to execute tests in\nparallel. All other subprojects will have to wait as Gradle currently\nblows up when used with parallel test execution.\n\nResolves #60. Closes #1461.\n\nCo-authored-by: Leonard Brünings \u003clord_damokles@gmx.net\u003e\nCo-authored-by: Christian Stein \u003csormuras@gmail.com\u003e\n",
          "commitDate": "2018-06-22, 1:55 p.m.",
          "commitName": "2f3440e0f221255a83b28c42cf77407bde92a8b4",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2018-06-22, 10:23 a.m.",
          "commitNameOld": "948841c03c646c98866d0121bc3c89ad4ddbf277",
          "commitAuthorOld": "Sam Brannen",
          "daysBetweenCommits": 0.15,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void execute() {\n\t\tprepare();\n\t\tif (executionErrors.isEmpty()) {\n\t\t\tcheckWhetherSkipped();\n\t\t}\n\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n\t\t\texecuteRecursively();\n\t\t}\n\t\tif (context !\u003d null) {\n\t\t\tcleanUp();\n\t\t}\n\t\treportCompletion();\n\t}",
          "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
          "functionStartLine": 103,
          "functionName": "execute",
          "diff": "@@ -1,14 +1,13 @@\n-\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n-\t\t\ttracker.markExecuted(testDescriptor);\n-\t\t\tprepare(parentContext);\n-\t\t\tif (executionErrors.isEmpty()) {\n-\t\t\t\tcheckWhetherSkipped();\n-\t\t\t}\n-\t\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n-\t\t\t\texecuteRecursively(tracker);\n-\t\t\t}\n-\t\t\tif (context !\u003d null) {\n-\t\t\t\tcleanUp();\n-\t\t\t}\n-\t\t\treportDone();\n-\t\t}\n\\ No newline at end of file\n+\tpublic void execute() {\n+\t\tprepare();\n+\t\tif (executionErrors.isEmpty()) {\n+\t\t\tcheckWhetherSkipped();\n+\t\t}\n+\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n+\t\t\texecuteRecursively();\n+\t\t}\n+\t\tif (context !\u003d null) {\n+\t\t\tcleanUp();\n+\t\t}\n+\t\treportCompletion();\n+\t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Introduce support for parallel test execution\n\nThis commit adds opt-in support for parallel test execution and\ncapturing output to `System.out` and `System.err`. Both features are\ndisabled by default but can be enabled and configured using\nconfiguration parameters.\n\nThe implementation is based on the Fork/Join Framework and designed to\nbe reusable by other test engines that extend HierarchicalTestEngine.\n\nThe Jupiter API provides annotations to declare which shared resources a\ntest needs to access and in which way. Moreover, the execution mode of a\ntest can be influenced.\n\nIn addition, a number of TestExecutionListeners have been made\nthread-safe.\n\nThe documentation subproject is now configured to execute tests in\nparallel. All other subprojects will have to wait as Gradle currently\nblows up when used with parallel test execution.\n\nResolves #60. Closes #1461.\n\nCo-authored-by: Leonard Brünings \u003clord_damokles@gmx.net\u003e\nCo-authored-by: Christian Stein \u003csormuras@gmail.com\u003e\n",
          "commitDate": "2018-06-22, 1:55 p.m.",
          "commitName": "2f3440e0f221255a83b28c42cf77407bde92a8b4",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2018-06-22, 10:23 a.m.",
          "commitNameOld": "948841c03c646c98866d0121bc3c89ad4ddbf277",
          "commitAuthorOld": "Sam Brannen",
          "daysBetweenCommits": 0.15,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void execute() {\n\t\tprepare();\n\t\tif (executionErrors.isEmpty()) {\n\t\t\tcheckWhetherSkipped();\n\t\t}\n\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n\t\t\texecuteRecursively();\n\t\t}\n\t\tif (context !\u003d null) {\n\t\t\tcleanUp();\n\t\t}\n\t\treportCompletion();\n\t}",
          "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
          "functionStartLine": 103,
          "functionName": "execute",
          "diff": "@@ -1,14 +1,13 @@\n-\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n-\t\t\ttracker.markExecuted(testDescriptor);\n-\t\t\tprepare(parentContext);\n-\t\t\tif (executionErrors.isEmpty()) {\n-\t\t\t\tcheckWhetherSkipped();\n-\t\t\t}\n-\t\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n-\t\t\t\texecuteRecursively(tracker);\n-\t\t\t}\n-\t\t\tif (context !\u003d null) {\n-\t\t\t\tcleanUp();\n-\t\t\t}\n-\t\t\treportDone();\n-\t\t}\n\\ No newline at end of file\n+\tpublic void execute() {\n+\t\tprepare();\n+\t\tif (executionErrors.isEmpty()) {\n+\t\t\tcheckWhetherSkipped();\n+\t\t}\n+\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n+\t\t\texecuteRecursively();\n+\t\t}\n+\t\tif (context !\u003d null) {\n+\t\t\tcleanUp();\n+\t\t}\n+\t\treportCompletion();\n+\t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[parentContext-C, tracker-ExecutionTracker]",
            "newValue": "[]"
          }
        }
      ]
    },
    "1092538773cba2058658bc41515a4d05cb50f19e": {
      "type": "Ybodychange",
      "commitMessage": "Only clean up non-null execution contexts\n\nIssue: #742\n",
      "commitDate": "2017-12-28, 12:23 p.m.",
      "commitName": "1092538773cba2058658bc41515a4d05cb50f19e",
      "commitAuthor": "Marc Philipp",
      "commitDateOld": "2017-12-28, 12:23 p.m.",
      "commitNameOld": "805d4dad6d3893b8e973019b824167d7b6f2cb8c",
      "commitAuthorOld": "Marc Philipp",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n\t\t\ttracker.markExecuted(testDescriptor);\n\t\t\tprepare(parentContext);\n\t\t\tif (executionErrors.isEmpty()) {\n\t\t\t\tcheckWhetherSkipped();\n\t\t\t}\n\t\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n\t\t\t\texecuteRecursively(tracker);\n\t\t\t}\n\t\t\tif (context !\u003d null) {\n\t\t\t\tcleanUp();\n\t\t\t}\n\t\t\treportDone();\n\t\t}",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
      "functionStartLine": 72,
      "functionName": "execute",
      "diff": "@@ -1,12 +1,14 @@\n \t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n \t\t\ttracker.markExecuted(testDescriptor);\n \t\t\tprepare(parentContext);\n \t\t\tif (executionErrors.isEmpty()) {\n \t\t\t\tcheckWhetherSkipped();\n \t\t\t}\n \t\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n \t\t\t\texecuteRecursively(tracker);\n \t\t\t}\n-\t\t\tcleanUp();\n+\t\t\tif (context !\u003d null) {\n+\t\t\t\tcleanUp();\n+\t\t\t}\n \t\t\treportDone();\n \t\t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "805d4dad6d3893b8e973019b824167d7b6f2cb8c": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "Refactor HierarchicalTestExecutor\n\nIssue: #742\n",
      "commitDate": "2017-12-28, 12:23 p.m.",
      "commitName": "805d4dad6d3893b8e973019b824167d7b6f2cb8c",
      "commitAuthor": "Marc Philipp",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Refactor HierarchicalTestExecutor\n\nIssue: #742\n",
          "commitDate": "2017-12-28, 12:23 p.m.",
          "commitName": "805d4dad6d3893b8e973019b824167d7b6f2cb8c",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2017-12-28, 12:23 p.m.",
          "commitNameOld": "e0a49d10ffb6505755fc8a0308e898382e3cc1eb",
          "commitAuthorOld": "Christian Stein",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n\t\t\ttracker.markExecuted(testDescriptor);\n\t\t\tprepare(parentContext);\n\t\t\tif (executionErrors.isEmpty()) {\n\t\t\t\tcheckWhetherSkipped();\n\t\t\t}\n\t\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n\t\t\t\texecuteRecursively(tracker);\n\t\t\t}\n\t\t\tcleanUp();\n\t\t\treportDone();\n\t\t}",
          "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
          "functionStartLine": 72,
          "functionName": "execute",
          "diff": "@@ -1,75 +1,12 @@\n-\tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n-\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n-\t\ttracker.markExecuted(testDescriptor);\n-\n-\t\tC preparedContext;\n-\t\ttry {\n-\t\t\tpreparedContext \u003d node.prepare(parentContext);\n-\t\t}\n-\t\tcatch (Throwable throwable) {\n-\t\t\trethrowIfBlacklisted(throwable);\n-\t\t\treportAsFailed(testDescriptor, throwable);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tSkipResult skipResult;\n-\t\ttry {\n-\t\t\tskipResult \u003d node.shouldBeSkipped(preparedContext);\n-\t\t}\n-\t\tcatch (Exception exception) {\n-\t\t\trethrowIfBlacklisted(exception);\n-\t\t\ttry {\n-\t\t\t\tnode.cleanUp(preparedContext);\n+\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n+\t\t\ttracker.markExecuted(testDescriptor);\n+\t\t\tprepare(parentContext);\n+\t\t\tif (executionErrors.isEmpty()) {\n+\t\t\t\tcheckWhetherSkipped();\n \t\t\t}\n-\t\t\tcatch (Exception cleanupException) {\n-\t\t\t\texception.addSuppressed(cleanupException);\n+\t\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n+\t\t\t\texecuteRecursively(tracker);\n \t\t\t}\n-\t\t\tfinally {\n-\t\t\t\treportAsFailed(testDescriptor, exception);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (skipResult.isSkipped()) {\n-\t\t\ttry {\n-\t\t\t\tnode.cleanUp(preparedContext);\n-\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n-\t\t\t}\n-\t\t\tcatch (Exception exception) {\n-\t\t\t\treportAsFailed(testDescriptor, exception);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.listener.executionStarted(testDescriptor);\n-\n-\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n-\t\t\tC context \u003d preparedContext;\n-\t\t\ttry {\n-\t\t\t\tcontext \u003d node.before(context);\n-\n-\t\t\t\tC contextForDynamicChildren \u003d context;\n-\t\t\t\tcontext \u003d node.execute(context, dynamicTestDescriptor -\u003e {\n-\t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n-\t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n-\t\t\t\t});\n-\n-\t\t\t\tC contextForStaticChildren \u003d context;\n-\t\t\t\t// @formatter:off\n-\t\t\t\ttestDescriptor.getChildren().stream()\n-\t\t\t\t\t\t.filter(child -\u003e !tracker.wasAlreadyExecuted(child))\n-\t\t\t\t\t\t.forEach(child -\u003e execute(child, contextForStaticChildren, tracker));\n-\t\t\t\t// @formatter:on\n-\t\t\t}\n-\t\t\tfinally {\n-\t\t\t\ttry {\n-\t\t\t\t\tnode.after(context);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t\tnode.cleanUp(context);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tthis.listener.executionFinished(testDescriptor, result);\n-\t}\n\\ No newline at end of file\n+\t\t\tcleanUp();\n+\t\t\treportDone();\n+\t\t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[testDescriptor-TestDescriptor, parentContext-C, tracker-ExecutionTracker]",
            "newValue": "[parentContext-C, tracker-ExecutionTracker]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Refactor HierarchicalTestExecutor\n\nIssue: #742\n",
          "commitDate": "2017-12-28, 12:23 p.m.",
          "commitName": "805d4dad6d3893b8e973019b824167d7b6f2cb8c",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2017-12-28, 12:23 p.m.",
          "commitNameOld": "e0a49d10ffb6505755fc8a0308e898382e3cc1eb",
          "commitAuthorOld": "Christian Stein",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n\t\t\ttracker.markExecuted(testDescriptor);\n\t\t\tprepare(parentContext);\n\t\t\tif (executionErrors.isEmpty()) {\n\t\t\t\tcheckWhetherSkipped();\n\t\t\t}\n\t\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n\t\t\t\texecuteRecursively(tracker);\n\t\t\t}\n\t\t\tcleanUp();\n\t\t\treportDone();\n\t\t}",
          "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
          "functionStartLine": 72,
          "functionName": "execute",
          "diff": "@@ -1,75 +1,12 @@\n-\tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n-\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n-\t\ttracker.markExecuted(testDescriptor);\n-\n-\t\tC preparedContext;\n-\t\ttry {\n-\t\t\tpreparedContext \u003d node.prepare(parentContext);\n-\t\t}\n-\t\tcatch (Throwable throwable) {\n-\t\t\trethrowIfBlacklisted(throwable);\n-\t\t\treportAsFailed(testDescriptor, throwable);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tSkipResult skipResult;\n-\t\ttry {\n-\t\t\tskipResult \u003d node.shouldBeSkipped(preparedContext);\n-\t\t}\n-\t\tcatch (Exception exception) {\n-\t\t\trethrowIfBlacklisted(exception);\n-\t\t\ttry {\n-\t\t\t\tnode.cleanUp(preparedContext);\n+\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n+\t\t\ttracker.markExecuted(testDescriptor);\n+\t\t\tprepare(parentContext);\n+\t\t\tif (executionErrors.isEmpty()) {\n+\t\t\t\tcheckWhetherSkipped();\n \t\t\t}\n-\t\t\tcatch (Exception cleanupException) {\n-\t\t\t\texception.addSuppressed(cleanupException);\n+\t\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n+\t\t\t\texecuteRecursively(tracker);\n \t\t\t}\n-\t\t\tfinally {\n-\t\t\t\treportAsFailed(testDescriptor, exception);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (skipResult.isSkipped()) {\n-\t\t\ttry {\n-\t\t\t\tnode.cleanUp(preparedContext);\n-\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n-\t\t\t}\n-\t\t\tcatch (Exception exception) {\n-\t\t\t\treportAsFailed(testDescriptor, exception);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.listener.executionStarted(testDescriptor);\n-\n-\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n-\t\t\tC context \u003d preparedContext;\n-\t\t\ttry {\n-\t\t\t\tcontext \u003d node.before(context);\n-\n-\t\t\t\tC contextForDynamicChildren \u003d context;\n-\t\t\t\tcontext \u003d node.execute(context, dynamicTestDescriptor -\u003e {\n-\t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n-\t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n-\t\t\t\t});\n-\n-\t\t\t\tC contextForStaticChildren \u003d context;\n-\t\t\t\t// @formatter:off\n-\t\t\t\ttestDescriptor.getChildren().stream()\n-\t\t\t\t\t\t.filter(child -\u003e !tracker.wasAlreadyExecuted(child))\n-\t\t\t\t\t\t.forEach(child -\u003e execute(child, contextForStaticChildren, tracker));\n-\t\t\t\t// @formatter:on\n-\t\t\t}\n-\t\t\tfinally {\n-\t\t\t\ttry {\n-\t\t\t\t\tnode.after(context);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t\tnode.cleanUp(context);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tthis.listener.executionFinished(testDescriptor, result);\n-\t}\n\\ No newline at end of file\n+\t\t\tcleanUp();\n+\t\t\treportDone();\n+\t\t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Refactor HierarchicalTestExecutor\n\nIssue: #742\n",
          "commitDate": "2017-12-28, 12:23 p.m.",
          "commitName": "805d4dad6d3893b8e973019b824167d7b6f2cb8c",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2017-12-28, 12:23 p.m.",
          "commitNameOld": "e0a49d10ffb6505755fc8a0308e898382e3cc1eb",
          "commitAuthorOld": "Christian Stein",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n\t\t\ttracker.markExecuted(testDescriptor);\n\t\t\tprepare(parentContext);\n\t\t\tif (executionErrors.isEmpty()) {\n\t\t\t\tcheckWhetherSkipped();\n\t\t\t}\n\t\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n\t\t\t\texecuteRecursively(tracker);\n\t\t\t}\n\t\t\tcleanUp();\n\t\t\treportDone();\n\t\t}",
          "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
          "functionStartLine": 72,
          "functionName": "execute",
          "diff": "@@ -1,75 +1,12 @@\n-\tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n-\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n-\t\ttracker.markExecuted(testDescriptor);\n-\n-\t\tC preparedContext;\n-\t\ttry {\n-\t\t\tpreparedContext \u003d node.prepare(parentContext);\n-\t\t}\n-\t\tcatch (Throwable throwable) {\n-\t\t\trethrowIfBlacklisted(throwable);\n-\t\t\treportAsFailed(testDescriptor, throwable);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tSkipResult skipResult;\n-\t\ttry {\n-\t\t\tskipResult \u003d node.shouldBeSkipped(preparedContext);\n-\t\t}\n-\t\tcatch (Exception exception) {\n-\t\t\trethrowIfBlacklisted(exception);\n-\t\t\ttry {\n-\t\t\t\tnode.cleanUp(preparedContext);\n+\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n+\t\t\ttracker.markExecuted(testDescriptor);\n+\t\t\tprepare(parentContext);\n+\t\t\tif (executionErrors.isEmpty()) {\n+\t\t\t\tcheckWhetherSkipped();\n \t\t\t}\n-\t\t\tcatch (Exception cleanupException) {\n-\t\t\t\texception.addSuppressed(cleanupException);\n+\t\t\tif (executionErrors.isEmpty() \u0026\u0026 !skipResult.isSkipped()) {\n+\t\t\t\texecuteRecursively(tracker);\n \t\t\t}\n-\t\t\tfinally {\n-\t\t\t\treportAsFailed(testDescriptor, exception);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (skipResult.isSkipped()) {\n-\t\t\ttry {\n-\t\t\t\tnode.cleanUp(preparedContext);\n-\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n-\t\t\t}\n-\t\t\tcatch (Exception exception) {\n-\t\t\t\treportAsFailed(testDescriptor, exception);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.listener.executionStarted(testDescriptor);\n-\n-\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n-\t\t\tC context \u003d preparedContext;\n-\t\t\ttry {\n-\t\t\t\tcontext \u003d node.before(context);\n-\n-\t\t\t\tC contextForDynamicChildren \u003d context;\n-\t\t\t\tcontext \u003d node.execute(context, dynamicTestDescriptor -\u003e {\n-\t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n-\t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n-\t\t\t\t});\n-\n-\t\t\t\tC contextForStaticChildren \u003d context;\n-\t\t\t\t// @formatter:off\n-\t\t\t\ttestDescriptor.getChildren().stream()\n-\t\t\t\t\t\t.filter(child -\u003e !tracker.wasAlreadyExecuted(child))\n-\t\t\t\t\t\t.forEach(child -\u003e execute(child, contextForStaticChildren, tracker));\n-\t\t\t\t// @formatter:on\n-\t\t\t}\n-\t\t\tfinally {\n-\t\t\t\ttry {\n-\t\t\t\t\tnode.after(context);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t\tnode.cleanUp(context);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tthis.listener.executionFinished(testDescriptor, result);\n-\t}\n\\ No newline at end of file\n+\t\t\tcleanUp();\n+\t\t\treportDone();\n+\t\t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "e0a49d10ffb6505755fc8a0308e898382e3cc1eb": {
      "type": "Ybodychange",
      "commitMessage": "Introduce ExtensionContext.Store.CloseableResource interface\n\nAn extension context store is bound to its extension context lifecycle.\nWhen an extension context lifecycle ends it closes its associated store.\nAll stored values that are instances of\n{@link ExtensionContext.Store.CloseableResource} are notified by\ninvoking their {@code close()} method.\n\nCloses #742\n",
      "commitDate": "2017-12-28, 12:23 p.m.",
      "commitName": "e0a49d10ffb6505755fc8a0308e898382e3cc1eb",
      "commitAuthor": "Christian Stein",
      "commitDateOld": "2017-09-08, 3:18 p.m.",
      "commitNameOld": "3c37e59640deaf1f8d9761c655c80193f8d9226a",
      "commitAuthorOld": "JUnit Team",
      "daysBetweenCommits": 110.92,
      "commitsBetweenForRepo": 306,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n\t\ttracker.markExecuted(testDescriptor);\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d node.prepare(parentContext);\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\t\t\treportAsFailed(testDescriptor, throwable);\n\t\t\treturn;\n\t\t}\n\n\t\tSkipResult skipResult;\n\t\ttry {\n\t\t\tskipResult \u003d node.shouldBeSkipped(preparedContext);\n\t\t}\n\t\tcatch (Exception exception) {\n\t\t\trethrowIfBlacklisted(exception);\n\t\t\ttry {\n\t\t\t\tnode.cleanUp(preparedContext);\n\t\t\t}\n\t\t\tcatch (Exception cleanupException) {\n\t\t\t\texception.addSuppressed(cleanupException);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\treportAsFailed(testDescriptor, exception);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (skipResult.isSkipped()) {\n\t\t\ttry {\n\t\t\t\tnode.cleanUp(preparedContext);\n\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t}\n\t\t\tcatch (Exception exception) {\n\t\t\t\treportAsFailed(testDescriptor, exception);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d preparedContext;\n\t\t\ttry {\n\t\t\t\tcontext \u003d node.before(context);\n\n\t\t\t\tC contextForDynamicChildren \u003d context;\n\t\t\t\tcontext \u003d node.execute(context, dynamicTestDescriptor -\u003e {\n\t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n\t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n\t\t\t\t});\n\n\t\t\t\tC contextForStaticChildren \u003d context;\n\t\t\t\t// @formatter:off\n\t\t\t\ttestDescriptor.getChildren().stream()\n\t\t\t\t\t\t.filter(child -\u003e !tracker.wasAlreadyExecuted(child))\n\t\t\t\t\t\t.forEach(child -\u003e execute(child, contextForStaticChildren, tracker));\n\t\t\t\t// @formatter:on\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tnode.after(context);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tnode.cleanUp(context);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis.listener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
      "functionStartLine": 54,
      "functionName": "execute",
      "diff": "@@ -1,48 +1,75 @@\n \tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n \t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n \t\ttracker.markExecuted(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d node.prepare(parentContext);\n-\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n-\t\t\tif (skipResult.isSkipped()) {\n-\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n-\t\t\t\treturn;\n-\t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n-\t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n-\t\t\tthis.listener.executionStarted(testDescriptor);\n-\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n+\t\t\treportAsFailed(testDescriptor, throwable);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSkipResult skipResult;\n+\t\ttry {\n+\t\t\tskipResult \u003d node.shouldBeSkipped(preparedContext);\n+\t\t}\n+\t\tcatch (Exception exception) {\n+\t\t\trethrowIfBlacklisted(exception);\n+\t\t\ttry {\n+\t\t\t\tnode.cleanUp(preparedContext);\n+\t\t\t}\n+\t\t\tcatch (Exception cleanupException) {\n+\t\t\t\texception.addSuppressed(cleanupException);\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\treportAsFailed(testDescriptor, exception);\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (skipResult.isSkipped()) {\n+\t\t\ttry {\n+\t\t\t\tnode.cleanUp(preparedContext);\n+\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n+\t\t\t}\n+\t\t\tcatch (Exception exception) {\n+\t\t\t\treportAsFailed(testDescriptor, exception);\n+\t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d preparedContext;\n \t\t\ttry {\n \t\t\t\tcontext \u003d node.before(context);\n \n \t\t\t\tC contextForDynamicChildren \u003d context;\n \t\t\t\tcontext \u003d node.execute(context, dynamicTestDescriptor -\u003e {\n \t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n \t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n \t\t\t\t});\n \n \t\t\t\tC contextForStaticChildren \u003d context;\n \t\t\t\t// @formatter:off\n \t\t\t\ttestDescriptor.getChildren().stream()\n \t\t\t\t\t\t.filter(child -\u003e !tracker.wasAlreadyExecuted(child))\n \t\t\t\t\t\t.forEach(child -\u003e execute(child, contextForStaticChildren, tracker));\n \t\t\t\t// @formatter:on\n \t\t\t}\n \t\t\tfinally {\n-\t\t\t\tnode.after(context);\n+\t\t\t\ttry {\n+\t\t\t\t\tnode.after(context);\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\tnode.cleanUp(context);\n+\t\t\t\t}\n \t\t\t}\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a3e4b97efb03bd7b52d18c17b9dc185d112a04e8": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Replace Node.isLeaf() with explicit tracking of executed descriptors\n\nFixes #812.",
      "commitDate": "2017-05-03, 5:52 a.m.",
      "commitName": "a3e4b97efb03bd7b52d18c17b9dc185d112a04e8",
      "commitAuthor": "Marc Philipp",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Replace Node.isLeaf() with explicit tracking of executed descriptors\n\nFixes #812.",
          "commitDate": "2017-05-03, 5:52 a.m.",
          "commitName": "a3e4b97efb03bd7b52d18c17b9dc185d112a04e8",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2017-02-24, 3:20 p.m.",
          "commitNameOld": "4b41518fa052b28a953e99b087d505603a22c175",
          "commitAuthorOld": "Marc Philipp",
          "daysBetweenCommits": 67.56,
          "commitsBetweenForRepo": 317,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n\t\ttracker.markExecuted(testDescriptor);\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d node.prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n\t\t\tthis.listener.executionStarted(testDescriptor);\n\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d preparedContext;\n\t\t\ttry {\n\t\t\t\tcontext \u003d node.before(context);\n\n\t\t\t\tC contextForDynamicChildren \u003d context;\n\t\t\t\tcontext \u003d node.execute(context, dynamicTestDescriptor -\u003e {\n\t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n\t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n\t\t\t\t});\n\n\t\t\t\tC contextForStaticChildren \u003d context;\n\t\t\t\t// @formatter:off\n\t\t\t\ttestDescriptor.getChildren().stream()\n\t\t\t\t\t\t.filter(child -\u003e !tracker.wasAlreadyExecuted(child))\n\t\t\t\t\t\t.forEach(child -\u003e execute(child, contextForStaticChildren, tracker));\n\t\t\t\t// @formatter:on\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tnode.after(context);\n\t\t\t}\n\t\t});\n\n\t\tthis.listener.executionFinished(testDescriptor, result);\n\t}",
          "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
          "functionStartLine": 54,
          "functionName": "execute",
          "diff": "@@ -1,48 +1,48 @@\n-\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n+\tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n \t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n+\t\ttracker.markExecuted(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d node.prepare(parentContext);\n \t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d preparedContext;\n \t\t\ttry {\n \t\t\t\tcontext \u003d node.before(context);\n-\t\t\t\tC dynamicTestContext \u003d context;\n+\n+\t\t\t\tC contextForDynamicChildren \u003d context;\n \t\t\t\tcontext \u003d node.execute(context, dynamicTestDescriptor -\u003e {\n \t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n-\t\t\t\t\texecute(dynamicTestDescriptor, dynamicTestContext);\n+\t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n \t\t\t\t});\n \n-\t\t\t\t// If a node is NOT a leaf, execute its children recursively.\n-\t\t\t\t// Note: executing children for a leaf could result in accidental\n-\t\t\t\t// execution of dynamically added children.\n-\t\t\t\tif (!node.isLeaf()) {\n-\t\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\t\t\texecute(child, context);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tC contextForStaticChildren \u003d context;\n+\t\t\t\t// @formatter:off\n+\t\t\t\ttestDescriptor.getChildren().stream()\n+\t\t\t\t\t\t.filter(child -\u003e !tracker.wasAlreadyExecuted(child))\n+\t\t\t\t\t\t.forEach(child -\u003e execute(child, contextForStaticChildren, tracker));\n+\t\t\t\t// @formatter:on\n \t\t\t}\n \t\t\tfinally {\n \t\t\t\tnode.after(context);\n \t\t\t}\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[testDescriptor-TestDescriptor, parentContext-C]",
            "newValue": "[testDescriptor-TestDescriptor, parentContext-C, tracker-ExecutionTracker]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Replace Node.isLeaf() with explicit tracking of executed descriptors\n\nFixes #812.",
          "commitDate": "2017-05-03, 5:52 a.m.",
          "commitName": "a3e4b97efb03bd7b52d18c17b9dc185d112a04e8",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2017-02-24, 3:20 p.m.",
          "commitNameOld": "4b41518fa052b28a953e99b087d505603a22c175",
          "commitAuthorOld": "Marc Philipp",
          "daysBetweenCommits": 67.56,
          "commitsBetweenForRepo": 317,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n\t\ttracker.markExecuted(testDescriptor);\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d node.prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n\t\t\tthis.listener.executionStarted(testDescriptor);\n\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d preparedContext;\n\t\t\ttry {\n\t\t\t\tcontext \u003d node.before(context);\n\n\t\t\t\tC contextForDynamicChildren \u003d context;\n\t\t\t\tcontext \u003d node.execute(context, dynamicTestDescriptor -\u003e {\n\t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n\t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n\t\t\t\t});\n\n\t\t\t\tC contextForStaticChildren \u003d context;\n\t\t\t\t// @formatter:off\n\t\t\t\ttestDescriptor.getChildren().stream()\n\t\t\t\t\t\t.filter(child -\u003e !tracker.wasAlreadyExecuted(child))\n\t\t\t\t\t\t.forEach(child -\u003e execute(child, contextForStaticChildren, tracker));\n\t\t\t\t// @formatter:on\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tnode.after(context);\n\t\t\t}\n\t\t});\n\n\t\tthis.listener.executionFinished(testDescriptor, result);\n\t}",
          "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
          "functionStartLine": 54,
          "functionName": "execute",
          "diff": "@@ -1,48 +1,48 @@\n-\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n+\tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n \t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n+\t\ttracker.markExecuted(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d node.prepare(parentContext);\n \t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d preparedContext;\n \t\t\ttry {\n \t\t\t\tcontext \u003d node.before(context);\n-\t\t\t\tC dynamicTestContext \u003d context;\n+\n+\t\t\t\tC contextForDynamicChildren \u003d context;\n \t\t\t\tcontext \u003d node.execute(context, dynamicTestDescriptor -\u003e {\n \t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n-\t\t\t\t\texecute(dynamicTestDescriptor, dynamicTestContext);\n+\t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n \t\t\t\t});\n \n-\t\t\t\t// If a node is NOT a leaf, execute its children recursively.\n-\t\t\t\t// Note: executing children for a leaf could result in accidental\n-\t\t\t\t// execution of dynamically added children.\n-\t\t\t\tif (!node.isLeaf()) {\n-\t\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\t\t\texecute(child, context);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tC contextForStaticChildren \u003d context;\n+\t\t\t\t// @formatter:off\n+\t\t\t\ttestDescriptor.getChildren().stream()\n+\t\t\t\t\t\t.filter(child -\u003e !tracker.wasAlreadyExecuted(child))\n+\t\t\t\t\t\t.forEach(child -\u003e execute(child, contextForStaticChildren, tracker));\n+\t\t\t\t// @formatter:on\n \t\t\t}\n \t\t\tfinally {\n \t\t\t\tnode.after(context);\n \t\t\t}\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "4b41518fa052b28a953e99b087d505603a22c175": {
      "type": "Ybodychange",
      "commitMessage": "Add support for dynamic test descriptors to HierarchicalTestExecutor\n\nIssue: #14\n",
      "commitDate": "2017-02-24, 3:20 p.m.",
      "commitName": "4b41518fa052b28a953e99b087d505603a22c175",
      "commitAuthor": "Marc Philipp",
      "commitDateOld": "2017-01-02, 3:10 p.m.",
      "commitNameOld": "73f3eeb436e78226f19554f2c2b5dab63e103670",
      "commitAuthorOld": "JUnit Team",
      "daysBetweenCommits": 53.01,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d node.prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n\t\t\tthis.listener.executionStarted(testDescriptor);\n\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d preparedContext;\n\t\t\ttry {\n\t\t\t\tcontext \u003d node.before(context);\n\t\t\t\tC dynamicTestContext \u003d context;\n\t\t\t\tcontext \u003d node.execute(context, dynamicTestDescriptor -\u003e {\n\t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n\t\t\t\t\texecute(dynamicTestDescriptor, dynamicTestContext);\n\t\t\t\t});\n\n\t\t\t\t// If a node is NOT a leaf, execute its children recursively.\n\t\t\t\t// Note: executing children for a leaf could result in accidental\n\t\t\t\t// execution of dynamically added children.\n\t\t\t\tif (!node.isLeaf()) {\n\t\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\t\t\texecute(child, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tnode.after(context);\n\t\t\t}\n\t\t});\n\n\t\tthis.listener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
      "functionStartLine": 54,
      "functionName": "execute",
      "diff": "@@ -1,44 +1,48 @@\n \tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n \t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d node.prepare(parentContext);\n \t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d preparedContext;\n \t\t\ttry {\n \t\t\t\tcontext \u003d node.before(context);\n-\t\t\t\tcontext \u003d node.execute(context);\n+\t\t\t\tC dynamicTestContext \u003d context;\n+\t\t\t\tcontext \u003d node.execute(context, dynamicTestDescriptor -\u003e {\n+\t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n+\t\t\t\t\texecute(dynamicTestDescriptor, dynamicTestContext);\n+\t\t\t\t});\n \n \t\t\t\t// If a node is NOT a leaf, execute its children recursively.\n \t\t\t\t// Note: executing children for a leaf could result in accidental\n \t\t\t\t// execution of dynamically added children.\n \t\t\t\tif (!node.isLeaf()) {\n \t\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\t\t\texecute(child, context);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tfinally {\n \t\t\t\tnode.after(context);\n \t\t\t}\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "67f3391ab9887e5956a650c7a6b645ab04a62157": {
      "type": "Ybodychange",
      "commitMessage": "Resolve TODO wrt. executionStarted() call on premature container failure\n\nFixes #336.\n",
      "commitDate": "2016-07-27, 3:51 p.m.",
      "commitName": "67f3391ab9887e5956a650c7a6b645ab04a62157",
      "commitAuthor": "Marc Philipp",
      "commitDateOld": "2016-07-20, 12:25 p.m.",
      "commitNameOld": "389de48c2a18c5a93a7203ef424aa47a8a835a74",
      "commitAuthorOld": "Matthias Merdes",
      "daysBetweenCommits": 7.14,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d node.prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n\t\t\tthis.listener.executionStarted(testDescriptor);\n\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d preparedContext;\n\t\t\ttry {\n\t\t\t\tcontext \u003d node.before(context);\n\t\t\t\tcontext \u003d node.execute(context);\n\n\t\t\t\t// If a node is NOT a leaf, execute its children recursively.\n\t\t\t\t// Note: executing children for a leaf could result in accidental\n\t\t\t\t// execution of dynamically added children.\n\t\t\t\tif (!node.isLeaf()) {\n\t\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\t\t\texecute(child, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tnode.after(context);\n\t\t\t}\n\t\t});\n\n\t\tthis.listener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
      "functionStartLine": 54,
      "functionName": "execute",
      "diff": "@@ -1,45 +1,44 @@\n \tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n \t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d node.prepare(parentContext);\n \t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n-\n-\t\t\t// TODO [#336] Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n+\t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d preparedContext;\n \t\t\ttry {\n \t\t\t\tcontext \u003d node.before(context);\n \t\t\t\tcontext \u003d node.execute(context);\n \n \t\t\t\t// If a node is NOT a leaf, execute its children recursively.\n \t\t\t\t// Note: executing children for a leaf could result in accidental\n \t\t\t\t// execution of dynamically added children.\n \t\t\t\tif (!node.isLeaf()) {\n \t\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\t\t\texecute(child, context);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tfinally {\n \t\t\t\tnode.after(context);\n \t\t\t}\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "62c433c14ce9d70fa5b82ef385a6e15c22cc0003": {
      "type": "Ybodychange",
      "commitMessage": "Ensure AfterAlls are invoked if exception is thrown by a BeforeAll\n\n- BeforeAll: @BeforeAll method or BeforeAllCallback\n- AfterAll:  @AfterAll method or AfterAllCallback\n\nPrior to this commit, if an exception was thrown by a BeforeAll, then\nAfterAlls were never invoked, which is in strict contrast to the\nsemantics of JUnit 4 and other frameworks.\n\nThis commit fixes this problem by ensuring that AfterAlls (for the\nappropriate nesting level) are invoked even if a BeforeAll throws an\nexception.\n\nFixes: #359\n",
      "commitDate": "2016-06-25, 3:29 p.m.",
      "commitName": "62c433c14ce9d70fa5b82ef385a6e15c22cc0003",
      "commitAuthor": "Sam Brannen",
      "commitDateOld": "2016-06-21, 6:45 a.m.",
      "commitNameOld": "5ca993afb2db6a2dd10e3fb4f0790cf30200a6ec",
      "commitAuthorOld": "Sam Brannen",
      "daysBetweenCommits": 4.36,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d node.prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\n\t\t\t// TODO [#336] Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n\t\t\tthis.listener.executionStarted(testDescriptor);\n\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d preparedContext;\n\t\t\ttry {\n\t\t\t\tcontext \u003d node.before(context);\n\t\t\t\tcontext \u003d node.execute(context);\n\n\t\t\t\t// If a node is NOT a leaf, execute its children recursively.\n\t\t\t\t// Note: executing children for a leaf could result in accidental\n\t\t\t\t// execution of dynamically added children.\n\t\t\t\tif (!node.isLeaf()) {\n\t\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\t\t\texecute(child, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tnode.after(context);\n\t\t\t}\n\t\t});\n\n\t\tthis.listener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
      "functionStartLine": 54,
      "functionName": "execute",
      "diff": "@@ -1,41 +1,45 @@\n \tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n \t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d node.prepare(parentContext);\n \t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO [#336] Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n-\t\t\tC context \u003d node.before(preparedContext);\n-\t\t\tcontext \u003d node.execute(context);\n+\t\t\tC context \u003d preparedContext;\n+\t\t\ttry {\n+\t\t\t\tcontext \u003d node.before(context);\n+\t\t\t\tcontext \u003d node.execute(context);\n \n-\t\t\t// If a node is not a leaf, execute its children recursively.\n-\t\t\t// Note: executing children for a leaf would result in accidental\n-\t\t\t// execution of dynamically added children.\n-\t\t\tif (!node.isLeaf()) {\n-\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\t\texecute(child, context);\n+\t\t\t\t// If a node is NOT a leaf, execute its children recursively.\n+\t\t\t\t// Note: executing children for a leaf could result in accidental\n+\t\t\t\t// execution of dynamically added children.\n+\t\t\t\tif (!node.isLeaf()) {\n+\t\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n+\t\t\t\t\t\texecute(child, context);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\n-\t\t\tnode.after(context);\n+\t\t\tfinally {\n+\t\t\t\tnode.after(context);\n+\t\t\t}\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5ca993afb2db6a2dd10e3fb4f0790cf30200a6ec": {
      "type": "Ybodychange",
      "commitMessage": "Track TODOs\n",
      "commitDate": "2016-06-21, 6:45 a.m.",
      "commitName": "5ca993afb2db6a2dd10e3fb4f0790cf30200a6ec",
      "commitAuthor": "Sam Brannen",
      "commitDateOld": "2016-06-20, 7:43 a.m.",
      "commitNameOld": "f05183091a62cbbd58df338fc58f599f7994ec74",
      "commitAuthorOld": "JUnit Team",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d node.prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\n\t\t\t// TODO [#336] Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n\t\t\tthis.listener.executionStarted(testDescriptor);\n\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d node.before(preparedContext);\n\t\t\tcontext \u003d node.execute(context);\n\n\t\t\t// If a node is not a leaf, execute its children recursively.\n\t\t\t// Note: executing children for a leaf would result in accidental\n\t\t\t// execution of dynamically added children.\n\t\t\tif (!node.isLeaf()) {\n\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\t\texecute(child, context);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.after(context);\n\t\t});\n\n\t\tthis.listener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
      "functionStartLine": 54,
      "functionName": "execute",
      "diff": "@@ -1,41 +1,41 @@\n \tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n \t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d node.prepare(parentContext);\n \t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n-\t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n+\t\t\t// TODO [#336] Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d node.before(preparedContext);\n \t\t\tcontext \u003d node.execute(context);\n \n \t\t\t// If a node is not a leaf, execute its children recursively.\n \t\t\t// Note: executing children for a leaf would result in accidental\n \t\t\t// execution of dynamically added children.\n \t\t\tif (!node.isLeaf()) {\n \t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\t\texecute(child, context);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tnode.after(context);\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4972eb58d680a30e8fbd1ffb6cdc6477bef83374": {
      "type": "Yfilerename",
      "commitMessage": "Rename all JUnit 5 artifacts to platform, jupiter, \u0026 vintage\n\nIssue: #286\n",
      "commitDate": "2016-06-20, 4:59 a.m.",
      "commitName": "4972eb58d680a30e8fbd1ffb6cdc6477bef83374",
      "commitAuthor": "JUnit Team",
      "commitDateOld": "2016-06-19, 2:04 p.m.",
      "commitNameOld": "e5b7300ba40a0420e310d463a63ea4c10cc8d9b9",
      "commitAuthorOld": "Sam Brannen",
      "daysBetweenCommits": 0.62,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d node.prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\n\t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n\t\t\tthis.listener.executionStarted(testDescriptor);\n\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d node.before(preparedContext);\n\t\t\tcontext \u003d node.execute(context);\n\n\t\t\t// If a node is not a leaf, execute its children recursively.\n\t\t\t// Note: executing children for a leaf would result in accidental\n\t\t\t// execution of dynamically added children.\n\t\t\tif (!node.isLeaf()) {\n\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\t\texecute(child, context);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.after(context);\n\t\t});\n\n\t\tthis.listener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
      "functionStartLine": 54,
      "functionName": "execute",
      "diff": "",
      "extendedDetails": {
        "oldPath": "junit-engine-api/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
        "newPath": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java"
      }
    },
    "4537bec58804c392a8bce296dced0337c8ec1a8d": {
      "type": "Yfilerename",
      "commitMessage": "Rename remaining org.junit.gen5 base packages to org.junit.platform\n\nIssue: #286\n",
      "commitDate": "2016-06-19, 1:22 p.m.",
      "commitName": "4537bec58804c392a8bce296dced0337c8ec1a8d",
      "commitAuthor": "JUnit Team",
      "commitDateOld": "2016-06-19, 12:25 p.m.",
      "commitNameOld": "4dd821ac0cf681f17f14e1dcd383b10c99104e70",
      "commitAuthorOld": "Sam Brannen",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d node.prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\n\t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n\t\t\tthis.listener.executionStarted(testDescriptor);\n\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d node.before(preparedContext);\n\t\t\tcontext \u003d node.execute(context);\n\n\t\t\t// If a node is not a leaf, execute its children recursively.\n\t\t\t// Note: executing children for a leaf would result in accidental\n\t\t\t// execution of dynamically added children.\n\t\t\tif (!node.isLeaf()) {\n\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\t\texecute(child, context);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.after(context);\n\t\t});\n\n\t\tthis.listener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
      "functionStartLine": 54,
      "functionName": "execute",
      "diff": "",
      "extendedDetails": {
        "oldPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/support/hierarchical/HierarchicalTestExecutor.java",
        "newPath": "junit-engine-api/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java"
      }
    },
    "6b46df0ee35ef56021ca5f4dc9e41ac96b19de0e": {
      "type": "Ybodychange",
      "commitMessage": "Introduce default semantics for Node.isLeaf()\n",
      "commitDate": "2016-05-31, 8:41 a.m.",
      "commitName": "6b46df0ee35ef56021ca5f4dc9e41ac96b19de0e",
      "commitAuthor": "Sam Brannen",
      "commitDateOld": "2016-05-30, 9:54 p.m.",
      "commitNameOld": "c8e52a7cde0579562c51c838ef1c83b68b0c31cf",
      "commitAuthorOld": "Sam Brannen",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d node.prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\n\t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n\t\t\tthis.listener.executionStarted(testDescriptor);\n\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d node.before(preparedContext);\n\t\t\tcontext \u003d node.execute(context);\n\n\t\t\t// If a node is not a leaf, execute its children recursively.\n\t\t\t// Note: executing children for a leaf would result in accidental\n\t\t\t// execution of dynamically added children.\n\t\t\tif (!node.isLeaf()) {\n\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\t\texecute(child, context);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.after(context);\n\t\t});\n\n\t\tthis.listener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/support/hierarchical/HierarchicalTestExecutor.java",
      "functionStartLine": 54,
      "functionName": "execute",
      "diff": "@@ -1,37 +1,41 @@\n \tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n \t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d node.prepare(parentContext);\n \t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d node.before(preparedContext);\n \t\t\tcontext \u003d node.execute(context);\n \n-\t\t\tif (!node.isLeaf()) { // Prevent execution of dynamically added children\n+\t\t\t// If a node is not a leaf, execute its children recursively.\n+\t\t\t// Note: executing children for a leaf would result in accidental\n+\t\t\t// execution of dynamically added children.\n+\t\t\tif (!node.isLeaf()) {\n \t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\t\texecute(child, context);\n \t\t\t\t}\n \t\t\t}\n+\n \t\t\tnode.after(context);\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c8e52a7cde0579562c51c838ef1c83b68b0c31cf": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "Remove Container \u0026 Leaf abstractions from the HierarchicalTestEngine\n",
      "commitDate": "2016-05-30, 9:54 p.m.",
      "commitName": "c8e52a7cde0579562c51c838ef1c83b68b0c31cf",
      "commitAuthor": "Sam Brannen",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "Remove Container \u0026 Leaf abstractions from the HierarchicalTestEngine\n",
          "commitDate": "2016-05-30, 9:54 p.m.",
          "commitName": "c8e52a7cde0579562c51c838ef1c83b68b0c31cf",
          "commitAuthor": "Sam Brannen",
          "commitDateOld": "2016-05-23, 3:21 p.m.",
          "commitNameOld": "ac7bb522519cd8a600324aa909a5c17a110cb97f",
          "commitAuthorOld": "Johannes Link",
          "daysBetweenCommits": 7.27,
          "commitsBetweenForRepo": 91,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d node.prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\n\t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n\t\t\tthis.listener.executionStarted(testDescriptor);\n\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d node.before(preparedContext);\n\t\t\tcontext \u003d node.execute(context);\n\n\t\t\tif (!node.isLeaf()) { // Prevent execution of dynamically added children\n\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\t\texecute(child, context);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode.after(context);\n\t\t});\n\n\t\tthis.listener.executionFinished(testDescriptor, result);\n\t}",
          "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/support/hierarchical/HierarchicalTestExecutor.java",
          "functionStartLine": 54,
          "functionName": "execute",
          "diff": "@@ -1,35 +1,37 @@\n-\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n+\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n+\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n-\t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n-\t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n+\t\t\tpreparedContext \u003d node.prepare(parentContext);\n+\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n-\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n+\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n-\t\t\tlistener.executionStarted(testDescriptor);\n-\t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n+\t\t\tthis.listener.executionStarted(testDescriptor);\n+\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n-\t\tlistener.executionStarted(testDescriptor);\n+\t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n-\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n-\t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n+\t\t\tC context \u003d node.before(preparedContext);\n+\t\t\tcontext \u003d node.execute(context);\n \n-\t\t\tif (testDescriptor instanceof Container) { // to prevent execution of dynamically added children\n+\t\t\tif (!node.isLeaf()) { // Prevent execution of dynamically added children\n \t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\t\texecuteAll(child, context);\n+\t\t\t\t\texecute(child, context);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n+\t\t\tnode.after(context);\n \t\t});\n-\t\tlistener.executionFinished(testDescriptor, result);\n+\n+\t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "executeAll",
            "newValue": "execute"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Remove Container \u0026 Leaf abstractions from the HierarchicalTestEngine\n",
          "commitDate": "2016-05-30, 9:54 p.m.",
          "commitName": "c8e52a7cde0579562c51c838ef1c83b68b0c31cf",
          "commitAuthor": "Sam Brannen",
          "commitDateOld": "2016-05-23, 3:21 p.m.",
          "commitNameOld": "ac7bb522519cd8a600324aa909a5c17a110cb97f",
          "commitAuthorOld": "Johannes Link",
          "daysBetweenCommits": 7.27,
          "commitsBetweenForRepo": 91,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d node.prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\n\t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n\t\t\tthis.listener.executionStarted(testDescriptor);\n\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d node.before(preparedContext);\n\t\t\tcontext \u003d node.execute(context);\n\n\t\t\tif (!node.isLeaf()) { // Prevent execution of dynamically added children\n\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\t\texecute(child, context);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode.after(context);\n\t\t});\n\n\t\tthis.listener.executionFinished(testDescriptor, result);\n\t}",
          "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/support/hierarchical/HierarchicalTestExecutor.java",
          "functionStartLine": 54,
          "functionName": "execute",
          "diff": "@@ -1,35 +1,37 @@\n-\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n+\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n+\t\tNode\u003cC\u003e node \u003d asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n-\t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n-\t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n+\t\t\tpreparedContext \u003d node.prepare(parentContext);\n+\t\t\tSkipResult skipResult \u003d node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n-\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n+\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n-\t\t\tlistener.executionStarted(testDescriptor);\n-\t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n+\t\t\tthis.listener.executionStarted(testDescriptor);\n+\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n-\t\tlistener.executionStarted(testDescriptor);\n+\t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n-\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n-\t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n+\t\t\tC context \u003d node.before(preparedContext);\n+\t\t\tcontext \u003d node.execute(context);\n \n-\t\t\tif (testDescriptor instanceof Container) { // to prevent execution of dynamically added children\n+\t\t\tif (!node.isLeaf()) { // Prevent execution of dynamically added children\n \t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\t\texecuteAll(child, context);\n+\t\t\t\t\texecute(child, context);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n+\t\t\tnode.after(context);\n \t\t});\n-\t\tlistener.executionFinished(testDescriptor, result);\n+\n+\t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ac7bb522519cd8a600324aa909a5c17a110cb97f": {
      "type": "Ybodychange",
      "commitMessage": "Execution of simple dynamic tests (#58)\n\n- HierarchicalTestExecutor only executes children from containers\n- Unique IDs for dynamic tests are created using index\n- Add tests for discovery of dynamic test by method selector (#58)\n",
      "commitDate": "2016-05-23, 3:21 p.m.",
      "commitName": "ac7bb522519cd8a600324aa909a5c17a110cb97f",
      "commitAuthor": "Johannes Link",
      "commitDateOld": "2016-01-22, 3:27 p.m.",
      "commitNameOld": "2d0b61d00defaa534532d5541cfcb818307ff0d0",
      "commitAuthorOld": "Sam Brannen",
      "daysBetweenCommits": 121.95,
      "commitsBetweenForRepo": 504,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\n\t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n\t\t\tlistener.executionStarted(testDescriptor);\n\t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tlistener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n\t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n\n\t\t\tif (testDescriptor instanceof Container) { // to prevent execution of dynamically added children\n\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\t\texecuteAll(child, context);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n\t\t});\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/support/hierarchical/HierarchicalTestExecutor.java",
      "functionStartLine": 57,
      "functionName": "executeAll",
      "diff": "@@ -1,33 +1,35 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n \t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n \t\t\tlistener.executionStarted(testDescriptor);\n \t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tlistener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n \n-\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\texecuteAll(child, context);\n+\t\t\tif (testDescriptor instanceof Container) { // to prevent execution of dynamically added children\n+\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n+\t\t\t\t\texecuteAll(child, context);\n+\t\t\t\t}\n \t\t\t}\n \t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2d0b61d00defaa534532d5541cfcb818307ff0d0": {
      "type": "Ybodychange",
      "commitMessage": "Consistent use of \u003cunknown\u003e for unknown results in evaluations\n\n- conditions\n- filters\n",
      "commitDate": "2016-01-22, 3:27 p.m.",
      "commitName": "2d0b61d00defaa534532d5541cfcb818307ff0d0",
      "commitAuthor": "Sam Brannen",
      "commitDateOld": "2016-01-22, 12:09 p.m.",
      "commitNameOld": "ebd537b73796d734739fa6aabb78b4e88bbdd907",
      "commitAuthorOld": "Sam Brannen",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\n\t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n\t\t\tlistener.executionStarted(testDescriptor);\n\t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tlistener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n\t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, context);\n\t\t\t}\n\t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n\t\t});\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/support/hierarchical/HierarchicalTestExecutor.java",
      "functionStartLine": 57,
      "functionName": "executeAll",
      "diff": "@@ -1,33 +1,33 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n \t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n-\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n+\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\u003cunknown\u003e\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n \t\t\tlistener.executionStarted(testDescriptor);\n \t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tlistener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n \n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ebd537b73796d734739fa6aabb78b4e88bbdd907": {
      "type": "Ybodychange",
      "commitMessage": "Document collaborators of HierarchicalTestEngine\n",
      "commitDate": "2016-01-22, 12:09 p.m.",
      "commitName": "ebd537b73796d734739fa6aabb78b4e88bbdd907",
      "commitAuthor": "Sam Brannen",
      "commitDateOld": "2016-01-22, 12:09 p.m.",
      "commitNameOld": "52b564dce77ed9f2fb055758c78cc6de4acc78b5",
      "commitAuthorOld": "Sam Brannen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\n\t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n\t\t\tlistener.executionStarted(testDescriptor);\n\t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tlistener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n\t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, context);\n\t\t\t}\n\t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n\t\t});\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/support/hierarchical/HierarchicalTestExecutor.java",
      "functionStartLine": 57,
      "functionName": "executeAll",
      "diff": "@@ -1,33 +1,33 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n \t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n-\t\t\t// TODO Is this what we want?\n+\t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n \t\t\tlistener.executionStarted(testDescriptor);\n \t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tlistener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n \n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0d2aa7088f7a586113524ba74448febcf6c70c51": {
      "type": "Yfilerename",
      "commitMessage": "Move support classes to separate packages\n\nIssue: #54\n",
      "commitDate": "2016-01-18, 8:44 a.m.",
      "commitName": "0d2aa7088f7a586113524ba74448febcf6c70c51",
      "commitAuthor": "Marc Philipp",
      "commitDateOld": "2016-01-18, 6:13 a.m.",
      "commitNameOld": "e99b1638955130803cd723245c4a797f03388b9b",
      "commitAuthorOld": "Stefan Bechtold",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\n\t\t\t// TODO Is this what we want?\n\t\t\tlistener.executionStarted(testDescriptor);\n\t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tlistener.executionStarted(testDescriptor);\n\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n\t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, context);\n\t\t\t}\n\t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n\t\t});\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/support/hierarchical/HierarchicalTestExecutor.java",
      "functionStartLine": 59,
      "functionName": "executeAll",
      "diff": "",
      "extendedDetails": {
        "oldPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestExecutor.java",
        "newPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/support/hierarchical/HierarchicalTestExecutor.java"
      }
    },
    "742e38c48236556233c280ddafe8a55e570de1a2": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n\nIssue: #83\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks msg systems ag\n(http://www.msg-systems.com) for supporting the JUnit crowdfunding\ncampaign!\n------------------------------------------------------------------------\n",
      "commitDate": "2016-01-05, 11:21 a.m.",
      "commitName": "742e38c48236556233c280ddafe8a55e570de1a2",
      "commitAuthor": "Sam Brannen",
      "commitDateOld": "2016-01-05, 11:14 a.m.",
      "commitNameOld": "614df95c0ec68977bb02515585340418fc3d7a6e",
      "commitAuthorOld": "Sam Brannen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlacklisted(throwable);\n\n\t\t\t// TODO Is this what we want?\n\t\t\tlistener.executionStarted(testDescriptor);\n\t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tlistener.executionStarted(testDescriptor);\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n\t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, context);\n\t\t\t}\n\t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n\t\t});\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestExecutor.java",
      "functionStartLine": 53,
      "functionName": "executeAll",
      "diff": "@@ -1,31 +1,31 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n \t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n-\t\t\trethrowIfBlackListed(throwable);\n+\t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO Is this what we want?\n \t\t\tlistener.executionStarted(testDescriptor);\n \t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tlistener.executionStarted(testDescriptor);\n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a02c0e24af370ced24d8fa9d758b1a1db396796f": {
      "type": "Ybodychange",
      "commitMessage": "Introduce support for blacklisted exceptions\n\nThis commit introduces a BlacklistedExceptions utility class for\nrethrowing blacklisted exceptions (i.e., errors that always terminate\nthe test plan execution immediately).\n\nHierarchicalTestExecutor and SingleTestExecutor have been retrofitted to\nsupport blacklisted exceptions.\n\nIssue: #83\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks msg systems ag\n(http://www.msg-systems.com) for supporting the JUnit crowdfunding\ncampaign!\n------------------------------------------------------------------------\n",
      "commitDate": "2016-01-05, 11:14 a.m.",
      "commitName": "a02c0e24af370ced24d8fa9d758b1a1db396796f",
      "commitAuthor": "Sam Brannen",
      "commitDateOld": "2016-01-01, 1:57 p.m.",
      "commitNameOld": "a6e3e77eeb01b8e6fdc91be3120c6d07af1b5a91",
      "commitAuthorOld": "Marc Philipp",
      "daysBetweenCommits": 3.89,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\trethrowIfBlackListed(throwable);\n\n\t\t\t// TODO Is this what we want?\n\t\t\tlistener.executionStarted(testDescriptor);\n\t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tlistener.executionStarted(testDescriptor);\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n\t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, context);\n\t\t\t}\n\t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n\t\t});\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestExecutor.java",
      "functionStartLine": 45,
      "functionName": "executeAll",
      "diff": "@@ -1,29 +1,31 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n \t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n-\t\t\t//TODO: Is this what we want?\n+\t\t\trethrowIfBlackListed(throwable);\n+\n+\t\t\t// TODO Is this what we want?\n \t\t\tlistener.executionStarted(testDescriptor);\n \t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tlistener.executionStarted(testDescriptor);\n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c54786d16f1c5f5ac5384a68893d069eba062e39": {
      "type": "Ybodychange",
      "commitMessage": "Added exception handling for errors in test preparation.\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nGradleware (https://gradle.org) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
      "commitDate": "2015-12-23, 3:39 a.m.",
      "commitName": "c54786d16f1c5f5ac5384a68893d069eba062e39",
      "commitAuthor": "Johannes Link",
      "commitDateOld": "2015-12-22, 4:34 a.m.",
      "commitNameOld": "0027ade00fd483e08714ece1021a7715bb1855da",
      "commitAuthorOld": "Johannes Link",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\t//TODO: Is this what we want?\n\t\t\tlistener.executionStarted(testDescriptor);\n\t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n\t\t\treturn;\n\t\t}\n\n\t\tlistener.executionStarted(testDescriptor);\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n\t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, context);\n\t\t\t}\n\t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n\t\t});\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestExecutor.java",
      "functionStartLine": 34,
      "functionName": "executeAll",
      "diff": "@@ -1,27 +1,29 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n \t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n-\t\t\t//TODO: What should happen if prepare or shouldBeSkipped thrown an exception?\n-\t\t\tthrow new RuntimeException(throwable);\n+\t\t\t//TODO: Is this what we want?\n+\t\t\tlistener.executionStarted(testDescriptor);\n+\t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n+\t\t\treturn;\n \t\t}\n \n \t\tlistener.executionStarted(testDescriptor);\n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0027ade00fd483e08714ece1021a7715bb1855da": {
      "type": "Ybodychange",
      "commitMessage": "Added skipping for methods and classes.\nSome duplication and naming issues left.\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nGradleware (https://gradle.org) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
      "commitDate": "2015-12-22, 4:34 a.m.",
      "commitName": "0027ade00fd483e08714ece1021a7715bb1855da",
      "commitAuthor": "Johannes Link",
      "commitDateOld": "2015-12-13, 4:24 p.m.",
      "commitNameOld": "55a1054a3310fdbf6e7a0c03f9a6ba9366aa2ece",
      "commitAuthorOld": "Marc Philipp",
      "daysBetweenCommits": 8.51,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n\n\t\tC preparedContext;\n\t\ttry {\n\t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n\t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n\t\t\tif (skipResult.isSkipped()) {\n\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\t//TODO: What should happen if prepare or shouldBeSkipped thrown an exception?\n\t\t\tthrow new RuntimeException(throwable);\n\t\t}\n\n\t\tlistener.executionStarted(testDescriptor);\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n\t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, context);\n\t\t\t}\n\t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n\t\t});\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestExecutor.java",
      "functionStartLine": 34,
      "functionName": "executeAll",
      "diff": "@@ -1,14 +1,27 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n-\t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n-\t\t// event instead.\n+\n+\t\tC preparedContext;\n+\t\ttry {\n+\t\t\tpreparedContext \u003d adapter.asNode(testDescriptor).prepare(parentContext);\n+\t\t\tSkipResult skipResult \u003d adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n+\t\t\tif (skipResult.isSkipped()) {\n+\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tcatch (Throwable throwable) {\n+\t\t\t//TODO: What should happen if prepare or shouldBeSkipped thrown an exception?\n+\t\t\tthrow new RuntimeException(throwable);\n+\t\t}\n+\n \t\tlistener.executionStarted(testDescriptor);\n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n-\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(parentContext);\n+\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "55a1054a3310fdbf6e7a0c03f9a6ba9366aa2ece": {
      "type": "Ybodychange",
      "commitMessage": "Less @SuppressWarnings\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nAdNovum Informatik AG (http://www.adnovum.ch) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
      "commitDate": "2015-12-13, 4:24 p.m.",
      "commitName": "55a1054a3310fdbf6e7a0c03f9a6ba9366aa2ece",
      "commitAuthor": "Marc Philipp",
      "commitDateOld": "2015-12-13, 3:54 p.m.",
      "commitNameOld": "d920335e85cfee5444fe3d69d12806d999b9f2ec",
      "commitAuthorOld": "Marc Philipp",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n\t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n\t\t// event instead.\n\t\tlistener.executionStarted(testDescriptor);\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(parentContext);\n\t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, context);\n\t\t\t}\n\t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n\t\t});\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestExecutor.java",
      "functionStartLine": 32,
      "functionName": "executeAll",
      "diff": "@@ -1,14 +1,14 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n \t\t// event instead.\n \t\tlistener.executionStarted(testDescriptor);\n \t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n-\t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n-\t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n+\t\t\tC context \u003d adapter.asContainer(testDescriptor).beforeAll(parentContext);\n+\t\t\tcontext \u003d adapter.asLeaf(testDescriptor).execute(context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n-\t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n+\t\t\tcontext \u003d adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cfefe1e65034c5e66e0fbcb503fe8ad1a4c086d2": {
      "type": "Ymultichange(Yfilerename,Ybodychange,Yparameterchange)",
      "commitMessage": "Extract stateful HierarchicalTestExecutor\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nAdNovum Informatik AG (http://www.adnovum.ch) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
      "commitDate": "2015-12-13, 3:54 p.m.",
      "commitName": "cfefe1e65034c5e66e0fbcb503fe8ad1a4c086d2",
      "commitAuthor": "Marc Philipp",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "Extract stateful HierarchicalTestExecutor\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nAdNovum Informatik AG (http://www.adnovum.ch) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
          "commitDate": "2015-12-13, 3:54 p.m.",
          "commitName": "cfefe1e65034c5e66e0fbcb503fe8ad1a4c086d2",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2015-12-13, 3:41 p.m.",
          "commitNameOld": "e9d19c214a3117efdd9295bdb1b2ddb4f7e67987",
          "commitAuthorOld": "Johannes Link",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n\t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n\t\t// event instead.\n\t\tlistener.executionStarted(testDescriptor);\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n\t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, context);\n\t\t\t}\n\t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n\t\t});\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
          "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestExecutor.java",
          "functionStartLine": 31,
          "functionName": "executeAll",
          "diff": "@@ -1,14 +1,14 @@\n-\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n+\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n \t\t// event instead.\n \t\tlistener.executionStarted(testDescriptor);\n-\t\tTestExecutionResult result \u003d new SingleTestExecutor().executeSafely(() -\u003e {\n+\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n \t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\texecuteAll(child, listener, context);\n+\t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestEngine.java",
            "newPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestExecutor.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Extract stateful HierarchicalTestExecutor\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nAdNovum Informatik AG (http://www.adnovum.ch) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
          "commitDate": "2015-12-13, 3:54 p.m.",
          "commitName": "cfefe1e65034c5e66e0fbcb503fe8ad1a4c086d2",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2015-12-13, 3:41 p.m.",
          "commitNameOld": "e9d19c214a3117efdd9295bdb1b2ddb4f7e67987",
          "commitAuthorOld": "Johannes Link",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n\t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n\t\t// event instead.\n\t\tlistener.executionStarted(testDescriptor);\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n\t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, context);\n\t\t\t}\n\t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n\t\t});\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
          "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestExecutor.java",
          "functionStartLine": 31,
          "functionName": "executeAll",
          "diff": "@@ -1,14 +1,14 @@\n-\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n+\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n \t\t// event instead.\n \t\tlistener.executionStarted(testDescriptor);\n-\t\tTestExecutionResult result \u003d new SingleTestExecutor().executeSafely(() -\u003e {\n+\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n \t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\texecuteAll(child, listener, context);\n+\t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Extract stateful HierarchicalTestExecutor\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nAdNovum Informatik AG (http://www.adnovum.ch) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
          "commitDate": "2015-12-13, 3:54 p.m.",
          "commitName": "cfefe1e65034c5e66e0fbcb503fe8ad1a4c086d2",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2015-12-13, 3:41 p.m.",
          "commitNameOld": "e9d19c214a3117efdd9295bdb1b2ddb4f7e67987",
          "commitAuthorOld": "Johannes Link",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n\t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n\t\t// event instead.\n\t\tlistener.executionStarted(testDescriptor);\n\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n\t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n\t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, context);\n\t\t\t}\n\t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n\t\t});\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
          "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestExecutor.java",
          "functionStartLine": 31,
          "functionName": "executeAll",
          "diff": "@@ -1,14 +1,14 @@\n-\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n+\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n \t\t// event instead.\n \t\tlistener.executionStarted(testDescriptor);\n-\t\tTestExecutionResult result \u003d new SingleTestExecutor().executeSafely(() -\u003e {\n+\t\tTestExecutionResult result \u003d singleTestExecutor.executeSafely(() -\u003e {\n \t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n \t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\texecuteAll(child, listener, context);\n+\t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[testDescriptor-TestDescriptor, listener-EngineExecutionListener, parentContext-C]",
            "newValue": "[testDescriptor-TestDescriptor, parentContext-C]"
          }
        }
      ]
    },
    "94bd5987b3b75c91a41fd70779bae83bb9b5fb9c": {
      "type": "Ybodychange",
      "commitMessage": "TestAbortedException leads to aborted test\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nAdNovum Informatik AG (http://www.adnovum.ch) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
      "commitDate": "2015-12-13, 3:08 p.m.",
      "commitName": "94bd5987b3b75c91a41fd70779bae83bb9b5fb9c",
      "commitAuthor": "Marc Philipp",
      "commitDateOld": "2015-12-11, 4:35 p.m.",
      "commitNameOld": "f8a1c6b5ae5a144d1a3e85100a4d61b7f059822d",
      "commitAuthorOld": "Marc Philipp",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n\t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n\t\t// event instead.\n\t\tlistener.executionStarted(testDescriptor);\n\t\tTestExecutionResult result \u003d new SingleTestExecutor().executeSafely(() -\u003e {\n\t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n\t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, listener, context);\n\t\t\t}\n\t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n\t\t});\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestEngine.java",
      "functionStartLine": 27,
      "functionName": "executeAll",
      "diff": "@@ -1,19 +1,14 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n \t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n \t\t// event instead.\n \t\tlistener.executionStarted(testDescriptor);\n-\t\tTestExecutionResult result;\n-\t\ttry {\n+\t\tTestExecutionResult result \u003d new SingleTestExecutor().executeSafely(() -\u003e {\n \t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n \t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, listener, context);\n \t\t\t}\n \t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n-\t\t\tresult \u003d TestExecutionResult.successful();\n-\t\t}\n-\t\tcatch (Throwable t) {\n-\t\t\tresult \u003d TestExecutionResult.failed(t);\n-\t\t}\n+\t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f8a1c6b5ae5a144d1a3e85100a4d61b7f059822d": {
      "type": "Ybodychange",
      "commitMessage": "Fire started/finished events for containers too\n\nIssue: #34\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks Netcetera AG\n(http://netcetera.com) for supporting the JUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
      "commitDate": "2015-12-11, 4:35 p.m.",
      "commitName": "f8a1c6b5ae5a144d1a3e85100a4d61b7f059822d",
      "commitAuthor": "Marc Philipp",
      "commitDateOld": "2015-12-11, 4:35 p.m.",
      "commitNameOld": "fc86dab57883ffcc0c5e6b9ea0999abb98101137",
      "commitAuthorOld": "Marc Philipp",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n\t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n\t\t// event instead.\n\t\tlistener.executionStarted(testDescriptor);\n\t\tTestExecutionResult result;\n\t\ttry {\n\t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n\t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, listener, context);\n\t\t\t}\n\t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n\t\t\tresult \u003d TestExecutionResult.successful();\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tresult \u003d TestExecutionResult.failed(t);\n\t\t}\n\t\tlistener.executionFinished(testDescriptor, result);\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestEngine.java",
      "functionStartLine": 27,
      "functionName": "executeAll",
      "diff": "@@ -1,21 +1,19 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n-\t\tif (testDescriptor.isTest()) {\n-\t\t\tlistener.testStarted(testDescriptor);\n-\t\t}\n+\t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n+\t\t// event instead.\n+\t\tlistener.executionStarted(testDescriptor);\n \t\tTestExecutionResult result;\n \t\ttry {\n \t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n \t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, listener, context);\n \t\t\t}\n \t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n \t\t\tresult \u003d TestExecutionResult.successful();\n \t\t}\n \t\tcatch (Throwable t) {\n \t\t\tresult \u003d TestExecutionResult.failed(t);\n \t\t}\n-\t\tif (testDescriptor.isTest()) {\n-\t\t\tlistener.testFinished(testDescriptor, result);\n-\t\t}\n+\t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc86dab57883ffcc0c5e6b9ea0999abb98101137": {
      "type": "Ybodychange",
      "commitMessage": "Trigger Finished event instead of separated ones\n\nInstead of triggering Succeeded/Aborted/Failed events we now only\ntrigger a Finished event with a TestExecutionResult parameter.\n\nIssue: #34\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks Netcetera AG\n(http://netcetera.com) for supporting the JUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
      "commitDate": "2015-12-11, 4:35 p.m.",
      "commitName": "fc86dab57883ffcc0c5e6b9ea0999abb98101137",
      "commitAuthor": "Marc Philipp",
      "commitDateOld": "2015-12-11, 2:07 p.m.",
      "commitNameOld": "417fd0e92571ec0cc01987c03f3ff112e4d867fc",
      "commitAuthorOld": "Marc Philipp",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n\t\tif (testDescriptor.isTest()) {\n\t\t\tlistener.testStarted(testDescriptor);\n\t\t}\n\t\tTestExecutionResult result;\n\t\ttry {\n\t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n\t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, listener, context);\n\t\t\t}\n\t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n\t\t\tresult \u003d TestExecutionResult.successful();\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tresult \u003d TestExecutionResult.failed(t);\n\t\t}\n\t\tif (testDescriptor.isTest()) {\n\t\t\tlistener.testFinished(testDescriptor, result);\n\t\t}\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestEngine.java",
      "functionStartLine": 27,
      "functionName": "executeAll",
      "diff": "@@ -1,21 +1,21 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n \t\tif (testDescriptor.isTest()) {\n \t\t\tlistener.testStarted(testDescriptor);\n \t\t}\n+\t\tTestExecutionResult result;\n \t\ttry {\n \t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n \t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, listener, context);\n \t\t\t}\n \t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n-\t\t\tif (testDescriptor.isTest()) {\n-\t\t\t\tlistener.testSucceeded(testDescriptor);\n-\t\t\t}\n+\t\t\tresult \u003d TestExecutionResult.successful();\n \t\t}\n \t\tcatch (Throwable t) {\n-\t\t\tif (testDescriptor.isTest()) {\n-\t\t\t\tlistener.testFailed(testDescriptor, t);\n-\t\t\t}\n+\t\t\tresult \u003d TestExecutionResult.failed(t);\n+\t\t}\n+\t\tif (testDescriptor.isTest()) {\n+\t\t\tlistener.testFinished(testDescriptor, result);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "417fd0e92571ec0cc01987c03f3ff112e4d867fc": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "Cleanup HierarchicalTestEngine\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nNetcetera AG (http://netcetera.com) for supporting the JUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
      "commitDate": "2015-12-11, 2:07 p.m.",
      "commitName": "417fd0e92571ec0cc01987c03f3ff112e4d867fc",
      "commitAuthor": "Marc Philipp",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Cleanup HierarchicalTestEngine\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nNetcetera AG (http://netcetera.com) for supporting the JUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
          "commitDate": "2015-12-11, 2:07 p.m.",
          "commitName": "417fd0e92571ec0cc01987c03f3ff112e4d867fc",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2015-12-11, 8:32 a.m.",
          "commitNameOld": "554912b8f895d7ede966afa64fecd6b392eb3072",
          "commitAuthorOld": "Sam Brannen",
          "daysBetweenCommits": 0.23,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n\t\tif (testDescriptor.isTest()) {\n\t\t\tlistener.testStarted(testDescriptor);\n\t\t}\n\t\ttry {\n\t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n\t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, listener, context);\n\t\t\t}\n\t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n\t\t\tif (testDescriptor.isTest()) {\n\t\t\t\tlistener.testSucceeded(testDescriptor);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tif (testDescriptor.isTest()) {\n\t\t\t\tlistener.testFailed(testDescriptor, t);\n\t\t\t}\n\t\t}\n\t}",
          "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestEngine.java",
          "functionStartLine": 27,
          "functionName": "executeAll",
          "diff": "@@ -1,24 +1,21 @@\n-\tprivate void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n-\t\t\tthrows Exception {\n-\t\tC context \u003d parentContext;\n-\t\tif (parentDescriptor instanceof Container) {\n-\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).beforeAll(context);\n+\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n+\t\tif (testDescriptor.isTest()) {\n+\t\t\tlistener.testStarted(testDescriptor);\n \t\t}\n-\t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n-\t\t\tif (childDescriptor instanceof Leaf) {\n-\t\t\t\tLeaf\u003cC\u003e child \u003d (Leaf\u003cC\u003e) childDescriptor;\n-\t\t\t\ttry {\n-\t\t\t\t\tlistener.testStarted(childDescriptor);\n-\t\t\t\t\tC childContext \u003d child.execute(context);\n-\t\t\t\t\tlistener.testSucceeded(childDescriptor);\n-\t\t\t\t}\n-\t\t\t\tcatch (Throwable t) {\n-\t\t\t\t\tlistener.testFailed(childDescriptor, t);\n-\t\t\t\t}\n+\t\ttry {\n+\t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n+\t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n+\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n+\t\t\t\texecuteAll(child, listener, context);\n \t\t\t}\n-\t\t\texecuteAll(childDescriptor, listener, context);\n+\t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n+\t\t\tif (testDescriptor.isTest()) {\n+\t\t\t\tlistener.testSucceeded(testDescriptor);\n+\t\t\t}\n \t\t}\n-\t\tif (parentDescriptor instanceof Container) {\n-\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).afterAll(context);\n+\t\tcatch (Throwable t) {\n+\t\t\tif (testDescriptor.isTest()) {\n+\t\t\t\tlistener.testFailed(testDescriptor, t);\n+\t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[parentDescriptor-TestDescriptor, listener-EngineExecutionListener, parentContext-C]",
            "newValue": "[testDescriptor-TestDescriptor, listener-EngineExecutionListener, parentContext-C]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "Cleanup HierarchicalTestEngine\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nNetcetera AG (http://netcetera.com) for supporting the JUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
          "commitDate": "2015-12-11, 2:07 p.m.",
          "commitName": "417fd0e92571ec0cc01987c03f3ff112e4d867fc",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2015-12-11, 8:32 a.m.",
          "commitNameOld": "554912b8f895d7ede966afa64fecd6b392eb3072",
          "commitAuthorOld": "Sam Brannen",
          "daysBetweenCommits": 0.23,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n\t\tif (testDescriptor.isTest()) {\n\t\t\tlistener.testStarted(testDescriptor);\n\t\t}\n\t\ttry {\n\t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n\t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, listener, context);\n\t\t\t}\n\t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n\t\t\tif (testDescriptor.isTest()) {\n\t\t\t\tlistener.testSucceeded(testDescriptor);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tif (testDescriptor.isTest()) {\n\t\t\t\tlistener.testFailed(testDescriptor, t);\n\t\t\t}\n\t\t}\n\t}",
          "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestEngine.java",
          "functionStartLine": 27,
          "functionName": "executeAll",
          "diff": "@@ -1,24 +1,21 @@\n-\tprivate void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n-\t\t\tthrows Exception {\n-\t\tC context \u003d parentContext;\n-\t\tif (parentDescriptor instanceof Container) {\n-\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).beforeAll(context);\n+\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n+\t\tif (testDescriptor.isTest()) {\n+\t\t\tlistener.testStarted(testDescriptor);\n \t\t}\n-\t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n-\t\t\tif (childDescriptor instanceof Leaf) {\n-\t\t\t\tLeaf\u003cC\u003e child \u003d (Leaf\u003cC\u003e) childDescriptor;\n-\t\t\t\ttry {\n-\t\t\t\t\tlistener.testStarted(childDescriptor);\n-\t\t\t\t\tC childContext \u003d child.execute(context);\n-\t\t\t\t\tlistener.testSucceeded(childDescriptor);\n-\t\t\t\t}\n-\t\t\t\tcatch (Throwable t) {\n-\t\t\t\t\tlistener.testFailed(childDescriptor, t);\n-\t\t\t\t}\n+\t\ttry {\n+\t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n+\t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n+\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n+\t\t\t\texecuteAll(child, listener, context);\n \t\t\t}\n-\t\t\texecuteAll(childDescriptor, listener, context);\n+\t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n+\t\t\tif (testDescriptor.isTest()) {\n+\t\t\t\tlistener.testSucceeded(testDescriptor);\n+\t\t\t}\n \t\t}\n-\t\tif (parentDescriptor instanceof Container) {\n-\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).afterAll(context);\n+\t\tcatch (Throwable t) {\n+\t\t\tif (testDescriptor.isTest()) {\n+\t\t\t\tlistener.testFailed(testDescriptor, t);\n+\t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[Exception]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Cleanup HierarchicalTestEngine\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nNetcetera AG (http://netcetera.com) for supporting the JUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
          "commitDate": "2015-12-11, 2:07 p.m.",
          "commitName": "417fd0e92571ec0cc01987c03f3ff112e4d867fc",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2015-12-11, 8:32 a.m.",
          "commitNameOld": "554912b8f895d7ede966afa64fecd6b392eb3072",
          "commitAuthorOld": "Sam Brannen",
          "daysBetweenCommits": 0.23,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n\t\tif (testDescriptor.isTest()) {\n\t\t\tlistener.testStarted(testDescriptor);\n\t\t}\n\t\ttry {\n\t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n\t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n\t\t\t\texecuteAll(child, listener, context);\n\t\t\t}\n\t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n\t\t\tif (testDescriptor.isTest()) {\n\t\t\t\tlistener.testSucceeded(testDescriptor);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tif (testDescriptor.isTest()) {\n\t\t\t\tlistener.testFailed(testDescriptor, t);\n\t\t\t}\n\t\t}\n\t}",
          "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestEngine.java",
          "functionStartLine": 27,
          "functionName": "executeAll",
          "diff": "@@ -1,24 +1,21 @@\n-\tprivate void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n-\t\t\tthrows Exception {\n-\t\tC context \u003d parentContext;\n-\t\tif (parentDescriptor instanceof Container) {\n-\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).beforeAll(context);\n+\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n+\t\tif (testDescriptor.isTest()) {\n+\t\t\tlistener.testStarted(testDescriptor);\n \t\t}\n-\t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n-\t\t\tif (childDescriptor instanceof Leaf) {\n-\t\t\t\tLeaf\u003cC\u003e child \u003d (Leaf\u003cC\u003e) childDescriptor;\n-\t\t\t\ttry {\n-\t\t\t\t\tlistener.testStarted(childDescriptor);\n-\t\t\t\t\tC childContext \u003d child.execute(context);\n-\t\t\t\t\tlistener.testSucceeded(childDescriptor);\n-\t\t\t\t}\n-\t\t\t\tcatch (Throwable t) {\n-\t\t\t\t\tlistener.testFailed(childDescriptor, t);\n-\t\t\t\t}\n+\t\ttry {\n+\t\t\tC context \u003d executeBeforeAll(testDescriptor, parentContext);\n+\t\t\tcontext \u003d executeLeaf(testDescriptor, context);\n+\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n+\t\t\t\texecuteAll(child, listener, context);\n \t\t\t}\n-\t\t\texecuteAll(childDescriptor, listener, context);\n+\t\t\tcontext \u003d executeAfterAll(testDescriptor, context);\n+\t\t\tif (testDescriptor.isTest()) {\n+\t\t\t\tlistener.testSucceeded(testDescriptor);\n+\t\t\t}\n \t\t}\n-\t\tif (parentDescriptor instanceof Container) {\n-\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).afterAll(context);\n+\t\tcatch (Throwable t) {\n+\t\t\tif (testDescriptor.isTest()) {\n+\t\t\t\tlistener.testFailed(testDescriptor, t);\n+\t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "3f9c11b9326b7d3051cb2a50568cd91113a0c0da": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "Group discussion renaming results\n",
      "commitDate": "2015-12-10, 8:39 a.m.",
      "commitName": "3f9c11b9326b7d3051cb2a50568cd91113a0c0da",
      "commitAuthor": "Marc Philipp",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "Group discussion renaming results\n",
          "commitDate": "2015-12-10, 8:39 a.m.",
          "commitName": "3f9c11b9326b7d3051cb2a50568cd91113a0c0da",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2015-12-09, 5:17 p.m.",
          "commitNameOld": "0e14ad4525a5ade99dacdd76d0ab27223f57ebd4",
          "commitAuthorOld": "Marc Philipp",
          "daysBetweenCommits": 0.64,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate \u003cT\u003e void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n\t\t\tthrows Exception {\n\t\tC context \u003d parentContext;\n\t\tif (parentDescriptor instanceof Container) {\n\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).beforeAll(context);\n\t\t}\n\t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n\t\t\tif (childDescriptor instanceof Leaf) {\n\t\t\t\tLeaf\u003cC\u003e child \u003d (Leaf\u003cC\u003e) childDescriptor;\n\t\t\t\ttry {\n\t\t\t\t\tlistener.testStarted(childDescriptor);\n\t\t\t\t\tC childContext \u003d child.execute(context);\n\t\t\t\t\tlistener.testSucceeded(childDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\tlistener.testFailed(childDescriptor, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\texecuteAll(childDescriptor, listener, context);\n\t\t}\n\t\tif (parentDescriptor instanceof Container) {\n\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).afterAll(context);\n\t\t}\n\t}",
          "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestEngine.java",
          "functionStartLine": 32,
          "functionName": "executeAll",
          "diff": "@@ -1,24 +1,24 @@\n \tprivate \u003cT\u003e void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n \t\t\tthrows Exception {\n \t\tC context \u003d parentContext;\n-\t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext \u003d ((Parent\u003cC\u003e) parentDescriptor).beforeAll(context);\n+\t\tif (parentDescriptor instanceof Container) {\n+\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).beforeAll(context);\n \t\t}\n \t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n-\t\t\tif (childDescriptor instanceof Child) {\n-\t\t\t\tChild\u003cC\u003e child \u003d (Child\u003cC\u003e) childDescriptor;\n+\t\t\tif (childDescriptor instanceof Leaf) {\n+\t\t\t\tLeaf\u003cC\u003e child \u003d (Leaf\u003cC\u003e) childDescriptor;\n \t\t\t\ttry {\n \t\t\t\t\tlistener.testStarted(childDescriptor);\n \t\t\t\t\tC childContext \u003d child.execute(context);\n \t\t\t\t\tlistener.testSucceeded(childDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (Throwable t) {\n \t\t\t\t\tlistener.testFailed(childDescriptor, t);\n \t\t\t\t}\n \t\t\t}\n \t\t\texecuteAll(childDescriptor, listener, context);\n \t\t}\n-\t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext \u003d ((Parent\u003cC\u003e) parentDescriptor).afterAll(context);\n+\t\tif (parentDescriptor instanceof Container) {\n+\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).afterAll(context);\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/TreeBasedTestEngine.java",
            "newPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestEngine.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Group discussion renaming results\n",
          "commitDate": "2015-12-10, 8:39 a.m.",
          "commitName": "3f9c11b9326b7d3051cb2a50568cd91113a0c0da",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2015-12-09, 5:17 p.m.",
          "commitNameOld": "0e14ad4525a5ade99dacdd76d0ab27223f57ebd4",
          "commitAuthorOld": "Marc Philipp",
          "daysBetweenCommits": 0.64,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate \u003cT\u003e void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n\t\t\tthrows Exception {\n\t\tC context \u003d parentContext;\n\t\tif (parentDescriptor instanceof Container) {\n\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).beforeAll(context);\n\t\t}\n\t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n\t\t\tif (childDescriptor instanceof Leaf) {\n\t\t\t\tLeaf\u003cC\u003e child \u003d (Leaf\u003cC\u003e) childDescriptor;\n\t\t\t\ttry {\n\t\t\t\t\tlistener.testStarted(childDescriptor);\n\t\t\t\t\tC childContext \u003d child.execute(context);\n\t\t\t\t\tlistener.testSucceeded(childDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\tlistener.testFailed(childDescriptor, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\texecuteAll(childDescriptor, listener, context);\n\t\t}\n\t\tif (parentDescriptor instanceof Container) {\n\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).afterAll(context);\n\t\t}\n\t}",
          "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestEngine.java",
          "functionStartLine": 32,
          "functionName": "executeAll",
          "diff": "@@ -1,24 +1,24 @@\n \tprivate \u003cT\u003e void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n \t\t\tthrows Exception {\n \t\tC context \u003d parentContext;\n-\t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext \u003d ((Parent\u003cC\u003e) parentDescriptor).beforeAll(context);\n+\t\tif (parentDescriptor instanceof Container) {\n+\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).beforeAll(context);\n \t\t}\n \t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n-\t\t\tif (childDescriptor instanceof Child) {\n-\t\t\t\tChild\u003cC\u003e child \u003d (Child\u003cC\u003e) childDescriptor;\n+\t\t\tif (childDescriptor instanceof Leaf) {\n+\t\t\t\tLeaf\u003cC\u003e child \u003d (Leaf\u003cC\u003e) childDescriptor;\n \t\t\t\ttry {\n \t\t\t\t\tlistener.testStarted(childDescriptor);\n \t\t\t\t\tC childContext \u003d child.execute(context);\n \t\t\t\t\tlistener.testSucceeded(childDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (Throwable t) {\n \t\t\t\t\tlistener.testFailed(childDescriptor, t);\n \t\t\t\t}\n \t\t\t}\n \t\t\texecuteAll(childDescriptor, listener, context);\n \t\t}\n-\t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext \u003d ((Parent\u003cC\u003e) parentDescriptor).afterAll(context);\n+\t\tif (parentDescriptor instanceof Container) {\n+\t\t\tcontext \u003d ((Container\u003cC\u003e) parentDescriptor).afterAll(context);\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "57b31220d25f59bb4aa4903dfee4b8ec2be4525e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "TestEngine-specific context using type parameter\n",
      "commitDate": "2015-12-08, 8:55 a.m.",
      "commitName": "57b31220d25f59bb4aa4903dfee4b8ec2be4525e",
      "commitAuthor": "Marc Philipp",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "TestEngine-specific context using type parameter\n",
          "commitDate": "2015-12-08, 8:55 a.m.",
          "commitName": "57b31220d25f59bb4aa4903dfee4b8ec2be4525e",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2015-12-08, 8:32 a.m.",
          "commitNameOld": "28ffd5ee9d1e996133445cac2256407f28380e91",
          "commitAuthorOld": "Marc Philipp",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate \u003cT\u003e void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n\t\t\tthrows Exception {\n\t\tC context \u003d parentContext;\n\t\tif (parentDescriptor instanceof Parent) {\n\t\t\tcontext \u003d ((Parent\u003cC\u003e) parentDescriptor).beforeAll(context);\n\t\t}\n\t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n\t\t\tif (childDescriptor instanceof Child) {\n\t\t\t\tChild\u003cC\u003e child \u003d (Child\u003cC\u003e) childDescriptor;\n\t\t\t\ttry {\n\t\t\t\t\tlistener.testStarted(childDescriptor);\n\t\t\t\t\tC childContext \u003d child.execute(context);\n\t\t\t\t\tlistener.testSucceeded(childDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\tlistener.testFailed(childDescriptor, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\texecuteAll(childDescriptor, listener, context);\n\t\t}\n\t\tif (parentDescriptor instanceof Parent) {\n\t\t\tcontext \u003d ((Parent\u003cC\u003e) parentDescriptor).afterAll(context);\n\t\t}\n\t}",
          "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/TreeBasedTestEngine.java",
          "functionStartLine": 32,
          "functionName": "executeAll",
          "diff": "@@ -1,25 +1,24 @@\n-\tprivate \u003cT\u003e void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener,\n-\t\t\tContext parentContext) throws Exception {\n-\t\tContext context \u003d parentContext;\n+\tprivate \u003cT\u003e void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n+\t\t\tthrows Exception {\n+\t\tC context \u003d parentContext;\n \t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext \u003d ((Parent) parentDescriptor).beforeAll(context);\n+\t\t\tcontext \u003d ((Parent\u003cC\u003e) parentDescriptor).beforeAll(context);\n \t\t}\n \t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n \t\t\tif (childDescriptor instanceof Child) {\n-\t\t\t\tChild child \u003d (Child) childDescriptor;\n+\t\t\t\tChild\u003cC\u003e child \u003d (Child\u003cC\u003e) childDescriptor;\n \t\t\t\ttry {\n \t\t\t\t\tlistener.testStarted(childDescriptor);\n-\t\t\t\t\tcontext \u003d child.execute(context);\n+\t\t\t\t\tC childContext \u003d child.execute(context);\n \t\t\t\t\tlistener.testSucceeded(childDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (Throwable t) {\n \t\t\t\t\tlistener.testFailed(childDescriptor, t);\n-\t\t\t\t\tcontext \u003d context.with(\"Throwable\", t);\n \t\t\t\t}\n \t\t\t}\n \t\t\texecuteAll(childDescriptor, listener, context);\n \t\t}\n \t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext \u003d ((Parent) parentDescriptor).afterAll(context);\n+\t\t\tcontext \u003d ((Parent\u003cC\u003e) parentDescriptor).afterAll(context);\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[parentDescriptor-TestDescriptor, listener-EngineExecutionListener, parentContext-Context]",
            "newValue": "[parentDescriptor-TestDescriptor, listener-EngineExecutionListener, parentContext-C]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "TestEngine-specific context using type parameter\n",
          "commitDate": "2015-12-08, 8:55 a.m.",
          "commitName": "57b31220d25f59bb4aa4903dfee4b8ec2be4525e",
          "commitAuthor": "Marc Philipp",
          "commitDateOld": "2015-12-08, 8:32 a.m.",
          "commitNameOld": "28ffd5ee9d1e996133445cac2256407f28380e91",
          "commitAuthorOld": "Marc Philipp",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate \u003cT\u003e void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n\t\t\tthrows Exception {\n\t\tC context \u003d parentContext;\n\t\tif (parentDescriptor instanceof Parent) {\n\t\t\tcontext \u003d ((Parent\u003cC\u003e) parentDescriptor).beforeAll(context);\n\t\t}\n\t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n\t\t\tif (childDescriptor instanceof Child) {\n\t\t\t\tChild\u003cC\u003e child \u003d (Child\u003cC\u003e) childDescriptor;\n\t\t\t\ttry {\n\t\t\t\t\tlistener.testStarted(childDescriptor);\n\t\t\t\t\tC childContext \u003d child.execute(context);\n\t\t\t\t\tlistener.testSucceeded(childDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\tlistener.testFailed(childDescriptor, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\texecuteAll(childDescriptor, listener, context);\n\t\t}\n\t\tif (parentDescriptor instanceof Parent) {\n\t\t\tcontext \u003d ((Parent\u003cC\u003e) parentDescriptor).afterAll(context);\n\t\t}\n\t}",
          "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/TreeBasedTestEngine.java",
          "functionStartLine": 32,
          "functionName": "executeAll",
          "diff": "@@ -1,25 +1,24 @@\n-\tprivate \u003cT\u003e void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener,\n-\t\t\tContext parentContext) throws Exception {\n-\t\tContext context \u003d parentContext;\n+\tprivate \u003cT\u003e void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n+\t\t\tthrows Exception {\n+\t\tC context \u003d parentContext;\n \t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext \u003d ((Parent) parentDescriptor).beforeAll(context);\n+\t\t\tcontext \u003d ((Parent\u003cC\u003e) parentDescriptor).beforeAll(context);\n \t\t}\n \t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n \t\t\tif (childDescriptor instanceof Child) {\n-\t\t\t\tChild child \u003d (Child) childDescriptor;\n+\t\t\t\tChild\u003cC\u003e child \u003d (Child\u003cC\u003e) childDescriptor;\n \t\t\t\ttry {\n \t\t\t\t\tlistener.testStarted(childDescriptor);\n-\t\t\t\t\tcontext \u003d child.execute(context);\n+\t\t\t\t\tC childContext \u003d child.execute(context);\n \t\t\t\t\tlistener.testSucceeded(childDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (Throwable t) {\n \t\t\t\t\tlistener.testFailed(childDescriptor, t);\n-\t\t\t\t\tcontext \u003d context.with(\"Throwable\", t);\n \t\t\t\t}\n \t\t\t}\n \t\t\texecuteAll(childDescriptor, listener, context);\n \t\t}\n \t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext \u003d ((Parent) parentDescriptor).afterAll(context);\n+\t\t\tcontext \u003d ((Parent\u003cC\u003e) parentDescriptor).afterAll(context);\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "28ffd5ee9d1e996133445cac2256407f28380e91": {
      "type": "Yintroduced",
      "commitMessage": "Spike tree-based \"implementation\" of JUnit5 engine\n",
      "commitDate": "2015-12-08, 8:32 a.m.",
      "commitName": "28ffd5ee9d1e996133445cac2256407f28380e91",
      "commitAuthor": "Marc Philipp",
      "diff": "@@ -0,0 +1,25 @@\n+\tprivate \u003cT\u003e void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener,\n+\t\t\tContext parentContext) throws Exception {\n+\t\tContext context \u003d parentContext;\n+\t\tif (parentDescriptor instanceof Parent) {\n+\t\t\tcontext \u003d ((Parent) parentDescriptor).beforeAll(context);\n+\t\t}\n+\t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n+\t\t\tif (childDescriptor instanceof Child) {\n+\t\t\t\tChild child \u003d (Child) childDescriptor;\n+\t\t\t\ttry {\n+\t\t\t\t\tlistener.testStarted(childDescriptor);\n+\t\t\t\t\tcontext \u003d child.execute(context);\n+\t\t\t\t\tlistener.testSucceeded(childDescriptor);\n+\t\t\t\t}\n+\t\t\t\tcatch (Throwable t) {\n+\t\t\t\t\tlistener.testFailed(childDescriptor, t);\n+\t\t\t\t\tcontext \u003d context.with(\"Throwable\", t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\texecuteAll(childDescriptor, listener, context);\n+\t\t}\n+\t\tif (parentDescriptor instanceof Parent) {\n+\t\t\tcontext \u003d ((Parent) parentDescriptor).afterAll(context);\n+\t\t}\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tprivate \u003cT\u003e void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener,\n\t\t\tContext parentContext) throws Exception {\n\t\tContext context \u003d parentContext;\n\t\tif (parentDescriptor instanceof Parent) {\n\t\t\tcontext \u003d ((Parent) parentDescriptor).beforeAll(context);\n\t\t}\n\t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n\t\t\tif (childDescriptor instanceof Child) {\n\t\t\t\tChild child \u003d (Child) childDescriptor;\n\t\t\t\ttry {\n\t\t\t\t\tlistener.testStarted(childDescriptor);\n\t\t\t\t\tcontext \u003d child.execute(context);\n\t\t\t\t\tlistener.testSucceeded(childDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\tlistener.testFailed(childDescriptor, t);\n\t\t\t\t\tcontext \u003d context.with(\"Throwable\", t);\n\t\t\t\t}\n\t\t\t}\n\t\t\texecuteAll(childDescriptor, listener, context);\n\t\t}\n\t\tif (parentDescriptor instanceof Parent) {\n\t\t\tcontext \u003d ((Parent) parentDescriptor).afterAll(context);\n\t\t}\n\t}",
      "path": "junit-engine-api/src/main/java/org/junit/gen5/engine/TreeBasedTestEngine.java",
      "functionStartLine": 21,
      "functionName": "executeAll"
    }
  }
}