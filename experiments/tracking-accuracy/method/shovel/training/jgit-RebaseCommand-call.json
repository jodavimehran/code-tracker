{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "H:\\Projects\\eclipse\\jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "RebaseCommand.java",
  "functionName": "call",
  "functionId": "call",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
  "functionStartLine": 263,
  "functionEndLine": 379,
  "numCommitsSeen": 85,
  "timeTaken": 4389,
  "changeHistory": [
    "26c5d0e56a8c5adb2c93cda45e25175363798516",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
    "6f0b92ff22ff58a4c8eb9de8d9b3281d77852070",
    "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
    "3db6e05e52b24e16fbe93376d3fd8935e5f4fc9b",
    "f86a488e32906593903acb31a93a82bed8d87915",
    "591998c2d628ec4f6309caea826fab16a6de2adc",
    "ec0d78d0939ee8ce30bd349bd885186c13d3b645",
    "979e3467112618cc787e161097986212eaaa4533",
    "18069ffe8cbede40cf2524922c262b67656e7021",
    "cce2561e9fe2ce1cf60182f9d95c8537ce13de92",
    "765896febb4b63cfe2c37dc0a73c90c79dd1591b",
    "da9db6b20c6203dae3f828adbd14218ea063ad91",
    "c3873b584f81bc5be3fdea53e9e0e76271a9a854",
    "60e01cff2f763a85ed24a706d26eb9f159ffa832",
    "0e9f1cf57dac274f92a6db38197e14b55b3277af",
    "baf7ca9cc0d2bdf237a9bb19486d6fde5250a7f5",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
    "257f3fe4a1b9e450b2f665b5f0ed09a3ab3839b9",
    "8eb4d926371edea2d58dc598e3ebcddacbdc326e",
    "84fb2b59d11418d2fa753d27de11775ddc18adde",
    "5854ca091a22346e1c710ca9f875165afb3f2cc8",
    "b61d35e848e637ef85fde4ebe95d60ced171e963",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
    "edc1fee033a23189742cea1807d8029d1b77da00",
    "557ea857e3b5229379476f1ee4160fcf5b695bbd",
    "0b5ad24915824a8c999bb6951b131a958e418306",
    "a21e508a318664dac23701ca29d5f0b64d36a76a",
    "e8a1328d05aa55b7ace0d101e34b87422219c959",
    "9b039b42e0ecf69640c5f1a34ee72a86dba3f1c2",
    "2a7cd0086bf1bd614478c5722eac5142326e6f2b",
    "6bca46e1683a07f18f00f6ad552eab79ab50bb88",
    "45731756a56361a51e839e26d3b0bed1c06ee37a",
    "ad96546ca023c260ed7250c447f4c8abe168afd3",
    "59e62ba7e10188c6170bd97ffbd9c8768d9745ea",
    "e5b96a7848d680cf50123a44cbc147db91d798d3"
  ],
  "changeHistoryShort": {
    "26c5d0e56a8c5adb2c93cda45e25175363798516": "Ybodychange",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": "Ybodychange",
    "6f0b92ff22ff58a4c8eb9de8d9b3281d77852070": "Ybodychange",
    "e0fbae5dc3fc2345383ec373b384fcca10e64f24": "Ybodychange",
    "3db6e05e52b24e16fbe93376d3fd8935e5f4fc9b": "Ybodychange",
    "f86a488e32906593903acb31a93a82bed8d87915": "Ybodychange",
    "591998c2d628ec4f6309caea826fab16a6de2adc": "Ybodychange",
    "ec0d78d0939ee8ce30bd349bd885186c13d3b645": "Ybodychange",
    "979e3467112618cc787e161097986212eaaa4533": "Ybodychange",
    "18069ffe8cbede40cf2524922c262b67656e7021": "Ybodychange",
    "cce2561e9fe2ce1cf60182f9d95c8537ce13de92": "Ybodychange",
    "765896febb4b63cfe2c37dc0a73c90c79dd1591b": "Ybodychange",
    "da9db6b20c6203dae3f828adbd14218ea063ad91": "Ybodychange",
    "c3873b584f81bc5be3fdea53e9e0e76271a9a854": "Ybodychange",
    "60e01cff2f763a85ed24a706d26eb9f159ffa832": "Ybodychange",
    "0e9f1cf57dac274f92a6db38197e14b55b3277af": "Ybodychange",
    "baf7ca9cc0d2bdf237a9bb19486d6fde5250a7f5": "Ybodychange",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": "Ybodychange",
    "257f3fe4a1b9e450b2f665b5f0ed09a3ab3839b9": "Ybodychange",
    "8eb4d926371edea2d58dc598e3ebcddacbdc326e": "Ybodychange",
    "84fb2b59d11418d2fa753d27de11775ddc18adde": "Ybodychange",
    "5854ca091a22346e1c710ca9f875165afb3f2cc8": "Ybodychange",
    "b61d35e848e637ef85fde4ebe95d60ced171e963": "Yexceptionschange",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": "Yexceptionschange",
    "edc1fee033a23189742cea1807d8029d1b77da00": "Ybodychange",
    "557ea857e3b5229379476f1ee4160fcf5b695bbd": "Ybodychange",
    "0b5ad24915824a8c999bb6951b131a958e418306": "Ybodychange",
    "a21e508a318664dac23701ca29d5f0b64d36a76a": "Ybodychange",
    "e8a1328d05aa55b7ace0d101e34b87422219c959": "Ybodychange",
    "9b039b42e0ecf69640c5f1a34ee72a86dba3f1c2": "Ybodychange",
    "2a7cd0086bf1bd614478c5722eac5142326e6f2b": "Ybodychange",
    "6bca46e1683a07f18f00f6ad552eab79ab50bb88": "Ybodychange",
    "45731756a56361a51e839e26d3b0bed1c06ee37a": "Ybodychange",
    "ad96546ca023c260ed7250c447f4c8abe168afd3": "Ybodychange",
    "59e62ba7e10188c6170bd97ffbd9c8768d9745ea": "Ybodychange",
    "e5b96a7848d680cf50123a44cbc147db91d798d3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "26c5d0e56a8c5adb2c93cda45e25175363798516": {
      "type": "Ybodychange",
      "commitMessage": "RebaseCommand: Remove unnecessary fall through comments\n\nIt\u0027s easier to read a list of cases\n\n\tcase A:\n\tcase B:\n\tcase C:\n\t\t... do something ...;\n\t\tbreak;\n\nwithout intervening \"// fall through\" lines separating the cases.\n\nThis also makes it clearer that JGit uses \"$FALL-THROUGH$\", not \"fall\nthrough\", to suppress fallthrough warnings in switch statements.\nEclipse does not pay attention to the second comment style.\n\nChange-Id: I5279a727aee2868854d06bfcaac8cb8186b4299e\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
      "commitDate": "2018-08-04, 5:04 p.m.",
      "commitName": "26c5d0e56a8c5adb2c93cda45e25175363798516",
      "commitAuthor": "Jonathan Nieder",
      "commitDateOld": "2018-03-13, 5:16 p.m.",
      "commitNameOld": "5c70be00856d5375485e6f062b6e1e09a606601f",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 143.99,
      "commitsBetweenForRepo": 211,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tnewHead \u003d null;\n\t\tlastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase PROCESS_STEPS:\n\t\t\tcase SKIP:\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tpreserveMerges \u003d rebaseState.getRewrittenDir().exists();\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tautoStash();\n\t\t\t\tif (stopAfterInitialization\n\t\t\t\t\t\t|| !walk.isMergedInto(\n\t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n\t\t\t\t\t\t\t\tupstreamCommit)) {\n\t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n\t\t\t\t\t\t\t.status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n\t\t\t\t\tif (status.hasUncommittedChanges()) {\n\t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n\t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n\t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (stopAfterInitialization)\n\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n\t\t\t\tif (res !\u003d null) {\n\t\t\t\t\tautoStashApply();\n\t\t\t\t\tif (rebaseState.getDir().exists())\n\t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n\t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n\t\t\t\t\t\trebaseState.getPath(DONE), true);\n\t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n\t\t\t\tif (newHead !\u003d null\n\t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n\t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n\t\t\t\t\t\t\tstep.getAction(),\n\t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n\t\t\t\t\t\t\tstep.getShortMessage());\n\t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n\t\t\t\t\tif (result !\u003d null)\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (steps.size() \u003d\u003d 0) {\n\t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n\t\t\t}\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tcheckSteps(steps);\n\t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n\t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n\t\t\t\tpopSteps(1);\n\t\t\t\tRebaseResult result \u003d processStep(step, true);\n\t\t\t\tif (result !\u003d null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn finishRebase(newHead, lastStepWasForward);\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 263,
      "functionName": "call",
      "diff": "@@ -1,119 +1,117 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead \u003d null;\n \t\tlastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n-\t\t\t\t// fall through\n \t\t\tcase SKIP:\n-\t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tpreserveMerges \u003d rebaseState.getRewrittenDir().exists();\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tautoStash();\n \t\t\t\tif (stopAfterInitialization\n \t\t\t\t\t\t|| !walk.isMergedInto(\n \t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n \t\t\t\t\t\t\t\tupstreamCommit)) {\n \t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n \t\t\t\t\t\t\t.status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n \t\t\t\t\tif (status.hasUncommittedChanges()) {\n \t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n \t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n \t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res !\u003d null) {\n \t\t\t\t\tautoStashApply();\n \t\t\t\t\tif (rebaseState.getDir().exists())\n \t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n \t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n \t\t\t\t\treturn res;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead !\u003d null\n \t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n \t\t\t\t\tif (result !\u003d null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() \u003d\u003d 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result \u003d processStep(step, true);\n \t\t\t\tif (result !\u003d null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
      "type": "Ybodychange",
      "commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit\u0027s not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017-02-20, 4:47 p.m.",
      "commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017-02-19, 7:05 p.m.",
      "commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tnewHead \u003d null;\n\t\tlastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase PROCESS_STEPS:\n\t\t\t\t// fall through\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tpreserveMerges \u003d rebaseState.getRewrittenDir().exists();\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tautoStash();\n\t\t\t\tif (stopAfterInitialization\n\t\t\t\t\t\t|| !walk.isMergedInto(\n\t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n\t\t\t\t\t\t\t\tupstreamCommit)) {\n\t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n\t\t\t\t\t\t\t.status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n\t\t\t\t\tif (status.hasUncommittedChanges()) {\n\t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n\t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n\t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (stopAfterInitialization)\n\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n\t\t\t\tif (res !\u003d null) {\n\t\t\t\t\tautoStashApply();\n\t\t\t\t\tif (rebaseState.getDir().exists())\n\t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n\t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n\t\t\t\t\t\trebaseState.getPath(DONE), true);\n\t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n\t\t\t\tif (newHead !\u003d null\n\t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n\t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n\t\t\t\t\t\t\tstep.getAction(),\n\t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n\t\t\t\t\t\t\tstep.getShortMessage());\n\t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n\t\t\t\t\tif (result !\u003d null)\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (steps.size() \u003d\u003d 0) {\n\t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n\t\t\t}\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tcheckSteps(steps);\n\t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n\t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n\t\t\t\tpopSteps(1);\n\t\t\t\tRebaseResult result \u003d processStep(step, true);\n\t\t\t\tif (result !\u003d null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn finishRebase(newHead, lastStepWasForward);\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 262,
      "functionName": "call",
      "diff": "@@ -1,119 +1,119 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead \u003d null;\n \t\tlastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tpreserveMerges \u003d rebaseState.getRewrittenDir().exists();\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tautoStash();\n \t\t\t\tif (stopAfterInitialization\n \t\t\t\t\t\t|| !walk.isMergedInto(\n \t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n \t\t\t\t\t\t\t\tupstreamCommit)) {\n \t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n \t\t\t\t\t\t\t.status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n \t\t\t\t\tif (status.hasUncommittedChanges()) {\n-\t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n+\t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n \t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n \t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res !\u003d null) {\n \t\t\t\t\tautoStashApply();\n \t\t\t\t\tif (rebaseState.getDir().exists())\n \t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n \t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n \t\t\t\t\treturn res;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead !\u003d null\n \t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n \t\t\t\t\tif (result !\u003d null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() \u003d\u003d 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result \u003d processStep(step, true);\n \t\t\t\tif (result !\u003d null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f0b92ff22ff58a4c8eb9de8d9b3281d77852070": {
      "type": "Ybodychange",
      "commitMessage": "RebaseCommand should ignore submodule modifications\n\nBefore a rebase happens the RebaseCommand checks that the working tree\nis clean. We don\u0027t want to start a rebase on a dirty working tree. If\nthe working tree is dirty a rebase should not be allowed. But\nRebaseCommand should ignore modifications done to submodules. E.g. if a\nsubmodules HEAD points to \u003cx\u003e but the root repository has in index that\nthe submodule should point to \u003cy\u003e then this should not prohibit a\nrebase. Also native git allows a rebase in this case. Since jgit\u0027s\nStatusCommand has learned to ignore submodule changes this is now used\nby the RebaseCommand to determine the repository state correctly.\n\nBug: 446922\nChange-Id: I487bf7484dca3f5501e6e514584e2871524eea19\n",
      "commitDate": "2014-11-03, 4:32 a.m.",
      "commitName": "6f0b92ff22ff58a4c8eb9de8d9b3281d77852070",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2014-09-04, 5:35 a.m.",
      "commitNameOld": "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 60.0,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tnewHead \u003d null;\n\t\tlastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase PROCESS_STEPS:\n\t\t\t\t// fall through\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tpreserveMerges \u003d rebaseState.getRewrittenDir().exists();\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tautoStash();\n\t\t\t\tif (stopAfterInitialization\n\t\t\t\t\t\t|| !walk.isMergedInto(\n\t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n\t\t\t\t\t\t\t\tupstreamCommit)) {\n\t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n\t\t\t\t\t\t\t.status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n\t\t\t\t\tif (status.hasUncommittedChanges()) {\n\t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n\t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (stopAfterInitialization)\n\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n\t\t\t\tif (res !\u003d null) {\n\t\t\t\t\tautoStashApply();\n\t\t\t\t\tif (rebaseState.getDir().exists())\n\t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n\t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n\t\t\t\t\t\trebaseState.getPath(DONE), true);\n\t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n\t\t\t\tif (newHead !\u003d null\n\t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n\t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n\t\t\t\t\t\t\tstep.getAction(),\n\t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n\t\t\t\t\t\t\tstep.getShortMessage());\n\t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n\t\t\t\t\tif (result !\u003d null)\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (steps.size() \u003d\u003d 0) {\n\t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n\t\t\t}\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tcheckSteps(steps);\n\t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n\t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n\t\t\t\tpopSteps(1);\n\t\t\t\tRebaseResult result \u003d processStep(step, true);\n\t\t\t\tif (result !\u003d null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn finishRebase(newHead, lastStepWasForward);\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 260,
      "functionName": "call",
      "diff": "@@ -1,119 +1,119 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead \u003d null;\n \t\tlastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tpreserveMerges \u003d rebaseState.getRewrittenDir().exists();\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tautoStash();\n \t\t\t\tif (stopAfterInitialization\n \t\t\t\t\t\t|| !walk.isMergedInto(\n \t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n \t\t\t\t\t\t\t\tupstreamCommit)) {\n \t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n-\t\t\t\t\t\t\t.status().call();\n+\t\t\t\t\t\t\t.status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n \t\t\t\t\tif (status.hasUncommittedChanges()) {\n \t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n \t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n \t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res !\u003d null) {\n \t\t\t\t\tautoStashApply();\n \t\t\t\t\tif (rebaseState.getDir().exists())\n \t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n \t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n \t\t\t\t\treturn res;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead !\u003d null\n \t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n \t\t\t\t\tif (result !\u003d null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() \u003d\u003d 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result \u003d processStep(step, true);\n \t\t\t\tif (result !\u003d null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e0fbae5dc3fc2345383ec373b384fcca10e64f24": {
      "type": "Ybodychange",
      "commitMessage": "Rebase: Add --preserve-merges support\n\nWith --preserve-merges C Git re-does merges using the rewritten merge\nparents, discarding the old merge commit. For the common use-case of\npull with rebase this is unfortunate, as it loses the merge conflict\nresolution (and other fixes in the merge), which may have taken quite\nsome time to get right in the first place.\n\nTo overcome this we use a two-fold approach:\nIf any of the (non-first) merge parents of a merge were rewritten, we\nalso redo the merge, to include the (potential) new changes in those\ncommits.\nIf only the first parent was rewritten, i.e. we are merging a branch\nthat is otherwise unaffected by the rebase, we instead cherry-pick the\nmerge commit at hand. This is done with the --mainline 1 and --no-commit\noptions to apply the changes introduced by the merge. Then we set up an\nappropriate MERGE_HEAD and commit the result, thus effectively forging a\nmerge.\n\nApart from the approach taken to rebase merge commits, this\nimplementation closely follows C Git. As a result, both Git\nimplementations can continue rebases of each other.\n\nPreserving merges works for both interactive and non-interactive rebase,\nbut as in C Git it is easy do get undesired outcomes with interactive\nrebase.\n\nCommitCommand supports committing merges during rebase now.\n\nBug: 439421\nChange-Id: I4cf69b9d4ec6109d130ab8e3f42fcbdac25a13b2\nSigned-off-by: Konrad Kügler \u003cswamblumat-eclipsebugs@yahoo.de\u003e\n",
      "commitDate": "2014-07-15, 7:00 p.m.",
      "commitName": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
      "commitAuthor": "Konrad Kügler",
      "commitDateOld": "2014-05-16, 3:01 a.m.",
      "commitNameOld": "1350d27e904f7e016dd33cff01686e527b0d26ad",
      "commitAuthorOld": "Konrad Kügler",
      "daysBetweenCommits": 60.67,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tnewHead \u003d null;\n\t\tlastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase PROCESS_STEPS:\n\t\t\t\t// fall through\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tpreserveMerges \u003d rebaseState.getRewrittenDir().exists();\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tautoStash();\n\t\t\t\tif (stopAfterInitialization\n\t\t\t\t\t\t|| !walk.isMergedInto(\n\t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n\t\t\t\t\t\t\t\tupstreamCommit)) {\n\t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n\t\t\t\t\t\t\t.status().call();\n\t\t\t\t\tif (status.hasUncommittedChanges()) {\n\t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n\t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (stopAfterInitialization)\n\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n\t\t\t\tif (res !\u003d null) {\n\t\t\t\t\tautoStashApply();\n\t\t\t\t\tif (rebaseState.getDir().exists())\n\t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n\t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n\t\t\t\t\t\trebaseState.getPath(DONE), true);\n\t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n\t\t\t\tif (newHead !\u003d null\n\t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n\t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n\t\t\t\t\t\t\tstep.getAction(),\n\t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n\t\t\t\t\t\t\tstep.getShortMessage());\n\t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n\t\t\t\t\tif (result !\u003d null)\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (steps.size() \u003d\u003d 0) {\n\t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n\t\t\t}\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tcheckSteps(steps);\n\t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n\t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n\t\t\t\tpopSteps(1);\n\t\t\t\tRebaseResult result \u003d processStep(step, true);\n\t\t\t\tif (result !\u003d null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn finishRebase(newHead, lastStepWasForward);\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 259,
      "functionName": "call",
      "diff": "@@ -1,118 +1,119 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead \u003d null;\n \t\tlastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n+\t\t\t\tpreserveMerges \u003d rebaseState.getRewrittenDir().exists();\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tautoStash();\n \t\t\t\tif (stopAfterInitialization\n \t\t\t\t\t\t|| !walk.isMergedInto(\n \t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n \t\t\t\t\t\t\t\tupstreamCommit)) {\n \t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n \t\t\t\t\t\t\t.status().call();\n \t\t\t\t\tif (status.hasUncommittedChanges()) {\n \t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n \t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n \t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res !\u003d null) {\n \t\t\t\t\tautoStashApply();\n \t\t\t\t\tif (rebaseState.getDir().exists())\n \t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n \t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n \t\t\t\t\treturn res;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead !\u003d null\n \t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n \t\t\t\t\tif (result !\u003d null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() \u003d\u003d 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result \u003d processStep(step, true);\n \t\t\t\tif (result !\u003d null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3db6e05e52b24e16fbe93376d3fd8935e5f4fc9b": {
      "type": "Ybodychange",
      "commitMessage": "Fix fast forward rebase with rebase.autostash\u003dtrue\n\nThe folder .git/rebase-merge was not removed in this case. The\nrepository was then still in rebase state, but neither abort nor\ncontinue worked.\n\nBug: 425742\nChange-Id: I43cea6c9e5f3cef9d6b15643722fddecb40632d9\n",
      "commitDate": "2014-01-15, 7:23 a.m.",
      "commitName": "3db6e05e52b24e16fbe93376d3fd8935e5f4fc9b",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013-12-10, 9:54 a.m.",
      "commitNameOld": "e90438c0e867bd105334b75df3a6d640ef8dab01",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 35.9,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tnewHead \u003d null;\n\t\tlastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase PROCESS_STEPS:\n\t\t\t\t// fall through\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tautoStash();\n\t\t\t\tif (stopAfterInitialization\n\t\t\t\t\t\t|| !walk.isMergedInto(\n\t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n\t\t\t\t\t\t\t\tupstreamCommit)) {\n\t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n\t\t\t\t\t\t\t.status().call();\n\t\t\t\t\tif (status.hasUncommittedChanges()) {\n\t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n\t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (stopAfterInitialization)\n\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n\t\t\t\tif (res !\u003d null) {\n\t\t\t\t\tautoStashApply();\n\t\t\t\t\tif (rebaseState.getDir().exists())\n\t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n\t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n\t\t\t\t\t\trebaseState.getPath(DONE), true);\n\t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n\t\t\t\tif (newHead !\u003d null\n\t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n\t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n\t\t\t\t\t\t\tstep.getAction(),\n\t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n\t\t\t\t\t\t\tstep.getShortMessage());\n\t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n\t\t\t\t\tif (result !\u003d null)\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (steps.size() \u003d\u003d 0) {\n\t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n\t\t\t}\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tcheckSteps(steps);\n\t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n\t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n\t\t\t\tpopSteps(1);\n\t\t\t\tRebaseResult result \u003d processStep(step, true);\n\t\t\t\tif (result !\u003d null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn finishRebase(newHead, lastStepWasForward);\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 235,
      "functionName": "call",
      "diff": "@@ -1,115 +1,118 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead \u003d null;\n \t\tlastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tautoStash();\n \t\t\t\tif (stopAfterInitialization\n \t\t\t\t\t\t|| !walk.isMergedInto(\n \t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n \t\t\t\t\t\t\t\tupstreamCommit)) {\n \t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n \t\t\t\t\t\t\t.status().call();\n \t\t\t\t\tif (status.hasUncommittedChanges()) {\n \t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n \t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n \t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res !\u003d null) {\n \t\t\t\t\tautoStashApply();\n+\t\t\t\t\tif (rebaseState.getDir().exists())\n+\t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n+\t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n \t\t\t\t\treturn res;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead !\u003d null\n \t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n \t\t\t\t\tif (result !\u003d null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() \u003d\u003d 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result \u003d processStep(step, true);\n \t\t\t\tif (result !\u003d null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f86a488e32906593903acb31a93a82bed8d87915": {
      "type": "Ybodychange",
      "commitMessage": "Implement rebase.autostash\n\nThis feature was introduced in native git with version 1.8.4.\n\nBug: 422951\nChange-Id: I42f194174d64d7ada6631e2156c2a7bf93b5e91c\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2013-12-04, 4:02 p.m.",
      "commitName": "f86a488e32906593903acb31a93a82bed8d87915",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013-12-02, 3:45 a.m.",
      "commitNameOld": "591998c2d628ec4f6309caea826fab16a6de2adc",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 2.51,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tnewHead \u003d null;\n\t\tlastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase PROCESS_STEPS:\n\t\t\t\t// fall through\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tautoStash();\n\t\t\t\tif (stopAfterInitialization\n\t\t\t\t\t\t|| !walk.isMergedInto(\n\t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n\t\t\t\t\t\t\t\tupstreamCommit)) {\n\t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n\t\t\t\t\t\t\t.status().call();\n\t\t\t\t\tif (status.hasUncommittedChanges()) {\n\t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n\t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (stopAfterInitialization)\n\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n\t\t\t\tif (res !\u003d null) {\n\t\t\t\t\tautoStashApply();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n\t\t\t\t\t\trebaseState.getPath(DONE), true);\n\t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n\t\t\t\tif (newHead !\u003d null\n\t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n\t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n\t\t\t\t\t\t\tstep.getAction(),\n\t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n\t\t\t\t\t\t\tstep.getShortMessage());\n\t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n\t\t\t\t\tif (result !\u003d null)\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (steps.size() \u003d\u003d 0) {\n\t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n\t\t\t}\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tcheckSteps(steps);\n\t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n\t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n\t\t\t\tpopSteps(1);\n\t\t\t\tRebaseResult result \u003d processStep(step, true);\n\t\t\t\tif (result !\u003d null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn finishRebase(newHead, lastStepWasForward);\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 235,
      "functionName": "call",
      "diff": "@@ -1,112 +1,115 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead \u003d null;\n \t\tlastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n+\t\t\t\tautoStash();\n \t\t\t\tif (stopAfterInitialization\n \t\t\t\t\t\t|| !walk.isMergedInto(\n \t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n \t\t\t\t\t\t\t\tupstreamCommit)) {\n \t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n \t\t\t\t\t\t\t.status().call();\n \t\t\t\t\tif (status.hasUncommittedChanges()) {\n \t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n \t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n \t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n-\t\t\t\tif (res !\u003d null)\n+\t\t\t\tif (res !\u003d null) {\n+\t\t\t\t\tautoStashApply();\n \t\t\t\t\treturn res;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead !\u003d null\n \t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n \t\t\t\t\tif (result !\u003d null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() \u003d\u003d 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result \u003d processStep(step, true);\n \t\t\t\tif (result !\u003d null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "591998c2d628ec4f6309caea826fab16a6de2adc": {
      "type": "Ybodychange",
      "commitMessage": "Do not allow non-ff-rebase if there are uncommitted changes\n\nWith this change jgit checks for uncommitted changes before a rebase is\nstarted. This is also done by native git. One reason is that an abort\nwould override such changes. The check is skipped for a non-interactive\nrebase when it will result in a fast-forward. In this case there can be\nonly checkout conflicts but no merge conflicts, so there cannot be an\nabort which overrides uncommitted changes.\n\nBug: 422352\nChange-Id: I1e0b59b2a4d80a686b67a6729e441924362b1236\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2013-12-02, 3:45 a.m.",
      "commitName": "591998c2d628ec4f6309caea826fab16a6de2adc",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013-11-29, 3:34 a.m.",
      "commitNameOld": "ec0d78d0939ee8ce30bd349bd885186c13d3b645",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 3.01,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tnewHead \u003d null;\n\t\tlastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase PROCESS_STEPS:\n\t\t\t\t// fall through\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tif (stopAfterInitialization\n\t\t\t\t\t\t|| !walk.isMergedInto(\n\t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n\t\t\t\t\t\t\t\tupstreamCommit)) {\n\t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n\t\t\t\t\t\t\t.status().call();\n\t\t\t\t\tif (status.hasUncommittedChanges()) {\n\t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n\t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (stopAfterInitialization)\n\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n\t\t\t\t\t\trebaseState.getPath(DONE), true);\n\t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n\t\t\t\tif (newHead !\u003d null\n\t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n\t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n\t\t\t\t\t\t\tstep.getAction(),\n\t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n\t\t\t\t\t\t\tstep.getShortMessage());\n\t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n\t\t\t\t\tif (result !\u003d null)\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (steps.size() \u003d\u003d 0) {\n\t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n\t\t\t}\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tcheckSteps(steps);\n\t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n\t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n\t\t\t\tpopSteps(1);\n\t\t\t\tRebaseResult result \u003d processStep(step, true);\n\t\t\t\tif (result !\u003d null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn finishRebase(newHead, lastStepWasForward);\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 229,
      "functionName": "call",
      "diff": "@@ -1,100 +1,112 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead \u003d null;\n \t\tlastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n+\t\t\t\tif (stopAfterInitialization\n+\t\t\t\t\t\t|| !walk.isMergedInto(\n+\t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n+\t\t\t\t\t\t\t\tupstreamCommit)) {\n+\t\t\t\t\torg.eclipse.jgit.api.Status status \u003d Git.wrap(repo)\n+\t\t\t\t\t\t\t.status().call();\n+\t\t\t\t\tif (status.hasUncommittedChanges()) {\n+\t\t\t\t\t\tList\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n+\t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n+\t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead !\u003d null\n \t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n \t\t\t\t\tif (result !\u003d null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() \u003d\u003d 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result \u003d processStep(step, true);\n \t\t\t\tif (result !\u003d null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec0d78d0939ee8ce30bd349bd885186c13d3b645": {
      "type": "Ybodychange",
      "commitMessage": "Use static factory methods instead of overloaded constructors\n\nChange-Id: Ib10e0798dcfb9f1b611caec393926c95eff4c2a2\n",
      "commitDate": "2013-11-29, 3:34 a.m.",
      "commitName": "ec0d78d0939ee8ce30bd349bd885186c13d3b645",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013-11-22, 4:50 p.m.",
      "commitNameOld": "8339a07e8314d6a40e15252bcc736a46c0aca0ea",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 6.45,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tnewHead \u003d null;\n\t\tlastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase PROCESS_STEPS:\n\t\t\t\t// fall through\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (stopAfterInitialization)\n\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n\t\t\t\t\t\trebaseState.getPath(DONE), true);\n\t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n\t\t\t\tif (newHead !\u003d null\n\t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n\t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n\t\t\t\t\t\t\tstep.getAction(),\n\t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n\t\t\t\t\t\t\tstep.getShortMessage());\n\t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n\t\t\t\t\tif (result !\u003d null)\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (steps.size() \u003d\u003d 0) {\n\t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n\t\t\t}\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tcheckSteps(steps);\n\t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n\t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n\t\t\t\tpopSteps(1);\n\t\t\t\tRebaseResult result \u003d processStep(step, true);\n\t\t\t\tif (result !\u003d null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn finishRebase(newHead, lastStepWasForward);\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 229,
      "functionName": "call",
      "diff": "@@ -1,100 +1,100 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead \u003d null;\n \t\tlastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead !\u003d null\n \t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n \t\t\t\t\tif (result !\u003d null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() \u003d\u003d 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result \u003d processStep(step, true);\n \t\t\t\tif (result !\u003d null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n-\t\t\treturn new RebaseResult(cce.getConflictingPaths());\n+\t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "979e3467112618cc787e161097986212eaaa4533": {
      "type": "Ybodychange",
      "commitMessage": "Interactive Rebase: Do actions if there were conflicts\n\nIf a commit was marked for edit, reword, squash or fixup, but the\ninteractive rebase stopped because of a conflict, the step was not done\nafter conflict resolution. This is done now.\n\nChange-Id: If8e7ccc50469165744f2b8a53d180f9ba0f72330\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2013-11-08, 5:43 p.m.",
      "commitName": "979e3467112618cc787e161097986212eaaa4533",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013-11-06, 3:43 a.m.",
      "commitNameOld": "18069ffe8cbede40cf2524922c262b67656e7021",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 2.58,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tnewHead \u003d null;\n\t\tlastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase PROCESS_STEPS:\n\t\t\t\t// fall through\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (stopAfterInitialization)\n\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n\t\t\t\t\t\trebaseState.getPath(DONE), true);\n\t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n\t\t\t\tif (newHead !\u003d null\n\t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n\t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n\t\t\t\t\t\t\tstep.getAction(),\n\t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n\t\t\t\t\t\t\tstep.getShortMessage());\n\t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n\t\t\t\t\tif (result !\u003d null)\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (steps.size() \u003d\u003d 0) {\n\t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n\t\t\t}\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tcheckSteps(steps);\n\t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n\t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n\t\t\t\tpopSteps(1);\n\t\t\t\tRebaseResult result \u003d processStep(step, true);\n\t\t\t\tif (result !\u003d null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn finishRebase(newHead, lastStepWasForward);\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn new RebaseResult(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 228,
      "functionName": "call",
      "diff": "@@ -1,162 +1,100 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n-\t\tRevCommit newHead \u003d null;\n-\t\tboolean lastStepWasForward \u003d false;\n+\t\tnewHead \u003d null;\n+\t\tlastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n-\n+\t\t\t\tList\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(\n+\t\t\t\t\t\trebaseState.getPath(DONE), true);\n+\t\t\t\tRebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n+\t\t\t\tif (newHead !\u003d null\n+\t\t\t\t\t\t\u0026\u0026 step.getAction() !\u003d Action.PICK) {\n+\t\t\t\t\tRebaseTodoLine newStep \u003d new RebaseTodoLine(\n+\t\t\t\t\t\t\tstep.getAction(),\n+\t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n+\t\t\t\t\t\t\tstep.getShortMessage());\n+\t\t\t\t\tRebaseResult result \u003d processStep(newStep, false);\n+\t\t\t\t\tif (result !\u003d null)\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t}\n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n-\t\t\tObjectReader or \u003d repo.newObjectReader();\n-\n \t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() \u003d\u003d 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n \t\t\t\tpopSteps(1);\n-\t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n-\t\t\t\t\tcontinue;\n-\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n-\t\t\t\tif (ids.size() !\u003d 1)\n-\t\t\t\t\tthrow new JGitInternalException(\n-\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n-\t\t\t\tRevCommit commitToPick \u003d walk\n-\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n-\t\t\t\tif (monitor.isCancelled())\n-\t\t\t\t\treturn new RebaseResult(commitToPick, Status.STOPPED);\n-\t\t\t\ttry {\n-\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n-\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n-\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n-\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n-\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n-\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n-\t\t\t\t\t// unnecessary object rewriting\n-\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n-\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n-\t\t\t\t\tif (!lastStepWasForward) {\n-\t\t\t\t\t\t// TODO if the content of this commit is already merged\n-\t\t\t\t\t\t// here we should skip this step in order to avoid\n-\t\t\t\t\t\t// confusing pseudo-changed\n-\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n-\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n-\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n-\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n-\t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n-\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n-\t\t\t\t\t\tcase FAILED:\n-\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n-\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n-\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n-\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n-\t\t\t\t\t\tcase CONFLICTING:\n-\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n-\t\t\t\t\t\tcase OK:\n-\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tboolean isSquash \u003d false;\n-\t\t\t\t\tswitch (step.getAction()) {\n-\t\t\t\t\tcase PICK:\n-\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n-\t\t\t\t\tcase REWORD:\n-\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n-\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n-\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n-\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n-\t\t\t\t\t\t\t\t.setAmend(true).call();\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\tcase EDIT:\n-\t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n-\t\t\t\t\t\treturn stop(commitToPick, Status.EDIT);\n-\t\t\t\t\tcase COMMENT:\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase SQUASH:\n-\t\t\t\t\t\tisSquash \u003d true;\n-\t\t\t\t\t\t//$FALL-THROUGH$\n-\t\t\t\t\tcase FIXUP:\n-\t\t\t\t\t\tresetSoftToParent();\n-\t\t\t\t\t\tRebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null\n-\t\t\t\t\t\t\t\t: steps.get(i + 1));\n-\t\t\t\t\t\tFile messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n-\t\t\t\t\t\tFile messageSquashFile \u003d rebaseState\n-\t\t\t\t\t\t\t\t.getFile(MESSAGE_SQUASH);\n-\t\t\t\t\t\tif (isSquash \u0026\u0026 messageFixupFile.exists())\n-\t\t\t\t\t\t\t\tmessageFixupFile.delete();\n-\t\t\t\t\t\tnewHead \u003d doSquashFixup(isSquash, commitToPick,\n-\t\t\t\t\t\t\t\tnextStep, messageFixupFile, messageSquashFile);\n-\t\t\t\t\t}\n-\t\t\t\t} finally {\n-\t\t\t\t\tmonitor.endTask();\n+\t\t\t\tRebaseResult result \u003d processStep(step, true);\n+\t\t\t\tif (result !\u003d null) {\n+\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "18069ffe8cbede40cf2524922c262b67656e7021": {
      "type": "Ybodychange",
      "commitMessage": "Rebase interactive should finish if last step is edit\n\nWhen the last step was an edit step, rebase interactive did not finish\nafter continuing the rebase. Instead, it returned with the status\nFAST_FORWARD.\n\nChange-Id: Ib19857474ac089dfeaae665ad5e95c66c21099b0\n",
      "commitDate": "2013-11-06, 3:43 a.m.",
      "commitName": "18069ffe8cbede40cf2524922c262b67656e7021",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013-11-05, 12:05 p.m.",
      "commitNameOld": "cce2561e9fe2ce1cf60182f9d95c8537ce13de92",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 0.65,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase PROCESS_STEPS:\n\t\t\t\t// fall through\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (stopAfterInitialization)\n\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (steps.size() \u003d\u003d 0) {\n\t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n\t\t\t}\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tcheckSteps(steps);\n\t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n\t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n\t\t\t\tpopSteps(1);\n\t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n\t\t\t\t\tcontinue;\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick, Status.STOPPED);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n\t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tboolean isSquash \u003d false;\n\t\t\t\t\tswitch (step.getAction()) {\n\t\t\t\t\tcase PICK:\n\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n\t\t\t\t\tcase REWORD:\n\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n\t\t\t\t\t\t\t\t.setAmend(true).call();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase EDIT:\n\t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n\t\t\t\t\t\treturn stop(commitToPick, Status.EDIT);\n\t\t\t\t\tcase COMMENT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SQUASH:\n\t\t\t\t\t\tisSquash \u003d true;\n\t\t\t\t\t\t//$FALL-THROUGH$\n\t\t\t\t\tcase FIXUP:\n\t\t\t\t\t\tresetSoftToParent();\n\t\t\t\t\t\tRebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null\n\t\t\t\t\t\t\t\t: steps.get(i + 1));\n\t\t\t\t\t\tFile messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n\t\t\t\t\t\tFile messageSquashFile \u003d rebaseState\n\t\t\t\t\t\t\t\t.getFile(MESSAGE_SQUASH);\n\t\t\t\t\t\tif (isSquash \u0026\u0026 messageFixupFile.exists())\n\t\t\t\t\t\t\t\tmessageFixupFile.delete();\n\t\t\t\t\t\tnewHead \u003d doSquashFixup(isSquash, commitToPick,\n\t\t\t\t\t\t\t\tnextStep, messageFixupFile, messageSquashFile);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn finishRebase(newHead, lastStepWasForward);\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn new RebaseResult(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 221,
      "functionName": "call",
      "diff": "@@ -1,167 +1,162 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n+\t\t\tif (steps.size() \u003d\u003d 0) {\n+\t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n+\t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n \t\t\t\t\tcontinue;\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick, Status.STOPPED);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n \t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tboolean isSquash \u003d false;\n \t\t\t\t\tswitch (step.getAction()) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage \u003d interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick, Status.EDIT);\n \t\t\t\t\tcase COMMENT:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase SQUASH:\n \t\t\t\t\t\tisSquash \u003d true;\n \t\t\t\t\t\t//$FALL-THROUGH$\n \t\t\t\t\tcase FIXUP:\n \t\t\t\t\t\tresetSoftToParent();\n \t\t\t\t\t\tRebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null\n \t\t\t\t\t\t\t\t: steps.get(i + 1));\n \t\t\t\t\t\tFile messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n \t\t\t\t\t\tFile messageSquashFile \u003d rebaseState\n \t\t\t\t\t\t\t\t.getFile(MESSAGE_SQUASH);\n \t\t\t\t\t\tif (isSquash \u0026\u0026 messageFixupFile.exists())\n \t\t\t\t\t\t\t\tmessageFixupFile.delete();\n \t\t\t\t\t\tnewHead \u003d doSquashFixup(isSquash, commitToPick,\n \t\t\t\t\t\t\t\tnextStep, messageFixupFile, messageSquashFile);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif (newHead !\u003d null) {\n-\t\t\t\tString headName \u003d rebaseState.readFile(HEAD_NAME);\n-\t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n-\t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n-\t\t\t\tif (lastStepWasForward)\n-\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n-\t\t\t\treturn RebaseResult.OK_RESULT;\n-\t\t\t}\n-\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n+\t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cce2561e9fe2ce1cf60182f9d95c8537ce13de92": {
      "type": "Ybodychange",
      "commitMessage": "Add additional RebaseResult for editing commits\n\nWith the new RebaseResult.EDIT a client can now distinguish if rebase\nstopped due to a conflict or because the commit was marked for edit in\nan interactive rebase.\n\nChange-Id: I40f2311cf43ed5f290dcda65a7bd85ba770a85f5\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\n",
      "commitDate": "2013-11-05, 12:05 p.m.",
      "commitName": "cce2561e9fe2ce1cf60182f9d95c8537ce13de92",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013-11-05, 12:05 p.m.",
      "commitNameOld": "765896febb4b63cfe2c37dc0a73c90c79dd1591b",
      "commitAuthorOld": "Tobias Pfeifer",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase PROCESS_STEPS:\n\t\t\t\t// fall through\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (stopAfterInitialization)\n\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tcheckSteps(steps);\n\t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n\t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n\t\t\t\tpopSteps(1);\n\t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n\t\t\t\t\tcontinue;\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick, Status.STOPPED);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n\t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tboolean isSquash \u003d false;\n\t\t\t\t\tswitch (step.getAction()) {\n\t\t\t\t\tcase PICK:\n\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n\t\t\t\t\tcase REWORD:\n\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n\t\t\t\t\t\t\t\t.setAmend(true).call();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase EDIT:\n\t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n\t\t\t\t\t\treturn stop(commitToPick, Status.EDIT);\n\t\t\t\t\tcase COMMENT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SQUASH:\n\t\t\t\t\t\tisSquash \u003d true;\n\t\t\t\t\t\t//$FALL-THROUGH$\n\t\t\t\t\tcase FIXUP:\n\t\t\t\t\t\tresetSoftToParent();\n\t\t\t\t\t\tRebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null\n\t\t\t\t\t\t\t\t: steps.get(i + 1));\n\t\t\t\t\t\tFile messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n\t\t\t\t\t\tFile messageSquashFile \u003d rebaseState\n\t\t\t\t\t\t\t\t.getFile(MESSAGE_SQUASH);\n\t\t\t\t\t\tif (isSquash \u0026\u0026 messageFixupFile.exists())\n\t\t\t\t\t\t\t\tmessageFixupFile.delete();\n\t\t\t\t\t\tnewHead \u003d doSquashFixup(isSquash, commitToPick,\n\t\t\t\t\t\t\t\tnextStep, messageFixupFile, messageSquashFile);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d rebaseState.readFile(HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n\t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn new RebaseResult(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 221,
      "functionName": "call",
      "diff": "@@ -1,167 +1,167 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n \t\t\t\t\tcontinue;\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n-\t\t\t\t\treturn new RebaseResult(commitToPick);\n+\t\t\t\t\treturn new RebaseResult(commitToPick, Status.STOPPED);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n \t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n \t\t\t\t\t\tcase CONFLICTING:\n-\t\t\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tboolean isSquash \u003d false;\n \t\t\t\t\tswitch (step.getAction()) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage \u003d interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n-\t\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\t\t\treturn stop(commitToPick, Status.EDIT);\n \t\t\t\t\tcase COMMENT:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase SQUASH:\n \t\t\t\t\t\tisSquash \u003d true;\n \t\t\t\t\t\t//$FALL-THROUGH$\n \t\t\t\t\tcase FIXUP:\n \t\t\t\t\t\tresetSoftToParent();\n \t\t\t\t\t\tRebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null\n \t\t\t\t\t\t\t\t: steps.get(i + 1));\n \t\t\t\t\t\tFile messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n \t\t\t\t\t\tFile messageSquashFile \u003d rebaseState\n \t\t\t\t\t\t\t\t.getFile(MESSAGE_SQUASH);\n \t\t\t\t\t\tif (isSquash \u0026\u0026 messageFixupFile.exists())\n \t\t\t\t\t\t\t\tmessageFixupFile.delete();\n \t\t\t\t\t\tnewHead \u003d doSquashFixup(isSquash, commitToPick,\n \t\t\t\t\t\t\t\tnextStep, messageFixupFile, messageSquashFile);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d rebaseState.readFile(HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n \t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "765896febb4b63cfe2c37dc0a73c90c79dd1591b": {
      "type": "Ybodychange",
      "commitMessage": "Add Squash/Fixup support for rebase interactive in RebaseCommand\n\nThe rebase command now supports squash and fixup. Both actions are not\nallowed as the first step of the rebase.\n\nIn JGit, before any rebase step is performed, the next commit is\nalready cherry-picked. This commit keeps that behaviour. In case of\nsquash or fixup a soft reset to the parent is perfomed afterwards.\n\nCQ: 7684\nBug: 396510\nChange-Id: I3c4190940b4d7f19860e223d647fc78705e57203\nSigned-off-by: Tobias Pfeifer \u003cto.pfeifer@web.de\u003e\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2013-11-05, 12:05 p.m.",
      "commitName": "765896febb4b63cfe2c37dc0a73c90c79dd1591b",
      "commitAuthor": "Tobias Pfeifer",
      "commitDateOld": "2013-11-01, 6:43 p.m.",
      "commitNameOld": "da9db6b20c6203dae3f828adbd14218ea063ad91",
      "commitAuthorOld": "Tobias Pfeifer",
      "daysBetweenCommits": 3.76,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase PROCESS_STEPS:\n\t\t\t\t// fall through\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (stopAfterInitialization)\n\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tcheckSteps(steps);\n\t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n\t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n\t\t\t\tpopSteps(1);\n\t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n\t\t\t\t\tcontinue;\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n\t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tboolean isSquash \u003d false;\n\t\t\t\t\tswitch (step.getAction()) {\n\t\t\t\t\tcase PICK:\n\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n\t\t\t\t\tcase REWORD:\n\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n\t\t\t\t\t\t\t\t.setAmend(true).call();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase EDIT:\n\t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\tcase COMMENT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SQUASH:\n\t\t\t\t\t\tisSquash \u003d true;\n\t\t\t\t\t\t//$FALL-THROUGH$\n\t\t\t\t\tcase FIXUP:\n\t\t\t\t\t\tresetSoftToParent();\n\t\t\t\t\t\tRebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null\n\t\t\t\t\t\t\t\t: steps.get(i + 1));\n\t\t\t\t\t\tFile messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n\t\t\t\t\t\tFile messageSquashFile \u003d rebaseState\n\t\t\t\t\t\t\t\t.getFile(MESSAGE_SQUASH);\n\t\t\t\t\t\tif (isSquash \u0026\u0026 messageFixupFile.exists())\n\t\t\t\t\t\t\t\tmessageFixupFile.delete();\n\t\t\t\t\t\tnewHead \u003d doSquashFixup(isSquash, commitToPick,\n\t\t\t\t\t\t\t\tnextStep, messageFixupFile, messageSquashFile);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d rebaseState.readFile(HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n\t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn new RebaseResult(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 221,
      "functionName": "call",
      "diff": "@@ -1,150 +1,167 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n-\t\t\tfor (RebaseTodoLine step : steps) {\n+\t\t\tcheckSteps(steps);\n+\t\t\tfor (int i \u003d 0; i \u003c steps.size(); i++) {\n+\t\t\t\tRebaseTodoLine step \u003d steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n \t\t\t\t\tcontinue;\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n \t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\tboolean isSquash \u003d false;\n \t\t\t\t\tswitch (step.getAction()) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage \u003d interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\tcase COMMENT:\n \t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase SQUASH:\n+\t\t\t\t\t\tisSquash \u003d true;\n+\t\t\t\t\t\t//$FALL-THROUGH$\n+\t\t\t\t\tcase FIXUP:\n+\t\t\t\t\t\tresetSoftToParent();\n+\t\t\t\t\t\tRebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null\n+\t\t\t\t\t\t\t\t: steps.get(i + 1));\n+\t\t\t\t\t\tFile messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n+\t\t\t\t\t\tFile messageSquashFile \u003d rebaseState\n+\t\t\t\t\t\t\t\t.getFile(MESSAGE_SQUASH);\n+\t\t\t\t\t\tif (isSquash \u0026\u0026 messageFixupFile.exists())\n+\t\t\t\t\t\t\t\tmessageFixupFile.delete();\n+\t\t\t\t\t\tnewHead \u003d doSquashFixup(isSquash, commitToPick,\n+\t\t\t\t\t\t\t\tnextStep, messageFixupFile, messageSquashFile);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d rebaseState.readFile(HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n \t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "da9db6b20c6203dae3f828adbd14218ea063ad91": {
      "type": "Ybodychange",
      "commitMessage": "Enable to prepare interactive rebase and then start it explicitly\n\nAdd Operation.PROCESS_STEPS to RebaseCommand to enable starting\ninteractive rebase explicitly after rebase steps have been configured.\n\nChange-Id: I2d6f0de82010ea6523fbce6fb4501e847bdcdddc\nSigned-off-by: Tobias Pfeifer \u003cto.pfeifer@web.de\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2013-11-01, 6:43 p.m.",
      "commitName": "da9db6b20c6203dae3f828adbd14218ea063ad91",
      "commitAuthor": "Tobias Pfeifer",
      "commitDateOld": "2013-10-31, 9:22 a.m.",
      "commitNameOld": "c3873b584f81bc5be3fdea53e9e0e76271a9a854",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 1.39,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase PROCESS_STEPS:\n\t\t\t\t// fall through\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (stopAfterInitialization)\n\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tfor (RebaseTodoLine step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n\t\t\t\t\tcontinue;\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n\t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch (step.getAction()) {\n\t\t\t\t\tcase PICK:\n\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n\t\t\t\t\tcase REWORD:\n\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n\t\t\t\t\t\t\t\t.setAmend(true).call();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase EDIT:\n\t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\tcase COMMENT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d rebaseState.readFile(HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n\t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn new RebaseResult(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 213,
      "functionName": "call",
      "diff": "@@ -1,146 +1,150 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n+\t\t\tcase PROCESS_STEPS:\n+\t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n+\t\t\t\tif (stopAfterInitialization)\n+\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tfor (RebaseTodoLine step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n \t\t\t\t\tcontinue;\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n \t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.getAction()) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage \u003d interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\tcase COMMENT:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d rebaseState.readFile(HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n \t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c3873b584f81bc5be3fdea53e9e0e76271a9a854": {
      "type": "Ybodychange",
      "commitMessage": "Enhance reading of git-rebase-todo formatted files\n\nReading and writing files formatted like the git-rebase-todo files was\nhidden in the RebaseCommand. Certain constructs (like leading tabs and\nspaces) have not been handled as in native git. Also the upcoming\nrebase interactive feature in EGit needs reading/writing these files\nindependently from a RebaseCommand.\n\nTherefore reading and writing those files has been moved to the\nRepository class. RebaseCommand gets smaller because of that and doesn\u0027t\nhave to deal with reading/writing files.\n\nAdditional tests for empty todo-list files, or files containing comments\nhave been added.\n\nChange-Id: I323f3619952fecdf28ddf50139a88e0bea34f5ba\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nAlso-by: Tobias Pfeifer \u003cto.pfeifer@sap.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2013-10-31, 9:22 a.m.",
      "commitName": "c3873b584f81bc5be3fdea53e9e0e76271a9a854",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2013-09-29, 4:17 p.m.",
      "commitNameOld": "c6aba99668eab76c1b05e021719f8ef9a69c3ae9",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 31.71,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n\t\t\t\t\t\tsteps, false);\n\t\t\t}\n\t\t\tfor (RebaseTodoLine step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n\t\t\t\t\tcontinue;\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n\t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch (step.getAction()) {\n\t\t\t\t\tcase PICK:\n\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n\t\t\t\t\tcase REWORD:\n\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n\t\t\t\t\t\t\t\t.setAmend(true).call();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase EDIT:\n\t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\tcase COMMENT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d rebaseState.readFile(HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n\t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn new RebaseResult(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 207,
      "functionName": "call",
      "diff": "@@ -1,160 +1,146 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n-\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n+\t\t\tList\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(\n+\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n-\t\t\t\tBufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(\n-\t\t\t\t\t\tnew FileOutputStream(\n-\t\t\t\t\t\t\t\trebaseState.getFile(GIT_REBASE_TODO)),\n-\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n-\t\t\t\tfw.newLine();\n-\t\t\t\ttry {\n-\t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n-\t\t\t\t\tfor (Step step : steps) {\n-\t\t\t\t\t\tsb.setLength(0);\n-\t\t\t\t\t\tsb.append(step.action.token);\n-\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n-\t\t\t\t\t\tsb.append(step.commit.name());\n-\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n-\t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n-\t\t\t\t\t\t\t\t.trim());\n-\t\t\t\t\t\tfw.write(sb.toString());\n-\t\t\t\t\t\tfw.newLine();\n-\t\t\t\t\t}\n-\t\t\t\t} finally {\n-\t\t\t\t\tfw.close();\n-\t\t\t\t}\n+\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n+\t\t\t\t\t\tsteps, false);\n \t\t\t}\n-\t\t\tfor (Step step : steps) {\n+\t\t\tfor (RebaseTodoLine step : steps) {\n \t\t\t\tpopSteps(1);\n-\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n+\t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n+\t\t\t\t\tcontinue;\n+\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n \t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tswitch (step.action) {\n+\t\t\t\t\tswitch (step.getAction()) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage \u003d interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\t\tcase COMMENT:\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d rebaseState.readFile(HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n \t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "60e01cff2f763a85ed24a706d26eb9f159ffa832": {
      "type": "Ybodychange",
      "commitMessage": "Update reflog like C Git during rebase (non-interactive)\n\nBug: 346350\nChange-Id: I119766a00bc52a810c51cffaa19207cb8555ca22\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2013-07-21, 10:54 p.m.",
      "commitName": "60e01cff2f763a85ed24a706d26eb9f159ffa832",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013-03-16, 6:32 p.m.",
      "commitNameOld": "44ea46dd40d2411dfc615c14db92786730d977be",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 127.18,
      "commitsBetweenForRepo": 196,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\tBufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(\n\t\t\t\t\t\tnew FileOutputStream(\n\t\t\t\t\t\t\t\trebaseState.getFile(GIT_REBASE_TODO)),\n\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n\t\t\t\tfw.newLine();\n\t\t\t\ttry {\n\t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n\t\t\t\t\tfor (Step step : steps) {\n\t\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\t\tsb.append(step.action.token);\n\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\tsb.append(step.commit.name());\n\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n\t\t\t\t\t\t\t\t.trim());\n\t\t\t\t\t\tfw.write(sb.toString());\n\t\t\t\t\t\tfw.newLine();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tfw.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n\t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch (step.action) {\n\t\t\t\t\tcase PICK:\n\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n\t\t\t\t\tcase REWORD:\n\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n\t\t\t\t\t\t\t\t.setAmend(true).call();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase EDIT:\n\t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d rebaseState.readFile(HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n\t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn new RebaseResult(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 210,
      "functionName": "call",
      "diff": "@@ -1,159 +1,160 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\tBufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(\n \t\t\t\t\t\tnew FileOutputStream(\n \t\t\t\t\t\t\t\trebaseState.getFile(GIT_REBASE_TODO)),\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\tfw.newLine();\n \t\t\t\ttry {\n \t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n \t\t\t\t\tfor (Step step : steps) {\n \t\t\t\t\t\tsb.setLength(0);\n \t\t\t\t\t\tsb.append(step.action.token);\n \t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(step.commit.name());\n \t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n \t\t\t\t\t\t\t\t.trim());\n \t\t\t\t\t\tfw.write(sb.toString());\n \t\t\t\t\t\tfw.newLine();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tfw.close();\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n-\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n+\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n+\t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.action) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage \u003d interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d rebaseState.readFile(HEAD_NAME);\n-\t\t\t\tupdateHead(headName, newHead);\n+\t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n \t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e9f1cf57dac274f92a6db38197e14b55b3277af": {
      "type": "Ybodychange",
      "commitMessage": "Support aborting non-interactive rebase started from C Git\n\nContinuing is trickier, as .git/rebase-apply contains no message file\nand no git-rebase-todo.\n\nBug: 336820\nChange-Id: I4eb87c850078ca187b38b81cc91c92afb1176945\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2013-03-16, 6:32 p.m.",
      "commitName": "0e9f1cf57dac274f92a6db38197e14b55b3277af",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2013-03-08, 10:40 a.m.",
      "commitNameOld": "3ad454497cdb6a917c00b01c735f5a469b8fb2ff",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 8.29,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\tBufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(\n\t\t\t\t\t\tnew FileOutputStream(\n\t\t\t\t\t\t\t\trebaseState.getFile(GIT_REBASE_TODO)),\n\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n\t\t\t\tfw.newLine();\n\t\t\t\ttry {\n\t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n\t\t\t\t\tfor (Step step : steps) {\n\t\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\t\tsb.append(step.action.token);\n\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\tsb.append(step.commit.name());\n\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n\t\t\t\t\t\t\t\t.trim());\n\t\t\t\t\t\tfw.write(sb.toString());\n\t\t\t\t\t\tfw.newLine();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tfw.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch (step.action) {\n\t\t\t\t\tcase PICK:\n\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n\t\t\t\t\tcase REWORD:\n\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n\t\t\t\t\t\t\t\t.setAmend(true).call();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase EDIT:\n\t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d rebaseState.readFile(HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead);\n\t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn new RebaseResult(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 210,
      "functionName": "call",
      "diff": "@@ -1,159 +1,159 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n-\t\t\t\tString upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n+\t\t\t\tString upstreamCommitId \u003d rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n-\t\t\t\t\tupstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n+\t\t\t\t\tupstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n-\t\t\t\tFile amendFile \u003d new File(rebaseDir, AMEND);\n+\t\t\t\tFile amendFile \u003d rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n-\t\t\t\tBufferedWriter fw \u003d new BufferedWriter(\n-\t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n-\t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n+\t\t\t\tBufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(\n+\t\t\t\t\t\tnew FileOutputStream(\n+\t\t\t\t\t\t\t\trebaseState.getFile(GIT_REBASE_TODO)),\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\tfw.newLine();\n \t\t\t\ttry {\n \t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n \t\t\t\t\tfor (Step step : steps) {\n \t\t\t\t\t\tsb.setLength(0);\n \t\t\t\t\t\tsb.append(step.action.token);\n \t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(step.commit.name());\n \t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n \t\t\t\t\t\t\t\t.trim());\n \t\t\t\t\t\tfw.write(sb.toString());\n \t\t\t\t\t\tfw.newLine();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tfw.close();\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.action) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage \u003d interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n-\t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n+\t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n-\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n+\t\t\t\tString headName \u003d rebaseState.readFile(HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n-\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n+\t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "baf7ca9cc0d2bdf237a9bb19486d6fde5250a7f5": {
      "type": "Ybodychange",
      "commitMessage": "Improve handling of checkout conflicts\n\nThis converts a checkout conflict exception into a RebaseResult /\nMergeResult containing the conflicting paths, which enables EGit (or\nothers) to handle the situation in a user-friendly way\n\nChange-Id: I48d9bdcc1e98095576513a54a225a42409f301f3",
      "commitDate": "2013-01-11, 8:32 p.m.",
      "commitName": "baf7ca9cc0d2bdf237a9bb19486d6fde5250a7f5",
      "commitAuthor": "Markus Duft",
      "commitDateOld": "2012-12-27, 10:57 a.m.",
      "commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 15.4,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tFile amendFile \u003d new File(rebaseDir, AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\tBufferedWriter fw \u003d new BufferedWriter(\n\t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n\t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n\t\t\t\tfw.newLine();\n\t\t\t\ttry {\n\t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n\t\t\t\t\tfor (Step step : steps) {\n\t\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\t\tsb.append(step.action.token);\n\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\tsb.append(step.commit.name());\n\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n\t\t\t\t\t\t\t\t.trim());\n\t\t\t\t\t\tfw.write(sb.toString());\n\t\t\t\t\t\tfw.newLine();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tfw.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch (step.action) {\n\t\t\t\t\tcase PICK:\n\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n\t\t\t\t\tcase REWORD:\n\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n\t\t\t\t\t\t\t\t.setAmend(true).call();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase EDIT:\n\t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead);\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (CheckoutConflictException cce) {\n\t\t\treturn new RebaseResult(cce.getConflictingPaths());\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 205,
      "functionName": "call",
      "diff": "@@ -1,157 +1,159 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\t\tFile amendFile \u003d new File(rebaseDir, AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\tBufferedWriter fw \u003d new BufferedWriter(\n \t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n \t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\tfw.newLine();\n \t\t\t\ttry {\n \t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n \t\t\t\t\tfor (Step step : steps) {\n \t\t\t\t\t\tsb.setLength(0);\n \t\t\t\t\t\tsb.append(step.action.token);\n \t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(step.commit.name());\n \t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n \t\t\t\t\t\t\t\t.trim());\n \t\t\t\t\t\tfw.write(sb.toString());\n \t\t\t\t\t\tfw.newLine();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tfw.close();\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.action) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage \u003d interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n+\t\t} catch (CheckoutConflictException cce) {\n+\t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": {
      "type": "Ybodychange",
      "commitMessage": "Mark non-externalizable strings as such\n\nA few classes such as Constanrs are marked with @SuppressWarnings, as are\ntoString() methods with many liternal, but otherwise $NLS-n$ is used for\nstring containing text that should not be translated. A few literals may\nfall into the gray zone, but mostly I\u0027ve tried to only tag the obvious\nones.\n\nChange-Id: I22e50a77e2bf9e0b842a66bdf674e8fa1692f590\n",
      "commitDate": "2012-12-27, 10:57 a.m.",
      "commitName": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012-12-05, 6:16 p.m.",
      "commitNameOld": "8d062dec0ca6815bd24457b02dbbc24f9dc143ee",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 21.69,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tFile amendFile \u003d new File(rebaseDir, AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\tBufferedWriter fw \u003d new BufferedWriter(\n\t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n\t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n\t\t\t\tfw.newLine();\n\t\t\t\ttry {\n\t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n\t\t\t\t\tfor (Step step : steps) {\n\t\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\t\tsb.append(step.action.token);\n\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\tsb.append(step.commit.name());\n\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n\t\t\t\t\t\t\t\t.trim());\n\t\t\t\t\t\tfw.write(sb.toString());\n\t\t\t\t\t\tfw.newLine();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tfw.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch (step.action) {\n\t\t\t\t\tcase PICK:\n\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n\t\t\t\t\tcase REWORD:\n\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n\t\t\t\t\t\t\t\t.setAmend(true).call();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase EDIT:\n\t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead);\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 205,
      "functionName": "call",
      "diff": "@@ -1,157 +1,157 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\t\tFile amendFile \u003d new File(rebaseDir, AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\tBufferedWriter fw \u003d new BufferedWriter(\n \t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n \t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\tfw.newLine();\n \t\t\t\ttry {\n \t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n \t\t\t\t\tfor (Step step : steps) {\n \t\t\t\t\t\tsb.setLength(0);\n \t\t\t\t\t\tsb.append(step.action.token);\n-\t\t\t\t\t\tsb.append(\" \");\n+\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(step.commit.name());\n-\t\t\t\t\t\tsb.append(\" \");\n+\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n \t\t\t\t\t\t\t\t.trim());\n \t\t\t\t\t\tfw.write(sb.toString());\n \t\t\t\t\t\tfw.newLine();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tfw.close();\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.action) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage \u003d interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "257f3fe4a1b9e450b2f665b5f0ed09a3ab3839b9": {
      "type": "Ybodychange",
      "commitMessage": "Commit message may not necessarily be in UTF-8\n\nTrying different encoding makes presentation nicer\nto user.\n\nChange-Id: I2d2c2a95d0b5cd709855d7a67cbc247478434d2f\n",
      "commitDate": "2012-11-27, 2:34 a.m.",
      "commitName": "257f3fe4a1b9e450b2f665b5f0ed09a3ab3839b9",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012-11-19, 11:02 a.m.",
      "commitNameOld": "8eb4d926371edea2d58dc598e3ebcddacbdc326e",
      "commitAuthorOld": "Dariusz Luksza",
      "daysBetweenCommits": 7.65,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tFile amendFile \u003d new File(rebaseDir, AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\tBufferedWriter fw \u003d new BufferedWriter(\n\t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n\t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n\t\t\t\tfw.newLine();\n\t\t\t\ttry {\n\t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n\t\t\t\t\tfor (Step step : steps) {\n\t\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\t\tsb.append(step.action.token);\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(step.commit.name());\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n\t\t\t\t\t\t\t\t.trim());\n\t\t\t\t\t\tfw.write(sb.toString());\n\t\t\t\t\t\tfw.newLine();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tfw.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch (step.action) {\n\t\t\t\t\tcase PICK:\n\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n\t\t\t\t\tcase REWORD:\n\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n\t\t\t\t\t\t\t\t.setAmend(true).call();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase EDIT:\n\t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead);\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 205,
      "functionName": "call",
      "diff": "@@ -1,157 +1,157 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\t\tFile amendFile \u003d new File(rebaseDir, AMEND);\n \t\t\t\tboolean amendExists \u003d amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\tBufferedWriter fw \u003d new BufferedWriter(\n \t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n \t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\tfw.newLine();\n \t\t\t\ttry {\n \t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n \t\t\t\t\tfor (Step step : steps) {\n \t\t\t\t\t\tsb.setLength(0);\n \t\t\t\t\t\tsb.append(step.action.token);\n \t\t\t\t\t\tsb.append(\" \");\n \t\t\t\t\t\tsb.append(step.commit.name());\n \t\t\t\t\t\tsb.append(\" \");\n-\t\t\t\t\t\tsb.append(new String(step.shortMessage,\n-\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING).trim());\n+\t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n+\t\t\t\t\t\t\t\t.trim());\n \t\t\t\t\t\tfw.write(sb.toString());\n \t\t\t\t\t\tfw.newLine();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tfw.close();\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.action) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage \u003d interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8eb4d926371edea2d58dc598e3ebcddacbdc326e": {
      "type": "Ybodychange",
      "commitMessage": "Add support for rebase interactive \u0027edit\u0027 command\n\nThe \u0027edit\u0027 command allows you to change arbitrary commit\ncontent and the message of any commit in the repository.\n\nBug: 394577\nChange-Id: I43a44782cdb10b29f13784fa75ab37fe5d4da01b\nSigned-off-by: Dariusz Luksza \u003cdariusz@luksza.org\u003e\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2012-11-19, 11:02 a.m.",
      "commitName": "8eb4d926371edea2d58dc598e3ebcddacbdc326e",
      "commitAuthor": "Dariusz Luksza",
      "commitDateOld": "2012-11-19, 10:40 a.m.",
      "commitNameOld": "84fb2b59d11418d2fa753d27de11775ddc18adde",
      "commitAuthorOld": "Dariusz Luksza",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tFile amendFile \u003d new File(rebaseDir, AMEND);\n\t\t\t\tboolean amendExists \u003d amendFile.exists();\n\t\t\t\tif (amendExists) {\n\t\t\t\t\tFileUtils.delete(amendFile);\n\t\t\t\t}\n\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\tBufferedWriter fw \u003d new BufferedWriter(\n\t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n\t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n\t\t\t\tfw.newLine();\n\t\t\t\ttry {\n\t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n\t\t\t\t\tfor (Step step : steps) {\n\t\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\t\tsb.append(step.action.token);\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(step.commit.name());\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(new String(step.shortMessage,\n\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING).trim());\n\t\t\t\t\t\tfw.write(sb.toString());\n\t\t\t\t\t\tfw.newLine();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tfw.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch (step.action) {\n\t\t\t\t\tcase PICK:\n\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n\t\t\t\t\tcase REWORD:\n\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n\t\t\t\t\t\t\t\t.setAmend(true).call();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase EDIT:\n\t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead);\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 205,
      "functionName": "call",
      "diff": "@@ -1,149 +1,157 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n-\t\t\t\tif (newHead \u003d\u003d null) {\n+\t\t\t\tFile amendFile \u003d new File(rebaseDir, AMEND);\n+\t\t\t\tboolean amendExists \u003d amendFile.exists();\n+\t\t\t\tif (amendExists) {\n+\t\t\t\t\tFileUtils.delete(amendFile);\n+\t\t\t\t}\n+\t\t\t\tif (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\tBufferedWriter fw \u003d new BufferedWriter(\n \t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n \t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\tfw.newLine();\n \t\t\t\ttry {\n \t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n \t\t\t\t\tfor (Step step : steps) {\n \t\t\t\t\t\tsb.setLength(0);\n \t\t\t\t\t\tsb.append(step.action.token);\n \t\t\t\t\t\tsb.append(\" \");\n \t\t\t\t\t\tsb.append(step.commit.name());\n \t\t\t\t\t\tsb.append(\" \");\n \t\t\t\t\t\tsb.append(new String(step.shortMessage,\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING).trim());\n \t\t\t\t\t\tfw.write(sb.toString());\n \t\t\t\t\t\tfw.newLine();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tfw.close();\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.action) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage \u003d interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n+\t\t\t\t\tcase EDIT:\n+\t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n+\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "84fb2b59d11418d2fa753d27de11775ddc18adde": {
      "type": "Ybodychange",
      "commitMessage": "Add support for rebase interactive \u0027reword\u0027 command\n\n\u0027reword\u0027 command is used to change commit message of any\ncommit in git history.\n\nBug: 394575\nChange-Id: Ic974e76dfd923fd6f0cb8f07d1a6fbecd9abbf31\nSigned-off-by: Dariusz Luksza \u003cdariusz@luksza.org\u003e\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2012-11-19, 10:40 a.m.",
      "commitName": "84fb2b59d11418d2fa753d27de11775ddc18adde",
      "commitAuthor": "Dariusz Luksza",
      "commitDateOld": "2012-08-26, 6:54 p.m.",
      "commitNameOld": "0264c313bae0308dadc4ed1db28f2f979a435451",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 84.7,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tif (isInteractive()) {\n\t\t\t\tinteractiveHandler.prepareSteps(steps);\n\t\t\t\tBufferedWriter fw \u003d new BufferedWriter(\n\t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n\t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n\t\t\t\tfw.newLine();\n\t\t\t\ttry {\n\t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n\t\t\t\t\tfor (Step step : steps) {\n\t\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\t\tsb.append(step.action.token);\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(step.commit.name());\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(new String(step.shortMessage,\n\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING).trim());\n\t\t\t\t\t\tfw.write(sb.toString());\n\t\t\t\t\t\tfw.newLine();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tfw.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch (step.action) {\n\t\t\t\t\tcase PICK:\n\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n\t\t\t\t\tcase REWORD:\n\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n\t\t\t\t\t\t\t\t.setAmend(true).call();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead);\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 203,
      "functionName": "call",
      "diff": "@@ -1,114 +1,149 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\t\tif (newHead \u003d\u003d null) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n+\t\t\tif (isInteractive()) {\n+\t\t\t\tinteractiveHandler.prepareSteps(steps);\n+\t\t\t\tBufferedWriter fw \u003d new BufferedWriter(\n+\t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n+\t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n+\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n+\t\t\t\tfw.newLine();\n+\t\t\t\ttry {\n+\t\t\t\t\tStringBuilder sb \u003d new StringBuilder();\n+\t\t\t\t\tfor (Step step : steps) {\n+\t\t\t\t\t\tsb.setLength(0);\n+\t\t\t\t\t\tsb.append(step.action.token);\n+\t\t\t\t\t\tsb.append(\" \");\n+\t\t\t\t\t\tsb.append(step.commit.name());\n+\t\t\t\t\t\tsb.append(\" \");\n+\t\t\t\t\t\tsb.append(new String(step.shortMessage,\n+\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING).trim());\n+\t\t\t\t\t\tfw.write(sb.toString());\n+\t\t\t\t\t\tfw.newLine();\n+\t\t\t\t\t}\n+\t\t\t\t} finally {\n+\t\t\t\t\tfw.close();\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\tswitch (step.action) {\n+\t\t\t\t\tcase PICK:\n+\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n+\t\t\t\t\tcase REWORD:\n+\t\t\t\t\t\tString oldMessage \u003d commitToPick.getFullMessage();\n+\t\t\t\t\t\tString newMessage \u003d interactiveHandler\n+\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n+\t\t\t\t\t\tnewHead \u003d new Git(repo).commit().setMessage(newMessage)\n+\t\t\t\t\t\t\t\t.setAmend(true).call();\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5854ca091a22346e1c710ca9f875165afb3f2cc8": {
      "type": "Ybodychange",
      "commitMessage": "Improve ours/theirs conflict markers for rebase, cherry-pick\n\nOn conflicts in rebase or cherry-pick, the conflict markers were like\nthis:\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c OURS\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e THEIRS\n\nThis is technically correct, but it could be better.\n\nIt\u0027s especially confusing during a rebase, where the meaning of\nOURS/THEIRS is not obvious. The intuition is that \"ours\" is the commits\nthat \"I\" did before the rebase, but it\u0027s the other way around because of\nthe way rebase works. See various bug reports and stackoverflow\ndiscussions.\n\nWith this change, in the case of a cherry-pick while on master, the\nmarkers will be like this:\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c master\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e bad1dea Message of the commit I\u0027m cherry-picking\n\nIn the case of a \"git rebase master\":\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c Upstream, based on master\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e b161dea Message of a commit I\u0027m rebasing\n\nIt\u0027s not \"master\" because that would only be correct for the first\ncherry-pick during a rebase, after that, it\u0027s master + already\ncherry-picked commits.\n\nAnd in the case of a \"git pull --rebase\":\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c Upstream, based on branch \u0027master\u0027 of git@example.org:repo\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e b161dea Message of a commit I\u0027m rebasing\n\nBug: 336819\nChange-Id: I1333a8dd170bb0077f491962013485efb6f2a926\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2012-08-17, 6:11 p.m.",
      "commitName": "5854ca091a22346e1c710ca9f875165afb3f2cc8",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2012-08-07, 10:49 a.m.",
      "commitNameOld": "993fcac2d34f113977c1ad7e0f83a2cc0f903f71",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 10.31,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n\t\t\t\ttry {\n\t\t\t\t\tupstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n\t\t\t\t\t// was started by C Git)\n\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n\t\t\t\t}\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitId));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead);\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 201,
      "functionName": "call",
      "diff": "@@ -1,105 +1,114 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n-\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n+\t\t\t\tString upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n+\t\t\t\ttry {\n+\t\t\t\t\tupstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n+\t\t\t\t} catch (FileNotFoundException e) {\n+\t\t\t\t\t// Fall back to commit ID if file doesn\u0027t exist (e.g. rebase\n+\t\t\t\t\t// was started by C Git)\n+\t\t\t\t\tupstreamCommitName \u003d upstreamCommitId;\n+\t\t\t\t}\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n-\t\t\t\t\t\t.resolve(upstreamCommitName));\n+\t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\t\tif (newHead \u003d\u003d null) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n+\t\t\t\t\t\tString ourCommitName \u003d getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n-\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n+\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n+\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b61d35e848e637ef85fde4ebe95d60ced171e963": {
      "type": "Yexceptionschange",
      "commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2012-06-05, 10:55 a.m.",
      "commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012-05-31, 3:52 p.m.",
      "commitNameOld": "058c74d8adcfb5ef0eed203a64b7f9ff65e87c8c",
      "commitAuthorOld": "Kevin Sawicki",
      "daysBetweenCommits": 4.79,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException, WrongRepositoryStateException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead);\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 197,
      "functionName": "call",
      "diff": "@@ -1,105 +1,105 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n-\t\t\tRefNotFoundException {\n+\t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\t\tif (newHead \u003d\u003d null) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[GitAPIException, NoHeadException, RefNotFoundException]",
        "newValue": "[GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException]"
      }
    },
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": {
      "type": "Yexceptionschange",
      "commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2012-05-30, 4:08 p.m.",
      "commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012-04-02, 5:36 a.m.",
      "commitNameOld": "622232b936fee6d2f308947359b4bc09811ce556",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 58.44,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n\t\t\tRefNotFoundException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead);\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 193,
      "functionName": "call",
      "diff": "@@ -1,105 +1,105 @@\n-\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n-\t\t\tJGitInternalException, GitAPIException {\n+\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n+\t\t\tRefNotFoundException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\t\tif (newHead \u003d\u003d null) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException]",
        "newValue": "[GitAPIException, NoHeadException, RefNotFoundException]"
      }
    },
    "edc1fee033a23189742cea1807d8029d1b77da00": {
      "type": "Ybodychange",
      "commitMessage": "Fix rebase \u003e continue when nothing left to commit.\n\nIf after resolving all conflicts nothing is left to commit, return\nan according result, so that downstreams (EGit, ...) can behave like\ncgit, and display a nice message informing the user.\n\nCurrently, EGit displays a \"HEAD advanced fast forward\" message, which\nis absolutely not helpful at all.\n\nThis is the basic API revamping required to get that state communicated\nto the outside world (EGit).\n\nBug: 336812\nChange-Id: If2665005cf54a5b51c0fe80bad019fa42b0205af",
      "commitDate": "2012-03-09, 7:56 a.m.",
      "commitName": "edc1fee033a23189742cea1807d8029d1b77da00",
      "commitAuthor": "Markus Duft",
      "commitDateOld": "2012-03-06, 4:43 p.m.",
      "commitNameOld": "90d002c15fd2131b9f80fb9bb6f28bf691c00b5d",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 2.63,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n\t\t\tJGitInternalException, GitAPIException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\t// continueRebase() returns null only if no commit was\n\t\t\t\t\t// neccessary. This means that no changes where left over\n\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n\t\t\t\t\t// and displays a nice message to the user, telling him to\n\t\t\t\t\t// either do changes or skip the commit instead of continue.\n\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead);\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 193,
      "functionName": "call",
      "diff": "@@ -1,95 +1,105 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n-\t\t\tif (operation \u003d\u003d Operation.CONTINUE)\n+\t\t\tif (operation \u003d\u003d Operation.CONTINUE) {\n \t\t\t\tnewHead \u003d continueRebase();\n \n+\t\t\t\tif (newHead \u003d\u003d null) {\n+\t\t\t\t\t// continueRebase() returns null only if no commit was\n+\t\t\t\t\t// neccessary. This means that no changes where left over\n+\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n+\t\t\t\t\t// and displays a nice message to the user, telling him to\n+\t\t\t\t\t// either do changes or skip the commit instead of continue.\n+\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "557ea857e3b5229379476f1ee4160fcf5b695bbd": {
      "type": "Ybodychange",
      "commitMessage": "Implement rebase ff for upstream branches with merge commits\n\nChange Ib9898fe0f982fa08e41f1dca9452c43de715fdb6 added support for\nthe \u0027cherry-pick\u0027 fast forward case where the upstream commit history\ndoes not include any merge commits.  This change adds support for the\ncase where merge commits exist and the local branch has no changes.\n\nBug: 344779\nChange-Id: If203ce5aa1b4e5d4d7982deb621b710e71f4ee10\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011-05-18, 12:40 p.m.",
      "commitName": "557ea857e3b5229379476f1ee4160fcf5b695bbd",
      "commitAuthor": "Chris Aniszczyk",
      "commitDateOld": "2011-04-06, 2:28 p.m.",
      "commitNameOld": "6e10aa42e90a25b82f00f0c27574f57ffa9e4a25",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 41.93,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n\t\t\tJGitInternalException, GitAPIException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE)\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tupdateHead(headName, newHead);\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t\t\treturn RebaseResult.OK_RESULT;\n\t\t\t}\n\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 192,
      "functionName": "call",
      "diff": "@@ -1,118 +1,95 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n-\t\t\t\t\treturn abort(new RebaseResult(Status.ABORTED));\n+\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n-\t\t\t\treturn abort(new RebaseResult(Status.ABORTED));\n+\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation \u003d\u003d Operation.CONTINUE)\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n-\t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n-\t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n-\t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n-\t\t\t\t\trup.setNewObjectId(newHead);\n-\t\t\t\t\tResult res \u003d rup.forceUpdate();\n-\t\t\t\t\tswitch (res) {\n-\t\t\t\t\tcase FAST_FORWARD:\n-\t\t\t\t\tcase FORCED:\n-\t\t\t\t\tcase NO_CHANGE:\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n-\t\t\t\t\t}\n-\t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n-\t\t\t\t\tres \u003d rup.link(headName);\n-\t\t\t\t\tswitch (res) {\n-\t\t\t\t\tcase FAST_FORWARD:\n-\t\t\t\t\tcase FORCED:\n-\t\t\t\t\tcase NO_CHANGE:\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n-\t\t\t\t\treturn new RebaseResult(Status.FAST_FORWARD);\n-\t\t\t\treturn new RebaseResult(Status.OK);\n+\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n+\t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n-\t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n+\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0b5ad24915824a8c999bb6951b131a958e418306": {
      "type": "Ybodychange",
      "commitMessage": "Introduce FAILED result for RebaseCommand\n\nIn case an underlying cherry-pick fails due to uncommitted changes, a\nRebaseCommand shall fail and roll-back changes.\n\nChange-Id: Ic22eb047fb03ac2c8391f777036b7dbf22a1b061\nSigned-off-by: Philipp Thun \u003cphilipp.thun@sap.com\u003e\n",
      "commitDate": "2011-03-24, 7:24 a.m.",
      "commitName": "0b5ad24915824a8c999bb6951b131a958e418306",
      "commitAuthor": "Philipp Thun",
      "commitDateOld": "2011-03-23, 5:24 a.m.",
      "commitNameOld": "a21e508a318664dac23701ca29d5f0b64d36a76a",
      "commitAuthorOld": "Philipp Thun",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n\t\t\tJGitInternalException, GitAPIException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort(new RebaseResult(Status.ABORTED));\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort(new RebaseResult(Status.ABORTED));\n\n\t\t\tif (operation \u003d\u003d Operation.CONTINUE)\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\tif (operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t\t// unnecessary object rewriting\n\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\t\tif (!lastStepWasForward) {\n\t\t\t\t\t\t// TODO if the content of this commit is already merged\n\t\t\t\t\t\t// here we should skip this step in order to avoid\n\t\t\t\t\t\t// confusing pseudo-changed\n\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n\t\t\t\t\t\tcase FAILED:\n\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase CONFLICTING:\n\t\t\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t\t\tcase OK:\n\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmonitor.endTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\t// point the previous head (if any) to the new commit\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n\t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n\t\t\t\t\trup.setNewObjectId(newHead);\n\t\t\t\t\tResult res \u003d rup.forceUpdate();\n\t\t\t\t\tswitch (res) {\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase NO_CHANGE:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n\t\t\t\t\t}\n\t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tres \u003d rup.link(headName);\n\t\t\t\t\tswitch (res) {\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase NO_CHANGE:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn new RebaseResult(Status.FAST_FORWARD);\n\t\t\t\treturn new RebaseResult(Status.OK);\n\t\t\t}\n\t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 192,
      "functionName": "call",
      "diff": "@@ -1,104 +1,118 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n-\t\t\t\t\treturn abort();\n+\t\t\t\t\treturn abort(new RebaseResult(Status.ABORTED));\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n-\t\t\t\treturn abort();\n+\t\t\t\treturn abort(new RebaseResult(Status.ABORTED));\n \n-\t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n+\t\t\tif (operation \u003d\u003d Operation.CONTINUE)\n \t\t\t\tnewHead \u003d continueRebase();\n \n-\t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n+\t\t\tif (operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n-\t\t\t\tmonitor.beginTask(MessageFormat.format(\n-\t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n-\t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n-\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n-\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n-\t\t\t\t// unnecessary object rewriting\n-\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n-\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n-\t\t\t\tif (!lastStepWasForward)\n-\t\t\t\t\t// TODO if the content of this commit is already merged here\n-\t\t\t\t\t// we should skip this step in order to avoid confusing\n-\t\t\t\t\t// pseudo-changed\n-\t\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n-\t\t\t\t\t\t\t.call().getNewHead();\n-\t\t\t\tmonitor.endTask();\n-\t\t\t\tif (newHead \u003d\u003d null) {\n-\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\ttry {\n+\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n+\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n+\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n+\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n+\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n+\t\t\t\t\t// unnecessary object rewriting\n+\t\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n+\t\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n+\t\t\t\t\tif (!lastStepWasForward) {\n+\t\t\t\t\t\t// TODO if the content of this commit is already merged\n+\t\t\t\t\t\t// here we should skip this step in order to avoid\n+\t\t\t\t\t\t// confusing pseudo-changed\n+\t\t\t\t\t\tCherryPickResult cherryPickResult \u003d new Git(repo)\n+\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n+\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n+\t\t\t\t\t\tcase FAILED:\n+\t\t\t\t\t\t\tif (operation \u003d\u003d Operation.BEGIN)\n+\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n+\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n+\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\t\t\tcase CONFLICTING:\n+\t\t\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\t\t\tcase OK:\n+\t\t\t\t\t\t\tnewHead \u003d cherryPickResult.getNewHead();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} finally {\n+\t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\tResult res \u003d rup.forceUpdate();\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\tres \u003d rup.link(headName);\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn new RebaseResult(Status.FAST_FORWARD);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a21e508a318664dac23701ca29d5f0b64d36a76a": {
      "type": "Ybodychange",
      "commitMessage": "Introduce CherryPickResult\n\nIn order to distinguish cherry-pick failures caused by conflicts vs.\n\u0027abnormal failures\u0027 (e.g. due to unstaged changes or a dirty\nworktree), a CherryPickResult class is introduced and returned by\nCherryPickCommand.call() instead of a RevCommit. This new class is\nsimilar to MergeResult and RebaseResult. The CherryPickResult contains\nall necessary information, e.g. paths causing the cherry-pick (a merge\ncalled within, respectively) to fail. This allows callers to better\nreact on failures.\n\nChange-Id: I5db57b9259e82ed118e4bf4ec94463efe68b8c1f\nSigned-off-by: Philipp Thun \u003cphilipp.thun@sap.com\u003e\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e",
      "commitDate": "2011-03-23, 5:24 a.m.",
      "commitName": "a21e508a318664dac23701ca29d5f0b64d36a76a",
      "commitAuthor": "Philipp Thun",
      "commitDateOld": "2011-01-31, 6:12 a.m.",
      "commitNameOld": "b15b9d5df25b375108ca125b31338df637454865",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 50.92,
      "commitsBetweenForRepo": 158,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n\t\t\tJGitInternalException, GitAPIException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort();\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort();\n\n\t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n\t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t// unnecessary object rewriting\n\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\tif (!lastStepWasForward)\n\t\t\t\t\t// TODO if the content of this commit is already merged here\n\t\t\t\t\t// we should skip this step in order to avoid confusing\n\t\t\t\t\t// pseudo-changed\n\t\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t.call().getNewHead();\n\t\t\t\tmonitor.endTask();\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\t// point the previous head (if any) to the new commit\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n\t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n\t\t\t\t\trup.setNewObjectId(newHead);\n\t\t\t\t\tResult res \u003d rup.forceUpdate();\n\t\t\t\t\tswitch (res) {\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase NO_CHANGE:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n\t\t\t\t\t}\n\t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tres \u003d rup.link(headName);\n\t\t\t\t\tswitch (res) {\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase NO_CHANGE:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn new RebaseResult(Status.FAST_FORWARD);\n\t\t\t\treturn new RebaseResult(Status.OK);\n\t\t\t}\n\t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 192,
      "functionName": "call",
      "diff": "@@ -1,104 +1,104 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead \u003d null;\n \t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n \t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n \t\t\t\tif (!lastStepWasForward)\n \t\t\t\t\t// TODO if the content of this commit is already merged here\n \t\t\t\t\t// we should skip this step in order to avoid confusing\n \t\t\t\t\t// pseudo-changed\n \t\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n-\t\t\t\t\t\t\t.call();\n+\t\t\t\t\t\t\t.call().getNewHead();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead \u003d\u003d null) {\n \t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\tResult res \u003d rup.forceUpdate();\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\tres \u003d rup.link(headName);\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn new RebaseResult(Status.FAST_FORWARD);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e8a1328d05aa55b7ace0d101e34b87422219c959": {
      "type": "Ybodychange",
      "commitMessage": "RebaseCommand: detect and handle fast-forward properly\n\nThis bug was hidden by an incomplete test: the current Rebase\nimplementation using the \"git rebase -i\" pattern does not work\ncorrectly if fast-forwarding is involved. The reason for this is that\nthe log command does not return any commits in this case.\nIn addition, a check for already merged commits was introduced to\navoid spurious conflicts.\n\nChange-Id: Ib9898fe0f982fa08e41f1dca9452c43de715fdb6\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2011-01-28, 9:03 a.m.",
      "commitName": "e8a1328d05aa55b7ace0d101e34b87422219c959",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2011-01-27, 7:11 p.m.",
      "commitNameOld": "38eec8f4a26935ba9e75bfbdde8a5682e05f338d",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 0.58,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n\t\t\tJGitInternalException, GitAPIException {\n\t\tRevCommit newHead \u003d null;\n\t\tboolean lastStepWasForward \u003d false;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort();\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort();\n\n\t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n\t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n\t\t\t\t// unnecessary object rewriting\n\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n\t\t\t\tif (!lastStepWasForward)\n\t\t\t\t\t// TODO if the content of this commit is already merged here\n\t\t\t\t\t// we should skip this step in order to avoid confusing\n\t\t\t\t\t// pseudo-changed\n\t\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n\t\t\t\t\t\t\t.call();\n\t\t\t\tmonitor.endTask();\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\t// point the previous head (if any) to the new commit\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n\t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n\t\t\t\t\trup.setNewObjectId(newHead);\n\t\t\t\t\tResult res \u003d rup.forceUpdate();\n\t\t\t\t\tswitch (res) {\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase NO_CHANGE:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n\t\t\t\t\t}\n\t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tres \u003d rup.link(headName);\n\t\t\t\t\tswitch (res) {\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase NO_CHANGE:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\tif (lastStepWasForward)\n\t\t\t\t\treturn new RebaseResult(Status.FAST_FORWARD);\n\t\t\t\treturn new RebaseResult(Status.OK);\n\t\t\t}\n\t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 191,
      "functionName": "call",
      "diff": "@@ -1,95 +1,104 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead \u003d null;\n+\t\tboolean lastStepWasForward \u003d false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n-\t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n-\t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n+\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n+\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n-\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n-\t\t\t\t\t\t.call();\n+\t\t\t\tnewHead \u003d tryFastForward(commitToPick);\n+\t\t\t\tlastStepWasForward \u003d newHead !\u003d null;\n+\t\t\t\tif (!lastStepWasForward)\n+\t\t\t\t\t// TODO if the content of this commit is already merged here\n+\t\t\t\t\t// we should skip this step in order to avoid confusing\n+\t\t\t\t\t// pseudo-changed\n+\t\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n+\t\t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead \u003d\u003d null) {\n \t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\tResult res \u003d rup.forceUpdate();\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\tres \u003d rup.link(headName);\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n+\t\t\t\tif (lastStepWasForward)\n+\t\t\t\t\treturn new RebaseResult(Status.FAST_FORWARD);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9b039b42e0ecf69640c5f1a34ee72a86dba3f1c2": {
      "type": "Ybodychange",
      "commitMessage": "Rebase: abort on unknown/unsupported command in git-rebase-todo\n\nThis is needed to ensure interoperability with the command line: if\nthe git-rebase-todo file was created manually (by git rebase -i in the\ncommand line), and any commands other than pick are used (reword,\nedit, fixup, squash) JGit must abort as it does not understand these\ncommands yet.\nThe same is true if an unknown command is found (e.g. due to a typo);\nthis is the same behavior as shown by the command line.\n\nChange-Id: I2322014f69460361f7fc09da223e8a5c31f100dd\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2010-12-10, 3:44 a.m.",
      "commitName": "9b039b42e0ecf69640c5f1a34ee72a86dba3f1c2",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010-12-09, 1:22 p.m.",
      "commitNameOld": "2a7cd0086bf1bd614478c5722eac5142326e6f2b",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 0.6,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n\t\t\tJGitInternalException, GitAPIException {\n\t\tRevCommit newHead \u003d null;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort();\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort();\n\n\t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tfor (Step step : steps) {\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n\t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n\t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n\t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n\t\t\t\t// unnecessary object rewriting\n\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n\t\t\t\t\t\t.call();\n\t\t\t\tmonitor.endTask();\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\t// point the previous head (if any) to the new commit\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n\t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n\t\t\t\t\trup.setNewObjectId(newHead);\n\t\t\t\t\tResult res \u003d rup.forceUpdate();\n\t\t\t\t\tswitch (res) {\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase NO_CHANGE:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n\t\t\t\t\t}\n\t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tres \u003d rup.link(headName);\n\t\t\t\t\tswitch (res) {\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase NO_CHANGE:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\treturn new RebaseResult(Status.OK);\n\t\t\t}\n\t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 189,
      "functionName": "call",
      "diff": "@@ -1,97 +1,95 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead \u003d null;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n \t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n \t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tfor (Step step : steps) {\n-\t\t\t\tif (step.action !\u003d Action.PICK)\n-\t\t\t\t\tcontinue;\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n \t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead \u003d\u003d null) {\n \t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\tResult res \u003d rup.forceUpdate();\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\tres \u003d rup.link(headName);\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2a7cd0086bf1bd614478c5722eac5142326e6f2b": {
      "type": "Ybodychange",
      "commitMessage": "Rebase: fix wrong update if original HEAD after Merge+Skip\n\nRebase would update the original HEAD to the wrong commit when\n\"skipping\" the last commit after a merged commit.\n\nIncludes a test for the specific situation.\n\nChange-Id: I087314b1834a3f11a4561f04ca5c21411d54d993\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2010-12-09, 1:22 p.m.",
      "commitName": "2a7cd0086bf1bd614478c5722eac5142326e6f2b",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010-12-09, 10:10 a.m.",
      "commitNameOld": "6bca46e1683a07f18f00f6ad552eab79ab50bb88",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n\t\t\tJGitInternalException, GitAPIException {\n\t\tRevCommit newHead \u003d null;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort();\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort();\n\n\t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n\t\t\t\tnewHead \u003d checkoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tfor (Step step : steps) {\n\t\t\t\tif (step.action !\u003d Action.PICK)\n\t\t\t\t\tcontinue;\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n\t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n\t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n\t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n\t\t\t\t// unnecessary object rewriting\n\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n\t\t\t\t\t\t.call();\n\t\t\t\tmonitor.endTask();\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\t// point the previous head (if any) to the new commit\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n\t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n\t\t\t\t\trup.setNewObjectId(newHead);\n\t\t\t\t\tResult res \u003d rup.forceUpdate();\n\t\t\t\t\tswitch (res) {\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase NO_CHANGE:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n\t\t\t\t\t}\n\t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\tres \u003d rup.link(headName);\n\t\t\t\t\tswitch (res) {\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase NO_CHANGE:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\treturn new RebaseResult(Status.OK);\n\t\t\t}\n\t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 189,
      "functionName": "call",
      "diff": "@@ -1,89 +1,97 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead \u003d null;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n \t\t\t\tnewHead \u003d continueRebase();\n \n-\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n-\n-\t\t\tif (this.operation \u003d\u003d Operation.SKIP \u0026\u0026 !steps.isEmpty())\n-\t\t\t\tcheckoutCurrentHead();\n+\t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n+\t\t\t\tnewHead \u003d checkoutCurrentHead();\n \n \t\t\tObjectReader or \u003d repo.newObjectReader();\n-\t\t\tint stepsToPop \u003d 0;\n \n+\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tif (step.action !\u003d Action.PICK)\n \t\t\t\t\tcontinue;\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n \t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead \u003d\u003d null) {\n \t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n-\t\t\t\tstepsToPop++;\n \t\t\t}\n-\t\t\tif (newHead !\u003d null || steps.isEmpty()) {\n+\t\t\tif (newHead !\u003d null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n-\t\t\t\t\tif (newHead !\u003d null) {\n-\t\t\t\t\t\trup.setNewObjectId(newHead);\n-\t\t\t\t\t\trup.forceUpdate();\n+\t\t\t\t\trup.setNewObjectId(newHead);\n+\t\t\t\t\tResult res \u003d rup.forceUpdate();\n+\t\t\t\t\tswitch (res) {\n+\t\t\t\t\tcase FAST_FORWARD:\n+\t\t\t\t\tcase FORCED:\n+\t\t\t\t\tcase NO_CHANGE:\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n-\t\t\t\t\trup.link(headName);\n-\t\t\t\t}\n-\t\t\t\tif (this.operation \u003d\u003d Operation.SKIP \u0026\u0026 steps.isEmpty()) {\n-\t\t\t\t\tcheckoutCurrentHead();\n+\t\t\t\t\tres \u003d rup.link(headName);\n+\t\t\t\t\tswitch (res) {\n+\t\t\t\t\tcase FAST_FORWARD:\n+\t\t\t\t\tcase FORCED:\n+\t\t\t\t\tcase NO_CHANGE:\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6bca46e1683a07f18f00f6ad552eab79ab50bb88": {
      "type": "Ybodychange",
      "commitMessage": "Implement rebase --continue and --skip\n\nFor --continue, the Rebase command asserts that there are no unmerged\npaths in the current repository. Then it checks if a commit is needed.\nIf yes, the commit message and author are taken from the author_script\nand message files, respectively, and a commit is performed before the\nnext step is applied.\nFor --skip, the workspace is reset to the current HEAD before applying\nthe next step.\n\nIncludes some tests and a refactoring that extracts Strings in the\ncode into constants.\n\n\nChange-Id: I72d9968535727046e737ec20e23239fe79976179\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2010-12-09, 10:10 a.m.",
      "commitName": "6bca46e1683a07f18f00f6ad552eab79ab50bb88",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010-12-07, 7:18 p.m.",
      "commitNameOld": "45731756a56361a51e839e26d3b0bed1c06ee37a",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 1.62,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n\t\t\tJGitInternalException, GitAPIException {\n\t\tRevCommit newHead \u003d null;\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort();\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort();\n\n\t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n\t\t\t\tnewHead \u003d continueRebase();\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\n\t\t\tif (this.operation \u003d\u003d Operation.SKIP \u0026\u0026 !steps.isEmpty())\n\t\t\t\tcheckoutCurrentHead();\n\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\t\t\tint stepsToPop \u003d 0;\n\n\t\t\tfor (Step step : steps) {\n\t\t\t\tif (step.action !\u003d Action.PICK)\n\t\t\t\t\tcontinue;\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n\t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n\t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n\t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n\t\t\t\t// unnecessary object rewriting\n\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n\t\t\t\t\t\t.call();\n\t\t\t\tmonitor.endTask();\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t}\n\t\t\t\tstepsToPop++;\n\t\t\t}\n\t\t\tif (newHead !\u003d null || steps.isEmpty()) {\n\t\t\t\t// point the previous head (if any) to the new commit\n\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n\t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n\t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n\t\t\t\t\tif (newHead !\u003d null) {\n\t\t\t\t\t\trup.setNewObjectId(newHead);\n\t\t\t\t\t\trup.forceUpdate();\n\t\t\t\t\t}\n\t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\trup.link(headName);\n\t\t\t\t}\n\t\t\t\tif (this.operation \u003d\u003d Operation.SKIP \u0026\u0026 steps.isEmpty()) {\n\t\t\t\t\tcheckoutCurrentHead();\n\t\t\t\t}\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\treturn new RebaseResult(Status.OK);\n\t\t\t}\n\t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 189,
      "functionName": "call",
      "diff": "@@ -1,86 +1,89 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n+\t\tRevCommit newHead \u003d null;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n-\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n+\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n-\t\t\t\tthrow new UnsupportedOperationException(\n-\t\t\t\t\t\t\"--continue Not yet implemented\");\n-\n-\t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n-\t\t\t\tthrow new UnsupportedOperationException(\n-\t\t\t\t\t\t\"--skip Not yet implemented\");\n-\n-\t\t\tRevCommit newHead \u003d null;\n+\t\t\t\tnewHead \u003d continueRebase();\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n+\n+\t\t\tif (this.operation \u003d\u003d Operation.SKIP \u0026\u0026 !steps.isEmpty())\n+\t\t\t\tcheckoutCurrentHead();\n+\n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \t\t\tint stepsToPop \u003d 0;\n \n \t\t\tfor (Step step : steps) {\n \t\t\t\tif (step.action !\u003d Action.PICK)\n \t\t\t\t\tcontinue;\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n \t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead \u003d\u003d null) {\n \t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n \t\t\t\tstepsToPop++;\n \t\t\t}\n-\t\t\tif (newHead !\u003d null) {\n+\t\t\tif (newHead !\u003d null || steps.isEmpty()) {\n \t\t\t\t// point the previous head (if any) to the new commit\n-\t\t\t\tString headName \u003d readFile(rebaseDir, \"head-name\");\n+\t\t\t\tString headName \u003d readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n-\t\t\t\t\trup.setNewObjectId(newHead);\n-\t\t\t\t\trup.forceUpdate();\n+\t\t\t\t\tif (newHead !\u003d null) {\n+\t\t\t\t\t\trup.setNewObjectId(newHead);\n+\t\t\t\t\t\trup.forceUpdate();\n+\t\t\t\t\t}\n \t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\trup.link(headName);\n \t\t\t\t}\n+\t\t\t\tif (this.operation \u003d\u003d Operation.SKIP \u0026\u0026 steps.isEmpty()) {\n+\t\t\t\t\tcheckoutCurrentHead();\n+\t\t\t\t}\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45731756a56361a51e839e26d3b0bed1c06ee37a": {
      "type": "Ybodychange",
      "commitMessage": "[findbugs] Do not ignore exceptional return value\n\njava.io.File.delete() reports failure as an exceptional\nreturn value false. Fix the code which silently ignored\nthis exceptional return value. Also remove some duplicate\ndeletion helper methods.\n\nChange-Id: I80ed20ca1f07a2bc6e779957a4ad0c713789c5be\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2010-12-07, 7:18 p.m.",
      "commitName": "45731756a56361a51e839e26d3b0bed1c06ee37a",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2010-12-07, 7:34 a.m.",
      "commitNameOld": "ad96546ca023c260ed7250c447f4c8abe168afd3",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 0.49,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n\t\t\tJGitInternalException, GitAPIException {\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort();\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort();\n\n\t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n\t\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\t\"--continue Not yet implemented\");\n\n\t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n\t\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\t\"--skip Not yet implemented\");\n\n\t\t\tRevCommit newHead \u003d null;\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\t\t\tint stepsToPop \u003d 0;\n\n\t\t\tfor (Step step : steps) {\n\t\t\t\tif (step.action !\u003d Action.PICK)\n\t\t\t\t\tcontinue;\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n\t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n\t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n\t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n\t\t\t\t// unnecessary object rewriting\n\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n\t\t\t\t\t\t.call();\n\t\t\t\tmonitor.endTask();\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t}\n\t\t\t\tstepsToPop++;\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\t// point the previous head (if any) to the new commit\n\t\t\t\tString headName \u003d readFile(rebaseDir, \"head-name\");\n\t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n\t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n\t\t\t\t\trup.setNewObjectId(newHead);\n\t\t\t\t\trup.forceUpdate();\n\t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\trup.link(headName);\n\t\t\t\t}\n\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n\t\t\t\treturn new RebaseResult(Status.OK);\n\t\t\t}\n\t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 146,
      "functionName": "call",
      "diff": "@@ -1,86 +1,86 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n \t\t\t\tthrow new UnsupportedOperationException(\n \t\t\t\t\t\t\"--continue Not yet implemented\");\n \n \t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n \t\t\t\tthrow new UnsupportedOperationException(\n \t\t\t\t\t\t\"--skip Not yet implemented\");\n \n \t\t\tRevCommit newHead \u003d null;\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \t\t\tint stepsToPop \u003d 0;\n \n \t\t\tfor (Step step : steps) {\n \t\t\t\tif (step.action !\u003d Action.PICK)\n \t\t\t\t\tcontinue;\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n \t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead \u003d\u003d null) {\n \t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n \t\t\t\tstepsToPop++;\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName \u003d readFile(rebaseDir, \"head-name\");\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\trup.forceUpdate();\n \t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\trup.link(headName);\n \t\t\t\t}\n-\t\t\t\tdeleteRecursive(rebaseDir);\n+\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad96546ca023c260ed7250c447f4c8abe168afd3": {
      "type": "Ybodychange",
      "commitMessage": "Rebase Interoperability third part: handle stop upon conflict\n\nThere are some files that need to exist so that the CLI can continue\nafter the rebase has been stopped due to conflicts\n\nChange-Id: I3cb4dc98609c059bf0cf9fd5f9e47a9c681cea2d\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2010-12-07, 7:34 a.m.",
      "commitName": "ad96546ca023c260ed7250c447f4c8abe168afd3",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010-12-01, 9:10 a.m.",
      "commitNameOld": "59e62ba7e10188c6170bd97ffbd9c8768d9745ea",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 5.93,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n\t\t\tJGitInternalException, GitAPIException {\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort();\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort();\n\n\t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n\t\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\t\"--continue Not yet implemented\");\n\n\t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n\t\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\t\"--skip Not yet implemented\");\n\n\t\t\tRevCommit newHead \u003d null;\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\t\t\tint stepsToPop \u003d 0;\n\n\t\t\tfor (Step step : steps) {\n\t\t\t\tif (step.action !\u003d Action.PICK)\n\t\t\t\t\tcontinue;\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n\t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n\t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n\t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n\t\t\t\t// unnecessary object rewriting\n\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n\t\t\t\t\t\t.call();\n\t\t\t\tmonitor.endTask();\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\treturn stop(commitToPick);\n\t\t\t\t}\n\t\t\t\tstepsToPop++;\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\t// point the previous head (if any) to the new commit\n\t\t\t\tString headName \u003d readFile(rebaseDir, \"head-name\");\n\t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n\t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n\t\t\t\t\trup.setNewObjectId(newHead);\n\t\t\t\t\trup.forceUpdate();\n\t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\trup.link(headName);\n\t\t\t\t}\n\t\t\t\tdeleteRecursive(rebaseDir);\n\t\t\t\treturn new RebaseResult(Status.OK);\n\t\t\t}\n\t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 145,
      "functionName": "call",
      "diff": "@@ -1,86 +1,86 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n \t\t\t\tthrow new UnsupportedOperationException(\n \t\t\t\t\t\t\"--continue Not yet implemented\");\n \n \t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n \t\t\t\tthrow new UnsupportedOperationException(\n \t\t\t\t\t\t\"--skip Not yet implemented\");\n \n \t\t\tRevCommit newHead \u003d null;\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \t\t\tint stepsToPop \u003d 0;\n \n \t\t\tfor (Step step : steps) {\n \t\t\t\tif (step.action !\u003d Action.PICK)\n \t\t\t\t\tcontinue;\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n \t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead \u003d\u003d null) {\n-\t\t\t\t\treturn new RebaseResult(commitToPick);\n+\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n \t\t\t\tstepsToPop++;\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName \u003d readFile(rebaseDir, \"head-name\");\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\trup.forceUpdate();\n \t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\trup.link(headName);\n \t\t\t\t}\n \t\t\t\tdeleteRecursive(rebaseDir);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59e62ba7e10188c6170bd97ffbd9c8768d9745ea": {
      "type": "Ybodychange",
      "commitMessage": "Rebase Interoperability second part: fix \"pop steps\"\n\nIf the CLI stops a rebase upon conflict, the current\nstep is already popped from the git-rebase-todo and appended to the\n\"done\" file. The current implementation wrongly pops the step only\nafter successful cherry-pick.\n\nChange-Id: I8640dda0cbb2a5271ecf75fcbad69410122eeab6\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2010-12-01, 9:10 a.m.",
      "commitName": "59e62ba7e10188c6170bd97ffbd9c8768d9745ea",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010-12-01, 9:08 a.m.",
      "commitNameOld": "7aa1b85821e007c0243772273960069497284290",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n\t\t\tJGitInternalException, GitAPIException {\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort();\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort();\n\n\t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n\t\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\t\"--continue Not yet implemented\");\n\n\t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n\t\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\t\"--skip Not yet implemented\");\n\n\t\t\tRevCommit newHead \u003d null;\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\t\t\tint stepsToPop \u003d 0;\n\n\t\t\tfor (Step step : steps) {\n\t\t\t\tif (step.action !\u003d Action.PICK)\n\t\t\t\t\tcontinue;\n\t\t\t\tpopSteps(1);\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n\t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n\t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n\t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n\t\t\t\t// unnecessary object rewriting\n\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n\t\t\t\t\t\t.call();\n\t\t\t\tmonitor.endTask();\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\t}\n\t\t\t\tstepsToPop++;\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\t// point the previous head (if any) to the new commit\n\t\t\t\tString headName \u003d readFile(rebaseDir, \"head-name\");\n\t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n\t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n\t\t\t\t\trup.setNewObjectId(newHead);\n\t\t\t\t\trup.forceUpdate();\n\t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\trup.link(headName);\n\t\t\t\t}\n\t\t\t\tdeleteRecursive(rebaseDir);\n\t\t\t\treturn new RebaseResult(Status.OK);\n\t\t\t}\n\t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 143,
      "functionName": "call",
      "diff": "@@ -1,86 +1,86 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n \t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n \t\t\t\tif (res !\u003d null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n \t\t\t\tthrow new UnsupportedOperationException(\n \t\t\t\t\t\t\"--continue Not yet implemented\");\n \n \t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n \t\t\t\tthrow new UnsupportedOperationException(\n \t\t\t\t\t\t\"--skip Not yet implemented\");\n \n \t\t\tRevCommit newHead \u003d null;\n \n \t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n \t\t\tObjectReader or \u003d repo.newObjectReader();\n \t\t\tint stepsToPop \u003d 0;\n \n \t\t\tfor (Step step : steps) {\n \t\t\t\tif (step.action !\u003d Action.PICK)\n \t\t\t\t\tcontinue;\n+\t\t\t\tpopSteps(1);\n \t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n \t\t\t\tif (ids.size() !\u003d 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick \u003d walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n \t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead \u003d\u003d null) {\n-\t\t\t\t\tpopSteps(stepsToPop);\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\t}\n \t\t\t\tstepsToPop++;\n \t\t\t}\n \t\t\tif (newHead !\u003d null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName \u003d readFile(rebaseDir, \"head-name\");\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\trup.forceUpdate();\n \t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\t\trup.link(headName);\n \t\t\t\t}\n \t\t\t\tdeleteRecursive(rebaseDir);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e5b96a7848d680cf50123a44cbc147db91d798d3": {
      "type": "Yintroduced",
      "commitMessage": "Initial implementation of a Rebase command\n\nThis is a first iteration to implement Rebase. At the moment, this\ndoes not implement --continue and --skip, so if the first\nconflict is found, the only option is to --abort the command.\n\nBug: 328217\nChange-Id: I24d60c0214e71e5572955f8261e10a42e9e95298\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2010-11-22, 10:58 a.m.",
      "commitName": "e5b96a7848d680cf50123a44cbc147db91d798d3",
      "commitAuthor": "Mathias Kinzler",
      "diff": "@@ -0,0 +1,86 @@\n+\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n+\t\t\tJGitInternalException, GitAPIException {\n+\t\tcheckCallable();\n+\t\tcheckParameters();\n+\t\ttry {\n+\t\t\tswitch (operation) {\n+\t\t\tcase ABORT:\n+\t\t\t\ttry {\n+\t\t\t\t\treturn abort();\n+\t\t\t\t} catch (IOException ioe) {\n+\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n+\t\t\t\t}\n+\t\t\tcase SKIP:\n+\t\t\t\t// fall through\n+\t\t\tcase CONTINUE:\n+\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n+\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n+\t\t\t\t\t\t.resolve(upstreamCommitName));\n+\t\t\t\tbreak;\n+\t\t\tcase BEGIN:\n+\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n+\t\t\t\tif (res !\u003d null)\n+\t\t\t\t\treturn res;\n+\t\t\t}\n+\n+\t\t\tif (monitor.isCancelled())\n+\t\t\t\treturn abort();\n+\n+\t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n+\t\t\t\tthrow new UnsupportedOperationException(\n+\t\t\t\t\t\t\"--continue Not yet implemented\");\n+\n+\t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n+\t\t\t\tthrow new UnsupportedOperationException(\n+\t\t\t\t\t\t\"--skip Not yet implemented\");\n+\n+\t\t\tRevCommit newHead \u003d null;\n+\n+\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n+\t\t\tObjectReader or \u003d repo.newObjectReader();\n+\t\t\tint stepsToPop \u003d 0;\n+\n+\t\t\tfor (Step step : steps) {\n+\t\t\t\tif (step.action !\u003d Action.PICK)\n+\t\t\t\t\tcontinue;\n+\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n+\t\t\t\tif (ids.size() !\u003d 1)\n+\t\t\t\t\tthrow new JGitInternalException(\n+\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n+\t\t\t\tRevCommit commitToPick \u003d walk\n+\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n+\t\t\t\tif (monitor.isCancelled())\n+\t\t\t\t\treturn new RebaseResult(commitToPick);\n+\t\t\t\tmonitor.beginTask(MessageFormat.format(\n+\t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n+\t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n+\t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n+\t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n+\t\t\t\t// unnecessary object rewriting\n+\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n+\t\t\t\t\t\t.call();\n+\t\t\t\tmonitor.endTask();\n+\t\t\t\tif (newHead \u003d\u003d null) {\n+\t\t\t\t\tpopSteps(stepsToPop);\n+\t\t\t\t\treturn new RebaseResult(commitToPick);\n+\t\t\t\t}\n+\t\t\t\tstepsToPop++;\n+\t\t\t}\n+\t\t\tif (newHead !\u003d null) {\n+\t\t\t\t// point the previous head (if any) to the new commit\n+\t\t\t\tString headName \u003d readFile(rebaseDir, \"head-name\");\n+\t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n+\t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n+\t\t\t\t\trup.setNewObjectId(newHead);\n+\t\t\t\t\trup.forceUpdate();\n+\t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n+\t\t\t\t\trup.link(headName);\n+\t\t\t\t}\n+\t\t\t\tdeleteRecursive(rebaseDir);\n+\t\t\t\treturn new RebaseResult(Status.OK);\n+\t\t\t}\n+\t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n+\t\t} catch (IOException ioe) {\n+\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n+\t\t}\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n\t\t\tJGitInternalException, GitAPIException {\n\t\tcheckCallable();\n\t\tcheckParameters();\n\t\ttry {\n\t\t\tswitch (operation) {\n\t\t\tcase ABORT:\n\t\t\t\ttry {\n\t\t\t\t\treturn abort();\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t\t\t}\n\t\t\tcase SKIP:\n\t\t\t\t// fall through\n\t\t\tcase CONTINUE:\n\t\t\t\tString upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n\t\t\t\tthis.upstreamCommit \u003d walk.parseCommit(repo\n\t\t\t\t\t\t.resolve(upstreamCommitName));\n\t\t\t\tbreak;\n\t\t\tcase BEGIN:\n\t\t\t\tRebaseResult res \u003d initFilesAndRewind();\n\t\t\t\tif (res !\u003d null)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\treturn abort();\n\n\t\t\tif (this.operation \u003d\u003d Operation.CONTINUE)\n\t\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\t\"--continue Not yet implemented\");\n\n\t\t\tif (this.operation \u003d\u003d Operation.SKIP)\n\t\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\t\"--skip Not yet implemented\");\n\n\t\t\tRevCommit newHead \u003d null;\n\n\t\t\tList\u003cStep\u003e steps \u003d loadSteps();\n\t\t\tObjectReader or \u003d repo.newObjectReader();\n\t\t\tint stepsToPop \u003d 0;\n\n\t\t\tfor (Step step : steps) {\n\t\t\t\tif (step.action !\u003d Action.PICK)\n\t\t\t\t\tcontinue;\n\t\t\t\tCollection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n\t\t\t\tif (ids.size() !\u003d 1)\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n\t\t\t\tRevCommit commitToPick \u003d walk\n\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n\t\t\t\tif (monitor.isCancelled())\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\tmonitor.beginTask(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n\t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n\t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n\t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n\t\t\t\t// unnecessary object rewriting\n\t\t\t\tnewHead \u003d new Git(repo).cherryPick().include(commitToPick)\n\t\t\t\t\t\t.call();\n\t\t\t\tmonitor.endTask();\n\t\t\t\tif (newHead \u003d\u003d null) {\n\t\t\t\t\tpopSteps(stepsToPop);\n\t\t\t\t\treturn new RebaseResult(commitToPick);\n\t\t\t\t}\n\t\t\t\tstepsToPop++;\n\t\t\t}\n\t\t\tif (newHead !\u003d null) {\n\t\t\t\t// point the previous head (if any) to the new commit\n\t\t\t\tString headName \u003d readFile(rebaseDir, \"head-name\");\n\t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n\t\t\t\t\tRefUpdate rup \u003d repo.updateRef(headName);\n\t\t\t\t\trup.setNewObjectId(newHead);\n\t\t\t\t\trup.forceUpdate();\n\t\t\t\t\trup \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\t\trup.link(headName);\n\t\t\t\t}\n\t\t\t\tdeleteRecursive(rebaseDir);\n\t\t\t\treturn new RebaseResult(Status.OK);\n\t\t\t}\n\t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 143,
      "functionName": "call"
    }
  }
}