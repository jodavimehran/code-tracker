{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "H:\\Projects\\eclipse\\jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "MergeCommand.java",
  "functionName": "call",
  "functionId": "call",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
  "functionStartLine": 235,
  "functionEndLine": 444,
  "numCommitsSeen": 53,
  "timeTaken": 4001,
  "changeHistory": [
    "f6c4a492d06e0dd345679bfba3399dabbf778f41",
    "42e69409d796421bb1353279cfae463b19a43fe9",
    "2c29af786763c0c8d74741c86edbeff4e5140e35",
    "1c43af8b9794abcad7a4ac77c352626063aa1f05",
    "b13a285098305149b34924bce2679a0cd98d9b2c",
    "64a404803eaccc88d7d57567c5cd86b88c342bec",
    "4c236ff4bbf664fd177a33f42517b0eef52510c8",
    "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
    "0e73d395061d1bfee365acaa2f79c392175d13bf",
    "46f3007b52a5d12c5a973957128ac38680b20ab8",
    "48e36d8cb335382b99ec829d0dfe34be71ed49bb",
    "7dc8a4f089c1ca4762cf6fbf2e77898607a5820a",
    "545358577376bec8fc140a76ce0f72bf81cc0a94",
    "3a4ebc0c24b7732a57064299153794084fbfae59",
    "eb6093293022e468c2aea93a11f63b366e0d3891",
    "642ff2cd7dd6ae361e4993255ade89a32e20601f",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
    "318f3d464307e3efd8342852310c17e71a7282fe",
    "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
    "26b573862912b2faf3824bb18dfeb44a3b700014",
    "39ad503fcb0c293e9c6d47d653a0d52456d4760b",
    "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
    "c580c56c4def9639b603553b3d4cbc7117a30938",
    "5dbef3fa51053b37f68b44ed390cab6dc8336dcc",
    "dcf7bd9a8f7acafbd1461dc0414aded2db030983",
    "85f69c286b6c3225dcff05aba42910daefb28da0",
    "e43887b69e27672b80e55391e0ee255efe715ab9",
    "6290ca3a638d1ac999da6c11628f904b31972067",
    "fb1e500adc011dfaad1a6e68b23a9b254a77bf43",
    "67263e2056108e471d684c3cef9e719724b51220",
    "45e79a526c7ffebaf8e4758a6cb6b7af05716707",
    "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75",
    "75c9b2438594dc6ac125ff1bdf97022c7f429b78",
    "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
    "5b0e73b849d19c9f072c4c6738a5d5adae413112"
  ],
  "changeHistoryShort": {
    "f6c4a492d06e0dd345679bfba3399dabbf778f41": "Ybodychange",
    "42e69409d796421bb1353279cfae463b19a43fe9": "Ybodychange",
    "2c29af786763c0c8d74741c86edbeff4e5140e35": "Ybodychange",
    "1c43af8b9794abcad7a4ac77c352626063aa1f05": "Ybodychange",
    "b13a285098305149b34924bce2679a0cd98d9b2c": "Ybodychange",
    "64a404803eaccc88d7d57567c5cd86b88c342bec": "Ybodychange",
    "4c236ff4bbf664fd177a33f42517b0eef52510c8": "Ybodychange",
    "1e1fb9fc596603a44b0fff6d19eeba2b005d659d": "Ybodychange",
    "0e73d395061d1bfee365acaa2f79c392175d13bf": "Ybodychange",
    "46f3007b52a5d12c5a973957128ac38680b20ab8": "Ybodychange",
    "48e36d8cb335382b99ec829d0dfe34be71ed49bb": "Ybodychange",
    "7dc8a4f089c1ca4762cf6fbf2e77898607a5820a": "Ybodychange",
    "545358577376bec8fc140a76ce0f72bf81cc0a94": "Ybodychange",
    "3a4ebc0c24b7732a57064299153794084fbfae59": "Ybodychange",
    "eb6093293022e468c2aea93a11f63b366e0d3891": "Ybodychange",
    "642ff2cd7dd6ae361e4993255ade89a32e20601f": "Ybodychange",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": "Ybodychange",
    "318f3d464307e3efd8342852310c17e71a7282fe": "Ybodychange",
    "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214": "Ybodychange",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": "Yexceptionschange",
    "26b573862912b2faf3824bb18dfeb44a3b700014": "Ybodychange",
    "39ad503fcb0c293e9c6d47d653a0d52456d4760b": "Ybodychange",
    "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f": "Ybodychange",
    "c580c56c4def9639b603553b3d4cbc7117a30938": "Ybodychange",
    "5dbef3fa51053b37f68b44ed390cab6dc8336dcc": "Ybodychange",
    "dcf7bd9a8f7acafbd1461dc0414aded2db030983": "Ybodychange",
    "85f69c286b6c3225dcff05aba42910daefb28da0": "Ybodychange",
    "e43887b69e27672b80e55391e0ee255efe715ab9": "Ybodychange",
    "6290ca3a638d1ac999da6c11628f904b31972067": "Ybodychange",
    "fb1e500adc011dfaad1a6e68b23a9b254a77bf43": "Ybodychange",
    "67263e2056108e471d684c3cef9e719724b51220": "Ybodychange",
    "45e79a526c7ffebaf8e4758a6cb6b7af05716707": "Ymultichange(Yexceptionschange,Ybodychange)",
    "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75": "Ybodychange",
    "75c9b2438594dc6ac125ff1bdf97022c7f429b78": "Ybodychange",
    "515deaf7e503738b4c53c3c2dfd6d7acab3bef18": "Ybodychange",
    "5b0e73b849d19c9f072c4c6738a5d5adae413112": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f6c4a492d06e0dd345679bfba3399dabbf778f41": {
      "type": "Ybodychange",
      "commitMessage": "Repository: Deprecate #peel method\n\nCallers should use getRefDatabase().peel(ref) instead since it\ndoesn\u0027t swallow the IOException.\n\nAdapt all trivial callers to user the alternative.\n\nDescribeCommand still uses the deprecated method and is not adapted in\nthis change since it will require more refactoring to add handling of\nthe IOException.\n\nChange-Id: I14d4a95a5e0570548753b9fc5c03d024dc3ff832\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018-05-21, 10:49 p.m.",
      "commitName": "f6c4a492d06e0dd345679bfba3399dabbf778f41",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2018-04-18, 5:33 p.m.",
      "commitNameOld": "42e69409d796421bb1353279cfae463b19a43fe9",
      "commitAuthorOld": "Thomas Wolf",
      "daysBetweenCommits": 33.22,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tfallBackToConfiguration();\n\t\tcheckParameters();\n\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry (RevWalk revWalk \u003d new RevWalk(repo)) {\n\t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.getRefDatabase().peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.setProgressMonitor(monitor);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setProgressMonitor(monitor);\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tif (message !\u003d null)\n\t\t\t\t\t\tmergeMessage \u003d message;\n\t\t\t\t\telse\n\t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tmerger.setProgressMonitor(monitor);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t\tif (!resolveMerger.getModifiedFiles().isEmpty()) {\n\t\t\t\t\t\trepo.fireEvent(new WorkingTreeModifiedEvent(\n\t\t\t\t\t\t\t\tresolveMerger.getModifiedFiles(), null));\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.setProgressMonitor(monitor);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tObjectId newHeadId \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n\t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n\t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n\t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n\t\t\t\t\t\t\t\t\t.setInsertChangeId(insertChangeId)\n\t\t\t\t\t\t\t\t\t.call().getId();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t\tgetRepository().autoGC(monitor);\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHeadId, null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 235,
      "functionName": "call",
      "diff": "@@ -1,210 +1,210 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tfallBackToConfiguration();\n \t\tcheckParameters();\n \n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry (RevWalk revWalk \u003d new RevWalk(repo)) {\n \t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n-\t\t\tref \u003d repo.peel(ref);\n+\t\t\tref \u003d repo.getRefDatabase().peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.setProgressMonitor(monitor);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setProgressMonitor(monitor);\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tif (message !\u003d null)\n \t\t\t\t\t\tmergeMessage \u003d message;\n \t\t\t\t\telse\n \t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tmerger.setProgressMonitor(monitor);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t\tif (!resolveMerger.getModifiedFiles().isEmpty()) {\n \t\t\t\t\t\trepo.fireEvent(new WorkingTreeModifiedEvent(\n \t\t\t\t\t\t\t\tresolveMerger.getModifiedFiles(), null));\n \t\t\t\t\t}\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.setProgressMonitor(monitor);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tObjectId newHeadId \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 !squash) {\n \t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n \t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n \t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n \t\t\t\t\t\t\t\t\t.setInsertChangeId(insertChangeId)\n \t\t\t\t\t\t\t\t\t.call().getId();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t\tgetRepository().autoGC(monitor);\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHeadId, null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "42e69409d796421bb1353279cfae463b19a43fe9": {
      "type": "Ybodychange",
      "commitMessage": "Handle Gerrit Change-Ids for merge commits\n\nOtherwise successful, non-conflicting merges will never get a\nGerrit Change-Id.\n\nBug: 358206\nChange-Id: I9b599ad01d9f7332200c1d81a1ba6ce5ef990ab5\nSigned-off-by: Thomas Wolf \u003cthomas.wolf@paranor.ch\u003e",
      "commitDate": "2018-04-18, 5:33 p.m.",
      "commitName": "42e69409d796421bb1353279cfae463b19a43fe9",
      "commitAuthor": "Thomas Wolf",
      "commitDateOld": "2018-03-07, 12:46 a.m.",
      "commitNameOld": "2c29af786763c0c8d74741c86edbeff4e5140e35",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 42.66,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tfallBackToConfiguration();\n\t\tcheckParameters();\n\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry (RevWalk revWalk \u003d new RevWalk(repo)) {\n\t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.setProgressMonitor(monitor);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setProgressMonitor(monitor);\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tif (message !\u003d null)\n\t\t\t\t\t\tmergeMessage \u003d message;\n\t\t\t\t\telse\n\t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tmerger.setProgressMonitor(monitor);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t\tif (!resolveMerger.getModifiedFiles().isEmpty()) {\n\t\t\t\t\t\trepo.fireEvent(new WorkingTreeModifiedEvent(\n\t\t\t\t\t\t\t\tresolveMerger.getModifiedFiles(), null));\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.setProgressMonitor(monitor);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tObjectId newHeadId \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n\t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n\t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n\t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n\t\t\t\t\t\t\t\t\t.setInsertChangeId(insertChangeId)\n\t\t\t\t\t\t\t\t\t.call().getId();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t\tgetRepository().autoGC(monitor);\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHeadId, null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 235,
      "functionName": "call",
      "diff": "@@ -1,209 +1,210 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tfallBackToConfiguration();\n \t\tcheckParameters();\n \n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry (RevWalk revWalk \u003d new RevWalk(repo)) {\n \t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tref \u003d repo.peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.setProgressMonitor(monitor);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setProgressMonitor(monitor);\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tif (message !\u003d null)\n \t\t\t\t\t\tmergeMessage \u003d message;\n \t\t\t\t\telse\n \t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tmerger.setProgressMonitor(monitor);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t\tif (!resolveMerger.getModifiedFiles().isEmpty()) {\n \t\t\t\t\t\trepo.fireEvent(new WorkingTreeModifiedEvent(\n \t\t\t\t\t\t\t\tresolveMerger.getModifiedFiles(), null));\n \t\t\t\t\t}\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.setProgressMonitor(monitor);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tObjectId newHeadId \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 !squash) {\n \t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n \t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n \t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n+\t\t\t\t\t\t\t\t\t.setInsertChangeId(insertChangeId)\n \t\t\t\t\t\t\t\t\t.call().getId();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t\tgetRepository().autoGC(monitor);\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHeadId, null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2c29af786763c0c8d74741c86edbeff4e5140e35": {
      "type": "Ybodychange",
      "commitMessage": "MergeCommand: Open RevWalk in try-with-resource\n\nChange-Id: I45ce481cc198b8dc78e9c46b433504840597e982\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018-03-07, 12:46 a.m.",
      "commitName": "2c29af786763c0c8d74741c86edbeff4e5140e35",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2018-01-22, 6:48 p.m.",
      "commitNameOld": "1c43af8b9794abcad7a4ac77c352626063aa1f05",
      "commitAuthorOld": "Markus Duft",
      "daysBetweenCommits": 43.25,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tfallBackToConfiguration();\n\t\tcheckParameters();\n\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry (RevWalk revWalk \u003d new RevWalk(repo)) {\n\t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.setProgressMonitor(monitor);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setProgressMonitor(monitor);\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tif (message !\u003d null)\n\t\t\t\t\t\tmergeMessage \u003d message;\n\t\t\t\t\telse\n\t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tmerger.setProgressMonitor(monitor);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t\tif (!resolveMerger.getModifiedFiles().isEmpty()) {\n\t\t\t\t\t\trepo.fireEvent(new WorkingTreeModifiedEvent(\n\t\t\t\t\t\t\t\tresolveMerger.getModifiedFiles(), null));\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.setProgressMonitor(monitor);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tObjectId newHeadId \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n\t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n\t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n\t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n\t\t\t\t\t\t\t\t\t.call().getId();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t\tgetRepository().autoGC(monitor);\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHeadId, null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 233,
      "functionName": "call",
      "diff": "@@ -1,214 +1,209 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tfallBackToConfiguration();\n \t\tcheckParameters();\n \n-\t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n-\t\ttry {\n+\t\ttry (RevWalk revWalk \u003d new RevWalk(repo)) {\n \t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n-\t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tref \u003d repo.peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.setProgressMonitor(monitor);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setProgressMonitor(monitor);\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tif (message !\u003d null)\n \t\t\t\t\t\tmergeMessage \u003d message;\n \t\t\t\t\telse\n \t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tmerger.setProgressMonitor(monitor);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t\tif (!resolveMerger.getModifiedFiles().isEmpty()) {\n \t\t\t\t\t\trepo.fireEvent(new WorkingTreeModifiedEvent(\n \t\t\t\t\t\t\t\tresolveMerger.getModifiedFiles(), null));\n \t\t\t\t\t}\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.setProgressMonitor(monitor);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tObjectId newHeadId \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 !squash) {\n \t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n \t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n \t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n \t\t\t\t\t\t\t\t\t.call().getId();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t\tgetRepository().autoGC(monitor);\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHeadId, null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n-\t\t} finally {\n-\t\t\tif (revWalk !\u003d null)\n-\t\t\t\trevWalk.close();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1c43af8b9794abcad7a4ac77c352626063aa1f05": {
      "type": "Ybodychange",
      "commitMessage": "Progress reporting for checkout\n\nThe reason for the change is LFS: when using a lot of LFS files,\ncheckout can take quite some time on larger repositories. To avoid\n\"hanging\" UI, provide progress reporting.\n\nAlso implement (partial) progress reporting for cherry-pick, reset,\nrevert which are using checkout internally.\n\nThe feature is also useful without LFS, so it is independent of it.\n\nChange-Id: I021e764241f3c107eaf2771f6b5785245b146b42\nSigned-off-by: Markus Duft \u003cmarkus.duft@ssi-schaefer.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2018-01-22, 6:48 p.m.",
      "commitName": "1c43af8b9794abcad7a4ac77c352626063aa1f05",
      "commitAuthor": "Markus Duft",
      "commitDateOld": "2017-12-18, 4:45 a.m.",
      "commitNameOld": "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 35.58,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tfallBackToConfiguration();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.setProgressMonitor(monitor);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setProgressMonitor(monitor);\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tif (message !\u003d null)\n\t\t\t\t\t\tmergeMessage \u003d message;\n\t\t\t\t\telse\n\t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tmerger.setProgressMonitor(monitor);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t\tif (!resolveMerger.getModifiedFiles().isEmpty()) {\n\t\t\t\t\t\trepo.fireEvent(new WorkingTreeModifiedEvent(\n\t\t\t\t\t\t\t\tresolveMerger.getModifiedFiles(), null));\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.setProgressMonitor(monitor);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tObjectId newHeadId \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n\t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n\t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n\t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n\t\t\t\t\t\t\t\t\t.call().getId();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t\tgetRepository().autoGC(monitor);\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHeadId, null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.close();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 233,
      "functionName": "call",
      "diff": "@@ -1,211 +1,214 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tfallBackToConfiguration();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tref \u003d repo.peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n+\t\t\t\tdco.setProgressMonitor(monitor);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n+\t\t\t\tdco.setProgressMonitor(monitor);\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tif (message !\u003d null)\n \t\t\t\t\t\tmergeMessage \u003d message;\n \t\t\t\t\telse\n \t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tmerger.setProgressMonitor(monitor);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t\tif (!resolveMerger.getModifiedFiles().isEmpty()) {\n \t\t\t\t\t\trepo.fireEvent(new WorkingTreeModifiedEvent(\n \t\t\t\t\t\t\t\tresolveMerger.getModifiedFiles(), null));\n \t\t\t\t\t}\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n+\t\t\t\t\tdco.setProgressMonitor(monitor);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tObjectId newHeadId \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 !squash) {\n \t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n \t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n \t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n \t\t\t\t\t\t\t\t\t.call().getId();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t\tgetRepository().autoGC(monitor);\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHeadId, null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.close();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b13a285098305149b34924bce2679a0cd98d9b2c": {
      "type": "Ybodychange",
      "commitMessage": "Send a detailed event on working tree modifications\n\nCurrently there is no way to determine the precise changes done\nto the working tree by a JGit command. Only the CheckoutCommand\nactually provides access to the lists of modified, deleted, and\nto-be-deleted files, but those lists may be inaccurate (since they\nare determined up-front before the working tree is modified) if\nthe actual checkout then fails halfway through. Moreover, other\nJGit commands that modify the working tree do not offer any way to\nfigure out which files were changed.\n\nThis poses problems for EGit, which may need to refresh parts of the\nEclipse workspace when JGit has done java.io file operations.\n\nProvide the foundations for better file change tracking: the working\ntree is modified exclusively in DirCacheCheckout. Make it emit a new\ntype of RepositoryEvent that lists all files that were modified or\ndeleted, even if the checkout failed halfway through. We update the\n\u0027updated\u0027 and \u0027removed\u0027 lists determined up-front in case of file\nsystem problems to reflect the actual state of changes made.\n\nEGit thus can register a listener for these events and then knows\nexactly which parts of the Eclipse workspace may need to be refreshed.\n\nTwo commands manage checking out individual DirCacheEntries themselves:\ncheckout specific paths, and applying a stash with untracked files.\nMake those two also emit such a new WorkingTreeModifiedEvent.\n\nFurthermore, merges may modify files, and clean, rm, and stash create\nmay delete files.\n\nCQ: 13969\nBug: 500106\nChange-Id: I7a100aee315791fa1201f43bbad61fbae60b35cb\nSigned-off-by: Thomas Wolf \u003cthomas.wolf@paranor.ch\u003e",
      "commitDate": "2017-08-15, 4:52 p.m.",
      "commitName": "b13a285098305149b34924bce2679a0cd98d9b2c",
      "commitAuthor": "Thomas Wolf",
      "commitDateOld": "2017-06-15, 5:11 p.m.",
      "commitNameOld": "a45b045c7378c3685d7b0a39173b69c87efe7371",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 60.99,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tfallBackToConfiguration();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tif (message !\u003d null)\n\t\t\t\t\t\tmergeMessage \u003d message;\n\t\t\t\t\telse\n\t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tmerger.setProgressMonitor(monitor);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t\tif (!resolveMerger.getModifiedFiles().isEmpty()) {\n\t\t\t\t\t\trepo.fireEvent(new WorkingTreeModifiedEvent(\n\t\t\t\t\t\t\t\tresolveMerger.getModifiedFiles(), null));\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tObjectId newHeadId \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n\t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n\t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n\t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n\t\t\t\t\t\t\t\t\t.call().getId();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t\tgetRepository().autoGC(monitor);\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHeadId, null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.close();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 230,
      "functionName": "call",
      "diff": "@@ -1,207 +1,211 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tfallBackToConfiguration();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tref \u003d repo.peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tif (message !\u003d null)\n \t\t\t\t\t\tmergeMessage \u003d message;\n \t\t\t\t\telse\n \t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tmerger.setProgressMonitor(monitor);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n+\t\t\t\t\tif (!resolveMerger.getModifiedFiles().isEmpty()) {\n+\t\t\t\t\t\trepo.fireEvent(new WorkingTreeModifiedEvent(\n+\t\t\t\t\t\t\t\tresolveMerger.getModifiedFiles(), null));\n+\t\t\t\t\t}\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tObjectId newHeadId \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 !squash) {\n \t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n \t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n \t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n \t\t\t\t\t\t\t\t\t.call().getId();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t\tgetRepository().autoGC(monitor);\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHeadId, null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.close();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "64a404803eaccc88d7d57567c5cd86b88c342bec": {
      "type": "Ybodychange",
      "commitMessage": "Implement auto gc\n\nWith the auto option, gc checks whether any housekeeping is required; if\nnot, it exits without performing any work. Some JGit commands run gc\n--auto after performing operations that could create many loose objects.\nHousekeeping is required if there are too many loose objects or too many\npacks in the repository.\n\nIf the number of loose objects exceeds the value of the gc.auto option\njgit\u0027s GC consolidates all existing packs into a single pack (equivalent\nto -A option), whereas git-core would combine all loose objects into a\nsingle pack using repack -d -l. Setting the value of gc.auto to 0\ndisables automatic packing of loose objects.\n\nIf the number of packs exceeds the value of gc.autoPackLimit, then\nexisting packs (except those marked with a .keep file) are consolidated\ninto a single pack by using the -A option of repack. Setting\ngc.autoPackLimit to 0 disables automatic consolidation of packs.\n\nLike git the following jgit commands run auto gc:\n- fetch\n- merge\n- rebase\n- receive-pack\n\nThe auto gc for receive-pack can be suppressed by setting the config\noption receive.autogc \u003d false\n\nChange-Id: I68a2a051b39ec2c53cb7c4b8f6c596ba65eeba5d\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016-10-22, 7:34 p.m.",
      "commitName": "64a404803eaccc88d7d57567c5cd86b88c342bec",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2016-05-30, 6:11 p.m.",
      "commitNameOld": "4c236ff4bbf664fd177a33f42517b0eef52510c8",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 145.06,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tfallBackToConfiguration();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tif (message !\u003d null)\n\t\t\t\t\t\tmergeMessage \u003d message;\n\t\t\t\t\telse\n\t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tmerger.setProgressMonitor(monitor);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tObjectId newHeadId \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n\t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n\t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n\t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n\t\t\t\t\t\t\t\t\t.call().getId();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t\tgetRepository().autoGC(monitor);\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHeadId, null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.close();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 224,
      "functionName": "call",
      "diff": "@@ -1,206 +1,207 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tfallBackToConfiguration();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tref \u003d repo.peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tif (message !\u003d null)\n \t\t\t\t\t\tmergeMessage \u003d message;\n \t\t\t\t\telse\n \t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tmerger.setProgressMonitor(monitor);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tObjectId newHeadId \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 !squash) {\n \t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n \t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n \t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n \t\t\t\t\t\t\t\t\t.call().getId();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n+\t\t\t\t\t\tgetRepository().autoGC(monitor);\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHeadId, null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.close();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4c236ff4bbf664fd177a33f42517b0eef52510c8": {
      "type": "Ybodychange",
      "commitMessage": "Replace use of deprecated method Repository.getRef()\n\nChange-Id: Iecf2b8deafc4991cc3333702fb9fa0638be7b914\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016-05-30, 6:11 p.m.",
      "commitName": "4c236ff4bbf664fd177a33f42517b0eef52510c8",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2016-01-21, 5:37 a.m.",
      "commitNameOld": "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
      "commitAuthorOld": "Laurent Delaigue",
      "daysBetweenCommits": 130.48,
      "commitsBetweenForRepo": 181,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tfallBackToConfiguration();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tif (message !\u003d null)\n\t\t\t\t\t\tmergeMessage \u003d message;\n\t\t\t\t\telse\n\t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tmerger.setProgressMonitor(monitor);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tObjectId newHeadId \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n\t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n\t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n\t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n\t\t\t\t\t\t\t\t\t.call().getId();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHeadId, null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.close();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 224,
      "functionName": "call",
      "diff": "@@ -1,206 +1,206 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tfallBackToConfiguration();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n-\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n+\t\t\tRef head \u003d repo.exactRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tref \u003d repo.peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tif (message !\u003d null)\n \t\t\t\t\t\tmergeMessage \u003d message;\n \t\t\t\t\telse\n \t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tmerger.setProgressMonitor(monitor);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tObjectId newHeadId \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 !squash) {\n \t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n \t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n \t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n \t\t\t\t\t\t\t\t\t.call().getId();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHeadId, null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.close();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1e1fb9fc596603a44b0fff6d19eeba2b005d659d": {
      "type": "Ybodychange",
      "commitMessage": "Add progress monitor to Merger\n\nMonitoring progress of merges can be useful for users for large\nrepositories or complex merge processes that take some time.\n\nThis enables setting a monitor. Existing merge implementations in jgit\ndo not yet report progress if a monitor is set. This will be added in a\nlater change.\n\nChange-Id: I17b978b3fc91750dd88649638b90a46820a0877c\nSigned-off-by: Laurent Delaigue \u003claurent.delaigue@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016-01-21, 5:37 a.m.",
      "commitName": "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
      "commitAuthor": "Laurent Delaigue",
      "commitDateOld": "2015-05-20, 6:01 p.m.",
      "commitNameOld": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 245.52,
      "commitsBetweenForRepo": 444,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tfallBackToConfiguration();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tif (message !\u003d null)\n\t\t\t\t\t\tmergeMessage \u003d message;\n\t\t\t\t\telse\n\t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tmerger.setProgressMonitor(monitor);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tObjectId newHeadId \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n\t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n\t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n\t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n\t\t\t\t\t\t\t\t\t.call().getId();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHeadId, null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.close();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 224,
      "functionName": "call",
      "diff": "@@ -1,205 +1,206 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tfallBackToConfiguration();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tref \u003d repo.peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tif (message !\u003d null)\n \t\t\t\t\t\tmergeMessage \u003d message;\n \t\t\t\t\telse\n \t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n+\t\t\t\tmerger.setProgressMonitor(monitor);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tObjectId newHeadId \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 !squash) {\n \t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n \t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n \t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n \t\t\t\t\t\t\t\t\t.call().getId();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHeadId, null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.close();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e73d395061d1bfee365acaa2f79c392175d13bf": {
      "type": "Ybodychange",
      "commitMessage": "Use AutoClosable to close resources in bundle org.eclipse.jgit\n\n- use try-with-resource where possible\n- replace use of deprecated release() by close()\n\nChange-Id: I0f139c3535679087b7fa09649166bca514750b81\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015-05-20, 6:01 p.m.",
      "commitName": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2014-09-04, 5:35 a.m.",
      "commitNameOld": "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 258.52,
      "commitsBetweenForRepo": 318,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tfallBackToConfiguration();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tif (message !\u003d null)\n\t\t\t\t\t\tmergeMessage \u003d message;\n\t\t\t\t\telse\n\t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tObjectId newHeadId \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n\t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n\t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n\t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n\t\t\t\t\t\t\t\t\t.call().getId();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHeadId, null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.close();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 219,
      "functionName": "call",
      "diff": "@@ -1,203 +1,205 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tfallBackToConfiguration();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tref \u003d repo.peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tif (message !\u003d null)\n \t\t\t\t\t\tmergeMessage \u003d message;\n \t\t\t\t\telse\n \t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tObjectId newHeadId \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 !squash) {\n-\t\t\t\t\t\tnewHeadId \u003d new Git(getRepository()).commit()\n-\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n-\t\t\t\t\t\t\t\t.call().getId();\n+\t\t\t\t\t\ttry (Git git \u003d new Git(getRepository())) {\n+\t\t\t\t\t\t\tnewHeadId \u003d git.commit()\n+\t\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n+\t\t\t\t\t\t\t\t\t.call().getId();\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHeadId, null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n-\t\t\t\trevWalk.release();\n+\t\t\t\trevWalk.close();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "46f3007b52a5d12c5a973957128ac38680b20ab8": {
      "type": "Ybodychange",
      "commitMessage": "Handle -m option for Merge command\n\nSet the commit message to be used for the merge commit (in case one is\ncreated)\n\nBug: 442886\nChange-Id: Ie5ecc13822faa366f00b3daa07f74c8441cae195\nSigned-off-by: Axel Richard \u003caxel.richard@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014-08-29, 7:17 p.m.",
      "commitName": "46f3007b52a5d12c5a973957128ac38680b20ab8",
      "commitAuthor": "Axel Richard",
      "commitDateOld": "2014-03-29, 1:34 p.m.",
      "commitNameOld": "32ff57a2b2b9480f4d374a2592fada7f720b124f",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 153.24,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tfallBackToConfiguration();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tif (message !\u003d null)\n\t\t\t\t\t\tmergeMessage \u003d message;\n\t\t\t\t\telse\n\t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tObjectId newHeadId \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tnewHeadId \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n\t\t\t\t\t\t\t\t.call().getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHeadId, null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 219,
      "functionName": "call",
      "diff": "@@ -1,200 +1,203 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tfallBackToConfiguration();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tref \u003d repo.peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n-\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n+\t\t\t\t\tif (message !\u003d null)\n+\t\t\t\t\t\tmergeMessage \u003d message;\n+\t\t\t\t\telse\n+\t\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tObjectId newHeadId \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tnewHeadId \u003d new Git(getRepository()).commit()\n \t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n \t\t\t\t\t\t\t\t.call().getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHeadId, null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "48e36d8cb335382b99ec829d0dfe34be71ed49bb": {
      "type": "Ybodychange",
      "commitMessage": "Use branch.\u003cx\u003e.mergeoptions and merge.ff as defaults for merging\n\nRead options that control squashing, whether or not to commit the merge\nand regarding fast forwarding from the configuration and use them if no\nexplicit values for these options have been provided to MergeCommand.\n\nChange-Id: Ifdaed4b5e4adc142657c03c8e78b709a99eeddbd\nSigned-off-by: Konrad Kgler \u003cswamblumat-eclipsebugs@yahoo.de\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014-02-13, 6:34 p.m.",
      "commitName": "48e36d8cb335382b99ec829d0dfe34be71ed49bb",
      "commitAuthor": "Konrad Kgler",
      "commitDateOld": "2013-12-03, 3:05 p.m.",
      "commitNameOld": "7dc8a4f089c1ca4762cf6fbf2e77898607a5820a",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 72.14,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tfallBackToConfiguration();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tObjectId newHeadId \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tnewHeadId \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n\t\t\t\t\t\t\t\t.call().getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHeadId, null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 217,
      "functionName": "call",
      "diff": "@@ -1,199 +1,200 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n+\t\tfallBackToConfiguration();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tref \u003d repo.peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tObjectId newHeadId \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tnewHeadId \u003d new Git(getRepository()).commit()\n \t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n \t\t\t\t\t\t\t\t.call().getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHeadId, null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7dc8a4f089c1ca4762cf6fbf2e77898607a5820a": {
      "type": "Ybodychange",
      "commitMessage": "Fix exception on conflicts with recursive merge\n\nWhen there are conflicts with a recursive merge, the conflicting paths\nare stored in unmergedPaths (field in ResolveMerger). Later, when the\nMergeResult is constructed in MergeCommand, getBaseCommit is called,\nwhich computes the merge base a second time.\n\nIn case of RecursiveMerger, getBaseCommit merges the multiple merge\nbases into one. It does this not by creating a new ResolveMerger but\ninstead calling mergeTrees. The problem with mergeTrees is that at the\nend, it checks if unmergedPaths is non-empty and returns false in that\ncase.\n\nBecause unmergedPaths was already non-empty because of the real merge,\nit thinks that there were conflicts when computing the merge base again,\nwhen there really were none.\n\nThis can be fixed by storing the base commit when computing it and then\nreturning that instead of computing it a second time.\n\nNote that another possible fix would be to just use a new ResolveMerger\nfor merging the merge bases instead. This would also remove the need to\nremember the old value of dircache, inCore and workingTreeIterator (see\nRecursiveMerger#getBaseCommit).\n\nBug: 419641\nChange-Id: Ib2ebf4e177498c22a9098aa225e3cfcf16bbd958\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\n",
      "commitDate": "2013-12-03, 3:05 p.m.",
      "commitName": "7dc8a4f089c1ca4762cf6fbf2e77898607a5820a",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2013-04-15, 3:46 p.m.",
      "commitNameOld": "aa7be667bcca4bdb28b2485e28a05da54c431df7",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 232.01,
      "commitsBetweenForRepo": 251,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tObjectId newHeadId \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tnewHeadId \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n\t\t\t\t\t\t\t\t.call().getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHeadId, null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 215,
      "functionName": "call",
      "diff": "@@ -1,201 +1,199 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tref \u003d repo.peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tObjectId newHeadId \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 !squash) {\n \t\t\t\t\t\tnewHeadId \u003d new Git(getRepository()).commit()\n \t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n \t\t\t\t\t\t\t\t.call().getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t}\n \t\t\t\t\tif (commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHeadId, null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n-\t\t\t\t\t\treturn new MergeResult(null,\n-\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n+\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n-\t\t\t\t\t\treturn new MergeResult(null,\n-\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n+\t\t\t\t\t\treturn new MergeResult(null, merger.getBaseCommitId(),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "545358577376bec8fc140a76ce0f72bf81cc0a94": {
      "type": "Ybodychange",
      "commitMessage": "Add the no-commit option to MergeCommand\n\nAdded also tests and the associated option for the command line Merge\ncommand.\n\nBug: 335091\nChange-Id: Ie321c572284a6f64765a81674089fc408a10d059\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2013-04-04, 9:11 a.m.",
      "commitName": "545358577376bec8fc140a76ce0f72bf81cc0a94",
      "commitAuthor": "Tomasz Zarna",
      "commitDateOld": "2013-02-08, 1:27 a.m.",
      "commitNameOld": "3a4ebc0c24b7732a57064299153794084fbfae59",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 55.28,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tObjectId newHeadId \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n\t\t\t\t\t\tnewHeadId \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n\t\t\t\t\t\t\t\t.call().getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t}\n\t\t\t\t\tif (commit \u0026\u0026 squash) {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHeadId, null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 215,
      "functionName": "call",
      "diff": "@@ -1,193 +1,201 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tref \u003d repo.peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n-\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$\n+\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n-\t\t\t\t\tRevCommit newHead \u003d null;\n+\t\t\t\t\tObjectId newHeadId \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n-\t\t\t\t\tif (!squash) {\n-\t\t\t\t\t\tnewHead \u003d new Git(getRepository()).commit()\n-\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n+\t\t\t\t\tif (!commit \u0026\u0026 squash) {\n+\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (!commit \u0026\u0026 !squash) {\n+\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (commit \u0026\u0026 !squash) {\n+\t\t\t\t\t\tnewHeadId \u003d new Git(getRepository()).commit()\n+\t\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString())\n+\t\t\t\t\t\t\t\t.call().getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n-\t\t\t\t\t} else {\n+\t\t\t\t\t}\n+\t\t\t\t\tif (commit \u0026\u0026 squash) {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n-\t\t\t\t\t\tnewHead \u003d headCommit;\n+\t\t\t\t\t\tnewHeadId \u003d headCommit.getId();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n-\t\t\t\t\treturn new MergeResult(newHead.getId(), null,\n+\t\t\t\t\treturn new MergeResult(newHeadId, null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3a4ebc0c24b7732a57064299153794084fbfae59": {
      "type": "Ybodychange",
      "commitMessage": "Really handle annotated tags in MergeCommand\n\nRepository.peel() must be called to ensure a tag is really peeled.\n\nChange-Id: I83e25f09fad3ad55a3ffe41ab4758f249b7ac9f9\n",
      "commitDate": "2013-02-08, 1:27 a.m.",
      "commitName": "3a4ebc0c24b7732a57064299153794084fbfae59",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013-01-29, 2:05 a.m.",
      "commitNameOld": "eb6093293022e468c2aea93a11f63b366e0d3891",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 9.97,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tref \u003d repo.peel(ref);\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tRevCommit newHead \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!squash) {\n\t\t\t\t\t\tnewHead \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHead \u003d headCommit;\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHead.getId(), null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 213,
      "functionName": "call",
      "diff": "@@ -1,192 +1,193 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n+\t\t\tref \u003d repo.peel(ref);\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tRevCommit newHead \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!squash) {\n \t\t\t\t\t\tnewHead \u003d new Git(getRepository()).commit()\n \t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHead \u003d headCommit;\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHead.getId(), null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eb6093293022e468c2aea93a11f63b366e0d3891": {
      "type": "Ybodychange",
      "commitMessage": "Fix Check for FF_ONLY merges again\n\nAdded more FF-mode tests\n\nChange-Id: I33eed5737d9411cc1cf214da62ce719916a1b736\n",
      "commitDate": "2013-01-29, 2:05 a.m.",
      "commitName": "eb6093293022e468c2aea93a11f63b366e0d3891",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013-01-28, 6:48 p.m.",
      "commitNameOld": "642ff2cd7dd6ae361e4993255ade89a32e20601f",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tRevCommit newHead \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!squash) {\n\t\t\t\t\t\tnewHead \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHead \u003d headCommit;\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHead.getId(), null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 213,
      "functionName": "call",
      "diff": "@@ -1,192 +1,192 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n-\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.NO_FF) {\n+\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tRevCommit newHead \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!squash) {\n \t\t\t\t\t\tnewHead \u003d new Git(getRepository()).commit()\n \t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHead \u003d headCommit;\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHead.getId(), null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "642ff2cd7dd6ae361e4993255ade89a32e20601f": {
      "type": "Ybodychange",
      "commitMessage": "Check for FF_ONLY merges correctly\n\nBug: 398192\nChange-Id: I1253c0ea0632185bbf9f77e32f13ba5842a6e18e\n",
      "commitDate": "2013-01-28, 6:48 p.m.",
      "commitName": "642ff2cd7dd6ae361e4993255ade89a32e20601f",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013-01-18, 6:04 a.m.",
      "commitNameOld": "6a8da4c134dff042712e4bae8817d79cc63866f4",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 10.53,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.NO_FF) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tRevCommit newHead \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!squash) {\n\t\t\t\t\t\tnewHead \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHead \u003d headCommit;\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHead.getId(), null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 213,
      "functionName": "call",
      "diff": "@@ -1,192 +1,192 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n-\t\t\t\t\t\u0026\u0026 fastForwardMode \u003d\u003d FastForwardMode.FF) {\n+\t\t\t\t\t\u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n-\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n+\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.NO_FF) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n \t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tRevCommit newHead \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!squash) {\n \t\t\t\t\t\tnewHead \u003d new Git(getRepository()).commit()\n \t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHead \u003d headCommit;\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHead.getId(), null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": {
      "type": "Ybodychange",
      "commitMessage": "Mark non-externalizable strings as such\n\nA few classes such as Constanrs are marked with @SuppressWarnings, as are\ntoString() methods with many liternal, but otherwise $NLS-n$ is used for\nstring containing text that should not be translated. A few literals may\nfall into the gray zone, but mostly I\u0027ve tried to only tag the obvious\nones.\n\nChange-Id: I22e50a77e2bf9e0b842a66bdf674e8fa1692f590\n",
      "commitDate": "2012-12-27, 10:57 a.m.",
      "commitName": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012-11-16, 5:04 a.m.",
      "commitNameOld": "318f3d464307e3efd8342852310c17e71a7282fe",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 41.25,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode \u003d\u003d FastForwardMode.FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n\t\t\t\tif (!squash) {\n\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tRevCommit newHead \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!squash) {\n\t\t\t\t\t\tnewHead \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHead \u003d headCommit;\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHead.getId(), null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 141,
      "functionName": "call",
      "diff": "@@ -1,192 +1,192 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n-\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n+\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \"); //$NON-NLS-1$\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n-\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n+\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false); //$NON-NLS-1$\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n \t\t\t\t\t\u0026\u0026 fastForwardMode \u003d\u003d FastForwardMode.FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n-\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n+\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD); //$NON-NLS-1$\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n \t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n \t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n \t\t\t\t}\n-\t\t\t\tString mergeMessage \u003d \"\";\n+\t\t\t\tString mergeMessage \u003d \"\"; //$NON-NLS-1$\n \t\t\t\tif (!squash) {\n \t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n-\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n+\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() }); //$NON-NLS-1$\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n-\t\t\t\trefLogMessage.append(\": Merge made by \");\n+\t\t\t\trefLogMessage.append(\": Merge made by \"); //$NON-NLS-1$\n \t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n \t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\telse\n-\t\t\t\t\trefLogMessage.append(\"recursive\");\n+\t\t\t\t\trefLogMessage.append(\"recursive\"); //$NON-NLS-1$\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tRevCommit newHead \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!squash) {\n \t\t\t\t\t\tnewHead \u003d new Git(getRepository()).commit()\n \t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHead \u003d headCommit;\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHead.getId(), null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "318f3d464307e3efd8342852310c17e71a7282fe": {
      "type": "Ybodychange",
      "commitMessage": "Add support for --no-ff while merging\n\nBug: 394432\nChange-Id: I373128c0ba949f9b24248874f77f3d68b50ccfd1\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2012-11-16, 5:04 a.m.",
      "commitName": "318f3d464307e3efd8342852310c17e71a7282fe",
      "commitAuthor": "Tomasz Zarna",
      "commitDateOld": "2012-06-15, 2:59 a.m.",
      "commitNameOld": "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 154.13,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\t\tcheckParameters();\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n\t\t\t\t\t\u0026\u0026 fastForwardMode \u003d\u003d FastForwardMode.FF) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n\t\t\t\t}\n\t\t\t\tString mergeMessage \u003d \"\";\n\t\t\t\tif (!squash) {\n\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \");\n\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\telse\n\t\t\t\t\trefLogMessage.append(\"recursive\");\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tRevCommit newHead \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!squash) {\n\t\t\t\t\t\tnewHead \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHead \u003d headCommit;\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHead.getId(), null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 141,
      "functionName": "call",
      "diff": "@@ -1,190 +1,192 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n-\n-\t\tif (commits.size() !\u003d 1)\n-\t\t\tthrow new InvalidMergeHeadsException(\n-\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n-\t\t\t\t\t\t\t: MessageFormat.format(\n-\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n-\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n-\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n+\t\tcheckParameters();\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n-\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n+\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)\n+\t\t\t\t\t\u0026\u0026 fastForwardMode \u003d\u003d FastForwardMode.FF) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tString msg \u003d null;\n \t\t\t\tObjectId newHead, base \u003d null;\n \t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\tif (!squash) {\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n \t\t\t\t} else {\n \t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\tnewHead \u003d base \u003d headId;\n \t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n \t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n+\t\t\t\tif (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n+\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n+\t\t\t\t\t\t\tnew ObjectId[] { headCommit, srcCommit },\n+\t\t\t\t\t\t\tMergeStatus.ABORTED, mergeStrategy, null, null);\n+\t\t\t\t}\n \t\t\t\tString mergeMessage \u003d \"\";\n \t\t\t\tif (!squash) {\n \t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\t\tcommits, head);\n \t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\t} else {\n \t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n \t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n \t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n \t\t\t\t\t\t\tsquashedCommits, head);\n \t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n \t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \");\n-\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n+\t\t\t\tif (!revWalk.isMergedInto(headCommit, srcCommit))\n+\t\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n+\t\t\t\telse\n+\t\t\t\t\trefLogMessage.append(\"recursive\");\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tString msg \u003d null;\n \t\t\t\t\tRevCommit newHead \u003d null;\n \t\t\t\t\tMergeStatus mergeStatus \u003d null;\n \t\t\t\t\tif (!squash) {\n \t\t\t\t\t\tnewHead \u003d new Git(getRepository()).commit()\n \t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n \t\t\t\t\t\tnewHead \u003d headCommit;\n \t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n \t\t\t\t\t}\n \t\t\t\t\treturn new MergeResult(newHead.getId(), null,\n \t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n \t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214": {
      "type": "Ybodychange",
      "commitMessage": "Add \"--squash\" option to MergeCommand\n\nCQ: 6570\nBug: 351806\nChange-Id: I5e47810376419264ecf4247b5a333af5c8945080\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2012-06-15, 2:59 a.m.",
      "commitName": "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214",
      "commitAuthor": "Tomasz Zarna",
      "commitDateOld": "2012-05-30, 4:08 p.m.",
      "commitNameOld": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 15.45,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tString msg \u003d null;\n\t\t\t\tObjectId newHead, base \u003d null;\n\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\tif (!squash) {\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n\t\t\t\t} else {\n\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\tnewHead \u003d base \u003d headId;\n\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n\t\t\t\t\t\tnull, msg);\n\t\t\t} else {\n\t\t\t\tString mergeMessage \u003d \"\";\n\t\t\t\tif (!squash) {\n\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\t\tcommits, head);\n\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\t} else {\n\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n\t\t\t\t\t\t\tsquashedCommits, head);\n\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n\t\t\t\t}\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \");\n\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tString msg \u003d null;\n\t\t\t\t\tRevCommit newHead \u003d null;\n\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n\t\t\t\t\tif (!squash) {\n\t\t\t\t\t\tnewHead \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n\t\t\t\t\t\tnewHead \u003d headCommit;\n\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n\t\t\t\t\t}\n\t\t\t\t\treturn new MergeResult(newHead.getId(), null,\n\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n\t\t\t\t\t\t\tmergeStrategy, null, msg);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 117,
      "functionName": "call",
      "diff": "@@ -1,157 +1,190 @@\n \tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n \t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n-\n-\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n+\t\t\t\tString msg \u003d null;\n+\t\t\t\tObjectId newHead, base \u003d null;\n+\t\t\t\tMergeStatus mergeStatus \u003d null;\n+\t\t\t\tif (!squash) {\n+\t\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n+\t\t\t\t\tnewHead \u003d base \u003d srcCommit;\n+\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD;\n+\t\t\t\t} else {\n+\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n+\t\t\t\t\tnewHead \u003d base \u003d headId;\n+\t\t\t\t\tmergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n+\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n+\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n+\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n+\t\t\t\t\t\t\tsquashedCommits, head);\n+\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n+\t\t\t\t}\n \t\t\t\tsetCallable(false);\n-\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n-\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n-\t\t\t\t\t\tmergeStrategy, null, null);\n+\t\t\t\treturn new MergeResult(newHead, base, new ObjectId[] {\n+\t\t\t\t\t\theadCommit, srcCommit }, mergeStatus, mergeStrategy,\n+\t\t\t\t\t\tnull, msg);\n \t\t\t} else {\n-\n-\t\t\t\tString mergeMessage \u003d new MergeMessageFormatter().format(\n-\t\t\t\t\t\tcommits, head);\n-\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n-\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n+\t\t\t\tString mergeMessage \u003d \"\";\n+\t\t\t\tif (!squash) {\n+\t\t\t\t\tmergeMessage \u003d new MergeMessageFormatter().format(\n+\t\t\t\t\t\t\tcommits, head);\n+\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n+\t\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n+\t\t\t\t} else {\n+\t\t\t\t\tList\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(\n+\t\t\t\t\t\t\trevWalk, srcCommit, headCommit);\n+\t\t\t\t\tString squashMessage \u003d new SquashMessageFormatter().format(\n+\t\t\t\t\t\t\tsquashedCommits, head);\n+\t\t\t\t\trepo.writeSquashCommitMsg(squashMessage);\n+\t\t\t\t}\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \");\n \t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n-\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit()\n+\t\t\t\t\tString msg \u003d null;\n+\t\t\t\t\tRevCommit newHead \u003d null;\n+\t\t\t\t\tMergeStatus mergeStatus \u003d null;\n+\t\t\t\t\tif (!squash) {\n+\t\t\t\t\t\tnewHead \u003d new Git(getRepository()).commit()\n \t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n-\t\t\t\t\treturn new MergeResult(newHead.getId(),\n-\t\t\t\t\t\t\tnull, new ObjectId[] {\n-\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n-\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n+\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tmsg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n+\t\t\t\t\t\tnewHead \u003d headCommit;\n+\t\t\t\t\t\tmergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n+\t\t\t\t\t}\n+\t\t\t\t\treturn new MergeResult(newHead.getId(), null,\n+\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n+\t\t\t\t\t\t\t\t\tsrcCommit.getId() }, mergeStatus,\n+\t\t\t\t\t\t\tmergeStrategy, null, msg);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": {
      "type": "Yexceptionschange",
      "commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2012-05-30, 4:08 p.m.",
      "commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012-03-12, 10:20 a.m.",
      "commitNameOld": "95d311f8886f42f31a4475f84aa23c6345ab7059",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 79.24,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\n\t\t\t\tString mergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\tcommits, head);\n\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \");\n\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 113,
      "functionName": "call",
      "diff": "@@ -1,157 +1,157 @@\n-\tpublic MergeResult call() throws NoHeadException,\n+\tpublic MergeResult call() throws GitAPIException, NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n \t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n \t\tRevWalk revWalk \u003d null;\n \t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \n \t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t} else {\n \n \t\t\t\tString mergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\tcommits, head);\n \t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \");\n \t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit()\n \t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n \t\t\t\t\treturn new MergeResult(newHead.getId(),\n \t\t\t\t\t\t\tnull, new ObjectId[] {\n \t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n \t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n \t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n \t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException]",
        "newValue": "[GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException]"
      }
    },
    "26b573862912b2faf3824bb18dfeb44a3b700014": {
      "type": "Ybodychange",
      "commitMessage": "Throw API exception when MergeCommand hits checkout conflicts \n\nWhen MergeCommand hit checkout conflicts it did throw an internal JGit\nexception org.eclipse.jgit.errors.CheckoutConflictException instead of\norg.eclipse.jgit.api.errors.CheckoutConflictException which it\ndeclares to throw. Hence translate the internal exception to the\nexception declared in the API.\n\nBug: 327573\nChange-Id: I1efcd93a43ecbf4a40583e0fc9d8d53cffc98cae\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2011-12-08, 5:33 p.m.",
      "commitName": "26b573862912b2faf3824bb18dfeb44a3b700014",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2011-09-21, 5:36 p.m.",
      "commitNameOld": "39ad503fcb0c293e9c6d47d653a0d52456d4760b",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 78.04,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\tDirCacheCheckout dco \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\n\t\t\t\tString mergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\tcommits, head);\n\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \");\n\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n\t\t\tthrow new CheckoutConflictException(conflicts, e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 112,
      "functionName": "call",
      "diff": "@@ -1,152 +1,157 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n \t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n \t\tRevWalk revWalk \u003d null;\n+\t\tDirCacheCheckout dco \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n-\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n+\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n-\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n+\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \n \t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t} else {\n \n \t\t\t\tString mergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\tcommits, head);\n \t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\trefLogMessage.append(\": Merge made by \");\n \t\t\t\trefLogMessage.append(mergeStrategy.getName());\n \t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n-\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n+\t\t\t\t\tdco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit()\n \t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n \t\t\t\t\treturn new MergeResult(newHead.getId(),\n \t\t\t\t\t\t\tnull, new ObjectId[] {\n \t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t} catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n+\t\t\tList\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections\n+\t\t\t\t\t.\u003cString\u003e emptyList() : dco.getConflicts();\n+\t\t\tthrow new CheckoutConflictException(conflicts, e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39ad503fcb0c293e9c6d47d653a0d52456d4760b": {
      "type": "Ybodychange",
      "commitMessage": "Append merge strategy to reflog message\n\nChange-Id: Ia0e73208b86c45a3d96698e973f6e70ec5cb7303\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2011-09-21, 5:36 p.m.",
      "commitName": "39ad503fcb0c293e9c6d47d653a0d52456d4760b",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2011-09-21, 5:36 p.m.",
      "commitNameOld": "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\n\t\t\t\tString mergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\tcommits, head);\n\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\trefLogMessage.append(\": Merge made by \");\n\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n\t\t\t\trefLogMessage.append(\u0027.\u0027);\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "diff": "@@ -1,150 +1,152 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n \t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n \t\tRevWalk revWalk \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \n \t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t} else {\n \n \t\t\t\tString mergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\tcommits, head);\n \t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n-\n+\t\t\t\trefLogMessage.append(\": Merge made by \");\n+\t\t\t\trefLogMessage.append(mergeStrategy.getName());\n+\t\t\t\trefLogMessage.append(\u0027.\u0027);\n \t\t\t\tif (noProblems) {\n \t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \n \t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit()\n \t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n \t\t\t\t\treturn new MergeResult(newHead.getId(),\n \t\t\t\t\t\t\tnull, new ObjectId[] {\n \t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f": {
      "type": "Ybodychange",
      "commitMessage": "Fix the reflog prefix for cherry-pick, revert and merge commands\n\nWe should see whether the commit was a regular commit or something\nelse.\n\nChange-Id: I82d8300cf3c53cb2bdcb6495386aadb803e0c6f7\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2011-09-21, 5:36 p.m.",
      "commitName": "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2011-08-21, 4:53 p.m.",
      "commitNameOld": "c580c56c4def9639b603553b3d4cbc7117a30938",
      "commitAuthorOld": "Denys Digtiar",
      "daysBetweenCommits": 31.03,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\n\t\t\t\tString mergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\tcommits, head);\n\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit()\n\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "diff": "@@ -1,148 +1,150 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n \t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n \t\tRevWalk revWalk \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \n \t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t} else {\n \n \t\t\t\tString mergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\tcommits, head);\n \t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \n \t\t\t\tif (noProblems) {\n \t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n-\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n+\n+\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit()\n+\t\t\t\t\t\t\t.setReflogComment(refLogMessage.toString()).call();\n \t\t\t\t\treturn new MergeResult(newHead.getId(),\n \t\t\t\t\t\t\tnull, new ObjectId[] {\n \t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c580c56c4def9639b603553b3d4cbc7117a30938": {
      "type": "Ybodychange",
      "commitMessage": "Fix ClassCastException in MergeCommand\n\nTest was added which reproduce the ClassCastException when ours or\ntheirs merge strategy is set to MergeCommand. Merger and MergeCommand\nwere updated in order to avoid exception.\n\nChange-Id: I4c1284b4e80d82638d0677a05e5d38182526d196\nSigned-off-by: Denys Digtiar \u003cduemir@gmail.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011-08-21, 4:53 p.m.",
      "commitName": "c580c56c4def9639b603553b3d4cbc7117a30938",
      "commitAuthor": "Denys Digtiar",
      "commitDateOld": "2011-04-06, 4:57 p.m.",
      "commitNameOld": "5dbef3fa51053b37f68b44ed390cab6dc8336dcc",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 137.0,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\n\t\t\t\tString mergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\tcommits, head);\n\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "diff": "@@ -1,149 +1,148 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n \t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n \t\tRevWalk revWalk \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \n \t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t} else {\n \n \t\t\t\tString mergeMessage \u003d new MergeMessageFormatter().format(\n \t\t\t\t\t\tcommits, head);\n \t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n-\t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n-\t\t\t\t\t\t.newMerger(repo);\n+\t\t\t\tMerger merger \u003d mergeStrategy.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \n \t\t\t\tif (noProblems) {\n \t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n \t\t\t\t\treturn new MergeResult(newHead.getId(),\n \t\t\t\t\t\t\tnull, new ObjectId[] {\n \t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n \t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n \t\t\t\t\t\t\t\t\t\tunmergedPaths);\n \t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5dbef3fa51053b37f68b44ed390cab6dc8336dcc": {
      "type": "Ybodychange",
      "commitMessage": "Add \"Conflicts\" section to merge message on conflict\n\nThe same as with cherry-pick, the commit message of a merge should\ninclude a \"Conflicts\" section when the merge resulted in conflicts.\n\nChange-Id: I6261dc898262322924af5ca1bef841a654b0df55\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\n",
      "commitDate": "2011-04-06, 4:57 p.m.",
      "commitName": "5dbef3fa51053b37f68b44ed390cab6dc8336dcc",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2011-03-21, 7:33 a.m.",
      "commitNameOld": "dcf7bd9a8f7acafbd1461dc0414aded2db030983",
      "commitAuthorOld": "Philipp Thun",
      "daysBetweenCommits": 16.39,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\n\t\t\t\tString mergeMessage \u003d new MergeMessageFormatter().format(\n\t\t\t\t\t\tcommits, head);\n\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n\t\t\t\t\t\t.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "diff": "@@ -1,141 +1,149 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n \t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n \t\tRevWalk revWalk \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \n \t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t} else {\n \n-\t\t\t\trepo.writeMergeCommitMsg(new MergeMessageFormatter().format(\n-\t\t\t\t\t\tcommits, head));\n+\t\t\t\tString mergeMessage \u003d new MergeMessageFormatter().format(\n+\t\t\t\t\t\tcommits, head);\n+\t\t\t\trepo.writeMergeCommitMsg(mergeMessage);\n \t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n \t\t\t\t\t\t.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n+\t\t\t\tList\u003cString\u003e unmergedPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n+\t\t\t\t\tunmergedPaths \u003d resolveMerger.getUnmergedPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \n \t\t\t\tif (noProblems) {\n \t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n \t\t\t\t\treturn new MergeResult(newHead.getId(),\n \t\t\t\t\t\t\tnull, new ObjectId[] {\n \t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n-\t\t\t\t\t} else\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tString mergeMessageWithConflicts \u003d new MergeMessageFormatter()\n+\t\t\t\t\t\t\t\t.formatWithConflicts(mergeMessage,\n+\t\t\t\t\t\t\t\t\t\tunmergedPaths);\n+\t\t\t\t\t\trepo.writeMergeCommitMsg(mergeMessageWithConflicts);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dcf7bd9a8f7acafbd1461dc0414aded2db030983": {
      "type": "Ybodychange",
      "commitMessage": "Improve MergeResult\n\nAdd paths causing abnormal merge failures (e.g. due to unstaged\nchanges) to the MergeResult returned by MergeCommand. This helps\ncallers to better handle (e.g. present) merge results.\n\nChange-Id: Idb8cf04c5cecfb6a12cb880e16febfc3b9358564\nSigned-off-by: Philipp Thun \u003cphilipp.thun@sap.com\u003e\n",
      "commitDate": "2011-03-21, 7:33 a.m.",
      "commitName": "dcf7bd9a8f7acafbd1461dc0414aded2db030983",
      "commitAuthor": "Philipp Thun",
      "commitDateOld": "2011-01-26, 11:17 a.m.",
      "commitNameOld": "85f69c286b6c3225dcff05aba42910daefb28da0",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 53.8,
      "commitsBetweenForRepo": 182,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\n\t\t\t\trepo.writeMergeCommitMsg(new MergeMessageFormatter().format(\n\t\t\t\t\t\tcommits, head));\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n\t\t\t\t\t\t.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "diff": "@@ -1,141 +1,141 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n \t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n \t\tRevWalk revWalk \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \n \t\t\tObjectId headId \u003d head.getObjectId();\n \t\t\tif (headId \u003d\u003d null) {\n \t\t\t\trevWalk.parseHeaders(srcCommit);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \t\t\t\tRefUpdate refUpdate \u003d repo\n \t\t\t\t\t\t.updateRef(head.getTarget().getName());\n \t\t\t\trefUpdate.setNewObjectId(objectId);\n \t\t\t\trefUpdate.setExpectedOldObjectId(null);\n \t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n \t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n \t\t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t}\n \n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n \n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \n \t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t} else {\n \n \t\t\t\trepo.writeMergeCommitMsg(new MergeMessageFormatter().format(\n \t\t\t\t\t\tcommits, head));\n \t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n \t\t\t\t\t\t.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \n \t\t\t\tif (noProblems) {\n \t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n \t\t\t\t\treturn new MergeResult(newHead.getId(),\n \t\t\t\t\t\t\tnull, new ObjectId[] {\n \t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n-\t\t\t\t\t\t\t\tlowLevelResults, null);\n+\t\t\t\t\t\t\t\tlowLevelResults, failingPaths, null);\n \t\t\t\t\t} else\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "85f69c286b6c3225dcff05aba42910daefb28da0": {
      "type": "Ybodychange",
      "commitMessage": "MergeCommand should create missing branches\n\nIf HEAD exists but points to an not-existing branch the merge\ncommand should silently create the missing branch and check\nit out. This happens if you pull into freshly initalized repo.\nHEAD points to refs/heads/master but refs/heads/master doesn\u0027t\nexist. If you know merge a commit X into HEAD then the branch\nmaster should be created (pointing to X) the working tree should\nbe updated to reflect X. That is achieved by checkout with one\ntree only (HEAD is missing).\n\nA test for this functionality will come the the next proposal\nin PullCommandTest.\n\nChange-Id: Id4a0d56d944e0acebd4b3157428bb50bd3fdd872\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2011-01-26, 11:17 a.m.",
      "commitName": "85f69c286b6c3225dcff05aba42910daefb28da0",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2011-01-17, 4:04 p.m.",
      "commitNameOld": "e43887b69e27672b80e55391e0ee255efe715ab9",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 8.8,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\n\t\t\tObjectId headId \u003d head.getObjectId();\n\t\t\tif (headId \u003d\u003d null) {\n\t\t\t\trevWalk.parseHeaders(srcCommit);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\t\t\t\tRefUpdate refUpdate \u003d repo\n\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n\t\t\t\trefUpdate.setNewObjectId(objectId);\n\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n\t\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t}\n\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\n\t\t\t\trepo.writeMergeCommitMsg(new MergeMessageFormatter().format(\n\t\t\t\t\t\tcommits, head));\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n\t\t\t\t\t\t.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "diff": "@@ -1,118 +1,141 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n \t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n \t\tRevWalk revWalk \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n-\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n+\n+\t\t\tObjectId headId \u003d head.getObjectId();\n+\t\t\tif (headId \u003d\u003d null) {\n+\t\t\t\trevWalk.parseHeaders(srcCommit);\n+\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n+\t\t\t\t\t\trepo.lockDirCache(), srcCommit.getTree());\n+\t\t\t\tdco.setFailOnConflict(true);\n+\t\t\t\tdco.checkout();\n+\t\t\t\tRefUpdate refUpdate \u003d repo\n+\t\t\t\t\t\t.updateRef(head.getTarget().getName());\n+\t\t\t\trefUpdate.setNewObjectId(objectId);\n+\t\t\t\trefUpdate.setExpectedOldObjectId(null);\n+\t\t\t\trefUpdate.setRefLogMessage(\"initial pull\", false);\n+\t\t\t\tif (refUpdate.update() !\u003d Result.NEW)\n+\t\t\t\t\tthrow new NoHeadException(\n+\t\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n+\t\t\t\tsetCallable(false);\n+\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n+\t\t\t\t\t\tnull, srcCommit }, MergeStatus.FAST_FORWARD,\n+\t\t\t\t\t\tmergeStrategy, null, null);\n+\t\t\t}\n+\n+\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(headId);\n+\n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \n-\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n+\t\t\t\tupdateHead(refLogMessage, srcCommit, headId);\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t} else {\n \n \t\t\t\trepo.writeMergeCommitMsg(new MergeMessageFormatter().format(\n \t\t\t\t\t\tcommits, head));\n \t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n \t\t\t\t\t\t.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \n \t\t\t\tif (noProblems) {\n \t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n \t\t\t\t\treturn new MergeResult(newHead.getId(),\n \t\t\t\t\t\t\tnull, new ObjectId[] {\n \t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t} else\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e43887b69e27672b80e55391e0ee255efe715ab9": {
      "type": "Ybodychange",
      "commitMessage": "Fix misc spelling errors in comments and method names\n\nChange-Id: I24552443710075856540696717ac4068dfe6a7f2\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\n",
      "commitDate": "2011-01-17, 4:04 p.m.",
      "commitName": "e43887b69e27672b80e55391e0ee255efe715ab9",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2010-11-06, 8:48 a.m.",
      "commitNameOld": "6290ca3a638d1ac999da6c11628f904b31972067",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 72.34,
      "commitsBetweenForRepo": 166,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\n\t\t\t\trepo.writeMergeCommitMsg(new MergeMessageFormatter().format(\n\t\t\t\t\t\tcommits, head));\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n\t\t\t\t\t\t.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "diff": "@@ -1,118 +1,118 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n \t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n \t\tRevWalk revWalk \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n \n \t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \n \t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t} else {\n \n \t\t\t\trepo.writeMergeCommitMsg(new MergeMessageFormatter().format(\n \t\t\t\t\t\tcommits, head));\n \t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n \t\t\t\t\t\t.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n-\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPathes();\n+\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPaths();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \n \t\t\t\tif (noProblems) {\n \t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n \t\t\t\t\treturn new MergeResult(newHead.getId(),\n \t\t\t\t\t\t\tnull, new ObjectId[] {\n \t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t} else\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6290ca3a638d1ac999da6c11628f904b31972067": {
      "type": "Ybodychange",
      "commitMessage": "Format merge commit messages like C Git\n\nThe automatically generated commit message of a merge should have the\nsame structure as in C Git for consistency (as per git fmt-merge-msg).\n\nBefore this change:\n\n  merging refs/heads/a into refs/heads/master\n\nAfter:\n\n  Merge branch \u0027a\u0027\n\nPlurals, \"into\" and joining by \",\" and \"and\" also work.\n\nChange-Id: I9658ce2817adc90d2df1060e8ac508d7bd0571cb\n",
      "commitDate": "2010-11-06, 8:48 a.m.",
      "commitName": "6290ca3a638d1ac999da6c11628f904b31972067",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2010-10-13, 5:30 a.m.",
      "commitNameOld": "fb1e500adc011dfaad1a6e68b23a9b254a77bf43",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 24.14,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n\n\t\t\t// we know for now there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\n\t\t\t\trepo.writeMergeCommitMsg(new MergeMessageFormatter().format(\n\t\t\t\t\t\tcommits, head));\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n\t\t\t\t\t\t.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPathes();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "diff": "@@ -1,117 +1,118 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n \t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n \t\tRevWalk revWalk \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n \n-\t\t\t// we know for know there is only one commit\n+\t\t\t// we know for now there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \n \t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t} else {\n-\t\t\t\trepo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \"\n-\t\t\t\t\t\t+ head.getName());\n+\n+\t\t\t\trepo.writeMergeCommitMsg(new MergeMessageFormatter().format(\n+\t\t\t\t\t\tcommits, head));\n \t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n \t\t\t\t\t\t.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n \t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPathes();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \n \t\t\t\tif (noProblems) {\n \t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n \t\t\t\t\treturn new MergeResult(newHead.getId(),\n \t\t\t\t\t\t\tnull, new ObjectId[] {\n \t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t} else\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb1e500adc011dfaad1a6e68b23a9b254a77bf43": {
      "type": "Ybodychange",
      "commitMessage": "Rename method to ResolveMerger.setWorkingTreeIterator()\n\nrenamed an ugly methodname\n\nChange-Id: I26bda06ef64b8644fd3a555dc55dff43cdb56a71\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2010-10-13, 5:30 a.m.",
      "commitName": "fb1e500adc011dfaad1a6e68b23a9b254a77bf43",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2010-10-12, 1:18 p.m.",
      "commitNameOld": "be93452842cfd18d7d738482175cfdbb128ed7dc",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 0.67,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n\n\t\t\t// we know for know there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\t\t\t\trepo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \"\n\t\t\t\t\t\t+ head.getName());\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n\t\t\t\t\t\t.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPathes();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 110,
      "functionName": "call",
      "diff": "@@ -1,117 +1,117 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n \t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n \t\tRevWalk revWalk \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n \n \t\t\t// we know for know there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \n \t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t} else {\n \t\t\t\trepo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \"\n \t\t\t\t\t\t+ head.getName());\n \t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n \t\t\t\t\t\t.newMerger(repo);\n \t\t\t\tboolean noProblems;\n \t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n-\t\t\t\t\tresolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n+\t\t\t\t\tresolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPathes();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \n \t\t\t\tif (noProblems) {\n \t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n \t\t\t\t\treturn new MergeResult(newHead.getId(),\n \t\t\t\t\t\t\tnull, new ObjectId[] {\n \t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t} else\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "67263e2056108e471d684c3cef9e719724b51220": {
      "type": "Ybodychange",
      "commitMessage": "Refactor diff sequence API\n\nInstead of making the sequence itself responsible for the equivalence\nfunction, use an external function that is supplied by the caller.\nThis cleans up the code because we now say cmp.equals(a, ai, b, bi)\ninstead of a.equals(ai, b, bi).\n\nThis refactoring also removes the odd concept of creating different\ntypes of sequences to have different behaviors for whitespace\nignoring.  Instead DiffComparator now supports singleton functions\nthat apply a particular equivalence algorithm to a type of sequence.\n\nChange-Id: I559f494d81cdc6f06bfb4208f60780c0ae251df9\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-09-06, 10:37 p.m.",
      "commitName": "67263e2056108e471d684c3cef9e719724b51220",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-09-01, 6:27 p.m.",
      "commitNameOld": "38327a54a86697458a1b326278e04833c105c00e",
      "commitAuthorOld": "Chris Aniszczyk",
      "daysBetweenCommits": 5.17,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n\n\t\t\t// we know for know there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\t\t\t\trepo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \"\n\t\t\t\t\t\t+ head.getName());\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n\t\t\t\t\t\t.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPathes();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 113,
      "functionName": "call",
      "diff": "@@ -1,117 +1,117 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n \t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n \t\tRevWalk revWalk \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\trevWalk \u003d new RevWalk(repo);\n \t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n \n \t\t\t// we know for know there is only one commit\n \t\t\tRef ref \u003d commits.get(0);\n \n \t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t// handle annotated tags\n \t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\tif (objectId \u003d\u003d null)\n \t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit },\n \t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n \t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t// update HEAD\n \t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\tsrcCommit.getTree());\n \t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\tdco.checkout();\n \n \t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n \t\t\t\tsetCallable(false);\n \t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n \t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n \t\t\t\t\t\tmergeStrategy, null, null);\n \t\t\t} else {\n \t\t\t\trepo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \"\n \t\t\t\t\t\t+ head.getName());\n \t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n \t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n \t\t\t\t\t\t.newMerger(repo);\n \t\t\t\tboolean noProblems;\n-\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003e lowLevelResults \u003d null;\n+\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n \t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n \t\t\t\tif (merger instanceof ResolveMerger) {\n \t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n \t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n \t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n \t\t\t\t\tresolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \t\t\t\t\tlowLevelResults \u003d resolveMerger\n \t\t\t\t\t\t\t.getMergeResults();\n \t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPathes();\n \t\t\t\t} else\n \t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n \n \t\t\t\tif (noProblems) {\n \t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n \t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n \t\t\t\t\t\t\tmerger.getResultTreeId());\n \t\t\t\t\tdco.setFailOnConflict(true);\n \t\t\t\t\tdco.checkout();\n \t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n \t\t\t\t\treturn new MergeResult(newHead.getId(),\n \t\t\t\t\t\t\tnull, new ObjectId[] {\n \t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n \t\t\t\t\tif (failingPaths !\u003d null) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] {\n \t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t\t} else\n \t\t\t\t\t\treturn new MergeResult(null,\n \t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n \t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n \t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n \t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n \t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n \t\t} finally {\n \t\t\tif (revWalk !\u003d null)\n \t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45e79a526c7ffebaf8e4758a6cb6b7af05716707": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Added merge strategy RESOLVE\n\nThis adds the first merge strategy to JGit which does real\ncontent-merges if necessary. The new merge strategy \"resolve\" takes as\ninput three commits: a common base, ours and theirs. It will simply takeover\nchanges on files which are only touched in ours or theirs. For files\ntouched in ours and theirs it will try to merge the two contents\nknowing taking into account the specified common base.\n\nRename detection has not been introduced for now.\n\nChange-Id: I49a5ebcdcf4f540f606092c0f1dc66c965dc66ba\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\n",
      "commitDate": "2010-08-30, 7:21 p.m.",
      "commitName": "45e79a526c7ffebaf8e4758a6cb6b7af05716707",
      "commitAuthor": "Christian Halstrick",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Added merge strategy RESOLVE\n\nThis adds the first merge strategy to JGit which does real\ncontent-merges if necessary. The new merge strategy \"resolve\" takes as\ninput three commits: a common base, ours and theirs. It will simply takeover\nchanges on files which are only touched in ours or theirs. For files\ntouched in ours and theirs it will try to merge the two contents\nknowing taking into account the specified common base.\n\nRename detection has not been introduced for now.\n\nChange-Id: I49a5ebcdcf4f540f606092c0f1dc66c965dc66ba\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\n",
          "commitDate": "2010-08-30, 7:21 p.m.",
          "commitName": "45e79a526c7ffebaf8e4758a6cb6b7af05716707",
          "commitAuthor": "Christian Halstrick",
          "commitDateOld": "2010-08-23, 4:20 a.m.",
          "commitNameOld": "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75",
          "commitAuthorOld": "Christian Halstrick",
          "daysBetweenCommits": 7.63,
          "commitsBetweenForRepo": 41,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n\n\t\t\t// we know for know there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\t\t\t\trepo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \"\n\t\t\t\t\t\t+ head.getName());\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n\t\t\t\t\t\t.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPathes();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
          "functionStartLine": 106,
          "functionName": "call",
          "diff": "@@ -1,68 +1,117 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n-\t\t\tInvalidMergeHeadsException {\n+\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n-\t\t\t\t\t\t\t\t\tmergeStrategy.getName(), commits.size()));\n+\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n+\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n+\t\tRevWalk revWalk \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n-\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n-\t\t\ttry {\n-\t\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n+\t\t\trevWalk \u003d new RevWalk(repo);\n+\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n \n-\t\t\t\tRef ref \u003d commits.get(0);\n+\t\t\t// we know for know there is only one commit\n+\t\t\tRef ref \u003d commits.get(0);\n \n-\t\t\t\trefLogMessage.append(ref.getName());\n+\t\t\trefLogMessage.append(ref.getName());\n \n-\t\t\t\t// handle annotated tags\n-\t\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n-\t\t\t\tif (objectId \u003d\u003d null)\n-\t\t\t\t\tobjectId \u003d ref.getObjectId();\n+\t\t\t// handle annotated tags\n+\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n+\t\t\tif (objectId \u003d\u003d null)\n+\t\t\t\tobjectId \u003d ref.getObjectId();\n \n-\t\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n-\t\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n-\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n-\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n-\t\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n-\t\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n-\t\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n-\t\t\t\t\t// update HEAD\n-\t\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n-\t\t\t\t\tcheckoutNewHead(revWalk, headCommit, srcCommit);\n-\t\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n-\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\treturn new MergeResult(srcCommit, headCommit,\n-\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n-\t\t\t\t\t\t\tMergeStatus.FAST_FORWARD, mergeStrategy);\n+\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n+\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n+\t\t\t\tsetCallable(false);\n+\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n+\t\t\t\t\t\theadCommit, srcCommit },\n+\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n+\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n+\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n+\t\t\t\t// update HEAD\n+\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n+\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n+\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n+\t\t\t\t\t\tsrcCommit.getTree());\n+\t\t\t\tdco.setFailOnConflict(true);\n+\t\t\t\tdco.checkout();\n+\n+\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n+\t\t\t\tsetCallable(false);\n+\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n+\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n+\t\t\t\t\t\tmergeStrategy, null, null);\n+\t\t\t} else {\n+\t\t\t\trepo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \"\n+\t\t\t\t\t\t+ head.getName());\n+\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n+\t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n+\t\t\t\t\t\t.newMerger(repo);\n+\t\t\t\tboolean noProblems;\n+\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003e lowLevelResults \u003d null;\n+\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n+\t\t\t\tif (merger instanceof ResolveMerger) {\n+\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n+\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n+\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n+\t\t\t\t\tresolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n+\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n+\t\t\t\t\tlowLevelResults \u003d resolveMerger\n+\t\t\t\t\t\t\t.getMergeResults();\n+\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPathes();\n+\t\t\t\t} else\n+\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n+\n+\t\t\t\tif (noProblems) {\n+\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n+\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n+\t\t\t\t\t\t\tmerger.getResultTreeId());\n+\t\t\t\t\tdco.setFailOnConflict(true);\n+\t\t\t\t\tdco.checkout();\n+\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n+\t\t\t\t\treturn new MergeResult(newHead.getId(),\n+\t\t\t\t\t\t\tnull, new ObjectId[] {\n+\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n+\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n-\t\t\t\t\treturn new MergeResult(\n-\t\t\t\t\t\t\theadCommit,\n-\t\t\t\t\t\t\tnull,\n-\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n-\t\t\t\t\t\t\tMergeResult.MergeStatus.NOT_SUPPORTED,\n-\t\t\t\t\t\t\tmergeStrategy,\n-\t\t\t\t\t\t\tJGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n+\t\t\t\t\tif (failingPaths !\u003d null) {\n+\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\trepo.writeMergeHeads(null);\n+\t\t\t\t\t\treturn new MergeResult(null,\n+\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n+\t\t\t\t\t\t\t\tnew ObjectId[] {\n+\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n+\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n+\t\t\t\t\t\t\t\tlowLevelResults, null);\n+\t\t\t\t\t} else\n+\t\t\t\t\t\treturn new MergeResult(null,\n+\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n+\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n+\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n+\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n+\t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t}\n-\t\t\t} finally {\n-\t\t\t\trevWalk.release();\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n+\t\t} finally {\n+\t\t\tif (revWalk !\u003d null)\n+\t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException]",
            "newValue": "[NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Added merge strategy RESOLVE\n\nThis adds the first merge strategy to JGit which does real\ncontent-merges if necessary. The new merge strategy \"resolve\" takes as\ninput three commits: a common base, ours and theirs. It will simply takeover\nchanges on files which are only touched in ours or theirs. For files\ntouched in ours and theirs it will try to merge the two contents\nknowing taking into account the specified common base.\n\nRename detection has not been introduced for now.\n\nChange-Id: I49a5ebcdcf4f540f606092c0f1dc66c965dc66ba\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\n",
          "commitDate": "2010-08-30, 7:21 p.m.",
          "commitName": "45e79a526c7ffebaf8e4758a6cb6b7af05716707",
          "commitAuthor": "Christian Halstrick",
          "commitDateOld": "2010-08-23, 4:20 a.m.",
          "commitNameOld": "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75",
          "commitAuthorOld": "Christian Halstrick",
          "daysBetweenCommits": 7.63,
          "commitsBetweenForRepo": 41,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n\n\t\tRevWalk revWalk \u003d null;\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\trevWalk \u003d new RevWalk(repo);\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n\n\t\t\t// we know for know there is only one commit\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit },\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\tsrcCommit.getTree());\n\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\tdco.checkout();\n\n\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy, null, null);\n\t\t\t} else {\n\t\t\t\trepo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \"\n\t\t\t\t\t\t+ head.getName());\n\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n\t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n\t\t\t\t\t\t.newMerger(repo);\n\t\t\t\tboolean noProblems;\n\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003e lowLevelResults \u003d null;\n\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n\t\t\t\tif (merger instanceof ResolveMerger) {\n\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n\t\t\t\t\tresolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\t\t\t\t\tlowLevelResults \u003d resolveMerger\n\t\t\t\t\t\t\t.getMergeResults();\n\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPathes();\n\t\t\t\t} else\n\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n\n\t\t\t\tif (noProblems) {\n\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n\t\t\t\t\t\t\tmerger.getResultTreeId());\n\t\t\t\t\tdco.setFailOnConflict(true);\n\t\t\t\t\tdco.checkout();\n\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n\t\t\t\t\treturn new MergeResult(newHead.getId(),\n\t\t\t\t\t\t\tnull, new ObjectId[] {\n\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (failingPaths !\u003d null) {\n\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n\t\t\t\t\t\trepo.writeMergeHeads(null);\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] {\n\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn new MergeResult(null,\n\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n\t\t\t\t\t\t\t\tlowLevelResults, null);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t} finally {\n\t\t\tif (revWalk !\u003d null)\n\t\t\t\trevWalk.release();\n\t\t}\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
          "functionStartLine": 106,
          "functionName": "call",
          "diff": "@@ -1,68 +1,117 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n-\t\t\tInvalidMergeHeadsException {\n+\t\t\tInvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n-\t\t\t\t\t\t\t\t\tmergeStrategy.getName(), commits.size()));\n+\t\t\t\t\t\t\t\t\tmergeStrategy.getName(),\n+\t\t\t\t\t\t\t\t\tInteger.valueOf(commits.size())));\n \n+\t\tRevWalk revWalk \u003d null;\n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n-\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n-\t\t\ttry {\n-\t\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n+\t\t\trevWalk \u003d new RevWalk(repo);\n+\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n \n-\t\t\t\tRef ref \u003d commits.get(0);\n+\t\t\t// we know for know there is only one commit\n+\t\t\tRef ref \u003d commits.get(0);\n \n-\t\t\t\trefLogMessage.append(ref.getName());\n+\t\t\trefLogMessage.append(ref.getName());\n \n-\t\t\t\t// handle annotated tags\n-\t\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n-\t\t\t\tif (objectId \u003d\u003d null)\n-\t\t\t\t\tobjectId \u003d ref.getObjectId();\n+\t\t\t// handle annotated tags\n+\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n+\t\t\tif (objectId \u003d\u003d null)\n+\t\t\t\tobjectId \u003d ref.getObjectId();\n \n-\t\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n-\t\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n-\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n-\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n-\t\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n-\t\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n-\t\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n-\t\t\t\t\t// update HEAD\n-\t\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n-\t\t\t\t\tcheckoutNewHead(revWalk, headCommit, srcCommit);\n-\t\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n-\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\treturn new MergeResult(srcCommit, headCommit,\n-\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n-\t\t\t\t\t\t\tMergeStatus.FAST_FORWARD, mergeStrategy);\n+\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n+\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n+\t\t\t\tsetCallable(false);\n+\t\t\t\treturn new MergeResult(headCommit, srcCommit, new ObjectId[] {\n+\t\t\t\t\t\theadCommit, srcCommit },\n+\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n+\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n+\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n+\t\t\t\t// update HEAD\n+\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n+\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n+\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n+\t\t\t\t\t\tsrcCommit.getTree());\n+\t\t\t\tdco.setFailOnConflict(true);\n+\t\t\t\tdco.checkout();\n+\n+\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n+\t\t\t\tsetCallable(false);\n+\t\t\t\treturn new MergeResult(srcCommit, srcCommit, new ObjectId[] {\n+\t\t\t\t\t\theadCommit, srcCommit }, MergeStatus.FAST_FORWARD,\n+\t\t\t\t\t\tmergeStrategy, null, null);\n+\t\t\t} else {\n+\t\t\t\trepo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \"\n+\t\t\t\t\t\t+ head.getName());\n+\t\t\t\trepo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n+\t\t\t\tThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy\n+\t\t\t\t\t\t.newMerger(repo);\n+\t\t\t\tboolean noProblems;\n+\t\t\t\tMap\u003cString, org.eclipse.jgit.merge.MergeResult\u003e lowLevelResults \u003d null;\n+\t\t\t\tMap\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n+\t\t\t\tif (merger instanceof ResolveMerger) {\n+\t\t\t\t\tResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n+\t\t\t\t\tresolveMerger.setCommitNames(new String[] {\n+\t\t\t\t\t\t\t\"BASE\", \"HEAD\", ref.getName() });\n+\t\t\t\t\tresolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n+\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n+\t\t\t\t\tlowLevelResults \u003d resolveMerger\n+\t\t\t\t\t\t\t.getMergeResults();\n+\t\t\t\t\tfailingPaths \u003d resolveMerger.getFailingPathes();\n+\t\t\t\t} else\n+\t\t\t\t\tnoProblems \u003d merger.merge(headCommit, srcCommit);\n+\n+\t\t\t\tif (noProblems) {\n+\t\t\t\t\tDirCacheCheckout dco \u003d new DirCacheCheckout(repo,\n+\t\t\t\t\t\t\theadCommit.getTree(), repo.lockDirCache(),\n+\t\t\t\t\t\t\tmerger.getResultTreeId());\n+\t\t\t\t\tdco.setFailOnConflict(true);\n+\t\t\t\t\tdco.checkout();\n+\t\t\t\t\tRevCommit newHead \u003d new Git(getRepository()).commit().call();\n+\t\t\t\t\treturn new MergeResult(newHead.getId(),\n+\t\t\t\t\t\t\tnull, new ObjectId[] {\n+\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n+\t\t\t\t\t\t\tMergeStatus.MERGED, mergeStrategy, null, null);\n \t\t\t\t} else {\n-\t\t\t\t\treturn new MergeResult(\n-\t\t\t\t\t\t\theadCommit,\n-\t\t\t\t\t\t\tnull,\n-\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n-\t\t\t\t\t\t\tMergeResult.MergeStatus.NOT_SUPPORTED,\n-\t\t\t\t\t\t\tmergeStrategy,\n-\t\t\t\t\t\t\tJGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n+\t\t\t\t\tif (failingPaths !\u003d null) {\n+\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\trepo.writeMergeHeads(null);\n+\t\t\t\t\t\treturn new MergeResult(null,\n+\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n+\t\t\t\t\t\t\t\tnew ObjectId[] {\n+\t\t\t\t\t\t\t\t\t\theadCommit.getId(), srcCommit.getId() },\n+\t\t\t\t\t\t\t\tMergeStatus.FAILED, mergeStrategy,\n+\t\t\t\t\t\t\t\tlowLevelResults, null);\n+\t\t\t\t\t} else\n+\t\t\t\t\t\treturn new MergeResult(null,\n+\t\t\t\t\t\t\t\tmerger.getBaseCommit(0, 1),\n+\t\t\t\t\t\t\t\tnew ObjectId[] { headCommit.getId(),\n+\t\t\t\t\t\t\t\t\t\tsrcCommit.getId() },\n+\t\t\t\t\t\t\t\tMergeStatus.CONFLICTING, mergeStrategy,\n+\t\t\t\t\t\t\t\tlowLevelResults, null);\n \t\t\t\t}\n-\t\t\t} finally {\n-\t\t\t\trevWalk.release();\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te), e);\n+\t\t} finally {\n+\t\t\tif (revWalk !\u003d null)\n+\t\t\t\trevWalk.release();\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75": {
      "type": "Ybodychange",
      "commitMessage": "Improved creation of JGitInternalException\n\nThere where 3 cases where a JGitInternalExcption was created\nwithout specifying the root cause. This has been fixed.\n\nChange-Id: I2ee08d04732371cd9e30874b1437b61217770b6a\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2010-08-23, 4:20 a.m.",
      "commitName": "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2010-08-20, 8:38 p.m.",
      "commitNameOld": "b46b635c0389e01a55b2f9c490e5b6c54a8ce640",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 2.32,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(), commits.size()));\n\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\ttry {\n\t\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n\n\t\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t\t// handle annotated tags\n\t\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\t\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n\t\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n\t\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t\t// update HEAD\n\t\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\t\tcheckoutNewHead(revWalk, headCommit, srcCommit);\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\treturn new MergeResult(srcCommit, headCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n\t\t\t\t\t\t\tMergeStatus.FAST_FORWARD, mergeStrategy);\n\t\t\t\t} else {\n\t\t\t\t\treturn new MergeResult(\n\t\t\t\t\t\t\theadCommit,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n\t\t\t\t\t\t\tMergeResult.MergeStatus.NOT_SUPPORTED,\n\t\t\t\t\t\t\tmergeStrategy,\n\t\t\t\t\t\t\tJGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\trevWalk.release();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te), e);\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 102,
      "functionName": "call",
      "diff": "@@ -1,68 +1,68 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(), commits.size()));\n \n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\ttry {\n \t\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n \n \t\t\t\tRef ref \u003d commits.get(0);\n \n \t\t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t\t// handle annotated tags\n \t\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\t\tif (objectId \u003d\u003d null)\n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \t\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n \t\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n \t\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t\t// update HEAD\n \t\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\t\tcheckoutNewHead(revWalk, headCommit, srcCommit);\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\treturn new MergeResult(srcCommit, headCommit,\n \t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n \t\t\t\t\t\t\tMergeStatus.FAST_FORWARD, mergeStrategy);\n \t\t\t\t} else {\n \t\t\t\t\treturn new MergeResult(\n \t\t\t\t\t\t\theadCommit,\n \t\t\t\t\t\t\tnull,\n \t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n \t\t\t\t\t\t\tMergeResult.MergeStatus.NOT_SUPPORTED,\n \t\t\t\t\t\t\tmergeStrategy,\n \t\t\t\t\t\t\tJGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\trevWalk.release();\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n-\t\t\t\t\t\t\te));\n+\t\t\t\t\t\t\te), e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "75c9b2438594dc6ac125ff1bdf97022c7f429b78": {
      "type": "Ybodychange",
      "commitMessage": "Enhance MergeResult to report conflicts, etc\n\nThe MergeResult class is enhanced to report more data about a\nthree-way merge. Information about conflicts and the base, ours,\ntheirs commits can be retrived.\n\nChange-Id: Iaaf41a1f4002b8fe3ddfa62dc73c787f363460c2\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2010-08-19, 1:16 p.m.",
      "commitName": "75c9b2438594dc6ac125ff1bdf97022c7f429b78",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2010-06-29, 6:12 p.m.",
      "commitNameOld": "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 50.79,
      "commitsBetweenForRepo": 131,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(), commits.size()));\n\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\ttry {\n\t\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n\n\t\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t\t// handle annotated tags\n\t\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\t\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n\t\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n\t\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t\t// update HEAD\n\t\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\t\tcheckoutNewHead(revWalk, headCommit, srcCommit);\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\treturn new MergeResult(srcCommit, headCommit,\n\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n\t\t\t\t\t\t\tMergeStatus.FAST_FORWARD, mergeStrategy);\n\t\t\t\t} else {\n\t\t\t\t\treturn new MergeResult(\n\t\t\t\t\t\t\theadCommit,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n\t\t\t\t\t\t\tMergeResult.MergeStatus.NOT_SUPPORTED,\n\t\t\t\t\t\t\tmergeStrategy,\n\t\t\t\t\t\t\tJGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\trevWalk.release();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te));\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 102,
      "functionName": "call",
      "diff": "@@ -1,63 +1,68 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(), commits.size()));\n \n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n-\t\t\t\tthrow new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n+\t\t\t\tthrow new NoHeadException(\n+\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n \t\t\ttry {\n \t\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n \n \t\t\t\tRef ref \u003d commits.get(0);\n \n \t\t\t\trefLogMessage.append(ref.getName());\n \n \t\t\t\t// handle annotated tags\n \t\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n \t\t\t\tif (objectId \u003d\u003d null)\n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \n \t\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n \t\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n \t\t\t\t\tsetCallable(false);\n-\t\t\t\t\treturn new MergeResult(headCommit,\n+\t\t\t\t\treturn new MergeResult(headCommit, srcCommit,\n+\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n \t\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n \t\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n \t\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n \t\t\t\t\t// update HEAD\n \t\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n \t\t\t\t\tcheckoutNewHead(revWalk, headCommit, srcCommit);\n \t\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n \t\t\t\t\tsetCallable(false);\n-\t\t\t\t\treturn new MergeResult(srcCommit, MergeStatus.FAST_FORWARD,\n-\t\t\t\t\t\t\tmergeStrategy);\n+\t\t\t\t\treturn new MergeResult(srcCommit, headCommit,\n+\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n+\t\t\t\t\t\t\tMergeStatus.FAST_FORWARD, mergeStrategy);\n \t\t\t\t} else {\n \t\t\t\t\treturn new MergeResult(\n \t\t\t\t\t\t\theadCommit,\n+\t\t\t\t\t\t\tnull,\n+\t\t\t\t\t\t\tnew ObjectId[] { srcCommit, headCommit },\n \t\t\t\t\t\t\tMergeResult.MergeStatus.NOT_SUPPORTED,\n \t\t\t\t\t\t\tmergeStrategy,\n \t\t\t\t\t\t\tJGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\trevWalk.release();\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te));\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "515deaf7e503738b4c53c3c2dfd6d7acab3bef18": {
      "type": "Ybodychange",
      "commitMessage": "Ensure RevWalk is released when done\n\nUpdate a number of calling sites of RevWalk to ensure the walker\u0027s\ninternal ObjectReader is released after the walk is no longer used.\nBecause the ObjectReader is likely to hold onto a native resource\nlike an Inflater, we don\u0027t want to leak them outside of their\nuseful scope.\n\nWhere possible we also try to share ObjectReaders across several\nwalk pools, or between a walker and a PackWriter.  This permits\nthe ObjectReader to actually do some caching if it felt inclined\nto do so.\n\nNot everything was updated, we\u0027ll probably need to come back and\nupdate even more call sites, but these are some of the biggest\noffenders.  Test cases in particular aren\u0027t updated.  My plan is to\nmove most storage-agnostic tests onto some purely in-memory storage\nsolution that doesn\u0027t do compression.\n\nChange-Id: I04087ec79faeea208b19848939898ad7172b6672\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-06-29, 6:12 p.m.",
      "commitName": "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-06-25, 9:03 p.m.",
      "commitNameOld": "203bd6626767015dfb04d421c572b26a34e9cecf",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 3.88,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(), commits.size()));\n\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\ttry {\n\t\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n\n\t\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t\t// handle annotated tags\n\t\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\t\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\treturn new MergeResult(headCommit,\n\t\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n\t\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t\t// update HEAD\n\t\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\t\tcheckoutNewHead(revWalk, headCommit, srcCommit);\n\t\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n\t\t\t\t\tsetCallable(false);\n\t\t\t\t\treturn new MergeResult(srcCommit, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\t\tmergeStrategy);\n\t\t\t\t} else {\n\t\t\t\t\treturn new MergeResult(\n\t\t\t\t\t\t\theadCommit,\n\t\t\t\t\t\t\tMergeResult.MergeStatus.NOT_SUPPORTED,\n\t\t\t\t\t\t\tmergeStrategy,\n\t\t\t\t\t\t\tJGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\trevWalk.release();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te));\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 102,
      "functionName": "call",
      "diff": "@@ -1,59 +1,63 @@\n \tpublic MergeResult call() throws NoHeadException,\n \t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n \t\t\tInvalidMergeHeadsException {\n \t\tcheckCallable();\n \n \t\tif (commits.size() !\u003d 1)\n \t\t\tthrow new InvalidMergeHeadsException(\n \t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n \t\t\t\t\t\t\t: MessageFormat.format(\n \t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n \t\t\t\t\t\t\t\t\tmergeStrategy.getName(), commits.size()));\n \n \t\ttry {\n \t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n \t\t\tif (head \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n \n \t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n \t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n-\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n+\t\t\ttry {\n+\t\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n \n-\t\t\tRef ref \u003d commits.get(0);\n+\t\t\t\tRef ref \u003d commits.get(0);\n \n-\t\t\trefLogMessage.append(ref.getName());\n+\t\t\t\trefLogMessage.append(ref.getName());\n \n-\t\t\t// handle annotated tags\n-\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n-\t\t\tif (objectId \u003d\u003d null)\n-\t\t\t\tobjectId \u003d ref.getObjectId();\n+\t\t\t\t// handle annotated tags\n+\t\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n+\t\t\t\tif (objectId \u003d\u003d null)\n+\t\t\t\t\tobjectId \u003d ref.getObjectId();\n \n-\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n-\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n-\t\t\t\tsetCallable(false);\n-\t\t\t\treturn new MergeResult(headCommit,\n-\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n-\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n-\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n-\t\t\t\t// update HEAD\n-\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n-\t\t\t\tcheckoutNewHead(revWalk, headCommit, srcCommit);\n-\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n-\t\t\t\tsetCallable(false);\n-\t\t\t\treturn new MergeResult(srcCommit, MergeStatus.FAST_FORWARD,\n-\t\t\t\t\t\tmergeStrategy);\n-\t\t\t} else {\n-\t\t\t\treturn new MergeResult(\n-\t\t\t\t\t\theadCommit,\n-\t\t\t\t\t\tMergeResult.MergeStatus.NOT_SUPPORTED,\n-\t\t\t\t\t\tmergeStrategy,\n-\t\t\t\t\t\tJGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n+\t\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n+\t\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n+\t\t\t\t\tsetCallable(false);\n+\t\t\t\t\treturn new MergeResult(headCommit,\n+\t\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n+\t\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n+\t\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n+\t\t\t\t\t// update HEAD\n+\t\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n+\t\t\t\t\tcheckoutNewHead(revWalk, headCommit, srcCommit);\n+\t\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n+\t\t\t\t\tsetCallable(false);\n+\t\t\t\t\treturn new MergeResult(srcCommit, MergeStatus.FAST_FORWARD,\n+\t\t\t\t\t\t\tmergeStrategy);\n+\t\t\t\t} else {\n+\t\t\t\t\treturn new MergeResult(\n+\t\t\t\t\t\t\theadCommit,\n+\t\t\t\t\t\t\tMergeResult.MergeStatus.NOT_SUPPORTED,\n+\t\t\t\t\t\t\tmergeStrategy,\n+\t\t\t\t\t\t\tJGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\trevWalk.release();\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n \t\t\t\t\t\t\te));\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5b0e73b849d19c9f072c4c6738a5d5adae413112": {
      "type": "Yintroduced",
      "commitMessage": "Add a merge command to the jgit API\n\nMerges the current head with one other commit.\nIn this first iteration the merge command supports\nonly fast forward and already up-to-date.\n\nChange-Id: I0db480f061e01b343570cf7da02cac13a0cbdf8f\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2010-05-24, 10:52 a.m.",
      "commitName": "5b0e73b849d19c9f072c4c6738a5d5adae413112",
      "commitAuthor": "Stefan Lay",
      "diff": "@@ -0,0 +1,59 @@\n+\tpublic MergeResult call() throws NoHeadException,\n+\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n+\t\t\tInvalidMergeHeadsException {\n+\t\tcheckCallable();\n+\n+\t\tif (commits.size() !\u003d 1)\n+\t\t\tthrow new InvalidMergeHeadsException(\n+\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n+\t\t\t\t\t\t\t: MessageFormat.format(\n+\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n+\t\t\t\t\t\t\t\t\tmergeStrategy.getName(), commits.size()));\n+\n+\t\ttry {\n+\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n+\t\t\tif (head \u003d\u003d null)\n+\t\t\t\tthrow new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n+\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n+\n+\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n+\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n+\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n+\n+\t\t\tRef ref \u003d commits.get(0);\n+\n+\t\t\trefLogMessage.append(ref.getName());\n+\n+\t\t\t// handle annotated tags\n+\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n+\t\t\tif (objectId \u003d\u003d null)\n+\t\t\t\tobjectId \u003d ref.getObjectId();\n+\n+\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n+\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n+\t\t\t\tsetCallable(false);\n+\t\t\t\treturn new MergeResult(headCommit,\n+\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n+\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n+\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n+\t\t\t\t// update HEAD\n+\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n+\t\t\t\tcheckoutNewHead(revWalk, headCommit, srcCommit);\n+\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n+\t\t\t\tsetCallable(false);\n+\t\t\t\treturn new MergeResult(srcCommit, MergeStatus.FAST_FORWARD,\n+\t\t\t\t\t\tmergeStrategy);\n+\t\t\t} else {\n+\t\t\t\treturn new MergeResult(\n+\t\t\t\t\t\theadCommit,\n+\t\t\t\t\t\tMergeResult.MergeStatus.NOT_SUPPORTED,\n+\t\t\t\t\t\tmergeStrategy,\n+\t\t\t\t\t\tJGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new JGitInternalException(\n+\t\t\t\t\tMessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n+\t\t\t\t\t\t\te));\n+\t\t}\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic MergeResult call() throws NoHeadException,\n\t\t\tConcurrentRefUpdateException, CheckoutConflictException,\n\t\t\tInvalidMergeHeadsException {\n\t\tcheckCallable();\n\n\t\tif (commits.size() !\u003d 1)\n\t\t\tthrow new InvalidMergeHeadsException(\n\t\t\t\t\tcommits.isEmpty() ? JGitText.get().noMergeHeadSpecified\n\t\t\t\t\t\t\t: MessageFormat.format(\n\t\t\t\t\t\t\t\t\tJGitText.get().mergeStrategyDoesNotSupportHeads,\n\t\t\t\t\t\t\t\t\tmergeStrategy.getName(), commits.size()));\n\n\t\ttry {\n\t\t\tRef head \u003d repo.getRef(Constants.HEAD);\n\t\t\tif (head \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tStringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n\n\t\t\t// Check for FAST_FORWARD, ALREADY_UP_TO_DATE\n\t\t\tRevWalk revWalk \u003d new RevWalk(repo);\n\t\t\tRevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n\n\t\t\tRef ref \u003d commits.get(0);\n\n\t\t\trefLogMessage.append(ref.getName());\n\n\t\t\t// handle annotated tags\n\t\t\tObjectId objectId \u003d ref.getPeeledObjectId();\n\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\tobjectId \u003d ref.getObjectId();\n\n\t\t\tRevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n\t\t\tif (revWalk.isMergedInto(srcCommit, headCommit)) {\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(headCommit,\n\t\t\t\t\t\tMergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n\t\t\t} else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n\t\t\t\t// FAST_FORWARD detected: skip doing a real merge but only\n\t\t\t\t// update HEAD\n\t\t\t\trefLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n\t\t\t\tcheckoutNewHead(revWalk, headCommit, srcCommit);\n\t\t\t\tupdateHead(refLogMessage, srcCommit, head.getObjectId());\n\t\t\t\tsetCallable(false);\n\t\t\t\treturn new MergeResult(srcCommit, MergeStatus.FAST_FORWARD,\n\t\t\t\t\t\tmergeStrategy);\n\t\t\t} else {\n\t\t\t\treturn new MergeResult(\n\t\t\t\t\t\theadCommit,\n\t\t\t\t\t\tMergeResult.MergeStatus.NOT_SUPPORTED,\n\t\t\t\t\t\tmergeStrategy,\n\t\t\t\t\t\tJGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,\n\t\t\t\t\t\t\te));\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 102,
      "functionName": "call"
    }
  }
}