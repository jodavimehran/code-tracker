{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "H:\\Projects\\javaparser\\javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "JavaParserFacade.java",
  "functionName": "convertToUsage",
  "functionId": "convertToUsage___type-com.github.javaparser.ast.type.Type__context-Context",
  "sourceFilePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
  "functionStartLine": 519,
  "functionEndLine": 578,
  "numCommitsSeen": 239,
  "timeTaken": 2601,
  "changeHistory": [
    "427dd53b9ebedcb0bdb687007eb0faf2de734df4",
    "6d59e3083ed82de3490c2f5ca35a07bb73806fea",
    "b54617e765d73b3ce0d187cf12ad8da382bce439",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
    "f63811a47591d89b25a1de78686bdc6dfcaf42b9",
    "478a9ba268137913d67438b1e3c8f61e5e0976a5",
    "198ba6cbe49832ac09ca84c6920e9be661a3b56a",
    "5d8d0cb7947efcf2282f7d056302dd905f348532",
    "56377a22d552f0880ceccacf1aca1eafbc7094e4",
    "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
    "33d37d1089463ba9af543996a05cac5955c46251",
    "90c22f84a61e12130a8750d235acf7ed06305796",
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
    "07782fbbe149055d495e0c358da844734c08641f",
    "c990d23490f5c4ac4322119b03d5951b63eef055",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
    "a1c7c58143a592965f8378767adc69709e4c0043",
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
    "9c53c2cbc607ea694438ade8630be0c155a33162",
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
    "3fcd7b41f404d112b13d3bfe732b26eceec0dbfe",
    "33753cab1604a44d43215ba4055b435606a7a71b",
    "341e081a5f8909a3a467671befcca2941b786d3d",
    "d6a1f32f00bd513d6bc56fbbfefcb9ae9c706492",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
    "82eb44707b620803d424188a1eb8708fcaf093cb",
    "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
    "e581ddb297f5a1da9790adaeadbb6d0f43c8432f",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
    "4a18b1ee8ed716d6e32e190f728f1eee57148872",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
    "03ec309bba14eaf50a32b05353fa9711b831de7f",
    "fb388c36c0045c50744cf215521e5c280036aa70",
    "1613b8d9cc00da012539ea3db05cdb0cc8153358",
    "0e81f51c40996b42cb262dc2397126cee8f60965",
    "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b",
    "eec165d9e3ef0ab1d93f69a231964984a3379762",
    "ee58eb8363ecd8fad15a63eb2fdc94a387b58807",
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
    "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
    "1829d9560d37efd59722aaa2f1f22e392918429b",
    "0c4c859f472f7243919f1af7a0871cf8155af1ba",
    "7b6c27e95fef9e725fbf9e15afb852bb952dfa34",
    "1d5332815b543d569be3d7ec672a65b7efc39a04",
    "6650e5a3818c15de2883b71cd41524b0337e26f6",
    "2568d9ebe91ceb0a13c98b16f99593cd22084efa"
  ],
  "changeHistoryShort": {
    "427dd53b9ebedcb0bdb687007eb0faf2de734df4": "Ybodychange",
    "6d59e3083ed82de3490c2f5ca35a07bb73806fea": "Ybodychange",
    "b54617e765d73b3ce0d187cf12ad8da382bce439": "Ybodychange",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": "Yfilerename",
    "f63811a47591d89b25a1de78686bdc6dfcaf42b9": "Ybodychange",
    "478a9ba268137913d67438b1e3c8f61e5e0976a5": "Ybodychange",
    "198ba6cbe49832ac09ca84c6920e9be661a3b56a": "Ybodychange",
    "5d8d0cb7947efcf2282f7d056302dd905f348532": "Ymultichange(Yreturntypechange,Ybodychange)",
    "56377a22d552f0880ceccacf1aca1eafbc7094e4": "Ymodifierchange",
    "0f40221492b47df25615a1b5909fefa6f2d6fa0e": "Ymodifierchange",
    "33d37d1089463ba9af543996a05cac5955c46251": "Ybodychange",
    "90c22f84a61e12130a8750d235acf7ed06305796": "Yparameterchange",
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923": "Ybodychange",
    "07782fbbe149055d495e0c358da844734c08641f": "Ymodifierchange",
    "c990d23490f5c4ac4322119b03d5951b63eef055": "Ymultichange(Yparameterchange,Ybodychange)",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": "Ybodychange",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": "Ybodychange",
    "a1c7c58143a592965f8378767adc69709e4c0043": "Ybodychange",
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae": "Ybodychange",
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf": "Ybodychange",
    "9c53c2cbc607ea694438ade8630be0c155a33162": "Yfilerename",
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7": "Ybodychange",
    "3fcd7b41f404d112b13d3bfe732b26eceec0dbfe": "Ybodychange",
    "33753cab1604a44d43215ba4055b435606a7a71b": "Ybodychange",
    "341e081a5f8909a3a467671befcca2941b786d3d": "Ybodychange",
    "d6a1f32f00bd513d6bc56fbbfefcb9ae9c706492": "Ybodychange",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": "Ybodychange",
    "82eb44707b620803d424188a1eb8708fcaf093cb": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "14c9305d49885a12acdb7c09d2e35ad29b5403cf": "Ybodychange",
    "e581ddb297f5a1da9790adaeadbb6d0f43c8432f": "Ybodychange",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": "Yfilerename",
    "4a18b1ee8ed716d6e32e190f728f1eee57148872": "Ybodychange",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": "Yfilerename",
    "03ec309bba14eaf50a32b05353fa9711b831de7f": "Ybodychange",
    "fb388c36c0045c50744cf215521e5c280036aa70": "Yfilerename",
    "1613b8d9cc00da012539ea3db05cdb0cc8153358": "Ybodychange",
    "0e81f51c40996b42cb262dc2397126cee8f60965": "Ybodychange",
    "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b": "Ybodychange",
    "eec165d9e3ef0ab1d93f69a231964984a3379762": "Ybodychange",
    "ee58eb8363ecd8fad15a63eb2fdc94a387b58807": "Ybodychange",
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4": "Ybodychange",
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176": "Ybodychange",
    "416e7b16f820700af08a94e4b38a2b4c24ef6a2c": "Ybodychange",
    "1829d9560d37efd59722aaa2f1f22e392918429b": "Ybodychange",
    "0c4c859f472f7243919f1af7a0871cf8155af1ba": "Ybodychange",
    "7b6c27e95fef9e725fbf9e15afb852bb952dfa34": "Ybodychange",
    "1d5332815b543d569be3d7ec672a65b7efc39a04": "Ybodychange",
    "6650e5a3818c15de2883b71cd41524b0337e26f6": "Ymodifierchange",
    "2568d9ebe91ceb0a13c98b16f99593cd22084efa": "Yintroduced"
  },
  "changeHistoryDetails": {
    "427dd53b9ebedcb0bdb687007eb0faf2de734df4": {
      "type": "Ybodychange",
      "commitMessage": "Better error handling for \"var\" inferrer.\n",
      "commitDate": "2018-02-14, 1:49 p.m.",
      "commitName": "427dd53b9ebedcb0bdb687007eb0faf2de734df4",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2018-02-14, 12:42 p.m.",
      "commitNameOld": "6d59e3083ed82de3490c2f5ca35a07bb73806fea",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (context \u003d\u003d null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType \u003d (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent \u003d type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator \u003d (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -\u003e new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 429,
      "functionName": "convertToUsage",
      "diff": "@@ -1,54 +1,60 @@\n     protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (context \u003d\u003d null) {\n             throw new NullPointerException(\"Context should not be null\");\n         }\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                     return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else if (type instanceof UnionType) {\n             UnionType unionType \u003d (UnionType) type;\n             return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n         } else if (type instanceof VarType) {\n-            final VariableDeclarator variableDeclarator \u003d (VariableDeclarator)type.getParentNode().get();\n-            return variableDeclarator.getInitializer().get().calculateResolvedType();\n+            Node parent \u003d type.getParentNode().get();\n+            if (!(parent instanceof VariableDeclarator)) {\n+                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n+            }\n+            final VariableDeclarator variableDeclarator \u003d (VariableDeclarator) parent;\n+            return variableDeclarator.getInitializer()\n+                    .map(Expression::calculateResolvedType)\n+                    .orElseThrow(() -\u003e new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6d59e3083ed82de3490c2f5ca35a07bb73806fea": {
      "type": "Ybodychange",
      "commitMessage": "Make a simple \"var\" inferrer.\n",
      "commitDate": "2018-02-14, 12:42 p.m.",
      "commitName": "6d59e3083ed82de3490c2f5ca35a07bb73806fea",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2018-02-03, 1:46 p.m.",
      "commitNameOld": "b54617e765d73b3ce0d187cf12ad8da382bce439",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 10.96,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "    protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (context \u003d\u003d null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType \u003d (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            final VariableDeclarator variableDeclarator \u003d (VariableDeclarator)type.getParentNode().get();\n            return variableDeclarator.getInitializer().get().calculateResolvedType();\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 429,
      "functionName": "convertToUsage",
      "diff": "@@ -1,51 +1,54 @@\n     protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (context \u003d\u003d null) {\n             throw new NullPointerException(\"Context should not be null\");\n         }\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                     return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else if (type instanceof UnionType) {\n             UnionType unionType \u003d (UnionType) type;\n             return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n+        } else if (type instanceof VarType) {\n+            final VariableDeclarator variableDeclarator \u003d (VariableDeclarator)type.getParentNode().get();\n+            return variableDeclarator.getInitializer().get().calculateResolvedType();\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b54617e765d73b3ce0d187cf12ad8da382bce439": {
      "type": "Ybodychange",
      "commitMessage": "Cleaning up JSS code\n",
      "commitDate": "2018-02-03, 1:46 p.m.",
      "commitName": "b54617e765d73b3ce0d187cf12ad8da382bce439",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2018-01-10, 7:52 a.m.",
      "commitNameOld": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 24.25,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "actualSource": "    protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (context \u003d\u003d null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType \u003d (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 429,
      "functionName": "convertToUsage",
      "diff": "@@ -1,51 +1,51 @@\n     protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (context \u003d\u003d null) {\n             throw new NullPointerException(\"Context should not be null\");\n         }\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                     return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n-            if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n-                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n-            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n-                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n-            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n+            if (wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n+                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n+            } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 wildcardType.getSuperType().isPresent()) {\n+                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n+            } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else if (type instanceof UnionType) {\n-            UnionType unionType \u003d (UnionType)type;\n+            UnionType unionType \u003d (UnionType) type;\n             return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
      "type": "Yfilerename",
      "commitMessage": "rename JSS modules\n",
      "commitDate": "2018-01-10, 7:52 a.m.",
      "commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018-01-10, 3:01 a.m.",
      "commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (context \u003d\u003d null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType \u003d (UnionType)type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 448,
      "functionName": "convertToUsage",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java"
      }
    },
    "f63811a47591d89b25a1de78686bdc6dfcaf42b9": {
      "type": "Ybodychange",
      "commitMessage": "adding support to resolve union types\n",
      "commitDate": "2017-11-25, 6:15 a.m.",
      "commitName": "f63811a47591d89b25a1de78686bdc6dfcaf42b9",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-11-25, 3:49 a.m.",
      "commitNameOld": "478a9ba268137913d67438b1e3c8f61e5e0976a5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (context \u003d\u003d null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType \u003d (UnionType)type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 443,
      "functionName": "convertToUsage",
      "diff": "@@ -1,48 +1,51 @@\n     protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (context \u003d\u003d null) {\n             throw new NullPointerException(\"Context should not be null\");\n         }\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                     return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n+        } else if (type instanceof UnionType) {\n+            UnionType unionType \u003d (UnionType)type;\n+            return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "478a9ba268137913d67438b1e3c8f61e5e0976a5": {
      "type": "Ybodychange",
      "commitMessage": "adding tests for #343 and improving error messages for nodes outside the AST\n",
      "commitDate": "2017-11-25, 3:49 a.m.",
      "commitName": "478a9ba268137913d67438b1e3c8f61e5e0976a5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-11-07, 3:09 p.m.",
      "commitNameOld": "23a829996b5393fc6697d51b1d3ec332157b1279",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 17.53,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "    protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (context \u003d\u003d null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 446,
      "functionName": "convertToUsage",
      "diff": "@@ -1,45 +1,48 @@\n     protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+        if (context \u003d\u003d null) {\n+            throw new NullPointerException(\"Context should not be null\");\n+        }\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                     return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "198ba6cbe49832ac09ca84c6920e9be661a3b56a": {
      "type": "Ybodychange",
      "commitMessage": "issue1154: correct most compilation errors in the jp model\n",
      "commitDate": "2017-09-29, 2:30 a.m.",
      "commitName": "198ba6cbe49832ac09ca84c6920e9be661a3b56a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-09-28, 4:36 p.m.",
      "commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.41,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 431,
      "functionName": "convertToUsage",
      "diff": "@@ -1,45 +1,45 @@\n     protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n-            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n+            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n-            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n+            ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n-                if (typeDeclaration instanceof TypeParameterDeclaration) {\n-                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n+                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n+                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n+                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n-            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n+            return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5d8d0cb7947efcf2282f7d056302dd905f348532": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "more work on converting to moved classes\n",
      "commitDate": "2017-09-28, 4:36 p.m.",
      "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017-09-28, 4:36 p.m.",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-09-28, 3:35 p.m.",
          "commitNameOld": "c3dc3669e86f005080c02e62162356022eafaac1",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "    protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 434,
          "functionName": "convertToUsage",
          "diff": "@@ -1,45 +1,45 @@\n-    protected Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n-            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n+            List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n+                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n+                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.UNBOUNDED;\n+                return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n-            return VoidType.INSTANCE;\n+            return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n-            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n+            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Type",
            "newValue": "ResolvedType"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017-09-28, 4:36 p.m.",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-09-28, 3:35 p.m.",
          "commitNameOld": "c3dc3669e86f005080c02e62162356022eafaac1",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "    protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 434,
          "functionName": "convertToUsage",
          "diff": "@@ -1,45 +1,45 @@\n-    protected Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n-            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n+            List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n+                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n+                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.UNBOUNDED;\n+                return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n-            return VoidType.INSTANCE;\n+            return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n-            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n+            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "56377a22d552f0880ceccacf1aca1eafbc7094e4": {
      "type": "Ymodifierchange",
      "commitMessage": "Switch method to protected as it wasn\u0027t originally public\n",
      "commitDate": "2017-02-13, 6:59 p.m.",
      "commitName": "56377a22d552f0880ceccacf1aca1eafbc7094e4",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017-02-13, 6:49 p.m.",
      "commitNameOld": "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    protected Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 396,
      "functionName": "convertToUsage",
      "diff": "@@ -1,45 +1,45 @@\n-    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    protected Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[protected]"
      }
    },
    "0f40221492b47df25615a1b5909fefa6f2d6fa0e": {
      "type": "Ymodifierchange",
      "commitMessage": "Refactored out huge method from facade to visitor\n",
      "commitDate": "2017-02-13, 6:49 p.m.",
      "commitName": "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017-02-01, 7:04 p.m.",
      "commitNameOld": "a12a91a78591323403230d5654879a44ab4afb20",
      "commitAuthorOld": "Brandon Fergerson",
      "daysBetweenCommits": 11.99,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 396,
      "functionName": "convertToUsage",
      "diff": "@@ -1,45 +1,45 @@\n-    private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[public]"
      }
    },
    "33d37d1089463ba9af543996a05cac5955c46251": {
      "type": "Ybodychange",
      "commitMessage": "Fixed issue when converting wildcard type with super bound\n",
      "commitDate": "2017-01-12, 12:17 p.m.",
      "commitName": "33d37d1089463ba9af543996a05cac5955c46251",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017-01-11, 7:45 p.m.",
      "commitNameOld": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 713,
      "functionName": "convertToUsage",
      "diff": "@@ -1,45 +1,45 @@\n     private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n+                return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "90c22f84a61e12130a8750d235acf7ed06305796": {
      "type": "Yparameterchange",
      "commitMessage": "migration to JavaParser 3.0.0-RC.3\n",
      "commitDate": "2016-12-19, 11:01 a.m.",
      "commitName": "90c22f84a61e12130a8750d235acf7ed06305796",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-12-13, 2:42 p.m.",
      "commitNameOld": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 5.85,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 711,
      "functionName": "convertToUsage",
      "diff": "@@ -1,45 +1,45 @@\n-    private Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n+    private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[type-com.github.javaparser.ast.type.Type\u003c?\u003e, context-Context]",
        "newValue": "[type-com.github.javaparser.ast.type.Type, context-Context]"
      }
    },
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923": {
      "type": "Ybodychange",
      "commitMessage": "porting to JavaParser 3.0.0 RC2\n",
      "commitDate": "2016-12-13, 2:42 p.m.",
      "commitName": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-12-13, 11:45 a.m.",
      "commitNameOld": "cb5ffb7fdd56f1b768d25da330fa3b29ecb74eaf",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 711,
      "functionName": "convertToUsage",
      "diff": "@@ -1,45 +1,45 @@\n     private Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n-            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context)); // removed (ReferenceTypeImpl) \n-            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context)); // removed (ReferenceTypeImpl) \n-            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n+            if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n+                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n+            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n+                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n+            } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "07782fbbe149055d495e0c358da844734c08641f": {
      "type": "Ymodifierchange",
      "commitMessage": "reformat JavaParserFacade\n",
      "commitDate": "2016-12-13, 11:41 a.m.",
      "commitName": "07782fbbe149055d495e0c358da844734c08641f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-12-13, 8:10 a.m.",
      "commitNameOld": "c990d23490f5c4ac4322119b03d5951b63eef055",
      "commitAuthorOld": "Fred Lefvre-Laoide",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context)); // removed (ReferenceTypeImpl) \n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context)); // removed (ReferenceTypeImpl) \n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 760,
      "functionName": "convertToUsage",
      "diff": "@@ -1,45 +1,45 @@\n-    public Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n+    private Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context)); // removed (ReferenceTypeImpl) \n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context)); // removed (ReferenceTypeImpl) \n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[private]"
      }
    },
    "c990d23490f5c4ac4322119b03d5951b63eef055": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "loads of changes to support our code",
      "commitDate": "2016-12-13, 8:10 a.m.",
      "commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
      "commitAuthor": "Fred Lefvre-Laoide",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "loads of changes to support our code",
          "commitDate": "2016-12-13, 8:10 a.m.",
          "commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
          "commitAuthor": "Fred Lefvre-Laoide",
          "commitDateOld": "2016-11-21, 3:52 p.m.",
          "commitNameOld": "dfebf682a440aa48a8a444562f7fdfc1819b9a1e",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 21.68,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context)); // removed (ReferenceTypeImpl) \n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context)); // removed (ReferenceTypeImpl) \n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 760,
          "functionName": "convertToUsage",
          "diff": "@@ -1,45 +1,45 @@\n-    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    public Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n+                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context)); // removed (ReferenceTypeImpl) \n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n+                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context)); // removed (ReferenceTypeImpl) \n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[type-com.github.javaparser.ast.type.Type, context-Context]",
            "newValue": "[type-com.github.javaparser.ast.type.Type\u003c?\u003e, context-Context]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "loads of changes to support our code",
          "commitDate": "2016-12-13, 8:10 a.m.",
          "commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
          "commitAuthor": "Fred Lefvre-Laoide",
          "commitDateOld": "2016-11-21, 3:52 p.m.",
          "commitNameOld": "dfebf682a440aa48a8a444562f7fdfc1819b9a1e",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 21.68,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context)); // removed (ReferenceTypeImpl) \n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context)); // removed (ReferenceTypeImpl) \n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 760,
          "functionName": "convertToUsage",
          "diff": "@@ -1,45 +1,45 @@\n-    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    public Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n+                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context)); // removed (ReferenceTypeImpl) \n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n+                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context)); // removed (ReferenceTypeImpl) \n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": {
      "type": "Ybodychange",
      "commitMessage": "adapt to alpha.10\n",
      "commitDate": "2016-11-21, 1:58 p.m.",
      "commitName": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-09, 12:15 p.m.",
      "commitNameOld": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 12.07,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 592,
      "functionName": "convertToUsage",
      "diff": "@@ -1,45 +1,45 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n-            if (classOrInterfaceType.getTypeArguments() !\u003d null) {\n-                typeParameters \u003d classOrInterfaceType.getTypeArguments().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n+            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n+                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n-            if (wildcardType.getExtends() !\u003dnull \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n-            } else if (wildcardType.getExtends() \u003d\u003dnull \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n-            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n+            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n+            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n+            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": {
      "type": "Ybodychange",
      "commitMessage": "changes necessary to support jpalpha8\n",
      "commitDate": "2016-11-09, 12:15 p.m.",
      "commitName": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-06, 3:40 a.m.",
      "commitNameOld": "c746c4ef7711a05c27827ab749d96155046a4f91",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 3.36,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends() !\u003dnull \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n            } else if (wildcardType.getExtends() \u003d\u003dnull \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 592,
      "functionName": "convertToUsage",
      "diff": "@@ -1,45 +1,45 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n-            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n-                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n+            if (classOrInterfaceType.getTypeArguments() !\u003d null) {\n+                typeParameters \u003d classOrInterfaceType.getTypeArguments().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n-            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n-            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n-            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n+            if (wildcardType.getExtends() !\u003dnull \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n+            } else if (wildcardType.getExtends() \u003d\u003dnull \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n+            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a1c7c58143a592965f8378767adc69709e4c0043": {
      "type": "Ybodychange",
      "commitMessage": "more refactoring for ReferenceTypeDeclaration\n",
      "commitDate": "2016-11-05, 11:22 a.m.",
      "commitName": "a1c7c58143a592965f8378767adc69709e4c0043",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-05, 11:08 a.m.",
      "commitNameOld": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 590,
      "functionName": "convertToUsage",
      "diff": "@@ -1,45 +1,45 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n-            SymbolReference\u003cReferenceTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n+            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n-            ReferenceTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n+            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n+                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae": {
      "type": "Ybodychange",
      "commitMessage": "creating ReferenceTypeDeclaration\n",
      "commitDate": "2016-11-05, 11:08 a.m.",
      "commitName": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-05, 3:58 a.m.",
      "commitNameOld": "2fde8a6409906ab1e0b5e846f2e54b82da7878b7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cReferenceTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ReferenceTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 590,
      "functionName": "convertToUsage",
      "diff": "@@ -1,45 +1,45 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n-            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n+            SymbolReference\u003cReferenceTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n-            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n+            ReferenceTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf": {
      "type": "Ybodychange",
      "commitMessage": "adding more comments in model declarations\n",
      "commitDate": "2016-10-21, 2:55 a.m.",
      "commitName": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-20, 4:06 p.m.",
      "commitNameOld": "1e7780e554428a10c73de88ca64e5933b2291593",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 570,
      "functionName": "convertToUsage",
      "diff": "@@ -1,45 +1,45 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n-            if (typeDeclaration.isTypeVariable()) {\n+            if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c53c2cbc607ea694438ade8630be0c155a33162": {
      "type": "Yfilerename",
      "commitMessage": "renamed packages to com.github.javapaerser\n",
      "commitDate": "2016-10-20, 2:39 a.m.",
      "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-20, 2:32 a.m.",
      "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType)type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 566,
      "functionName": "convertToUsage",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java"
      }
    },
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7": {
      "type": "Ybodychange",
      "commitMessage": "revision of modified code to use Navigator.getParentNode\n",
      "commitDate": "2016-10-19, 1:35 p.m.",
      "commitName": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:34 p.m.",
      "commitNameOld": "03e407957d600a18ef0a4a83224c17d155ef8645",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType)type;\n            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 567,
      "functionName": "convertToUsage",
      "diff": "@@ -1,42 +1,45 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n+        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n+            com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType)type;\n+            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3fcd7b41f404d112b13d3bfe732b26eceec0dbfe": {
      "type": "Ybodychange",
      "commitMessage": "issue91: JavaParserClassDeclarationTest passing\n",
      "commitDate": "2016-10-19, 1:33 p.m.",
      "commitName": "3fcd7b41f404d112b13d3bfe732b26eceec0dbfe",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:33 p.m.",
      "commitNameOld": "33753cab1604a44d43215ba4055b435606a7a71b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 563,
      "functionName": "convertToUsage",
      "diff": "@@ -1,42 +1,42 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n-            if (wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n+            if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n-            } else if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n+            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n-                throw new UnsupportedOperationException();\n+                throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "33753cab1604a44d43215ba4055b435606a7a71b": {
      "type": "Ybodychange",
      "commitMessage": "issue91: first fixes\n",
      "commitDate": "2016-10-19, 1:33 p.m.",
      "commitName": "33753cab1604a44d43215ba4055b435606a7a71b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:33 p.m.",
      "commitNameOld": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n            } else if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 563,
      "functionName": "convertToUsage",
      "diff": "@@ -1,46 +1,42 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n-        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n-            com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n-            Type typeUsage \u003d convertToUsage(referenceType, context);\n-            return typeUsage;\n-        } else if (type instanceof ClassOrInterfaceType) {\n+        if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n-            if (classOrInterfaceType.getTypeArguments() !\u003d null) {\n+            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n             } else if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "341e081a5f8909a3a467671befcca2941b786d3d": {
      "type": "Ybodychange",
      "commitMessage": "issue91: solve compilation issues\n",
      "commitDate": "2016-10-19, 1:33 p.m.",
      "commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 11:04 a.m.",
      "commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n            com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n            Type typeUsage \u003d convertToUsage(referenceType, context);\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n            } else if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 563,
      "functionName": "convertToUsage",
      "diff": "@@ -1,49 +1,46 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n             com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n-            Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n-            for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n-                typeUsage \u003d new ArrayType(typeUsage);\n-            }\n+            Type typeUsage \u003d convertToUsage(referenceType, context);\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n-            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n-                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n+            if (classOrInterfaceType.getTypeArguments() !\u003d null) {\n+                typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n-            if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n-            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n-            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n+            if (wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n+            } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n+            } else if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d6a1f32f00bd513d6bc56fbbfefcb9ae9c706492": {
      "type": "Ybodychange",
      "commitMessage": "rename to typevariable and add comment\n",
      "commitDate": "2016-10-17, 4:00 p.m.",
      "commitName": "d6a1f32f00bd513d6bc56fbbfefcb9ae9c706492",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-16, 12:48 p.m.",
      "commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.13,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n            com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n            Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                typeUsage \u003d new ArrayType(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 547,
      "functionName": "convertToUsage",
      "diff": "@@ -1,49 +1,49 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n             com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n             Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n             for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                 typeUsage \u003d new ArrayType(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n-                    return new TypeParameter((TypeParameterDeclaration) typeDeclaration);\n+                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": {
      "type": "Ybodychange",
      "commitMessage": "reorganize packages in model\n",
      "commitDate": "2016-10-14, 12:51 p.m.",
      "commitName": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-14, 2:19 a.m.",
      "commitNameOld": "6b50c90daa764492e074198460c807d83d52325e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.44,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n            com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n            Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                typeUsage \u003d new ArrayType(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameterDeclaration) {\n                    return new TypeParameter((TypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 548,
      "functionName": "convertToUsage",
      "diff": "@@ -1,49 +1,49 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n             com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n             Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n             for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                 typeUsage \u003d new ArrayType(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n-                if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n-                    return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n+                if (typeDeclaration instanceof TypeParameterDeclaration) {\n+                    return new TypeParameter((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82eb44707b620803d424188a1eb8708fcaf093cb": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "rename TypeUsage into Type\n",
      "commitDate": "2016-10-13, 4:11 p.m.",
      "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016-10-13, 4:11 p.m.",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-13, 8:20 a.m.",
          "commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n            com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n            Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                typeUsage \u003d new ArrayType(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n                    return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 546,
          "functionName": "convertToUsage",
          "diff": "@@ -1,49 +1,49 @@\n-    public TypeUsage convertToUsage(Type type, Context context) {\n-        if (type instanceof ReferenceType) {\n-            ReferenceType referenceType \u003d (ReferenceType) type;\n-            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n+    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n+            com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n+            Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n             for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n-                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n+                typeUsage \u003d new ArrayType(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n-            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n+            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n-                if (typeDeclaration instanceof TypeParameter) {\n-                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n+                if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n+                    return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n+                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n-        } else if (type instanceof PrimitiveType) {\n-            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n+        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n+            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-                return WildcardUsage.UNBOUNDED;\n+                return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n-        } else if (type instanceof VoidType) {\n-            return VoidTypeUsage.INSTANCE;\n+        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n+            return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[type-Type, context-Context]",
            "newValue": "[type-com.github.javaparser.ast.type.Type, context-Context]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016-10-13, 4:11 p.m.",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-13, 8:20 a.m.",
          "commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n            com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n            Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                typeUsage \u003d new ArrayType(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n                    return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 546,
          "functionName": "convertToUsage",
          "diff": "@@ -1,49 +1,49 @@\n-    public TypeUsage convertToUsage(Type type, Context context) {\n-        if (type instanceof ReferenceType) {\n-            ReferenceType referenceType \u003d (ReferenceType) type;\n-            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n+    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n+            com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n+            Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n             for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n-                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n+                typeUsage \u003d new ArrayType(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n-            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n+            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n-                if (typeDeclaration instanceof TypeParameter) {\n-                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n+                if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n+                    return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n+                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n-        } else if (type instanceof PrimitiveType) {\n-            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n+        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n+            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-                return WildcardUsage.UNBOUNDED;\n+                return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n-        } else if (type instanceof VoidType) {\n-            return VoidTypeUsage.INSTANCE;\n+        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n+            return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "TypeUsage",
            "newValue": "Type"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016-10-13, 4:11 p.m.",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-13, 8:20 a.m.",
          "commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n            com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n            Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                typeUsage \u003d new ArrayType(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n                    return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return Wildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n            return VoidType.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 546,
          "functionName": "convertToUsage",
          "diff": "@@ -1,49 +1,49 @@\n-    public TypeUsage convertToUsage(Type type, Context context) {\n-        if (type instanceof ReferenceType) {\n-            ReferenceType referenceType \u003d (ReferenceType) type;\n-            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n+    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n+            com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n+            Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n             for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n-                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n+                typeUsage \u003d new ArrayType(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n-            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n+            List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n-                if (typeDeclaration instanceof TypeParameter) {\n-                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n+                if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n+                    return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n+                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n-        } else if (type instanceof PrimitiveType) {\n-            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n+        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n+            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-                return WildcardUsage.UNBOUNDED;\n+                return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n-        } else if (type instanceof VoidType) {\n-            return VoidTypeUsage.INSTANCE;\n+        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n+            return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "14c9305d49885a12acdb7c09d2e35ad29b5403cf": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"issue80: improve TypeParameter.describe\"\n\nThis reverts commit e581ddb297f5a1da9790adaeadbb6d0f43c8432f.\n",
      "commitDate": "2016-10-13, 8:20 a.m.",
      "commitName": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-13, 8:12 a.m.",
      "commitNameOld": "e581ddb297f5a1da9790adaeadbb6d0f43c8432f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return WildcardUsage.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        } else if (type instanceof VoidType) {\n            return VoidTypeUsage.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 545,
      "functionName": "convertToUsage",
      "diff": "@@ -1,49 +1,49 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n             for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                 typeUsage \u003d new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n-                    return new TypeParameterUsage((TypeParameter) typeDeclaration, typeSolver);\n+                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter(), typeSolver);\n+                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                 return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                 return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                 return WildcardUsage.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e581ddb297f5a1da9790adaeadbb6d0f43c8432f": {
      "type": "Ybodychange",
      "commitMessage": "issue80: improve TypeParameter.describe\n",
      "commitDate": "2016-10-13, 8:12 a.m.",
      "commitName": "e581ddb297f5a1da9790adaeadbb6d0f43c8432f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-11, 1:37 p.m.",
      "commitNameOld": "acf74024c2d341bf4009af7173c9b1b972f19c32",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.77,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeParameterUsage((TypeParameter) typeDeclaration, typeSolver);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter(), typeSolver);\n                }\n            } else {\n                return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return WildcardUsage.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        } else if (type instanceof VoidType) {\n            return VoidTypeUsage.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 545,
      "functionName": "convertToUsage",
      "diff": "@@ -1,49 +1,49 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n             for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                 typeUsage \u003d new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n-                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n+                    return new TypeParameterUsage((TypeParameter) typeDeclaration, typeSolver);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter(), typeSolver);\n                 }\n             } else {\n                 return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                 return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                 return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                 return WildcardUsage.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
      "type": "Yfilerename",
      "commitMessage": "test JavaParserClassDeclaration\n",
      "commitDate": "2015-11-22, 5:45 a.m.",
      "commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-22, 5:03 a.m.",
      "commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return WildcardUsage.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        } else if (type instanceof VoidType) {\n            return VoidTypeUsage.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 425,
      "functionName": "convertToUsage",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java"
      }
    },
    "4a18b1ee8ed716d6e32e190f728f1eee57148872": {
      "type": "Ybodychange",
      "commitMessage": "modules: extraction of the model module\n",
      "commitDate": "2015-11-13, 4:59 a.m.",
      "commitName": "4a18b1ee8ed716d6e32e190f728f1eee57148872",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 4:12 a.m.",
      "commitNameOld": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return WildcardUsage.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        } else if (type instanceof VoidType) {\n            return VoidTypeUsage.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 331,
      "functionName": "convertToUsage",
      "diff": "@@ -1,49 +1,49 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n             for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                 typeUsage \u003d new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeParameterUsage((TypeParameter) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n+                return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType \u003d (WildcardType) type;\n             if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getExtends(), context));\n+                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getSuper(), context));\n+                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                 return WildcardUsage.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
      "type": "Yfilerename",
      "commitMessage": "modules: organization in modules\n",
      "commitDate": "2015-11-13, 4:12 a.m.",
      "commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 3:53 a.m.",
      "commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType) type;\n            if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getExtends(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getSuper(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return WildcardUsage.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        } else if (type instanceof VoidType) {\n            return VoidTypeUsage.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 327,
      "functionName": "convertToUsage",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java"
      }
    },
    "03ec309bba14eaf50a32b05353fa9711b831de7f": {
      "type": "Ybodychange",
      "commitMessage": "reimplement WildcardUsage\n",
      "commitDate": "2015-10-31, 11:01 a.m.",
      "commitName": "03ec309bba14eaf50a32b05353fa9711b831de7f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-31, 7:11 a.m.",
      "commitNameOld": "fb388c36c0045c50744cf215521e5c280036aa70",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i\u003d0;i\u003creferenceType.getArrayCount();i++){\n                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeParameterUsage((TypeParameter)typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType \u003d (WildcardType)type;\n            if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getExtends(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n                return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getSuper(), context));\n            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n                return WildcardUsage.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        } else if (type instanceof VoidType) {\n            return VoidTypeUsage.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 336,
      "functionName": "convertToUsage",
      "diff": "@@ -1,40 +1,49 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n             for (int i\u003d0;i\u003creferenceType.getArrayCount();i++){\n                 typeUsage \u003d new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeParameterUsage((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n-            return new WildcardUsage((WildcardType)type);\n+            WildcardType wildcardType \u003d (WildcardType)type;\n+            if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n+                return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getExtends(), context));\n+            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n+                return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getSuper(), context));\n+            } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n+                return WildcardUsage.UNBOUNDED;\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb388c36c0045c50744cf215521e5c280036aa70": {
      "type": "Yfilerename",
      "commitMessage": "move JavaParser specific code to specific package\n",
      "commitDate": "2015-10-31, 7:11 a.m.",
      "commitName": "fb388c36c0045c50744cf215521e5c280036aa70",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-31, 5:57 a.m.",
      "commitNameOld": "b2bf624be5d1ef59480250e66224aeaa1886df36",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i\u003d0;i\u003creferenceType.getArrayCount();i++){\n                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeParameterUsage((TypeParameter)typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return new WildcardUsage((WildcardType)type);\n        } else if (type instanceof VoidType) {\n            return VoidTypeUsage.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 336,
      "functionName": "convertToUsage",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java"
      }
    },
    "1613b8d9cc00da012539ea3db05cdb0cc8153358": {
      "type": "Ybodychange",
      "commitMessage": "renaming\n",
      "commitDate": "2015-10-31, 5:01 a.m.",
      "commitName": "1613b8d9cc00da012539ea3db05cdb0cc8153358",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-30, 6:51 p.m.",
      "commitNameOld": "adb02497ed443e836ae552e20bcb11ab8c1ab623",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.42,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i\u003d0;i\u003creferenceType.getArrayCount();i++){\n                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeParameterUsage((TypeParameter)typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return new WildcardUsage((WildcardType)type);\n        } else if (type instanceof VoidType) {\n            return VoidTypeUsage.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 337,
      "functionName": "convertToUsage",
      "diff": "@@ -1,40 +1,40 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n             for (int i\u003d0;i\u003creferenceType.getArrayCount();i++){\n                 typeUsage \u003d new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n-                    return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n+                    return new TypeParameterUsage((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             return new WildcardUsage((WildcardType)type);\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e81f51c40996b42cb262dc2397126cee8f60965": {
      "type": "Ybodychange",
      "commitMessage": "embedding TypeSolver\n",
      "commitDate": "2015-10-30, 6:37 p.m.",
      "commitName": "0e81f51c40996b42cb262dc2397126cee8f60965",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-30, 11:43 a.m.",
      "commitNameOld": "005ec580724781a825aaf08a496ad7f8f667b27f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i\u003d0;i\u003creferenceType.getArrayCount();i++){\n                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return new WildcardUsage((WildcardType)type);\n        } else if (type instanceof VoidType) {\n            return VoidTypeUsage.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 337,
      "functionName": "convertToUsage",
      "diff": "@@ -1,40 +1,40 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n             for (int i\u003d0;i\u003creferenceType.getArrayCount();i++){\n                 typeUsage \u003d new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeUsage(typeDeclaration, typeParameters);\n+                return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             return new WildcardUsage((WildcardType)type);\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b": {
      "type": "Ybodychange",
      "commitMessage": "renaming\n",
      "commitDate": "2015-10-28, 11:18 a.m.",
      "commitName": "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-27, 10:40 a.m.",
      "commitNameOld": "bed91989f7354552d72b2b7f0c28fcbd24fee003",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 62.03,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i\u003d0;i\u003creferenceType.getArrayCount();i++){\n                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeUsage(typeDeclaration, typeParameters);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return new WildcardUsage((WildcardType)type);\n        } else if (type instanceof VoidType) {\n            return VoidTypeUsage.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 316,
      "functionName": "convertToUsage",
      "diff": "@@ -1,40 +1,40 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n             for (int i\u003d0;i\u003creferenceType.getArrayCount();i++){\n                 typeUsage \u003d new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+                return new ReferenceTypeUsage(typeDeclaration, typeParameters);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             return new WildcardUsage((WildcardType)type);\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eec165d9e3ef0ab1d93f69a231964984a3379762": {
      "type": "Ybodychange",
      "commitMessage": "consider array modifiers\n",
      "commitDate": "2015-08-25, 5:57 a.m.",
      "commitName": "eec165d9e3ef0ab1d93f69a231964984a3379762",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 5:05 p.m.",
      "commitNameOld": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.54,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n            for (int i\u003d0;i\u003creferenceType.getArrayCount();i++){\n                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n            }\n            return typeUsage;\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return new WildcardUsage((WildcardType)type);\n        } else if (type instanceof VoidType) {\n            return VoidTypeUsage.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 316,
      "functionName": "convertToUsage",
      "diff": "@@ -1,37 +1,40 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n-            // TODO consider array modifiers\n-            return convertToUsage(referenceType.getType(), context);\n+            TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n+            for (int i\u003d0;i\u003creferenceType.getArrayCount();i++){\n+                typeUsage \u003d new ArrayTypeUsage(typeUsage);\n+            }\n+            return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             String name \u003d qName(classOrInterfaceType);\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             return new WildcardUsage((WildcardType)type);\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n-            throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n+            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ee58eb8363ecd8fad15a63eb2fdc94a387b58807": {
      "type": "Ybodychange",
      "commitMessage": "use qualified name when solving types\n",
      "commitDate": "2015-08-24, 3:57 p.m.",
      "commitName": "ee58eb8363ecd8fad15a63eb2fdc94a387b58807",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 3:37 p.m.",
      "commitNameOld": "1ae290f6f5e0c7ba62eab797aba22308957b9257",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            String name \u003d qName(classOrInterfaceType);\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return new WildcardUsage((WildcardType)type);\n        } else if (type instanceof VoidType) {\n            return VoidTypeUsage.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 323,
      "functionName": "convertToUsage",
      "diff": "@@ -1,36 +1,37 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n-            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n+            String name \u003d qName(classOrInterfaceType);\n+            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n-                throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n+                throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             return new WildcardUsage((WildcardType)type);\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4": {
      "type": "Ybodychange",
      "commitMessage": "consider method override\n",
      "commitDate": "2015-08-24, 3:19 p.m.",
      "commitName": "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 2:45 p.m.",
      "commitNameOld": "d0348de241a6cf6be9c51500870ee1fb26172101",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return new WildcardUsage((WildcardType)type);\n        } else if (type instanceof VoidType) {\n            return VoidTypeUsage.INSTANCE;\n        } else {\n            throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 311,
      "functionName": "convertToUsage",
      "diff": "@@ -1,36 +1,36 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             return new WildcardUsage((WildcardType)type);\n         } else if (type instanceof VoidType) {\n-            return new VoidTypeUsage();\n+            return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176": {
      "type": "Ybodychange",
      "commitMessage": "remove JavaParserFacade.convert\n",
      "commitDate": "2015-08-24, 10:22 a.m.",
      "commitName": "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 10:06 a.m.",
      "commitNameOld": "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                if (typeDeclaration instanceof TypeParameter) {\n                    return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return new WildcardUsage((WildcardType)type);\n        } else if (type instanceof VoidType) {\n            return new VoidTypeUsage();\n        } else {\n            throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 307,
      "functionName": "convertToUsage",
      "diff": "@@ -1,28 +1,36 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n-                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration)typeDeclaration;\n-                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+                if (typeDeclaration instanceof TypeParameter) {\n+                    return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n+                } else {\n+                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n+                    return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+                }\n             } else {\n                 return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n             }\n         } else if (type instanceof PrimitiveType) {\n-            return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n+            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n+        } else if (type instanceof WildcardType) {\n+            return new WildcardUsage((WildcardType)type);\n+        } else if (type instanceof VoidType) {\n+            return new VoidTypeUsage();\n         } else {\n             throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "416e7b16f820700af08a94e4b38a2b4c24ef6a2c": {
      "type": "Ybodychange",
      "commitMessage": "minor corrections for enums\n",
      "commitDate": "2015-08-24, 10:06 a.m.",
      "commitName": "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 9:58 a.m.",
      "commitNameOld": "1829d9560d37efd59722aaa2f1f22e392918429b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration)typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            } else {\n                return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n        } else {\n            throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 304,
      "functionName": "convertToUsage",
      "diff": "@@ -1,28 +1,28 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration)typeDeclaration;\n                 return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n             } else {\n                 return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n         } else {\n-            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+            throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1829d9560d37efd59722aaa2f1f22e392918429b": {
      "type": "Ybodychange",
      "commitMessage": "calculate if type variable are assignable\n",
      "commitDate": "2015-08-24, 9:58 a.m.",
      "commitName": "1829d9560d37efd59722aaa2f1f22e392918429b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 9:26 a.m.",
      "commitNameOld": "00f005b38e8b83eb1d60db9070c6e9e3beffe403",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeVariable()) {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration)typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            } else {\n                return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 304,
      "functionName": "convertToUsage",
      "diff": "@@ -1,23 +1,28 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n-            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+            if (typeDeclaration.isTypeVariable()) {\n+                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration)typeDeclaration;\n+                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+            } else {\n+                return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+            }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0c4c859f472f7243919f1af7a0871cf8155af1ba": {
      "type": "Ybodychange",
      "commitMessage": "add tests for static field access\n",
      "commitDate": "2015-08-21, 5:00 p.m.",
      "commitName": "0c4c859f472f7243919f1af7a0871cf8155af1ba",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-21, 2:45 p.m.",
      "commitNameOld": "7b6c27e95fef9e725fbf9e15afb852bb952dfa34",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 244,
      "functionName": "convertToUsage",
      "diff": "@@ -1,23 +1,23 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n-                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n+                throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7b6c27e95fef9e725fbf9e15afb852bb952dfa34": {
      "type": "Ybodychange",
      "commitMessage": "first round of cleaning the API\n",
      "commitDate": "2015-08-21, 2:45 p.m.",
      "commitName": "7b6c27e95fef9e725fbf9e15afb852bb952dfa34",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-21, 6:03 a.m.",
      "commitNameOld": "6d60a91b5d0d29dde1c081d82781fc60011d926d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.36,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        } else if (type instanceof PrimitiveType) {\n            return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 205,
      "functionName": "convertToUsage",
      "diff": "@@ -1,23 +1,23 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n         } else if (type instanceof PrimitiveType) {\n-            return new TypeUsageOfTypeDeclaration(new PrimitiveTypeDeclaration((PrimitiveType)type), Collections.emptyList());\n+            return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1d5332815b543d569be3d7ec672a65b7efc39a04": {
      "type": "Ybodychange",
      "commitMessage": "test ClassOrInterfaceDeclarationContext.solveSymbolAsValue\n",
      "commitDate": "2015-08-18, 5:15 a.m.",
      "commitName": "1d5332815b543d569be3d7ec672a65b7efc39a04",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-18, 3:14 a.m.",
      "commitNameOld": "3117fab4797fa9aba8b5f8dc596ab70c90c7d548",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        } else if (type instanceof PrimitiveType) {\n            return new TypeUsageOfTypeDeclaration(new PrimitiveTypeDeclaration((PrimitiveType)type), Collections.emptyList());\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 207,
      "functionName": "convertToUsage",
      "diff": "@@ -1,21 +1,23 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n-            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType)type;\n+            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n-                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt)-\u003econvertToUsage(pt, context)).collect(Collectors.toList());\n+                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+        } else if (type instanceof PrimitiveType) {\n+            return new TypeUsageOfTypeDeclaration(new PrimitiveTypeDeclaration((PrimitiveType)type), Collections.emptyList());\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6650e5a3818c15de2883b71cd41524b0337e26f6": {
      "type": "Ymodifierchange",
      "commitMessage": "add test resolveUsageOfGenericFieldAdvancedCase\n",
      "commitDate": "2015-08-05, 4:09 a.m.",
      "commitName": "6650e5a3818c15de2883b71cd41524b0337e26f6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-04, 9:54 a.m.",
      "commitNameOld": "80f951258992f75441239c79e0f31eda7d47e107",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType)type;\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt)-\u003econvertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 131,
      "functionName": "convertToUsage",
      "diff": "@@ -1,21 +1,21 @@\n-    private TypeUsage convertToUsage(Type type, Context context) {\n+    public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType \u003d (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType)type;\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n             List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                 typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt)-\u003econvertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[public]"
      }
    },
    "2568d9ebe91ceb0a13c98b16f99593cd22084efa": {
      "type": "Yintroduced",
      "commitMessage": "solving first case of generic type\n",
      "commitDate": "2015-08-04, 5:02 a.m.",
      "commitName": "2568d9ebe91ceb0a13c98b16f99593cd22084efa",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,21 @@\n+    private TypeUsage convertToUsage(Type type, Context context) {\n+        if (type instanceof ReferenceType) {\n+            ReferenceType referenceType \u003d (ReferenceType) type;\n+            // TODO consider array modifiers\n+            return convertToUsage(referenceType.getType(), context);\n+        } else if (type instanceof ClassOrInterfaceType) {\n+            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType)type;\n+            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n+            if (!ref.isSolved()) {\n+                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n+            }\n+            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n+            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n+            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n+                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt)-\u003econvertToUsage(pt, context)).collect(Collectors.toList());\n+            }\n+            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+        } else {\n+            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType \u003d (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType)type;\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n            List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n                typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt)-\u003econvertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 124,
      "functionName": "convertToUsage"
    }
  }
}