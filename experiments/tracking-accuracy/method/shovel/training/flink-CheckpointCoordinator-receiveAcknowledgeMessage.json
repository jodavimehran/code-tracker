{
  "origin": "codeshovel",
  "repositoryName": "flink",
  "repositoryPath": "H:\\Projects\\apache\\flink/.git",
  "startCommitName": "9e936a5f8198b0059e9b5fba33163c2bbe3efbdd",
  "sourceFileName": "CheckpointCoordinator.java",
  "functionName": "receiveAcknowledgeMessage",
  "functionId": "receiveAcknowledgeMessage___message-AcknowledgeCheckpoint",
  "sourceFilePath": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
  "functionStartLine": 726,
  "functionEndLine": 808,
  "numCommitsSeen": 101,
  "timeTaken": 11758,
  "changeHistory": [
    "aa21f853ab0380ec1f68ae1d0b7c8d9268da4533",
    "2edc97185700a5bdb3e181a71493d681c0f693e3",
    "579bc96446d598a2cfe8237b4ebd62d8c9df3483",
    "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
    "ea7080712f2dcbdf125b806007c80aa3d120f30a",
    "b181662be378652d6c4405841ccda6145968d145",
    "dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b",
    "c590912c93a4059b40452dfa6cffbdd4d58cac13",
    "72b295b3b52dff2d0bc5b78881826e8936c370ff",
    "48a48139172e86f548f3b2f1564bdc948c3fe76a",
    "cfb3790fb6feb6c771bccbd05d3b12c69f53657d",
    "cab9cd44eca83ef8cbcd2a2d070d8c79cb037977",
    "53ed6adac8cbe6b5dcb692dc9b94970f3ec5887c",
    "847ead01f2f0aaf318b2b1ba8501bc697d245900",
    "4e9d1775b5514c87981c78d55323cc2b17361867",
    "76ca1a7955fedd8583a0af12289a14d0f1bcf868",
    "f0ac261add2eb184358d5b89bc90b13aef7b267d",
    "0cf04108f70375d41ebb7c39629db3a081bd2876",
    "d739ee2532e0fd49ef37508b1c2e4a355473aaa5",
    "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2",
    "55fd5f32d7ef0292a01192ab08456fae49b91791",
    "73c73e92750ab8fb068d0a3cb37afcb642084fc0",
    "aa5e5b3087a68f2aac792c0b0fc64b4f9c707e9b",
    "0ecab82add0946503a000162813bb820f6f3b4d4",
    "f27c3f1d1cbff7433a23227e75f2f8e30058397a",
    "197cd6cf0fb10efc6badd5fc8584f4b36b09e705",
    "59bee4ad825d7252c791e0376ea2504602134fe7",
    "9b7f8aa121e4a231632296d0809029aca9ebde6a",
    "7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be"
  ],
  "changeHistoryShort": {
    "aa21f853ab0380ec1f68ae1d0b7c8d9268da4533": "Ybodychange",
    "2edc97185700a5bdb3e181a71493d681c0f693e3": "Ybodychange",
    "579bc96446d598a2cfe8237b4ebd62d8c9df3483": "Ybodychange",
    "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4": "Ymultichange(Yexceptionschange,Ybodychange)",
    "ea7080712f2dcbdf125b806007c80aa3d120f30a": "Ybodychange",
    "b181662be378652d6c4405841ccda6145968d145": "Ybodychange",
    "dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b": "Ybodychange",
    "c590912c93a4059b40452dfa6cffbdd4d58cac13": "Ybodychange",
    "72b295b3b52dff2d0bc5b78881826e8936c370ff": "Ybodychange",
    "48a48139172e86f548f3b2f1564bdc948c3fe76a": "Ybodychange",
    "cfb3790fb6feb6c771bccbd05d3b12c69f53657d": "Ybodychange",
    "cab9cd44eca83ef8cbcd2a2d070d8c79cb037977": "Ybodychange",
    "53ed6adac8cbe6b5dcb692dc9b94970f3ec5887c": "Ybodychange",
    "847ead01f2f0aaf318b2b1ba8501bc697d245900": "Ybodychange",
    "4e9d1775b5514c87981c78d55323cc2b17361867": "Ybodychange",
    "76ca1a7955fedd8583a0af12289a14d0f1bcf868": "Ybodychange",
    "f0ac261add2eb184358d5b89bc90b13aef7b267d": "Ybodychange",
    "0cf04108f70375d41ebb7c39629db3a081bd2876": "Ybodychange",
    "d739ee2532e0fd49ef37508b1c2e4a355473aaa5": "Ymultichange(Yreturntypechange,Ybodychange)",
    "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2": "Ybodychange",
    "55fd5f32d7ef0292a01192ab08456fae49b91791": "Ybodychange",
    "73c73e92750ab8fb068d0a3cb37afcb642084fc0": "Ymultichange(Yexceptionschange,Ybodychange)",
    "aa5e5b3087a68f2aac792c0b0fc64b4f9c707e9b": "Ybodychange",
    "0ecab82add0946503a000162813bb820f6f3b4d4": "Ybodychange",
    "f27c3f1d1cbff7433a23227e75f2f8e30058397a": "Ybodychange",
    "197cd6cf0fb10efc6badd5fc8584f4b36b09e705": "Ybodychange",
    "59bee4ad825d7252c791e0376ea2504602134fe7": "Ybodychange",
    "9b7f8aa121e4a231632296d0809029aca9ebde6a": "Ybodychange",
    "7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be": "Yintroduced"
  },
  "changeHistoryDetails": {
    "aa21f853ab0380ec1f68ae1d0b7c8d9268da4533": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-6014] [checkpoint] Additional review changes\n",
      "commitDate": "2017-04-22, 9:25 a.m.",
      "commitName": "aa21f853ab0380ec1f68ae1d0b7c8d9268da4533",
      "commitAuthor": "Stefan Richter",
      "commitDateOld": "2017-04-22, 9:25 a.m.",
      "commitNameOld": "218bed8b8e49b0e4c61c61f696a8f010eafea1b7",
      "commitAuthorOld": "xiaogang.sxg",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\t\t\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfinal PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\n\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {\n\t\t\t\t\tcase SUCCESS:\n\t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n\t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DUPLICATE:\n\t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UNKNOWN:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n\t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n\t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISCARDED:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n\t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean wasPendingCheckpoint;\n\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\twasPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n\t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\twasPendingCheckpoint \u003d false;\n\t\t\t\t}\n\n\t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n\t\t\t\tdiscardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\n\t\t\t\treturn wasPendingCheckpoint;\n\t\t\t}\n\t\t}\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 687,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,83 +1,83 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \t\t\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tfinal PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n \t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+\t\t\t\t\t\tdiscardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+\t\t\t\t\t\tdiscardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t\t}\n \n \t\t\t\treturn true;\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tboolean wasPendingCheckpoint;\n \n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\twasPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n \t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n \t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\twasPendingCheckpoint \u003d false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n-\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+\t\t\t\tdiscardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\treturn wasPendingCheckpoint;\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2edc97185700a5bdb3e181a71493d681c0f693e3": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-5763] [checkpoints] Acknowledge with explicit ID and CheckpointMetrics\n\nInstead of acknowledging checkpoints with the CheckpointMetaData make\nthe acknowledgement explicit by ID and CheckpointMetrics. The rest is\nnot needed.\n",
      "commitDate": "2017-02-22, 6:14 a.m.",
      "commitName": "2edc97185700a5bdb3e181a71493d681c0f693e3",
      "commitAuthor": "Ufuk Celebi",
      "commitDateOld": "2017-02-20, 1:43 p.m.",
      "commitNameOld": "f63426b0322e05fd0986ae5f224a69b1320724f6",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 1.69,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfinal PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\n\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {\n\t\t\t\t\tcase SUCCESS:\n\t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n\t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DUPLICATE:\n\t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UNKNOWN:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n\t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n\t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISCARDED:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n\t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean wasPendingCheckpoint;\n\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\twasPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n\t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\twasPendingCheckpoint \u003d false;\n\t\t\t\t}\n\n\t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\n\t\t\t\treturn wasPendingCheckpoint;\n\t\t\t}\n\t\t}\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 628,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,83 +1,83 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tfinal PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \n-\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {\n+\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n \t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t\t}\n \n \t\t\t\treturn true;\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tboolean wasPendingCheckpoint;\n \n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\twasPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n \t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n \t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\twasPendingCheckpoint \u003d false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n \t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\treturn wasPendingCheckpoint;\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "579bc96446d598a2cfe8237b4ebd62d8c9df3483": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4410] [runtime] Rework checkpoint stats tracking\n",
      "commitDate": "2017-01-10, 3:48 a.m.",
      "commitName": "579bc96446d598a2cfe8237b4ebd62d8c9df3483",
      "commitAuthor": "Ufuk Celebi",
      "commitDateOld": "2016-12-09, 10:05 a.m.",
      "commitNameOld": "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
      "commitAuthorOld": "Till Rohrmann",
      "daysBetweenCommits": 31.74,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfinal PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\n\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {\n\t\t\t\t\tcase SUCCESS:\n\t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n\t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DUPLICATE:\n\t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UNKNOWN:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n\t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n\t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISCARDED:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n\t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean wasPendingCheckpoint;\n\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\twasPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n\t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\twasPendingCheckpoint \u003d false;\n\t\t\t\t}\n\n\t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\n\t\t\t\treturn wasPendingCheckpoint;\n\t\t\t}\n\t\t}\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 628,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,83 +1,83 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tfinal PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \n-\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n+\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n \t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t\t}\n \n \t\t\t\treturn true;\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tboolean wasPendingCheckpoint;\n \n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\twasPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n \t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n \t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\twasPendingCheckpoint \u003d false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n \t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\treturn wasPendingCheckpoint;\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "[FLINK-5158] [ckPtCoord] Handle exceptions from CompletedCheckpointStore in CheckpointCoordinator\n\nHandle exceptions from the CompletedCheckpointStore properly in the CheckpointCoordinator. This\nmeans that in case of an exception, the completed checkpoint will be properly cleaned up and also\nthe triggering of subsequent checkpoints will be started.\n\nThis closes #2872.\n",
      "commitDate": "2016-12-09, 10:05 a.m.",
      "commitName": "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
      "commitAuthor": "Till Rohrmann",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "[FLINK-5158] [ckPtCoord] Handle exceptions from CompletedCheckpointStore in CheckpointCoordinator\n\nHandle exceptions from the CompletedCheckpointStore properly in the CheckpointCoordinator. This\nmeans that in case of an exception, the completed checkpoint will be properly cleaned up and also\nthe triggering of subsequent checkpoints will be started.\n\nThis closes #2872.\n",
          "commitDate": "2016-12-09, 10:05 a.m.",
          "commitName": "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
          "commitAuthor": "Till Rohrmann",
          "commitDateOld": "2016-12-09, 8:42 a.m.",
          "commitNameOld": "ea7080712f2dcbdf125b806007c80aa3d120f30a",
          "commitAuthorOld": "Till Rohrmann",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfinal PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\n\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n\t\t\t\t\tcase SUCCESS:\n\t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n\t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DUPLICATE:\n\t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UNKNOWN:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n\t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n\t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISCARDED:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n\t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean wasPendingCheckpoint;\n\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\twasPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n\t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\twasPendingCheckpoint \u003d false;\n\t\t\t\t}\n\n\t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\n\t\t\t\treturn wasPendingCheckpoint;\n\t\t\t}\n\t\t}\n\t}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
          "functionStartLine": 612,
          "functionName": "receiveAcknowledgeMessage",
          "diff": "@@ -1,132 +1,83 @@\n-\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n+\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \n \t\tif (!job.equals(message.getJob())) {\n-\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n+\t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n-\t\tCompletedCheckpoint completed \u003d null;\n-\t\tPendingCheckpoint checkpoint;\n-\n-\t\t// Flag indicating whether the ack message was for a known pending\n-\t\t// checkpoint.\n-\t\tboolean isPendingCheckpoint;\n-\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n-\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n+\t\t\tfinal PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n-\t\t\t\tisPendingCheckpoint \u003d true;\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n \t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\n-\t\t\t\t\t\t\t// record the time when this was completed, to calculate\n-\t\t\t\t\t\t\t// the \u0027min delay between checkpoints\u0027\n-\t\t\t\t\t\t\tlastCheckpointCompletionNanos \u003d System.nanoTime();\n-\n-\t\t\t\t\t\t\t// complete the checkpoint structure\n-\t\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n-\t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n-\n-\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint {} ({} bytes in {} ms).\", checkpointId,\n-\t\t\t\t\t\t\t\tcompleted.getStateSize(), completed.getDuration());\n-\n-\t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n-\t\t\t\t\t\t\t\tbuilder.append(\"Checkpoint state: \");\n-\t\t\t\t\t\t\t\tfor (TaskState state : completed.getTaskStates().values()) {\n-\t\t\t\t\t\t\t\t\tbuilder.append(state);\n-\t\t\t\t\t\t\t\t\tbuilder.append(\", \");\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t// Remove last two chars \", \"\n-\t\t\t\t\t\t\t\tbuilder.delete(builder.length() - 2, builder.length());\n-\n-\t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n-\t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n-\n-\t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n-\n-\t\t\t\t\t\t\ttriggerQueuedRequests();\n+\t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t\t}\n+\n+\t\t\t\treturn true;\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n+\t\t\t\tboolean wasPendingCheckpoint;\n+\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n-\t\t\t\t\tisPendingCheckpoint \u003d true;\n+\t\t\t\t\twasPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n \t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n \t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n-\t\t\t\t\tisPendingCheckpoint \u003d false;\n+\t\t\t\t\twasPendingCheckpoint \u003d false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n \t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+\n+\t\t\t\treturn wasPendingCheckpoint;\n \t\t\t}\n \t\t}\n-\n-\t\t// send the confirmation messages to the necessary targets. we do this here\n-\t\t// to be outside the lock scope\n-\t\tif (completed !\u003d null) {\n-\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n-\n-\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n-\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n-\t\t\t\tif (ee !\u003d null) {\n-\t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n-\t\t}\n-\n-\t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[Exception]",
            "newValue": "[CheckpointException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "[FLINK-5158] [ckPtCoord] Handle exceptions from CompletedCheckpointStore in CheckpointCoordinator\n\nHandle exceptions from the CompletedCheckpointStore properly in the CheckpointCoordinator. This\nmeans that in case of an exception, the completed checkpoint will be properly cleaned up and also\nthe triggering of subsequent checkpoints will be started.\n\nThis closes #2872.\n",
          "commitDate": "2016-12-09, 10:05 a.m.",
          "commitName": "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
          "commitAuthor": "Till Rohrmann",
          "commitDateOld": "2016-12-09, 8:42 a.m.",
          "commitNameOld": "ea7080712f2dcbdf125b806007c80aa3d120f30a",
          "commitAuthorOld": "Till Rohrmann",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfinal PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\n\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n\t\t\t\t\tcase SUCCESS:\n\t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n\t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DUPLICATE:\n\t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UNKNOWN:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n\t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n\t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISCARDED:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n\t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean wasPendingCheckpoint;\n\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\twasPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n\t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\twasPendingCheckpoint \u003d false;\n\t\t\t\t}\n\n\t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\n\t\t\t\treturn wasPendingCheckpoint;\n\t\t\t}\n\t\t}\n\t}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
          "functionStartLine": 612,
          "functionName": "receiveAcknowledgeMessage",
          "diff": "@@ -1,132 +1,83 @@\n-\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n+\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \n \t\tif (!job.equals(message.getJob())) {\n-\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n+\t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n-\t\tCompletedCheckpoint completed \u003d null;\n-\t\tPendingCheckpoint checkpoint;\n-\n-\t\t// Flag indicating whether the ack message was for a known pending\n-\t\t// checkpoint.\n-\t\tboolean isPendingCheckpoint;\n-\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n-\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n+\t\t\tfinal PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n-\t\t\t\tisPendingCheckpoint \u003d true;\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n \t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\n-\t\t\t\t\t\t\t// record the time when this was completed, to calculate\n-\t\t\t\t\t\t\t// the \u0027min delay between checkpoints\u0027\n-\t\t\t\t\t\t\tlastCheckpointCompletionNanos \u003d System.nanoTime();\n-\n-\t\t\t\t\t\t\t// complete the checkpoint structure\n-\t\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n-\t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n-\n-\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint {} ({} bytes in {} ms).\", checkpointId,\n-\t\t\t\t\t\t\t\tcompleted.getStateSize(), completed.getDuration());\n-\n-\t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n-\t\t\t\t\t\t\t\tbuilder.append(\"Checkpoint state: \");\n-\t\t\t\t\t\t\t\tfor (TaskState state : completed.getTaskStates().values()) {\n-\t\t\t\t\t\t\t\t\tbuilder.append(state);\n-\t\t\t\t\t\t\t\t\tbuilder.append(\", \");\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t// Remove last two chars \", \"\n-\t\t\t\t\t\t\t\tbuilder.delete(builder.length() - 2, builder.length());\n-\n-\t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n-\t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n-\n-\t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n-\n-\t\t\t\t\t\t\ttriggerQueuedRequests();\n+\t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t\t}\n+\n+\t\t\t\treturn true;\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n+\t\t\t\tboolean wasPendingCheckpoint;\n+\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n-\t\t\t\t\tisPendingCheckpoint \u003d true;\n+\t\t\t\t\twasPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n \t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n \t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n-\t\t\t\t\tisPendingCheckpoint \u003d false;\n+\t\t\t\t\twasPendingCheckpoint \u003d false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n \t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+\n+\t\t\t\treturn wasPendingCheckpoint;\n \t\t\t}\n \t\t}\n-\n-\t\t// send the confirmation messages to the necessary targets. we do this here\n-\t\t// to be outside the lock scope\n-\t\tif (completed !\u003d null) {\n-\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n-\n-\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n-\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n-\t\t\t\tif (ee !\u003d null) {\n-\t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n-\t\t}\n-\n-\t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ea7080712f2dcbdf125b806007c80aa3d120f30a": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-5278] Improve task and checkpoint related logging\n\nAdd more logging\n\nThis closes #2959.\n",
      "commitDate": "2016-12-09, 8:42 a.m.",
      "commitName": "ea7080712f2dcbdf125b806007c80aa3d120f30a",
      "commitAuthor": "Till Rohrmann",
      "commitDateOld": "2016-12-01, 9:55 a.m.",
      "commitNameOld": "b181662be378652d6c4405841ccda6145968d145",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 7.95,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n\t\t\t\t\tcase SUCCESS:\n\t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n\t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\n\t\t\t\t\t\t\t// record the time when this was completed, to calculate\n\t\t\t\t\t\t\t// the \u0027min delay between checkpoints\u0027\n\t\t\t\t\t\t\tlastCheckpointCompletionNanos \u003d System.nanoTime();\n\n\t\t\t\t\t\t\t// complete the checkpoint structure\n\t\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n\t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint {} ({} bytes in {} ms).\", checkpointId,\n\t\t\t\t\t\t\t\tcompleted.getStateSize(), completed.getDuration());\n\n\t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\t\tbuilder.append(\"Checkpoint state: \");\n\t\t\t\t\t\t\t\tfor (TaskState state : completed.getTaskStates().values()) {\n\t\t\t\t\t\t\t\t\tbuilder.append(state);\n\t\t\t\t\t\t\t\t\tbuilder.append(\", \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Remove last two chars \", \"\n\t\t\t\t\t\t\t\tbuilder.delete(builder.length() - 2, builder.length());\n\n\t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n\n\t\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DUPLICATE:\n\t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UNKNOWN:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n\t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n\t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISCARDED:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n\t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n\t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\n\t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 612,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,126 +1,132 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n+\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tcase SUCCESS:\n+\t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n+\t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n+\n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \n \t\t\t\t\t\t\t// record the time when this was completed, to calculate\n \t\t\t\t\t\t\t// the \u0027min delay between checkpoints\u0027\n \t\t\t\t\t\t\tlastCheckpointCompletionNanos \u003d System.nanoTime();\n \n \t\t\t\t\t\t\t// complete the checkpoint structure\n \t\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n-\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n-\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n+\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint {} ({} bytes in {} ms).\", checkpointId,\n+\t\t\t\t\t\t\t\tcompleted.getStateSize(), completed.getDuration());\n \n \t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n \t\t\t\t\t\t\t\tbuilder.append(\"Checkpoint state: \");\n \t\t\t\t\t\t\t\tfor (TaskState state : completed.getTaskStates().values()) {\n \t\t\t\t\t\t\t\t\tbuilder.append(state);\n \t\t\t\t\t\t\t\t\tbuilder.append(\", \");\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t// Remove last two chars \", \"\n \t\t\t\t\t\t\t\tbuilder.delete(builder.length() - 2, builder.length());\n \n \t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n+\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n+\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n-\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n+\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n+\t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n+\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n+\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n-\t\t\t\tdiscardState(message.getSubtaskState());\n+\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b181662be378652d6c4405841ccda6145968d145": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-5216] [checkpoints] \u0027Min Time Between Checkpoints\u0027 references timestamp after checkpoint\n",
      "commitDate": "2016-12-01, 9:55 a.m.",
      "commitName": "b181662be378652d6c4405841ccda6145968d145",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2016-12-01, 4:44 a.m.",
      "commitNameOld": "dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b",
      "commitAuthorOld": "Ufuk Celebi",
      "daysBetweenCommits": 0.22,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n\t\t\t\t\tcase SUCCESS:\n\t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\n\t\t\t\t\t\t\t// record the time when this was completed, to calculate\n\t\t\t\t\t\t\t// the \u0027min delay between checkpoints\u0027\n\t\t\t\t\t\t\tlastCheckpointCompletionNanos \u003d System.nanoTime();\n\n\t\t\t\t\t\t\t// complete the checkpoint structure\n\t\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n\t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\n\t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\t\tbuilder.append(\"Checkpoint state: \");\n\t\t\t\t\t\t\t\tfor (TaskState state : completed.getTaskStates().values()) {\n\t\t\t\t\t\t\t\t\tbuilder.append(state);\n\t\t\t\t\t\t\t\t\tbuilder.append(\", \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Remove last two chars \", \"\n\t\t\t\t\t\t\t\tbuilder.delete(builder.length() - 2, builder.length());\n\n\t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n\n\t\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DUPLICATE:\n\t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UNKNOWN:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n\t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n\t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISCARDED:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n\t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\n\t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n\t\t\t\tdiscardState(message.getSubtaskState());\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 612,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,121 +1,126 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\t\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \n+\t\t\t\t\t\t\t// record the time when this was completed, to calculate\n+\t\t\t\t\t\t\t// the \u0027min delay between checkpoints\u0027\n+\t\t\t\t\t\t\tlastCheckpointCompletionNanos \u003d System.nanoTime();\n+\n+\t\t\t\t\t\t\t// complete the checkpoint structure\n+\t\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n \t\t\t\t\t\t\t\tbuilder.append(\"Checkpoint state: \");\n \t\t\t\t\t\t\t\tfor (TaskState state : completed.getTaskStates().values()) {\n \t\t\t\t\t\t\t\t\tbuilder.append(state);\n \t\t\t\t\t\t\t\t\tbuilder.append(\", \");\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t// Remove last two chars \", \"\n \t\t\t\t\t\t\t\tbuilder.delete(builder.length() - 2, builder.length());\n \n \t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getSubtaskState());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n \t\t\t\tdiscardState(message.getSubtaskState());\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-5198] [logging] Improve TaskState toString\n",
      "commitDate": "2016-12-01, 4:44 a.m.",
      "commitName": "dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b",
      "commitAuthor": "Ufuk Celebi",
      "commitDateOld": "2016-11-22, 5:00 p.m.",
      "commitNameOld": "c590912c93a4059b40452dfa6cffbdd4d58cac13",
      "commitAuthorOld": "Till Rohrmann",
      "daysBetweenCommits": 8.49,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n\t\t\t\t\tcase SUCCESS:\n\t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n\n\t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\n\t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\t\tbuilder.append(\"Checkpoint state: \");\n\t\t\t\t\t\t\t\tfor (TaskState state : completed.getTaskStates().values()) {\n\t\t\t\t\t\t\t\t\tbuilder.append(state);\n\t\t\t\t\t\t\t\t\tbuilder.append(\", \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Remove last two chars \", \"\n\t\t\t\t\t\t\t\tbuilder.delete(builder.length() - 2, builder.length());\n\n\t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n\n\t\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DUPLICATE:\n\t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UNKNOWN:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n\t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n\t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISCARDED:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n\t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\n\t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n\t\t\t\tdiscardState(message.getSubtaskState());\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 614,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,117 +1,121 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n-\t\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n-\t\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n+\t\t\t\t\t\t\t\tbuilder.append(\"Checkpoint state: \");\n+\t\t\t\t\t\t\t\tfor (TaskState state : completed.getTaskStates().values()) {\n+\t\t\t\t\t\t\t\t\tbuilder.append(state);\n+\t\t\t\t\t\t\t\t\tbuilder.append(\", \");\n \t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t// Remove last two chars \", \"\n+\t\t\t\t\t\t\t\tbuilder.delete(builder.length() - 2, builder.length());\n \n \t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getSubtaskState());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n \t\t\t\tdiscardState(message.getSubtaskState());\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c590912c93a4059b40452dfa6cffbdd4d58cac13": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-5085] Execute CheckpointCoordinator\u0027s state discard calls asynchronously\n\nThe CheckpointCoordinator is now given an Executor which is used to execute the state discard\ncalls asynchronously. This will prevent blocking operations to be executed from within the\ncalling thread.\n\nShut down ExecutorServices gracefully\n\nThis closes #2825.\n",
      "commitDate": "2016-11-22, 5:00 p.m.",
      "commitName": "c590912c93a4059b40452dfa6cffbdd4d58cac13",
      "commitAuthor": "Till Rohrmann",
      "commitDateOld": "2016-11-16, 6:34 p.m.",
      "commitNameOld": "72b295b3b52dff2d0bc5b78881826e8936c370ff",
      "commitAuthorOld": "Till Rohrmann",
      "daysBetweenCommits": 5.93,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n\t\t\t\t\tcase SUCCESS:\n\t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n\n\t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\n\t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n\t\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n\n\t\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DUPLICATE:\n\t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UNKNOWN:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n\t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n\t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISCARDED:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n\t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\n\t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n\t\t\t\tdiscardState(message.getSubtaskState());\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 614,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,131 +1,117 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n \t\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tmessage.getSubtaskState().discardState();\n-\t\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n-\t\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n+\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tmessage.getSubtaskState().discardState();\n-\t\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n-\t\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \n-\t\t\t\ttry {\n-\t\t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n-\t\t\t\t\tmessage.getSubtaskState().discardState();\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n-\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n-\t\t\t\t}\n+\t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n+\t\t\t\tdiscardState(message.getSubtaskState());\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "72b295b3b52dff2d0bc5b78881826e8936c370ff": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-5063] [checkpointing] Discard state handles of declined or expired state handles\n\nWhenever the checkpoint coordinator receives an acknowledge checkpoint message which belongs\nto the job maintained by the checkpoint coordinator, it should either record the state handles\nfor later processing or discard to free the resources. The latter case can happen if a\ncheckpoint has been expired and late acknowledge checkpoint messages arrive. Furthremore, it\ncan happen if a Task sent a decline checkpoint message while other Tasks where still drawing\na checkpoint. This PR changes the behaviour such that state handles belonging to the job of\nthe checkpoint coordinator are discarded if they could not be added to the PendingCheckpoint.\n\nThis closes #2812\n",
      "commitDate": "2016-11-16, 6:34 p.m.",
      "commitName": "72b295b3b52dff2d0bc5b78881826e8936c370ff",
      "commitAuthor": "Till Rohrmann",
      "commitDateOld": "2016-11-08, 3:15 p.m.",
      "commitNameOld": "48a48139172e86f548f3b2f1564bdc948c3fe76a",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 8.14,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n\t\t\t\t\tcase SUCCESS:\n\t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n\n\t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\n\t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n\t\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n\n\t\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DUPLICATE:\n\t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UNKNOWN:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n\t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n\t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tmessage.getSubtaskState().discardState();\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n\t\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISCARDED:\n\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n\t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n\t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tmessage.getSubtaskState().discardState();\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n\t\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n\t\t\t\t\tmessage.getSubtaskState().discardState();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 611,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,95 +1,131 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n-\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n-\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n+\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n+\t\t\t\t\tcase SUCCESS:\n+\t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n+\t\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \n-\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n+\t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n-\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n+\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n-\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n-\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n-\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n-\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n+\t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n+\t\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n+\t\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n+\t\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n+\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\tLOG.debug(builder.toString());\n+\t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n+\t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n+\n+\t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n+\n+\t\t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase DUPLICATE:\n+\t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n+\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase UNKNOWN:\n+\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n+\t\t\t\t\t\t\t\t\"because the task\u0027s execution attempt id was unknown. Discarding \" +\n+\t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n+\t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n-\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tmessage.getSubtaskState().discardState();\n+\t\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n+\t\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase DISCARDED:\n+\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n+\t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n+\t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n+\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n-\n-\t\t\t\t\t\ttriggerQueuedRequests();\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// checkpoint did not accept message\n-\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint {} , task {}\",\n-\t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId());\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tmessage.getSubtaskState().discardState();\n+\t\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n+\t\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n+\t\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n-\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n+\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n+\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\t// try to discard the state so that we don\u0027t have lingering state lying around\n+\t\t\t\t\tmessage.getSubtaskState().discardState();\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n+\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "48a48139172e86f548f3b2f1564bdc948c3fe76a": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4985] [checkpointing] Report canceled / declined checkpoints to the Checkpoint Coordinator\n",
      "commitDate": "2016-11-08, 3:15 p.m.",
      "commitName": "48a48139172e86f548f3b2f1564bdc948c3fe76a",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2016-11-02, 2:34 a.m.",
      "commitNameOld": "c0e620f0ace0aa3500a5642e7165cf9f05e81f6a",
      "commitAuthorOld": "Ufuk Celebi",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\n\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n\n\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint {} , task {}\",\n\t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 611,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,97 +1,95 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n-\t\t\t\tif (checkpoint.acknowledgeTask(\n-\t\t\t\t\t\tmessage.getTaskExecutionId(),\n-\t\t\t\t\t\tmessage.getSubtaskState())) {\n+\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// checkpoint did not accept message\n-\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n-\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n+\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint {} , task {}\",\n+\t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cfb3790fb6feb6c771bccbd05d3b12c69f53657d": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4887] [execution graph] Introduce TaskManagerGateway to encapsulate communcation logic\n\nAll task manager related logic is now encapsulated in the TaskManagerGateway. Consequently,\nthere is no direct use of the ActorGateway in the ExecutionGraph anymore.\n\nAdd PartitionInfo\n\n[FLINK-4887] Add FutureUtils#retry to automatically retry failed future operations\n\nAdapt job manager\n\n[FLINK-4887] Refactor StackTraceSampleCoordinator to work with TaskManagerGateway and Flink futures\n\n[FLINK-4887] Refactor CheckpointCoordinator to work with TaskManagerGateway\n\n[FLINK-4887] Fix test cases to work with the newly introduce TaskManagerGateway\n\n[FLINK-4887] Update FlinkFuture#handlyAsync to avoid second future operation\n\n[FLINK-4887] Remove TaskOpeartionResult message\n\nMake StackTrace and StackTraceSampleResponse serializable\n\nIncrease timeout of TaskStopTest\n\nThis closes #2699.\n",
      "commitDate": "2016-11-01, 4:36 a.m.",
      "commitName": "cfb3790fb6feb6c771bccbd05d3b12c69f53657d",
      "commitAuthor": "Till Rohrmann",
      "commitDateOld": "2016-10-28, 5:04 a.m.",
      "commitNameOld": "3bc9cad045b25d413f0b9f054fff12fac18a4f0e",
      "commitAuthorOld": "Ufuk Celebi",
      "daysBetweenCommits": 3.98,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tif (checkpoint.acknowledgeTask(\n\t\t\t\t\t\tmessage.getTaskExecutionId(),\n\t\t\t\t\t\tmessage.getSubtaskState())) {\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\n\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n\n\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 615,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,99 +1,97 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n \t\t\t\t\t\tmessage.getTaskExecutionId(),\n \t\t\t\t\t\tmessage.getSubtaskState())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n-\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n-\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n-\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n+\t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cab9cd44eca83ef8cbcd2a2d070d8c79cb037977": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4844] Partitionable Raw Keyed/Operator State\n",
      "commitDate": "2016-10-20, 10:14 a.m.",
      "commitName": "cab9cd44eca83ef8cbcd2a2d070d8c79cb037977",
      "commitAuthor": "Stefan Richter",
      "commitDateOld": "2016-10-14, 4:07 a.m.",
      "commitNameOld": "5783671c2f30228a2d5b5b7bf09b762ae41db8e2",
      "commitAuthorOld": "Ufuk Celebi",
      "daysBetweenCommits": 6.25,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tif (checkpoint.acknowledgeTask(\n\t\t\t\t\t\tmessage.getTaskExecutionId(),\n\t\t\t\t\t\tmessage.getSubtaskState())) {\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\n\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n\n\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 619,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,99 +1,99 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n \t\t\t\t\t\tmessage.getTaskExecutionId(),\n-\t\t\t\t\t\tmessage.getCheckpointStateHandles())) {\n+\t\t\t\t\t\tmessage.getSubtaskState())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53ed6adac8cbe6b5dcb692dc9b94970f3ec5887c": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4379] [checkpoints] Introduce rescalable operator state\n\nThis introduces the Operator State Backend, which stores state that is not partitioned\nby a key. It replaces the \u0027Checkpointed\u0027 interface.\n\nAdditionally, this introduces CheckpointStateHandles as container for all checkpoint related state handles\n\nThis closes #2512\n",
      "commitDate": "2016-09-30, 6:38 a.m.",
      "commitName": "53ed6adac8cbe6b5dcb692dc9b94970f3ec5887c",
      "commitAuthor": "Stefan Richter",
      "commitDateOld": "2016-09-26, 12:05 p.m.",
      "commitNameOld": "70e71c16177b40c2418e6a8ca0838bf117f6a926",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tif (checkpoint.acknowledgeTask(\n\t\t\t\t\t\tmessage.getTaskExecutionId(),\n\t\t\t\t\t\tmessage.getCheckpointStateHandles())) {\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\n\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n\n\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 603,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,101 +1,99 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n-\t\t\t\t\tmessage.getTaskExecutionId(),\n-\t\t\t\t\tmessage.getStateHandle(),\n-\t\t\t\t\tmessage.getKeyGroupsStateHandle())) {\n+\t\t\t\t\t\tmessage.getTaskExecutionId(),\n+\t\t\t\t\t\tmessage.getCheckpointStateHandles())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n-\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry: completed.getTaskStates().entrySet()) {\n+\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n+\t\t\t\t} else {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "847ead01f2f0aaf318b2b1ba8501bc697d245900": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4381] Refactor State to Prepare For Key-Group State Backends\n",
      "commitDate": "2016-08-31, 1:10 p.m.",
      "commitName": "847ead01f2f0aaf318b2b1ba8501bc697d245900",
      "commitAuthor": "Stefan Richter",
      "commitDateOld": "2016-08-31, 1:04 p.m.",
      "commitNameOld": "ec975aaba79449bd93020f296b05ea509ea57bdc",
      "commitAuthorOld": "Till Rohrmann",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tif (checkpoint.acknowledgeTask(\n\t\t\t\t\tmessage.getTaskExecutionId(),\n\t\t\t\t\tmessage.getStateHandle(),\n\t\t\t\t\tmessage.getKeyGroupsStateHandle())) {\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\n\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry: completed.getTaskStates().entrySet()) {\n\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n\n\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 603,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,103 +1,101 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n \t\t\t\t\tmessage.getTaskExecutionId(),\n-\t\t\t\t\tmessage.getState(),\n-\t\t\t\t\tmessage.getStateSize(),\n-\t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n-\t\t\t\t\t\n+\t\t\t\t\tmessage.getStateHandle(),\n+\t\t\t\t\tmessage.getKeyGroupsStateHandle())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry: completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4e9d1775b5514c87981c78d55323cc2b17361867": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4417] [checkpoints] Checkpoints are subsumed by CheckpointID not, by timestamp\n\nThis closes #2407\n",
      "commitDate": "2016-08-24, 1:56 p.m.",
      "commitName": "4e9d1775b5514c87981c78d55323cc2b17361867",
      "commitAuthor": "Ramkrishna",
      "commitDateOld": "2016-08-24, 1:56 p.m.",
      "commitNameOld": "4da40bcb9ea01cb0c5e6fd0d7472dc09397f648e",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tif (checkpoint.acknowledgeTask(\n\t\t\t\t\tmessage.getTaskExecutionId(),\n\t\t\t\t\tmessage.getState(),\n\t\t\t\t\tmessage.getStateSize(),\n\t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n\t\t\t\t\t\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\n\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry: completed.getTaskStates().entrySet()) {\n\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n\n\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 618,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,103 +1,103 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n \t\t\t\t\tmessage.getTaskExecutionId(),\n \t\t\t\t\tmessage.getState(),\n \t\t\t\t\tmessage.getStateSize(),\n \t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry: completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n-\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n+\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "76ca1a7955fedd8583a0af12289a14d0f1bcf868": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4322] [checkpointing] Unify CheckpointCoordinator and SavepointCoordinator\n\nThe CheckpointCoordinator now also takes over the role of the SavepointCoordinator.\nSavepoints are just like other checkpoints - they only store the metadata in addition.\nRestoring from a savepoint means loading it into the CheckpointStore at startup.\n",
      "commitDate": "2016-08-17, 1:06 p.m.",
      "commitName": "76ca1a7955fedd8583a0af12289a14d0f1bcf868",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2016-07-26, 5:30 a.m.",
      "commitNameOld": "f0ac261add2eb184358d5b89bc90b13aef7b267d",
      "commitAuthorOld": "Ufuk Celebi",
      "daysBetweenCommits": 22.32,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tif (checkpoint.acknowledgeTask(\n\t\t\t\t\tmessage.getTaskExecutionId(),\n\t\t\t\t\tmessage.getState(),\n\t\t\t\t\tmessage.getStateSize(),\n\t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n\t\t\t\t\t\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\n\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry: completed.getTaskStates().entrySet()) {\n\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\n\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 633,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,104 +1,103 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n \t\t\t\t\tmessage.getTaskExecutionId(),\n \t\t\t\t\tmessage.getState(),\n \t\t\t\t\tmessage.getStateSize(),\n \t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n+\t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry: completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \n-\t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n-\n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0ac261add2eb184358d5b89bc90b13aef7b267d": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4067] [runtime] Add savepoint headers\n\nSavepoints were previously persisted without any meta data using default\nJava serialization of `CompletedCheckpoint`. This commit introduces a\nsavepoint interface with version-specific serializers and stores\nsavepoints with meta data.\n\nSavepoints expose a version number and a Collection\u003cTaskState\u003e for\nsavepoint restore.\n\nCurrently, there is only one savepoint version:\n\nSavepointV0 (Flink 1.1): This is the current savepoint version, which\nholds a reference to the Checkpoint task state collection, but is\nserialized with a custom serializater not relying on default Java\nserialization. Therefore, it should not happen again that we need to\nstick to certain classes in future Flink versions.\n\nThe savepoints are stored in `FsSavepointStore` with the following\nformat:\n\nMagicNumber SavepointVersion Savepoint\n  - MagicNumber \u003d\u003e int\n  - SavepointVersion \u003d\u003e int (returned by Savepoint#getVersion())\n  - Savepoint \u003d\u003e bytes (serialized via version-specific SavepointSerializer)\n\nThe header is minimal (magic number, version). All savepoint-specific\nmeta data can be moved to the savepoint itself. This is also were we\nwould have to add new meta data in future versions, allowing us to\ndifferentiate between different savepoint versions when we change the\nserialization stack.\n\nAll savepoint related classes have been moved from checkpoint to a new\nsub package `checkpoint.savepoint`.\n\nThis closes #2194.\n",
      "commitDate": "2016-07-26, 5:30 a.m.",
      "commitName": "f0ac261add2eb184358d5b89bc90b13aef7b267d",
      "commitAuthor": "Ufuk Celebi",
      "commitDateOld": "2016-07-22, 8:26 a.m.",
      "commitNameOld": "54f02ec7bae56a0559a61b981d0c88885090b128",
      "commitAuthorOld": "Ufuk Celebi",
      "daysBetweenCommits": 3.88,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tif (checkpoint.acknowledgeTask(\n\t\t\t\t\tmessage.getTaskExecutionId(),\n\t\t\t\t\tmessage.getState(),\n\t\t\t\t\tmessage.getStateSize(),\n\t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\n\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry: completed.getTaskStates().entrySet()) {\n\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\n\t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n\n\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 651,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,104 +1,104 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n \t\t\t\t\tmessage.getTaskExecutionId(),\n \t\t\t\t\tmessage.getState(),\n \t\t\t\t\tmessage.getStateSize(),\n \t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n+\t\t\t\t\t\tcompleted \u003d checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry: completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \n \t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0cf04108f70375d41ebb7c39629db3a081bd2876": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-3756] [state] Add state hierarchy to CheckpointCoordinator\n\nThis commit introduces a state hierarchy for the StateForTask objects kept\nat the CheckpointCoordinator. Task states are now grouped together if they\nbelong to the same ExecutionJobVertex. The StateForTask objects are now\nstored in so called StateForTaskGroup objects. The StateForTaskGroup object\ncan also store the key group state handles associated to a ExecutionJobVertex.\n\nAdapt restore methods of CheckpointCoordinator and SavepointCoordinator\n\nAdd state size computation\n\nAdd comments to createKeyGroupPartitions; Add more information to StateForTask.toString\n\nRename StateForTaskGroup -\u003e TaskState, StateForTask -\u003e SubtaskState, KvStateForTasks -\u003e KeyGroupState\n\nThis closes #1883.\n",
      "commitDate": "2016-04-26, 6:22 a.m.",
      "commitName": "0cf04108f70375d41ebb7c39629db3a081bd2876",
      "commitAuthor": "Till Rohrmann",
      "commitDateOld": "2016-04-11, 12:36 p.m.",
      "commitNameOld": "2e63d1afb2358760109ba0c90011ef565eaae0ff",
      "commitAuthorOld": "zentol",
      "daysBetweenCommits": 14.74,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tif (checkpoint.acknowledgeTask(\n\t\t\t\t\tmessage.getTaskExecutionId(),\n\t\t\t\t\tmessage.getState(),\n\t\t\t\t\tmessage.getStateSize(),\n\t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\n\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry: completed.getTaskStates().entrySet()) {\n\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tLOG.debug(builder.toString());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\n\t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n\n\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 623,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,92 +1,104 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint \u003d true;\n \n-\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n+\t\t\t\tif (checkpoint.acknowledgeTask(\n+\t\t\t\t\tmessage.getTaskExecutionId(),\n+\t\t\t\t\tmessage.getState(),\n+\t\t\t\t\tmessage.getStateSize(),\n+\t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n-\t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n+\n+\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n+\t\t\t\t\t\t\tStringBuilder builder \u003d new StringBuilder();\n+\t\t\t\t\t\t\tfor (Map.Entry\u003cJobVertexID, TaskState\u003e entry: completed.getTaskStates().entrySet()) {\n+\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tLOG.debug(builder.toString());\n+\t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \n \t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d739ee2532e0fd49ef37508b1c2e4a355473aaa5": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "[FLINK-2976] [runtime, tests] Add SavepointCoordinator\n\n[comments] Rename config keys\n\n[comments] Fix docs and don\u0027t overload savepoint backend configuration with checkpoint backend configuration\n\n[comments] Use ConcurrentMap in HeapStateStore\n\n[comments] Fix typo and add missing serialVersionUID\n\n[comments] Fix Scala style\n\n[comments] Fix Scala style\n\n[docs] Emphasize dangers and recommended approaches\n\nAdd test to show inf restart loop on submission with unknown savepoint path\n\n[comments] Suppress resart of savepoint recovery failure\n\nThis closes #1434.\n",
      "commitDate": "2016-01-11, 10:30 a.m.",
      "commitName": "d739ee2532e0fd49ef37508b1c2e4a355473aaa5",
      "commitAuthor": "Ufuk Celebi",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "[FLINK-2976] [runtime, tests] Add SavepointCoordinator\n\n[comments] Rename config keys\n\n[comments] Fix docs and don\u0027t overload savepoint backend configuration with checkpoint backend configuration\n\n[comments] Use ConcurrentMap in HeapStateStore\n\n[comments] Fix typo and add missing serialVersionUID\n\n[comments] Fix Scala style\n\n[comments] Fix Scala style\n\n[docs] Emphasize dangers and recommended approaches\n\nAdd test to show inf restart loop on submission with unknown savepoint path\n\n[comments] Suppress resart of savepoint recovery failure\n\nThis closes #1434.\n",
          "commitDate": "2016-01-11, 10:30 a.m.",
          "commitName": "d739ee2532e0fd49ef37508b1c2e4a355473aaa5",
          "commitAuthor": "Ufuk Celebi",
          "commitDateOld": "2015-12-30, 6:45 p.m.",
          "commitNameOld": "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2",
          "commitAuthorOld": "Ufuk Celebi",
          "daysBetweenCommits": 11.66,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\n\t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n\n\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
          "functionStartLine": 518,
          "functionName": "receiveAcknowledgeMessage",
          "diff": "@@ -1,80 +1,92 @@\n-\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n+\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n+\n+\t\t// Flag indicating whether the ack message was for a known pending\n+\t\t// checkpoint.\n+\t\tboolean isPendingCheckpoint;\n+\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n-\t\t\t\treturn;\n+\t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n+\t\t\t\tisPendingCheckpoint \u003d true;\n+\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \n+\t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n+\n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n+\t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n+\t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n+\n+\t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "[FLINK-2976] [runtime, tests] Add SavepointCoordinator\n\n[comments] Rename config keys\n\n[comments] Fix docs and don\u0027t overload savepoint backend configuration with checkpoint backend configuration\n\n[comments] Use ConcurrentMap in HeapStateStore\n\n[comments] Fix typo and add missing serialVersionUID\n\n[comments] Fix Scala style\n\n[comments] Fix Scala style\n\n[docs] Emphasize dangers and recommended approaches\n\nAdd test to show inf restart loop on submission with unknown savepoint path\n\n[comments] Suppress resart of savepoint recovery failure\n\nThis closes #1434.\n",
          "commitDate": "2016-01-11, 10:30 a.m.",
          "commitName": "d739ee2532e0fd49ef37508b1c2e4a355473aaa5",
          "commitAuthor": "Ufuk Celebi",
          "commitDateOld": "2015-12-30, 6:45 p.m.",
          "commitNameOld": "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2",
          "commitAuthorOld": "Ufuk Celebi",
          "daysBetweenCommits": 11.66,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\n\t\t// Flag indicating whether the ack message was for a known pending\n\t\t// checkpoint.\n\t\tboolean isPendingCheckpoint;\n\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tisPendingCheckpoint \u003d true;\n\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\n\t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n\n\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tisPendingCheckpoint \u003d true;\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisPendingCheckpoint \u003d false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\n\t\treturn isPendingCheckpoint;\n\t}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
          "functionStartLine": 518,
          "functionName": "receiveAcknowledgeMessage",
          "diff": "@@ -1,80 +1,92 @@\n-\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n+\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n+\n+\t\t// Flag indicating whether the ack message was for a known pending\n+\t\t// checkpoint.\n+\t\tboolean isPendingCheckpoint;\n+\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n-\t\t\t\treturn;\n+\t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n+\t\t\t\tisPendingCheckpoint \u003d true;\n+\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \n+\t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n+\n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n+\t\t\t\t\tisPendingCheckpoint \u003d true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n+\t\t\t\t\tisPendingCheckpoint \u003d false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n+\n+\t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-3131] [core, runtime] Add checkpoint statistics tracker\n\nAdds a simple tracker of checkpoint statistics.\n",
      "commitDate": "2015-12-30, 6:45 p.m.",
      "commitName": "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2",
      "commitAuthor": "Ufuk Celebi",
      "commitDateOld": "2015-11-26, 11:16 a.m.",
      "commitNameOld": "55fd5f32d7ef0292a01192ab08456fae49b91791",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 34.31,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n\t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\n\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n\t\t}\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 464,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,78 +1,80 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n-\t\t\n+\n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\t\n+\n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n-\t\t\t\n+\n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n-\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n-\t\t\t\t\t\n+\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n-\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n+\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n+\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n-\t\t\t\t\t\t\n+\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n-\t\t\t\n+\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "55fd5f32d7ef0292a01192ab08456fae49b91791": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-3051] [streaming] Add mechanisms to control the maximum number of concurrent checkpoints\n\nThis closes #1408\n",
      "commitDate": "2015-11-26, 11:16 a.m.",
      "commitName": "55fd5f32d7ef0292a01192ab08456fae49b91791",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2015-11-24, 3:28 a.m.",
      "commitNameOld": "c254bda3e84fcd9303f9a9e2a6f7a175d8e70d1e",
      "commitAuthorOld": "Gyula Fora",
      "daysBetweenCommits": 2.32,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\t\t\t\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n\t\t\t\t\t\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n\t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\n\t\t\t\t\t\ttriggerQueuedRequests();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\t\t\t\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 459,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,76 +1,78 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \t\t\t\n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n+\n+\t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \t\t\t\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "73c73e92750ab8fb068d0a3cb37afcb642084fc0": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "[FLINK-2354] [runtime] Add job graph and checkpoint recovery\n\nThis closes #1153.\n",
      "commitDate": "2015-10-19, 6:16 p.m.",
      "commitName": "73c73e92750ab8fb068d0a3cb37afcb642084fc0",
      "commitAuthor": "Ufuk Celebi",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "[FLINK-2354] [runtime] Add job graph and checkpoint recovery\n\nThis closes #1153.\n",
          "commitDate": "2015-10-19, 6:16 p.m.",
          "commitName": "73c73e92750ab8fb068d0a3cb37afcb642084fc0",
          "commitAuthor": "Ufuk Celebi",
          "commitDateOld": "2015-08-31, 5:02 a.m.",
          "commitNameOld": "b9de4ed37ffa68ef50dc6d6b3819afcc00d1d029",
          "commitAuthorOld": "Till Rohrmann",
          "daysBetweenCommits": 49.55,
          "commitsBetweenForRepo": 328,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\t\t\t\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n\t\t\t\t\t\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n\t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\t\t\t\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
          "functionStartLine": 367,
          "functionName": "receiveAcknowledgeMessage",
          "diff": "@@ -1,76 +1,76 @@\n-\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n+\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n-\t\tSuccessfulCheckpoint completed \u003d null;\n+\t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \t\t\t\n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n-\n \t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n-\t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n-\t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n-\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n-\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n+\n+\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n+\t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n+\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \t\t\t\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[Exception]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "[FLINK-2354] [runtime] Add job graph and checkpoint recovery\n\nThis closes #1153.\n",
          "commitDate": "2015-10-19, 6:16 p.m.",
          "commitName": "73c73e92750ab8fb068d0a3cb37afcb642084fc0",
          "commitAuthor": "Ufuk Celebi",
          "commitDateOld": "2015-08-31, 5:02 a.m.",
          "commitNameOld": "b9de4ed37ffa68ef50dc6d6b3819afcc00d1d029",
          "commitAuthorOld": "Till Rohrmann",
          "daysBetweenCommits": 49.55,
          "commitsBetweenForRepo": 328,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tCompletedCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\t\t\t\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n\t\t\t\t\t\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n\n\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n\t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\t\t\t\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
          "functionStartLine": 367,
          "functionName": "receiveAcknowledgeMessage",
          "diff": "@@ -1,76 +1,76 @@\n-\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n+\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n-\t\tSuccessfulCheckpoint completed \u003d null;\n+\t\tCompletedCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \t\t\t\n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n-\n \t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n-\t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n-\t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n-\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n-\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n+\n+\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n+\t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n+\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \t\t\t\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "aa5e5b3087a68f2aac792c0b0fc64b4f9c707e9b": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-2008] [FLINK-2296] Fix checkpoint committing \u0026 KafkaITCase\n\nThis closes #895\n",
      "commitDate": "2015-07-13, 11:54 a.m.",
      "commitName": "aa5e5b3087a68f2aac792c0b0fc64b4f9c707e9b",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2015-06-25, 10:38 a.m.",
      "commitNameOld": "0ecab82add0946503a000162813bb820f6f3b4d4",
      "commitAuthorOld": "Paris Carbone",
      "daysBetweenCommits": 18.05,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tSuccessfulCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\t\t\t\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n\t\t\t\t\t\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n\n\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n\t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n\t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\t\t\t\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 306,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,79 +1,76 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tSuccessfulCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \t\t\t\n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \n \t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n \t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n \t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n \t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \t\t\t\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n-\t\t\t\t\tStateForTask stateForTask \u003d completed.getState(ev.getJobvertexId());\n-\t\t\t\t\tSerializedValue\u003cStateHandle\u003c?\u003e\u003e taskState \u003d (stateForTask !\u003d null) ? stateForTask.getState() : null;\n-\t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, \n-\t\t\t\t\t\t\ttimestamp, taskState);\n-\t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n+\t\t\t\t\tNotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n+\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0ecab82add0946503a000162813bb820f6f3b4d4": {
      "type": "Ybodychange",
      "commitMessage": "[streaming] fix for null state in ConfirmCheckpoint messages\n",
      "commitDate": "2015-06-25, 10:38 a.m.",
      "commitName": "0ecab82add0946503a000162813bb820f6f3b4d4",
      "commitAuthor": "Paris Carbone",
      "commitDateOld": "2015-06-25, 10:38 a.m.",
      "commitNameOld": "f27c3f1d1cbff7433a23227e75f2f8e30058397a",
      "commitAuthorOld": "Paris Carbone",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tSuccessfulCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\t\t\t\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n\t\t\t\t\t\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n\n\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n\t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n\t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\t\t\t\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tStateForTask stateForTask \u003d completed.getState(ev.getJobvertexId());\n\t\t\t\t\tSerializedValue\u003cStateHandle\u003c?\u003e\u003e taskState \u003d (stateForTask !\u003d null) ? stateForTask.getState() : null;\n\t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, \n\t\t\t\t\t\t\ttimestamp, taskState);\n\t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 308,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,77 +1,79 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tSuccessfulCheckpoint completed \u003d null;\n \t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n \t\t\t\n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \n \t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n \t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n \t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n \t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \t\t\t\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n+\t\t\t\t\tStateForTask stateForTask \u003d completed.getState(ev.getJobvertexId());\n+\t\t\t\t\tSerializedValue\u003cStateHandle\u003c?\u003e\u003e taskState \u003d (stateForTask !\u003d null) ? stateForTask.getState() : null;\n \t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, \n-\t\t\t\t\t\t\ttimestamp, completed.getState(ev.getJobvertexId()).getState() );\n+\t\t\t\t\t\t\ttimestamp, taskState);\n \t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f27c3f1d1cbff7433a23227e75f2f8e30058397a": {
      "type": "Ybodychange",
      "commitMessage": "[streaming] Add stateHandle to checkpointed message\n",
      "commitDate": "2015-06-25, 10:38 a.m.",
      "commitName": "f27c3f1d1cbff7433a23227e75f2f8e30058397a",
      "commitAuthor": "Paris Carbone",
      "commitDateOld": "2015-06-12, 3:54 a.m.",
      "commitNameOld": "078e6ef3ef0d455d6f405c21c1ca209b80418a23",
      "commitAuthorOld": "mbalassi",
      "daysBetweenCommits": 13.28,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tSuccessfulCheckpoint completed \u003d null;\n\t\tPendingCheckpoint checkpoint;\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n\t\t\t\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n\t\t\t\t\t\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n\n\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n\t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n\t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\t\t\t\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, \n\t\t\t\t\t\t\ttimestamp, completed.getState(ev.getJobvertexId()).getState() );\n\t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 306,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,74 +1,77 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tSuccessfulCheckpoint completed \u003d null;\n-\t\t\n+\t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n-\t\t\tPendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n+\t\t\tcheckpoint \u003d pendingCheckpoints.get(checkpointId);\n+\t\t\t\n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \n \t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n \t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n \t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n \t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n+\t\t\t\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n-\t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n+\t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, \n+\t\t\t\t\t\t\ttimestamp, completed.getState(ev.getJobvertexId()).getState() );\n \t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "197cd6cf0fb10efc6badd5fc8584f4b36b09e705": {
      "type": "Ybodychange",
      "commitMessage": "[streaming] StateHandleProvider added for configurable state backend\n",
      "commitDate": "2015-05-19, 12:32 p.m.",
      "commitName": "197cd6cf0fb10efc6badd5fc8584f4b36b09e705",
      "commitAuthor": "Gyula Fora",
      "commitDateOld": "2015-05-19, 12:25 p.m.",
      "commitNameOld": "59bee4ad825d7252c791e0376ea2504602134fe7",
      "commitAuthorOld": "Gyula Fora",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tSuccessfulCheckpoint completed \u003d null;\n\t\t\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tPendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n\t\t\t\t\t\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n\n\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n\t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n\t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 307,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,74 +1,74 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tSuccessfulCheckpoint completed \u003d null;\n \t\t\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tPendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \n \t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n \t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n \t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n-\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().dispose(userClassLoader);;\n+\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59bee4ad825d7252c791e0376ea2504602134fe7": {
      "type": "Ybodychange",
      "commitMessage": "[streaming] Discard method added to state handle\n",
      "commitDate": "2015-05-19, 12:25 p.m.",
      "commitName": "59bee4ad825d7252c791e0376ea2504602134fe7",
      "commitAuthor": "Gyula Fora",
      "commitDateOld": "2015-05-12, 3:35 p.m.",
      "commitNameOld": "54e957614c38fed69baf726fc86059e9b11384cb",
      "commitAuthorOld": "Robert Metzger",
      "daysBetweenCommits": 6.87,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tSuccessfulCheckpoint completed \u003d null;\n\t\t\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tPendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n\t\t\t\t\t\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n\n\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n\t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n\t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().dispose(userClassLoader);;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 307,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,74 +1,74 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n \n \t\tSuccessfulCheckpoint completed \u003d null;\n \t\t\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tPendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \n \t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n \t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n \t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n-\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst();\n+\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().dispose(userClassLoader);;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed !\u003d null) {\n \t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n \t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9b7f8aa121e4a231632296d0809029aca9ebde6a": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1953] [runtime] Integrate new snapshot checkpoint coordinator with jobgraph and execution graph\n\nThis closes #651\n",
      "commitDate": "2015-05-12, 3:35 p.m.",
      "commitName": "9b7f8aa121e4a231632296d0809029aca9ebde6a",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2015-04-29, 4:47 a.m.",
      "commitNameOld": "7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 13.45,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\n\t\tSuccessfulCheckpoint completed \u003d null;\n\t\t\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tPendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n\t\t\t\t\t\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n\n\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n\t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n\t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (completed !\u003d null) {\n\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n\t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 298,
      "functionName": "receiveAcknowledgeMessage",
      "diff": "@@ -1,74 +1,74 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n \t\tif (shutdown || message \u003d\u003d null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId \u003d message.getCheckpointId();\n-\t\tboolean checkpointCompleted \u003d false;\n+\n+\t\tSuccessfulCheckpoint completed \u003d null;\n \t\t\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tPendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n \t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \n-\t\t\t\t\t\tSuccessfulCheckpoint completed \u003d checkpoint.toCompletedCheckpoint();\n+\t\t\t\t\t\tcompleted \u003d checkpoint.toCompletedCheckpoint();\n \t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n \t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n \t\t\t\t\t\t\tcompletedCheckpoints.removeFirst();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n-\t\t\t\t\t\t\n-\t\t\t\t\t\tcheckpointCompleted \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint !\u003d null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n-\t\tif (checkpointCompleted) {\n+\t\tif (completed !\u003d null) {\n+\t\t\tfinal long timestamp \u003d completed.getTimestamp();\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee !\u003d null) {\n \t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n-\t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId);\n+\t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be": {
      "type": "Yintroduced",
      "commitMessage": "[FLINK-1953] [runtime] Implement robust and flexible checkpoint coordinator with tests.\n\n - Checkpoints can be configured to have different sets of tasks\n   that triggering the checkpoint barriers, that acknowledging the checkpoint,\n   and that require checkpoint confirmations.\n\n - A configurable number of successful chckpoints can be retained\n\n - Checkpoints time out after a certain time, if not acknowledged (prevent resource leaks)\n\n - Checkpoints are robust to lost messages and out of order acknowledging.\n",
      "commitDate": "2015-04-29, 4:47 a.m.",
      "commitName": "7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be",
      "commitAuthor": "Stephan Ewen",
      "diff": "@@ -0,0 +1,74 @@\n+\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n+\t\tif (shutdown || message \u003d\u003d null) {\n+\t\t\treturn;\n+\t\t}\n+\t\tif (!job.equals(message.getJob())) {\n+\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n+\t\t\treturn;\n+\t\t}\n+\t\t\n+\t\tfinal long checkpointId \u003d message.getCheckpointId();\n+\t\tboolean checkpointCompleted \u003d false;\n+\t\t\n+\t\tsynchronized (lock) {\n+\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n+\t\t\t// get races and invalid error log messages\n+\t\t\tif (shutdown) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t\n+\t\t\tPendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n+\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n+\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n+\t\t\t\t\t\n+\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n+\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n+\n+\t\t\t\t\t\tSuccessfulCheckpoint completed \u003d checkpoint.toCompletedCheckpoint();\n+\t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n+\t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n+\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n+\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tcheckpointCompleted \u003d true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\t// checkpoint did not accept message\n+\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n+\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse if (checkpoint !\u003d null) {\n+\t\t\t\t// this should not happen\n+\t\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n+\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n+\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\t// send the confirmation messages to the necessary targets. we do this here\n+\t\t// to be outside the lock scope\n+\t\tif (checkpointCompleted) {\n+\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n+\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n+\t\t\t\tif (ee !\u003d null) {\n+\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n+\t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId);\n+\t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n\t\tif (shutdown || message \u003d\u003d null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!job.equals(message.getJob())) {\n\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal long checkpointId \u003d message.getCheckpointId();\n\t\tboolean checkpointCompleted \u003d false;\n\t\t\n\t\tsynchronized (lock) {\n\t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n\t\t\t// get races and invalid error log messages\n\t\t\tif (shutdown) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tPendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n\t\t\tif (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n\t\t\t\t\t\n\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n\n\t\t\t\t\t\tSuccessfulCheckpoint completed \u003d checkpoint.toCompletedCheckpoint();\n\t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n\t\t\t\t\t\tif (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n\t\t\t\t\t\t\n\t\t\t\t\t\tcheckpointCompleted \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// checkpoint did not accept message\n\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (checkpoint !\u003d null) {\n\t\t\t\t// this should not happen\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n\t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// send the confirmation messages to the necessary targets. we do this here\n\t\t// to be outside the lock scope\n\t\tif (checkpointCompleted) {\n\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n\t\t\t\tExecution ee \u003d ev.getCurrentExecutionAttempt();\n\t\t\t\tif (ee !\u003d null) {\n\t\t\t\t\tExecutionAttemptID attemptId \u003d ee.getAttemptId();\n\t\t\t\t\tConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId);\n\t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 263,
      "functionName": "receiveAcknowledgeMessage"
    }
  }
}