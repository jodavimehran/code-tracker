{
  "origin": "codeshovel",
  "repositoryName": "commons-lang",
  "repositoryPath": "H:\\Projects\\apache\\commons-lang/.git",
  "startCommitName": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83",
  "sourceFileName": "DurationFormatUtils.java",
  "functionName": "formatPeriod",
  "functionId": "formatPeriod___startMillis-long(modifiers-final)__endMillis-long(modifiers-final)__format-String(modifiers-final)__padWithZeros-boolean(modifiers-final)__timezone-TimeZone(modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java",
  "functionStartLine": 279,
  "functionEndLine": 409,
  "numCommitsSeen": 107,
  "timeTaken": 2433,
  "changeHistory": [
    "9a16b763d9c51b788415c5f83b6e9221a3cf5d0d",
    "4b74c385628ed1766209a79705a2d5986c23d02c",
    "64ef8a80224443c81dfb198cbc567e1b2b9356a2",
    "f33fba71c5ab38ebff98b5bea9291807c4999483",
    "5292526e476ffbb19c6613a98464054236c86ace",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db",
    "79cddd4ea5b4fad17f74878e40b3dcd0c54d9cf6",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
    "4f514d5eb3e80703012df9be190ae42d35d25bdc",
    "93aa88fded0cb63a8634cf8021cb889bc38505bf",
    "dd23ae863a8910581362b69c660b26d8e8f699b7",
    "5fb6521ab990c0c9ec655ca71d8c77060aedb0e5",
    "ee4ad2727fcfb949e258e0f215a79d56ea41a173",
    "1d5c03fac601d6ce291c3fe3e5e51a11881e2fc0",
    "b7d3fd9e4d435eb155570f326e8c799ead6c1901",
    "5111ae7db08a70323a51a21df0bbaf46f21e072e",
    "dd2a1841fc7c9c95af1ce1e6ed3ed0ee3587df19",
    "f80cb56da1316d5cb977c07937c2794efc87a522",
    "177d40989f45197fd9f9669f4eeb6033b73bc16e"
  ],
  "changeHistoryShort": {
    "9a16b763d9c51b788415c5f83b6e9221a3cf5d0d": "Ybodychange",
    "4b74c385628ed1766209a79705a2d5986c23d02c": "Ybodychange",
    "64ef8a80224443c81dfb198cbc567e1b2b9356a2": "Ybodychange",
    "f33fba71c5ab38ebff98b5bea9291807c4999483": "Ybodychange",
    "5292526e476ffbb19c6613a98464054236c86ace": "Ybodychange",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": "Yparametermetachange",
    "79cddd4ea5b4fad17f74878e40b3dcd0c54d9cf6": "Ybodychange",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": "Yfilerename",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": "Yfilerename",
    "4f514d5eb3e80703012df9be190ae42d35d25bdc": "Ybodychange",
    "93aa88fded0cb63a8634cf8021cb889bc38505bf": "Ybodychange",
    "dd23ae863a8910581362b69c660b26d8e8f699b7": "Ybodychange",
    "5fb6521ab990c0c9ec655ca71d8c77060aedb0e5": "Ybodychange",
    "ee4ad2727fcfb949e258e0f215a79d56ea41a173": "Ybodychange",
    "1d5c03fac601d6ce291c3fe3e5e51a11881e2fc0": "Ybodychange",
    "b7d3fd9e4d435eb155570f326e8c799ead6c1901": "Ybodychange",
    "5111ae7db08a70323a51a21df0bbaf46f21e072e": "Ymultichange(Yrename,Ybodychange)",
    "dd2a1841fc7c9c95af1ce1e6ed3ed0ee3587df19": "Ybodychange",
    "f80cb56da1316d5cb977c07937c2794efc87a522": "Ybodychange",
    "177d40989f45197fd9f9669f4eeb6033b73bc16e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9a16b763d9c51b788415c5f83b6e9221a3cf5d0d": {
      "type": "Ybodychange",
      "commitMessage": "Using Validate where possible in time package.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1594373 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014-05-13, 4:31 p.m.",
      "commitName": "9a16b763d9c51b788415c5f83b6e9221a3cf5d0d",
      "commitAuthor": "Duncan Jones",
      "commitDateOld": "2014-05-05, 2:02 p.m.",
      "commitNameOld": "7d6e0beccb1345078b3051504e623f399c012fd4",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 8.1,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n        Validate.isTrue(startMillis \u003c\u003d endMillis, \"startMillis must not be greater than endMillis\");\n        \n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months \u003c 0) {\n                months +\u003d 12;\n                years -\u003d 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                while (years !\u003d 0) {\n                    months +\u003d 12 * years;\n                    years \u003d 0;\n                }\n            }\n        } else {\n            // there are no M\u0027s in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target \u003d end.get(Calendar.YEAR);\n                if (months \u003c 0) {\n                    // target is end-year -1\n                    target -\u003d 1;\n                }\n                \n                while (start.get(Calendar.YEAR) !\u003d target) {\n                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar \u0026\u0026\n                            start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n                            start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n                        days +\u003d 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years \u003d 0;\n            }\n            \n            while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months \u003d 0;            \n\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java",
      "functionStartLine": 279,
      "functionName": "formatPeriod",
      "diff": "@@ -1,132 +1,131 @@\n     public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n             final TimeZone timezone) {\n-        if(startMillis \u003e endMillis) {\n-            throw new IllegalArgumentException(\"startMillis must not be greater than endMillis\");\n-        }\n+        Validate.isTrue(startMillis \u003c\u003d endMillis, \"startMillis must not be greater than endMillis\");\n+        \n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n         final Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         final Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         final Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months \u003c 0) {\n                 months +\u003d 12;\n                 years -\u003d 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                 while (years !\u003d 0) {\n                     months +\u003d 12 * years;\n                     years \u003d 0;\n                 }\n             }\n         } else {\n             // there are no M\u0027s in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target \u003d end.get(Calendar.YEAR);\n                 if (months \u003c 0) {\n                     // target is end-year -1\n                     target -\u003d 1;\n                 }\n                 \n                 while (start.get(Calendar.YEAR) !\u003d target) {\n                     days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n                     if (start instanceof GregorianCalendar \u0026\u0026\n                             start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n                             start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n                         days +\u003d 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years \u003d 0;\n             }\n             \n             while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months \u003d 0;            \n \n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4b74c385628ed1766209a79705a2d5986c23d02c": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1003: DurationFormatUtils are not able to handle negative duration/periods. Document new behavior for negative inputs.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1592324 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014-05-04, 4:49 a.m.",
      "commitName": "4b74c385628ed1766209a79705a2d5986c23d02c",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2014-05-02, 5:21 a.m.",
      "commitNameOld": "64ef8a80224443c81dfb198cbc567e1b2b9356a2",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 1.98,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n        if(startMillis \u003e endMillis) {\n            throw new IllegalArgumentException(\"startMillis must not be greater than endMillis\");\n        }\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months \u003c 0) {\n                months +\u003d 12;\n                years -\u003d 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                while (years !\u003d 0) {\n                    months +\u003d 12 * years;\n                    years \u003d 0;\n                }\n            }\n        } else {\n            // there are no M\u0027s in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target \u003d end.get(Calendar.YEAR);\n                if (months \u003c 0) {\n                    // target is end-year -1\n                    target -\u003d 1;\n                }\n                \n                while (start.get(Calendar.YEAR) !\u003d target) {\n                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar \u0026\u0026\n                            start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n                            start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n                        days +\u003d 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years \u003d 0;\n            }\n            \n            while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months \u003d 0;            \n\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java",
      "functionStartLine": 281,
      "functionName": "formatPeriod",
      "diff": "@@ -1,132 +1,132 @@\n     public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n             final TimeZone timezone) {\n         if(startMillis \u003e endMillis) {\n-            throw new IllegalArgumentException(\"endMillis must be greater than startMillis\");\n+            throw new IllegalArgumentException(\"startMillis must not be greater than endMillis\");\n         }\n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n         final Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         final Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         final Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months \u003c 0) {\n                 months +\u003d 12;\n                 years -\u003d 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                 while (years !\u003d 0) {\n                     months +\u003d 12 * years;\n                     years \u003d 0;\n                 }\n             }\n         } else {\n             // there are no M\u0027s in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target \u003d end.get(Calendar.YEAR);\n                 if (months \u003c 0) {\n                     // target is end-year -1\n                     target -\u003d 1;\n                 }\n                 \n                 while (start.get(Calendar.YEAR) !\u003d target) {\n                     days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n                     if (start instanceof GregorianCalendar \u0026\u0026\n                             start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n                             start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n                         days +\u003d 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years \u003d 0;\n             }\n             \n             while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months \u003d 0;            \n \n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "64ef8a80224443c81dfb198cbc567e1b2b9356a2": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1003: DurationFormatUtils are not able to handle negative durations/periods. Reported by Michael Osipov.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1591840 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014-05-02, 5:21 a.m.",
      "commitName": "64ef8a80224443c81dfb198cbc567e1b2b9356a2",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2014-04-30, 5:49 p.m.",
      "commitNameOld": "b4b51a8fc9eed7274a045b2f3192d77782b0e4fa",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 1.48,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n        if(startMillis \u003e endMillis) {\n            throw new IllegalArgumentException(\"endMillis must be greater than startMillis\");\n        }\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months \u003c 0) {\n                months +\u003d 12;\n                years -\u003d 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                while (years !\u003d 0) {\n                    months +\u003d 12 * years;\n                    years \u003d 0;\n                }\n            }\n        } else {\n            // there are no M\u0027s in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target \u003d end.get(Calendar.YEAR);\n                if (months \u003c 0) {\n                    // target is end-year -1\n                    target -\u003d 1;\n                }\n                \n                while (start.get(Calendar.YEAR) !\u003d target) {\n                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar \u0026\u0026\n                            start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n                            start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n                        days +\u003d 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years \u003d 0;\n            }\n            \n            while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months \u003d 0;            \n\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java",
      "functionStartLine": 273,
      "functionName": "formatPeriod",
      "diff": "@@ -1,129 +1,132 @@\n     public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n             final TimeZone timezone) {\n+        if(startMillis \u003e endMillis) {\n+            throw new IllegalArgumentException(\"endMillis must be greater than startMillis\");\n+        }\n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n         final Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         final Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         final Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months \u003c 0) {\n                 months +\u003d 12;\n                 years -\u003d 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                 while (years !\u003d 0) {\n                     months +\u003d 12 * years;\n                     years \u003d 0;\n                 }\n             }\n         } else {\n             // there are no M\u0027s in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target \u003d end.get(Calendar.YEAR);\n                 if (months \u003c 0) {\n                     // target is end-year -1\n                     target -\u003d 1;\n                 }\n                 \n                 while (start.get(Calendar.YEAR) !\u003d target) {\n                     days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n                     if (start instanceof GregorianCalendar \u0026\u0026\n                             start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n                             start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n                         days +\u003d 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years \u003d 0;\n             }\n             \n             while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months \u003d 0;            \n \n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f33fba71c5ab38ebff98b5bea9291807c4999483": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses (PMD).\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1455893 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-03-13, 7:41 a.m.",
      "commitName": "f33fba71c5ab38ebff98b5bea9291807c4999483",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013-01-22, 2:09 a.m.",
      "commitNameOld": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 50.19,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months \u003c 0) {\n                months +\u003d 12;\n                years -\u003d 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                while (years !\u003d 0) {\n                    months +\u003d 12 * years;\n                    years \u003d 0;\n                }\n            }\n        } else {\n            // there are no M\u0027s in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target \u003d end.get(Calendar.YEAR);\n                if (months \u003c 0) {\n                    // target is end-year -1\n                    target -\u003d 1;\n                }\n                \n                while (start.get(Calendar.YEAR) !\u003d target) {\n                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar \u0026\u0026\n                            start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n                            start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n                        days +\u003d 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years \u003d 0;\n            }\n            \n            while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months \u003d 0;            \n\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java",
      "functionStartLine": 269,
      "functionName": "formatPeriod",
      "diff": "@@ -1,129 +1,129 @@\n     public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n             final TimeZone timezone) {\n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n         final Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         final Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         final Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months \u003c 0) {\n                 months +\u003d 12;\n                 years -\u003d 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                 while (years !\u003d 0) {\n                     months +\u003d 12 * years;\n                     years \u003d 0;\n                 }\n             }\n         } else {\n             // there are no M\u0027s in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target \u003d end.get(Calendar.YEAR);\n                 if (months \u003c 0) {\n                     // target is end-year -1\n                     target -\u003d 1;\n                 }\n                 \n-                while ( (start.get(Calendar.YEAR) !\u003d target)) {\n+                while (start.get(Calendar.YEAR) !\u003d target) {\n                     days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n                     if (start instanceof GregorianCalendar \u0026\u0026\n                             start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n                             start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n                         days +\u003d 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years \u003d 0;\n             }\n             \n             while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months \u003d 0;            \n \n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5292526e476ffbb19c6613a98464054236c86ace": {
      "type": "Ybodychange",
      "commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-01-22, 2:09 a.m.",
      "commitName": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013-01-22, 2:07 a.m.",
      "commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months \u003c 0) {\n                months +\u003d 12;\n                years -\u003d 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                while (years !\u003d 0) {\n                    months +\u003d 12 * years;\n                    years \u003d 0;\n                }\n            }\n        } else {\n            // there are no M\u0027s in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target \u003d end.get(Calendar.YEAR);\n                if (months \u003c 0) {\n                    // target is end-year -1\n                    target -\u003d 1;\n                }\n                \n                while ( (start.get(Calendar.YEAR) !\u003d target)) {\n                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar \u0026\u0026\n                            start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n                            start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n                        days +\u003d 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years \u003d 0;\n            }\n            \n            while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months \u003d 0;            \n\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java",
      "functionStartLine": 269,
      "functionName": "formatPeriod",
      "diff": "@@ -1,129 +1,129 @@\n     public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n             final TimeZone timezone) {\n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n-        Token[] tokens \u003d lexx(format);\n+        final Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n-        Calendar start \u003d Calendar.getInstance(timezone);\n+        final Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n-        Calendar end \u003d Calendar.getInstance(timezone);\n+        final Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months \u003c 0) {\n                 months +\u003d 12;\n                 years -\u003d 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                 while (years !\u003d 0) {\n                     months +\u003d 12 * years;\n                     years \u003d 0;\n                 }\n             }\n         } else {\n             // there are no M\u0027s in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target \u003d end.get(Calendar.YEAR);\n                 if (months \u003c 0) {\n                     // target is end-year -1\n                     target -\u003d 1;\n                 }\n                 \n                 while ( (start.get(Calendar.YEAR) !\u003d target)) {\n                     days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n                     if (start instanceof GregorianCalendar \u0026\u0026\n                             start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n                             start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n                         days +\u003d 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years \u003d 0;\n             }\n             \n             while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months \u003d 0;            \n \n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": {
      "type": "Yparametermetachange",
      "commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-01-22, 2:07 a.m.",
      "commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2012-09-27, 1:21 p.m.",
      "commitNameOld": "89c64972282f39ecd48b3774963d7a541ca3c0f4",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 116.57,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months \u003c 0) {\n                months +\u003d 12;\n                years -\u003d 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                while (years !\u003d 0) {\n                    months +\u003d 12 * years;\n                    years \u003d 0;\n                }\n            }\n        } else {\n            // there are no M\u0027s in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target \u003d end.get(Calendar.YEAR);\n                if (months \u003c 0) {\n                    // target is end-year -1\n                    target -\u003d 1;\n                }\n                \n                while ( (start.get(Calendar.YEAR) !\u003d target)) {\n                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar \u0026\u0026\n                            start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n                            start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n                        days +\u003d 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years \u003d 0;\n            }\n            \n            while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months \u003d 0;            \n\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java",
      "functionStartLine": 269,
      "functionName": "formatPeriod",
      "diff": "@@ -1,129 +1,129 @@\n-    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n-            TimeZone timezone) {\n+    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n+            final TimeZone timezone) {\n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n         Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months \u003c 0) {\n                 months +\u003d 12;\n                 years -\u003d 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                 while (years !\u003d 0) {\n                     months +\u003d 12 * years;\n                     years \u003d 0;\n                 }\n             }\n         } else {\n             // there are no M\u0027s in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target \u003d end.get(Calendar.YEAR);\n                 if (months \u003c 0) {\n                     // target is end-year -1\n                     target -\u003d 1;\n                 }\n                 \n                 while ( (start.get(Calendar.YEAR) !\u003d target)) {\n                     days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n                     if (start instanceof GregorianCalendar \u0026\u0026\n                             start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n                             start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n                         days +\u003d 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years \u003d 0;\n             }\n             \n             while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months \u003d 0;            \n \n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[startMillis-long, endMillis-long, format-String, padWithZeros-boolean, timezone-TimeZone]",
        "newValue": "[startMillis-long(modifiers-final), endMillis-long(modifiers-final), format-String(modifiers-final), padWithZeros-boolean(modifiers-final), timezone-TimeZone(modifiers-final)]"
      }
    },
    "79cddd4ea5b4fad17f74878e40b3dcd0c54d9cf6": {
      "type": "Ybodychange",
      "commitMessage": "Fix brace positions\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1077921 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-03-04, 7:54 a.m.",
      "commitName": "79cddd4ea5b4fad17f74878e40b3dcd0c54d9cf6",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2010-01-02, 9:11 p.m.",
      "commitNameOld": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 425.45,
      "commitsBetweenForRepo": 413,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months \u003c 0) {\n                months +\u003d 12;\n                years -\u003d 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                while (years !\u003d 0) {\n                    months +\u003d 12 * years;\n                    years \u003d 0;\n                }\n            }\n        } else {\n            // there are no M\u0027s in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target \u003d end.get(Calendar.YEAR);\n                if (months \u003c 0) {\n                    // target is end-year -1\n                    target -\u003d 1;\n                }\n                \n                while ( (start.get(Calendar.YEAR) !\u003d target)) {\n                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar \u0026\u0026\n                            start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n                            start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n                        days +\u003d 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years \u003d 0;\n            }\n            \n            while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months \u003d 0;            \n\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java",
      "functionStartLine": 274,
      "functionName": "formatPeriod",
      "diff": "@@ -1,131 +1,129 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n         Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months \u003c 0) {\n                 months +\u003d 12;\n                 years -\u003d 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                 while (years !\u003d 0) {\n                     months +\u003d 12 * years;\n                     years \u003d 0;\n                 }\n             }\n         } else {\n             // there are no M\u0027s in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target \u003d end.get(Calendar.YEAR);\n                 if (months \u003c 0) {\n                     // target is end-year -1\n                     target -\u003d 1;\n                 }\n                 \n                 while ( (start.get(Calendar.YEAR) !\u003d target)) {\n                     days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n-                    if(start instanceof GregorianCalendar) {\n-                        if( (start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY) \u0026\u0026\n-                            (start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29 ) )\n-                        {\n-                            days +\u003d 1;\n-                        }\n+                    if (start instanceof GregorianCalendar \u0026\u0026\n+                            start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY \u0026\u0026\n+                            start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29) {\n+                        days +\u003d 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years \u003d 0;\n             }\n             \n             while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months \u003d 0;            \n \n             while (days \u003c 0) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -\u003d 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-01-02, 9:11 p.m.",
      "commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "2010-01-02, 9:09 p.m.",
      "commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months \u003c 0) {\n                months +\u003d 12;\n                years -\u003d 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                while (years !\u003d 0) {\n                    months +\u003d 12 * years;\n                    years \u003d 0;\n                }\n            }\n        } else {\n            // there are no M\u0027s in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target \u003d end.get(Calendar.YEAR);\n                if (months \u003c 0) {\n                    // target is end-year -1\n                    target -\u003d 1;\n                }\n                \n                while ( (start.get(Calendar.YEAR) !\u003d target)) {\n                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if(start instanceof GregorianCalendar) {\n                        if( (start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY) \u0026\u0026\n                            (start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29 ) )\n                        {\n                            days +\u003d 1;\n                        }\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years \u003d 0;\n            }\n            \n            while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months \u003d 0;            \n\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java",
      "functionStartLine": 274,
      "functionName": "formatPeriod",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/time/DurationFormatUtils.java",
        "newPath": "src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java"
      }
    },
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-12-10, 6:33 a.m.",
      "commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009-12-10, 6:31 a.m.",
      "commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months \u003c 0) {\n                months +\u003d 12;\n                years -\u003d 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                while (years !\u003d 0) {\n                    months +\u003d 12 * years;\n                    years \u003d 0;\n                }\n            }\n        } else {\n            // there are no M\u0027s in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target \u003d end.get(Calendar.YEAR);\n                if (months \u003c 0) {\n                    // target is end-year -1\n                    target -\u003d 1;\n                }\n                \n                while ( (start.get(Calendar.YEAR) !\u003d target)) {\n                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if(start instanceof GregorianCalendar) {\n                        if( (start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY) \u0026\u0026\n                            (start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29 ) )\n                        {\n                            days +\u003d 1;\n                        }\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years \u003d 0;\n            }\n            \n            while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months \u003d 0;            \n\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/java/org/apache/commons/lang3/time/DurationFormatUtils.java",
      "functionStartLine": 274,
      "functionName": "formatPeriod",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
        "newPath": "src/java/org/apache/commons/lang3/time/DurationFormatUtils.java"
      }
    },
    "4f514d5eb3e80703012df9be190ae42d35d25bdc": {
      "type": "Ybodychange",
      "commitMessage": "More tests, more bugfixes (aka rewrite of the guts). \n\nIt\u0027s looking much better, the only edge case that throws it for a loop is if things start on the 29th of February in a year. I\u0027ve hacked it in the day mode, but I\u0027m not sure why I had to do that - however I trust the brute force test to be right in day mode. \nIn month mode, it\u0027s even trickier as to what the correct answer is. How many months between 29th Feb and 28th of Feb the next year? The answer is 11, or with days included it\u0027s 11 months and 28 days. I can\u0027t see any reason to define that better, so I\u0027m declaring that law. \n\nThings are weird if you start on Feb 29 :)\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@488926 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-12-20, 1:10 a.m.",
      "commitName": "4f514d5eb3e80703012df9be190ae42d35d25bdc",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006-12-19, 6:59 p.m.",
      "commitNameOld": "93aa88fded0cb63a8634cf8021cb889bc38505bf",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months \u003c 0) {\n                months +\u003d 12;\n                years -\u003d 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n                while (years !\u003d 0) {\n                    months +\u003d 12 * years;\n                    years \u003d 0;\n                }\n            }\n        } else {\n            // there are no M\u0027s in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target \u003d end.get(Calendar.YEAR);\n                if (months \u003c 0) {\n                    // target is end-year -1\n                    target -\u003d 1;\n                }\n                \n                while ( (start.get(Calendar.YEAR) !\u003d target)) {\n                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if(start instanceof GregorianCalendar) {\n                        if( (start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY) \u0026\u0026\n                            (start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29 ) )\n                        {\n                            days +\u003d 1;\n                        }\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days +\u003d start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years \u003d 0;\n            }\n            \n            while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months \u003d 0;            \n\n            while (days \u003c 0) {\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -\u003d 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
      "functionStartLine": 273,
      "functionName": "formatPeriod",
      "diff": "@@ -1,123 +1,131 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n-        long millis \u003d endMillis - startMillis;\n-        if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n-            return formatDuration(millis, format, padWithZeros);\n-        }\n-\n+        // Used to optimise for differences under 28 days and \n+        // called formatDuration(millis, format); however this did not work \n+        // over leap years. \n+        // TODO: Compare performance to see if anything was lost by \n+        // losing this optimisation. \n+        \n         Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n-        // TODO: Create a test to see if this should be while. ie) one that makes hours above \n-        //       overflow and pushes this above the maximum # of days in a month?\n-        int leapDays \u003d 0;\n-        if (days \u003c 0) {\n-            days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n-            // Multiple answers possible. \n-            // For example, for Jan 15th to March 10th. If I count days-first it is \n-            // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-            // Here we choose the former. \n-            months -\u003d 1;\n-            start.add(Calendar.MONTH, 1);\n-        }\n-        while (months \u003c 0) {\n-            months +\u003d 12;\n-            years -\u003d 1;\n-            if (start instanceof GregorianCalendar) {\n-                if ( ((GregorianCalendar) start).isLeapYear(start.get(Calendar.YEAR) + 1) \u0026\u0026\n-                     ( end.get(Calendar.MONTH) \u003e 1) )  \n-                {\n-                    leapDays +\u003d 1;\n-                }\n+       \n+        if (Token.containsTokenWithValue(tokens, M)) {\n+            while (days \u003c 0) {\n+                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                months -\u003d 1;\n+                start.add(Calendar.MONTH, 1);\n             }\n-            if (end instanceof GregorianCalendar) {\n-                if ( ((GregorianCalendar) end).isLeapYear(end.get(Calendar.YEAR)) \u0026\u0026\n-                     ( end.get(Calendar.MONTH) \u003c 1) )  \n-                {\n-                    leapDays -\u003d 1;\n-                }\n-            }\n-            start.add(Calendar.YEAR, 1);\n-        }\n \n-        // This rest of this code adds in values that \n-        // aren\u0027t requested. This allows the user to ask for the \n-        // number of months and get the real count and not just 0-\u003e11.\n-        \n-        if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n-            if (Token.containsTokenWithValue(tokens, M)) {\n-                months +\u003d 12 * years;\n-                years \u003d 0;\n-            } else {\n-                while ( (start.get(Calendar.YEAR) !\u003d end.get(Calendar.YEAR))) {\n-                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR);\n-                    start.add(Calendar.YEAR, 1);\n+            while (months \u003c 0) {\n+                months +\u003d 12;\n+                years -\u003d 1;\n+            }\n+\n+            if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n+                while (years !\u003d 0) {\n+                    months +\u003d 12 * years;\n+                    years \u003d 0;\n                 }\n+            }\n+        } else {\n+            // there are no M\u0027s in the format string\n+\n+            if( !Token.containsTokenWithValue(tokens, y) ) {\n+                int target \u003d end.get(Calendar.YEAR);\n+                if (months \u003c 0) {\n+                    // target is end-year -1\n+                    target -\u003d 1;\n+                }\n+                \n+                while ( (start.get(Calendar.YEAR) !\u003d target)) {\n+                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+                    \n+                    // Not sure I grok why this is needed, but the brutal tests show it is\n+                    if(start instanceof GregorianCalendar) {\n+                        if( (start.get(Calendar.MONTH) \u003d\u003d Calendar.FEBRUARY) \u0026\u0026\n+                            (start.get(Calendar.DAY_OF_MONTH) \u003d\u003d 29 ) )\n+                        {\n+                            days +\u003d 1;\n+                        }\n+                    }\n+                    \n+                    start.add(Calendar.YEAR, 1);\n+                    \n+                    days +\u003d start.get(Calendar.DAY_OF_YEAR);\n+                }\n+                \n                 years \u003d 0;\n             }\n-        }\n-        start.set(Calendar.YEAR, end.get(Calendar.YEAR));\n-                \n-        if (!Token.containsTokenWithValue(tokens, M) \u0026\u0026 months !\u003d 0) {   \n-            while(start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH)) {\n-                String date \u003d start.getTime().toString();\n+            \n+            while( start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH) ) {\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n-            days +\u003d leapDays;\n+            \n             months \u003d 0;            \n+\n+            while (days \u003c 0) {\n+                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                months -\u003d 1;\n+                start.add(Calendar.MONTH, 1);\n+            }\n+            \n         }\n-        start.set(Calendar.MONTH, end.get(Calendar.MONTH));\n+\n+        // The rest of this code adds in values that \n+        // aren\u0027t requested. This allows the user to ask for the \n+        // number of months and get the real count and not just 0-\u003e11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "93aa88fded0cb63a8634cf8021cb889bc38505bf": {
      "type": "Ybodychange",
      "commitMessage": "Updated comment\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@488858 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-12-19, 6:59 p.m.",
      "commitName": "93aa88fded0cb63a8634cf8021cb889bc38505bf",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006-12-13, 2:12 a.m.",
      "commitNameOld": "868dd284443b6f950a2f360b0422dbf09a599ae9",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 6.7,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis \u003d endMillis - startMillis;\n        if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n        // TODO: Create a test to see if this should be while. ie) one that makes hours above \n        //       overflow and pushes this above the maximum # of days in a month?\n        int leapDays \u003d 0;\n        if (days \u003c 0) {\n            days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n            // Multiple answers possible. \n            // For example, for Jan 15th to March 10th. If I count days-first it is \n            // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n            // Here we choose the former. \n            months -\u003d 1;\n            start.add(Calendar.MONTH, 1);\n        }\n        while (months \u003c 0) {\n            months +\u003d 12;\n            years -\u003d 1;\n            if (start instanceof GregorianCalendar) {\n                if ( ((GregorianCalendar) start).isLeapYear(start.get(Calendar.YEAR) + 1) \u0026\u0026\n                     ( end.get(Calendar.MONTH) \u003e 1) )  \n                {\n                    leapDays +\u003d 1;\n                }\n            }\n            if (end instanceof GregorianCalendar) {\n                if ( ((GregorianCalendar) end).isLeapYear(end.get(Calendar.YEAR)) \u0026\u0026\n                     ( end.get(Calendar.MONTH) \u003c 1) )  \n                {\n                    leapDays -\u003d 1;\n                }\n            }\n            start.add(Calendar.YEAR, 1);\n        }\n\n        // This rest of this code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n        \n        if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months +\u003d 12 * years;\n                years \u003d 0;\n            } else {\n                while ( (start.get(Calendar.YEAR) !\u003d end.get(Calendar.YEAR))) {\n                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR);\n                    start.add(Calendar.YEAR, 1);\n                }\n                years \u003d 0;\n            }\n        }\n        start.set(Calendar.YEAR, end.get(Calendar.YEAR));\n                \n        if (!Token.containsTokenWithValue(tokens, M) \u0026\u0026 months !\u003d 0) {   \n            while(start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH)) {\n                String date \u003d start.getTime().toString();\n                days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            days +\u003d leapDays;\n            months \u003d 0;            \n        }\n        start.set(Calendar.MONTH, end.get(Calendar.MONTH));\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
      "functionStartLine": 273,
      "functionName": "formatPeriod",
      "diff": "@@ -1,124 +1,123 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         long millis \u003d endMillis - startMillis;\n         if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n             return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n         // TODO: Create a test to see if this should be while. ie) one that makes hours above \n         //       overflow and pushes this above the maximum # of days in a month?\n         int leapDays \u003d 0;\n         if (days \u003c 0) {\n             days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n-            // It\u0027s a tricky subject. Jan 15th to March 10th. If I count days-first it is \n+            // Multiple answers possible. \n+            // For example, for Jan 15th to March 10th. If I count days-first it is \n             // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n             // Here we choose the former. \n-            // Also it\u0027s contextual - if asked for no M in the format then I should probably \n-            // be doing no calculating here.\n             months -\u003d 1;\n             start.add(Calendar.MONTH, 1);\n         }\n         while (months \u003c 0) {\n             months +\u003d 12;\n             years -\u003d 1;\n             if (start instanceof GregorianCalendar) {\n                 if ( ((GregorianCalendar) start).isLeapYear(start.get(Calendar.YEAR) + 1) \u0026\u0026\n                      ( end.get(Calendar.MONTH) \u003e 1) )  \n                 {\n                     leapDays +\u003d 1;\n                 }\n             }\n             if (end instanceof GregorianCalendar) {\n                 if ( ((GregorianCalendar) end).isLeapYear(end.get(Calendar.YEAR)) \u0026\u0026\n                      ( end.get(Calendar.MONTH) \u003c 1) )  \n                 {\n                     leapDays -\u003d 1;\n                 }\n             }\n             start.add(Calendar.YEAR, 1);\n         }\n \n         // This rest of this code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n         \n         if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n             if (Token.containsTokenWithValue(tokens, M)) {\n                 months +\u003d 12 * years;\n                 years \u003d 0;\n             } else {\n                 while ( (start.get(Calendar.YEAR) !\u003d end.get(Calendar.YEAR))) {\n                     days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR);\n                     start.add(Calendar.YEAR, 1);\n                 }\n                 years \u003d 0;\n             }\n         }\n         start.set(Calendar.YEAR, end.get(Calendar.YEAR));\n                 \n         if (!Token.containsTokenWithValue(tokens, M) \u0026\u0026 months !\u003d 0) {   \n             while(start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH)) {\n                 String date \u003d start.getTime().toString();\n                 days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             days +\u003d leapDays;\n             months \u003d 0;            \n         }\n         start.set(Calendar.MONTH, end.get(Calendar.MONTH));\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dd23ae863a8910581362b69c660b26d8e8f699b7": {
      "type": "Ybodychange",
      "commitMessage": "More unit tests and bugfixes. The currently failing test is commented out, so more bugfixes to come.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@486523 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-12-13, 2:09 a.m.",
      "commitName": "dd23ae863a8910581362b69c660b26d8e8f699b7",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006-12-10, 10:33 p.m.",
      "commitNameOld": "5fb6521ab990c0c9ec655ca71d8c77060aedb0e5",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 2.15,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis \u003d endMillis - startMillis;\n        if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n        // TODO: Create a test to see if this should be while. ie) one that makes hours above \n        //       overflow and pushes this above the maximum # of days in a month?\n        int leapDays \u003d 0;\n        if (days \u003c 0) {\n            days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n            // It\u0027s a tricky subject. Jan 15th to March 10th. If I count days-first it is \n            // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n            // Here we choose the former. \n            // Also it\u0027s contextual - if asked for no M in the format then I should probably \n            // be doing no calculating here.\n            months -\u003d 1;\n            start.add(Calendar.MONTH, 1);\n        }\n        while (months \u003c 0) {\n            months +\u003d 12;\n            years -\u003d 1;\n            if (start instanceof GregorianCalendar) {\n                if ( ((GregorianCalendar) start).isLeapYear(start.get(Calendar.YEAR) + 1) \u0026\u0026\n                     ( end.get(Calendar.MONTH) \u003e 1) )  \n                {\n                    leapDays +\u003d 1;\n                }\n            }\n            if (end instanceof GregorianCalendar) {\n                if ( ((GregorianCalendar) end).isLeapYear(end.get(Calendar.YEAR)) \u0026\u0026\n                     ( end.get(Calendar.MONTH) \u003c 1) )  \n                {\n                    leapDays -\u003d 1;\n                }\n            }\n            start.add(Calendar.YEAR, 1);\n        }\n\n        // This rest of this code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n        \n        if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months +\u003d 12 * years;\n                years \u003d 0;\n            } else {\n            \twhile ( (start.get(Calendar.YEAR) !\u003d end.get(Calendar.YEAR))) {\n                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR);\n                    start.add(Calendar.YEAR, 1);\n            \t}\n                years \u003d 0;\n            }\n        }\n        start.set(Calendar.YEAR, end.get(Calendar.YEAR));\n                \n        if (!Token.containsTokenWithValue(tokens, M) \u0026\u0026 months !\u003d 0) {   \n            while(start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH)) {\n        \tString date \u003d start.getTime().toString();\n        \tdays +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n        \tstart.add(Calendar.MONTH, 1);\n            }\n            days +\u003d leapDays;\n            months \u003d 0;            \n        }\n        start.set(Calendar.MONTH, end.get(Calendar.MONTH));\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
      "functionStartLine": 273,
      "functionName": "formatPeriod",
      "diff": "@@ -1,106 +1,124 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         long millis \u003d endMillis - startMillis;\n         if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n             return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n+        // TODO: Create a test to see if this should be while. ie) one that makes hours above \n+        //       overflow and pushes this above the maximum # of days in a month?\n+        int leapDays \u003d 0;\n         if (days \u003c 0) {\n             days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n             // It\u0027s a tricky subject. Jan 15th to March 10th. If I count days-first it is \n             // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n             // Here we choose the former. \n             // Also it\u0027s contextual - if asked for no M in the format then I should probably \n             // be doing no calculating here.\n             months -\u003d 1;\n+            start.add(Calendar.MONTH, 1);\n         }\n         while (months \u003c 0) {\n             months +\u003d 12;\n             years -\u003d 1;\n+            if (start instanceof GregorianCalendar) {\n+                if ( ((GregorianCalendar) start).isLeapYear(start.get(Calendar.YEAR) + 1) \u0026\u0026\n+                     ( end.get(Calendar.MONTH) \u003e 1) )  \n+                {\n+                    leapDays +\u003d 1;\n+                }\n+            }\n+            if (end instanceof GregorianCalendar) {\n+                if ( ((GregorianCalendar) end).isLeapYear(end.get(Calendar.YEAR)) \u0026\u0026\n+                     ( end.get(Calendar.MONTH) \u003c 1) )  \n+                {\n+                    leapDays -\u003d 1;\n+                }\n+            }\n             start.add(Calendar.YEAR, 1);\n         }\n \n         // This rest of this code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n         \n-        if (!Token.containsTokenWithValue(tokens, y)) {\n+        if (!Token.containsTokenWithValue(tokens, y) \u0026\u0026 years !\u003d 0) {\n             if (Token.containsTokenWithValue(tokens, M)) {\n                 months +\u003d 12 * years;\n                 years \u003d 0;\n             } else {\n-            \twhile(start.get(Calendar.YEAR) !\u003d end.get(Calendar.YEAR)) {\n-            \t\tdays +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR);\n-            \t\tstart.add(Calendar.YEAR, 1);\n+            \twhile ( (start.get(Calendar.YEAR) !\u003d end.get(Calendar.YEAR))) {\n+                    days +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR);\n+                    start.add(Calendar.YEAR, 1);\n             \t}\n                 years \u003d 0;\n             }\n         }\n+        start.set(Calendar.YEAR, end.get(Calendar.YEAR));\n                 \n-        if (!Token.containsTokenWithValue(tokens, M) \u0026\u0026 months !\u003d 0) {\n-        \tstart.set(start.get(Calendar.YEAR), start.get(Calendar.MONTH), 0, 0, 0, 0);\n+        if (!Token.containsTokenWithValue(tokens, M) \u0026\u0026 months !\u003d 0) {   \n+            while(start.get(Calendar.MONTH) !\u003d end.get(Calendar.MONTH)) {\n+        \tString date \u003d start.getTime().toString();\n+        \tdays +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n         \tstart.add(Calendar.MONTH, 1);\n-        \tend.set(end.get(Calendar.YEAR), end.get(Calendar.MONTH), 0, 0, 0, 0);\n-            days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n-            months \u003d 0;\n-            \n-        \t// WARNING: For performance sake the Calendar instances are not being \n-        \t// cloned but modified inline. They should not be trusted after this point\n-            start \u003d null;\n-            end \u003d null;\n+            }\n+            days +\u003d leapDays;\n+            months \u003d 0;            \n         }\n+        start.set(Calendar.MONTH, end.get(Calendar.MONTH));\n+\n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5fb6521ab990c0c9ec655ca71d8c77060aedb0e5": {
      "type": "Ybodychange",
      "commitMessage": "More tests added to DurationFormatUtilsTest and discovered bugs fixed in the DurationFormatUtils.formatPeriod method. \n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@485481 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-12-10, 10:33 p.m.",
      "commitName": "5fb6521ab990c0c9ec655ca71d8c77060aedb0e5",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006-12-08, 4:05 a.m.",
      "commitNameOld": "ee4ad2727fcfb949e258e0f215a79d56ea41a173",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 2.77,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis \u003d endMillis - startMillis;\n        if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n        if (days \u003c 0) {\n            days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n            // It\u0027s a tricky subject. Jan 15th to March 10th. If I count days-first it is \n            // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n            // Here we choose the former. \n            // Also it\u0027s contextual - if asked for no M in the format then I should probably \n            // be doing no calculating here.\n            months -\u003d 1;\n        }\n        while (months \u003c 0) {\n            months +\u003d 12;\n            years -\u003d 1;\n            start.add(Calendar.YEAR, 1);\n        }\n\n        // This rest of this code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n        \n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months +\u003d 12 * years;\n                years \u003d 0;\n            } else {\n            \twhile(start.get(Calendar.YEAR) !\u003d end.get(Calendar.YEAR)) {\n            \t\tdays +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR);\n            \t\tstart.add(Calendar.YEAR, 1);\n            \t}\n                years \u003d 0;\n            }\n        }\n                \n        if (!Token.containsTokenWithValue(tokens, M) \u0026\u0026 months !\u003d 0) {\n        \tstart.set(start.get(Calendar.YEAR), start.get(Calendar.MONTH), 0, 0, 0, 0);\n        \tstart.add(Calendar.MONTH, 1);\n        \tend.set(end.get(Calendar.YEAR), end.get(Calendar.MONTH), 0, 0, 0, 0);\n            days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months \u003d 0;\n            \n        \t// WARNING: For performance sake the Calendar instances are not being \n        \t// cloned but modified inline. They should not be trusted after this point\n            start \u003d null;\n            end \u003d null;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
      "functionStartLine": 272,
      "functionName": "formatPeriod",
      "diff": "@@ -1,94 +1,106 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         long millis \u003d endMillis - startMillis;\n         if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n             return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n-        while (days \u003c 0) {\n-            end.add(Calendar.MONTH, -1);\n-            days +\u003d end.getActualMaximum(Calendar.DAY_OF_MONTH);\n-            // HEN: It\u0027s a tricky subject. Jan 15th to March 10th. If I count days-first it is \n+        if (days \u003c 0) {\n+            days +\u003d start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+            // It\u0027s a tricky subject. Jan 15th to March 10th. If I count days-first it is \n             // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n+            // Here we choose the former. \n             // Also it\u0027s contextual - if asked for no M in the format then I should probably \n             // be doing no calculating here.\n             months -\u003d 1;\n-            end.add(Calendar.MONTH, 1);\n         }\n         while (months \u003c 0) {\n             months +\u003d 12;\n             years -\u003d 1;\n+            start.add(Calendar.YEAR, 1);\n         }\n \n-        // This next block of code adds in values that \n+        // This rest of this code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n+        \n         if (!Token.containsTokenWithValue(tokens, y)) {\n             if (Token.containsTokenWithValue(tokens, M)) {\n                 months +\u003d 12 * years;\n                 years \u003d 0;\n             } else {\n-                // TODO: this is a bit weak, needs work to know about leap years\n-                days +\u003d 365 * years;\n+            \twhile(start.get(Calendar.YEAR) !\u003d end.get(Calendar.YEAR)) {\n+            \t\tdays +\u003d start.getActualMaximum(Calendar.DAY_OF_YEAR);\n+            \t\tstart.add(Calendar.YEAR, 1);\n+            \t}\n                 years \u003d 0;\n             }\n         }\n-        if (!Token.containsTokenWithValue(tokens, M)) {\n+                \n+        if (!Token.containsTokenWithValue(tokens, M) \u0026\u0026 months !\u003d 0) {\n+        \tstart.set(start.get(Calendar.YEAR), start.get(Calendar.MONTH), 0, 0, 0, 0);\n+        \tstart.add(Calendar.MONTH, 1);\n+        \tend.set(end.get(Calendar.YEAR), end.get(Calendar.MONTH), 0, 0, 0, 0);\n             days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months \u003d 0;\n+            \n+        \t// WARNING: For performance sake the Calendar instances are not being \n+        \t// cloned but modified inline. They should not be trusted after this point\n+            start \u003d null;\n+            end \u003d null;\n         }\n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ee4ad2727fcfb949e258e0f215a79d56ea41a173": {
      "type": "Ybodychange",
      "commitMessage": "Added javadoc to explain the quandry in how to count month/day differences\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@483891 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-12-08, 4:05 a.m.",
      "commitName": "ee4ad2727fcfb949e258e0f215a79d56ea41a173",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006-11-05, 11:02 p.m.",
      "commitNameOld": "d8a6e05b5f23458ddd57ad838f43936520689ff7",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 32.21,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis \u003d endMillis - startMillis;\n        if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n        while (days \u003c 0) {\n            end.add(Calendar.MONTH, -1);\n            days +\u003d end.getActualMaximum(Calendar.DAY_OF_MONTH);\n            // HEN: It\u0027s a tricky subject. Jan 15th to March 10th. If I count days-first it is \n            // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n            // Also it\u0027s contextual - if asked for no M in the format then I should probably \n            // be doing no calculating here.\n            months -\u003d 1;\n            end.add(Calendar.MONTH, 1);\n        }\n        while (months \u003c 0) {\n            months +\u003d 12;\n            years -\u003d 1;\n        }\n\n        // This next block of code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months +\u003d 12 * years;\n                years \u003d 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days +\u003d 365 * years;\n                years \u003d 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
      "functionStartLine": 272,
      "functionName": "formatPeriod",
      "diff": "@@ -1,95 +1,94 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         long millis \u003d endMillis - startMillis;\n         if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n             return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n         while (days \u003c 0) {\n             end.add(Calendar.MONTH, -1);\n             days +\u003d end.getActualMaximum(Calendar.DAY_OF_MONTH);\n-//days +\u003d 31; // TODO: Need tests to show this is bad and the new code is good.\n-// HEN: It\u0027s a tricky subject. Jan 15th to March 10th. If I count days-first it is \n-// 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-// Also it\u0027s contextual - if asked for no M in the format then I should probably \n-// be doing no calculating here.\n+            // HEN: It\u0027s a tricky subject. Jan 15th to March 10th. If I count days-first it is \n+            // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n+            // Also it\u0027s contextual - if asked for no M in the format then I should probably \n+            // be doing no calculating here.\n             months -\u003d 1;\n             end.add(Calendar.MONTH, 1);\n         }\n         while (months \u003c 0) {\n             months +\u003d 12;\n             years -\u003d 1;\n         }\n \n         // This next block of code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n         if (!Token.containsTokenWithValue(tokens, y)) {\n             if (Token.containsTokenWithValue(tokens, M)) {\n                 months +\u003d 12 * years;\n                 years \u003d 0;\n             } else {\n                 // TODO: this is a bit weak, needs work to know about leap years\n                 days +\u003d 365 * years;\n                 years \u003d 0;\n             }\n         }\n         if (!Token.containsTokenWithValue(tokens, M)) {\n             days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1d5c03fac601d6ce291c3fe3e5e51a11881e2fc0": {
      "type": "Ybodychange",
      "commitMessage": "Adding a unit test for #LANG-281 and a fix. The fix involves removing the reduceAndCorrect method. It appears that this method was doing sod all - which is worrying as it used to be important. I\u0027m guessing that it was a bad fix for a bug that was then subsequently fixed with other code. I\u0027ll create a JIRA issue to create more tests to test out the +31 block of code. \n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@453818 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-10-06, 8:22 p.m.",
      "commitName": "1d5c03fac601d6ce291c3fe3e5e51a11881e2fc0",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006-08-28, 2:21 a.m.",
      "commitNameOld": "a5a4f9067a0b22e629463b1ef059818ccda6f37e",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 39.75,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis \u003d endMillis - startMillis;\n        if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n        while (days \u003c 0) {\n            end.add(Calendar.MONTH, -1);\n            days +\u003d end.getActualMaximum(Calendar.DAY_OF_MONTH);\n//days +\u003d 31; // TODO: Need tests to show this is bad and the new code is good.\n// HEN: It\u0027s a tricky subject. Jan 15th to March 10th. If I count days-first it is \n// 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n// Also it\u0027s contextual - if asked for no M in the format then I should probably \n// be doing no calculating here.\n            months -\u003d 1;\n            end.add(Calendar.MONTH, 1);\n        }\n        while (months \u003c 0) {\n            months +\u003d 12;\n            years -\u003d 1;\n        }\n\n        // This next block of code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months +\u003d 12 * years;\n                years \u003d 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days +\u003d 365 * years;\n                years \u003d 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
      "functionStartLine": 262,
      "functionName": "formatPeriod",
      "diff": "@@ -1,97 +1,95 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         long millis \u003d endMillis - startMillis;\n         if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n             return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n         while (days \u003c 0) {\n-            days +\u003d 31; // such overshooting is taken care of later on\n+            end.add(Calendar.MONTH, -1);\n+            days +\u003d end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+//days +\u003d 31; // TODO: Need tests to show this is bad and the new code is good.\n+// HEN: It\u0027s a tricky subject. Jan 15th to March 10th. If I count days-first it is \n+// 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n+// Also it\u0027s contextual - if asked for no M in the format then I should probably \n+// be doing no calculating here.\n             months -\u003d 1;\n+            end.add(Calendar.MONTH, 1);\n         }\n         while (months \u003c 0) {\n             months +\u003d 12;\n             years -\u003d 1;\n         }\n \n-        // take estimates off of end to see if we can equal start, when it overshoots recalculate\n-        milliseconds -\u003d reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n-        seconds -\u003d reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n-        minutes -\u003d reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n-        hours -\u003d reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n-        days -\u003d reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n-        months -\u003d reduceAndCorrect(start, end, Calendar.MONTH, months);\n-        years -\u003d reduceAndCorrect(start, end, Calendar.YEAR, years);\n-\n         // This next block of code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n         if (!Token.containsTokenWithValue(tokens, y)) {\n             if (Token.containsTokenWithValue(tokens, M)) {\n                 months +\u003d 12 * years;\n                 years \u003d 0;\n             } else {\n                 // TODO: this is a bit weak, needs work to know about leap years\n                 days +\u003d 365 * years;\n                 years \u003d 0;\n             }\n         }\n         if (!Token.containsTokenWithValue(tokens, M)) {\n             days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b7d3fd9e4d435eb155570f326e8c799ead6c1901": {
      "type": "Ybodychange",
      "commitMessage": "Committing fix for LANG-140. By reversing the order of field calculation, Yu Peng\u0027s bug goes away\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@415317 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-06-19, 8:48 a.m.",
      "commitName": "b7d3fd9e4d435eb155570f326e8c799ead6c1901",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006-03-06, 2:18 a.m.",
      "commitNameOld": "9f4f79fe3fab819d45ded49b74773731705a0a6f",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 105.23,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis \u003d endMillis - startMillis;\n        if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n        while (days \u003c 0) {\n            days +\u003d 31; // such overshooting is taken care of later on\n            months -\u003d 1;\n        }\n        while (months \u003c 0) {\n            months +\u003d 12;\n            years -\u003d 1;\n        }\n\n        // take estimates off of end to see if we can equal start, when it overshoots recalculate\n        milliseconds -\u003d reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -\u003d reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -\u003d reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -\u003d reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -\u003d reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -\u003d reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -\u003d reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        // This next block of code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months +\u003d 12 * years;\n                years \u003d 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days +\u003d 365 * years;\n                years \u003d 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
      "functionStartLine": 261,
      "functionName": "formatPeriod",
      "diff": "@@ -1,96 +1,97 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         long millis \u003d endMillis - startMillis;\n         if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n             return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n-        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n-        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n-        // each initial estimate is adjusted in case it is under 0\n-        while (months \u003c 0) {\n-            months +\u003d 12;\n-            years -\u003d 1;\n-        }\n-        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n-        while (days \u003c 0) {\n-            days +\u003d 31; // such overshooting is taken care of later on\n-            months -\u003d 1;\n-        }\n-        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n-        while (hours \u003c 0) {\n-            hours +\u003d 24;\n-            days -\u003d 1;\n-        }\n-        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n-        while (minutes \u003c 0) {\n-            minutes +\u003d 60;\n-            hours -\u003d 1;\n-        }\n+        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n+        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n+        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n+        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n+        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n+        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n+\n+        // each initial estimate is adjusted in case it is under 0\n+        while (milliseconds \u003c 0) {\n+            milliseconds +\u003d 1000;\n+            seconds -\u003d 1;\n+        }\n         while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n-        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n-        while (milliseconds \u003c 0) {\n-            milliseconds +\u003d 1000;\n-            seconds -\u003d 1;\n+        while (minutes \u003c 0) {\n+            minutes +\u003d 60;\n+            hours -\u003d 1;\n+        }\n+        while (hours \u003c 0) {\n+            hours +\u003d 24;\n+            days -\u003d 1;\n+        }\n+        while (days \u003c 0) {\n+            days +\u003d 31; // such overshooting is taken care of later on\n+            months -\u003d 1;\n+        }\n+        while (months \u003c 0) {\n+            months +\u003d 12;\n+            years -\u003d 1;\n         }\n \n         // take estimates off of end to see if we can equal start, when it overshoots recalculate\n         milliseconds -\u003d reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n         seconds -\u003d reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n         minutes -\u003d reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n         hours -\u003d reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n         days -\u003d reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n         months -\u003d reduceAndCorrect(start, end, Calendar.MONTH, months);\n         years -\u003d reduceAndCorrect(start, end, Calendar.YEAR, years);\n \n         // This next block of code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n         if (!Token.containsTokenWithValue(tokens, y)) {\n             if (Token.containsTokenWithValue(tokens, M)) {\n                 months +\u003d 12 * years;\n                 years \u003d 0;\n             } else {\n                 // TODO: this is a bit weak, needs work to know about leap years\n                 days +\u003d 365 * years;\n                 years \u003d 0;\n             }\n         }\n         if (!Token.containsTokenWithValue(tokens, M)) {\n             days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5111ae7db08a70323a51a21df0bbaf46f21e072e": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "Rework DurationFormatUtils to have clearer API based on two types of formatting\nFix millisecond formatting bug\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137977 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004-10-15, 7:11 p.m.",
      "commitName": "5111ae7db08a70323a51a21df0bbaf46f21e072e",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "Rework DurationFormatUtils to have clearer API based on two types of formatting\nFix millisecond formatting bug\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137977 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004-10-15, 7:11 p.m.",
          "commitName": "5111ae7db08a70323a51a21df0bbaf46f21e072e",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2004-10-01, 9:40 p.m.",
          "commitNameOld": "dd2a1841fc7c9c95af1ce1e6ed3ed0ee3587df19",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 13.9,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n\n        long millis \u003d endMillis - startMillis;\n        if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        // each initial estimate is adjusted in case it is under 0\n        while (months \u003c 0) {\n            months +\u003d 12;\n            years -\u003d 1;\n        }\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        while (days \u003c 0) {\n            days +\u003d 31; // such overshooting is taken care of later on\n            months -\u003d 1;\n        }\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n\n        // take estimates off of end to see if we can equal start, when it overshoots recalculate\n        milliseconds -\u003d reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -\u003d reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -\u003d reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -\u003d reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -\u003d reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -\u003d reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -\u003d reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        // This next block of code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months +\u003d 12 * years;\n                years \u003d 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days +\u003d 365 * years;\n                years \u003d 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
          "functionStartLine": 259,
          "functionName": "formatPeriod",
          "diff": "@@ -1,95 +1,95 @@\n-    public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n+    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n \n         long millis \u003d endMillis - startMillis;\n-        if(millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n-            return format(millis, format, padWithZeros, timezone);\n+        if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n+            return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         // each initial estimate is adjusted in case it is under 0\n-        while(months \u003c 0) {\n+        while (months \u003c 0) {\n             months +\u003d 12;\n             years -\u003d 1;\n         }\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n-        while(days \u003c 0) {\n-            days +\u003d 31;  // such overshooting is taken care of later on\n+        while (days \u003c 0) {\n+            days +\u003d 31; // such overshooting is taken care of later on\n             months -\u003d 1;\n         }\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n-        while(hours \u003c 0) {\n+        while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n-        while(minutes \u003c 0) {\n+        while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n-        while(seconds \u003c 0) {\n+        while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n-        while(milliseconds \u003c 0) {\n+        while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n \n         // take estimates off of end to see if we can equal start, when it overshoots recalculate\n-        milliseconds -\u003d reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n-        seconds -\u003d reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n-        minutes -\u003d reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n-        hours -\u003d reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n-        days -\u003d reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n-        months -\u003d reduceAndCorrect( start, end, Calendar.MONTH, months );\n-        years -\u003d reduceAndCorrect( start, end, Calendar.YEAR, years );\n+        milliseconds -\u003d reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n+        seconds -\u003d reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n+        minutes -\u003d reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n+        hours -\u003d reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n+        days -\u003d reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n+        months -\u003d reduceAndCorrect(start, end, Calendar.MONTH, months);\n+        years -\u003d reduceAndCorrect(start, end, Calendar.YEAR, years);\n \n         // This next block of code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n-        if(!Token.containsTokenWithValue(tokens, y) ) {\n-            if(Token.containsTokenWithValue(tokens, M) ) {\n+        if (!Token.containsTokenWithValue(tokens, y)) {\n+            if (Token.containsTokenWithValue(tokens, M)) {\n                 months +\u003d 12 * years;\n                 years \u003d 0;\n             } else {\n                 // TODO: this is a bit weak, needs work to know about leap years\n                 days +\u003d 365 * years;\n                 years \u003d 0;\n             }\n         }\n-        if(!Token.containsTokenWithValue(tokens, M) ) {\n+        if (!Token.containsTokenWithValue(tokens, M)) {\n             days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months \u003d 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, d) ) {\n+        if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, H) ) {\n+        if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, m) ) {\n+        if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, s) ) {\n+        if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n-        return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "format",
            "newValue": "formatPeriod"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Rework DurationFormatUtils to have clearer API based on two types of formatting\nFix millisecond formatting bug\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137977 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004-10-15, 7:11 p.m.",
          "commitName": "5111ae7db08a70323a51a21df0bbaf46f21e072e",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2004-10-01, 9:40 p.m.",
          "commitNameOld": "dd2a1841fc7c9c95af1ce1e6ed3ed0ee3587df19",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 13.9,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n\n        long millis \u003d endMillis - startMillis;\n        if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        // each initial estimate is adjusted in case it is under 0\n        while (months \u003c 0) {\n            months +\u003d 12;\n            years -\u003d 1;\n        }\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        while (days \u003c 0) {\n            days +\u003d 31; // such overshooting is taken care of later on\n            months -\u003d 1;\n        }\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        while (hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        while (minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        while (seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        while (milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n\n        // take estimates off of end to see if we can equal start, when it overshoots recalculate\n        milliseconds -\u003d reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -\u003d reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -\u003d reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -\u003d reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -\u003d reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -\u003d reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -\u003d reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        // This next block of code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months +\u003d 12 * years;\n                years \u003d 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days +\u003d 365 * years;\n                years \u003d 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
          "functionStartLine": 259,
          "functionName": "formatPeriod",
          "diff": "@@ -1,95 +1,95 @@\n-    public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n+    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n \n         long millis \u003d endMillis - startMillis;\n-        if(millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n-            return format(millis, format, padWithZeros, timezone);\n+        if (millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n+            return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         // each initial estimate is adjusted in case it is under 0\n-        while(months \u003c 0) {\n+        while (months \u003c 0) {\n             months +\u003d 12;\n             years -\u003d 1;\n         }\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n-        while(days \u003c 0) {\n-            days +\u003d 31;  // such overshooting is taken care of later on\n+        while (days \u003c 0) {\n+            days +\u003d 31; // such overshooting is taken care of later on\n             months -\u003d 1;\n         }\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n-        while(hours \u003c 0) {\n+        while (hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n-        while(minutes \u003c 0) {\n+        while (minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n-        while(seconds \u003c 0) {\n+        while (seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n-        while(milliseconds \u003c 0) {\n+        while (milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n \n         // take estimates off of end to see if we can equal start, when it overshoots recalculate\n-        milliseconds -\u003d reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n-        seconds -\u003d reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n-        minutes -\u003d reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n-        hours -\u003d reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n-        days -\u003d reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n-        months -\u003d reduceAndCorrect( start, end, Calendar.MONTH, months );\n-        years -\u003d reduceAndCorrect( start, end, Calendar.YEAR, years );\n+        milliseconds -\u003d reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n+        seconds -\u003d reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n+        minutes -\u003d reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n+        hours -\u003d reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n+        days -\u003d reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n+        months -\u003d reduceAndCorrect(start, end, Calendar.MONTH, months);\n+        years -\u003d reduceAndCorrect(start, end, Calendar.YEAR, years);\n \n         // This next block of code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n-        if(!Token.containsTokenWithValue(tokens, y) ) {\n-            if(Token.containsTokenWithValue(tokens, M) ) {\n+        if (!Token.containsTokenWithValue(tokens, y)) {\n+            if (Token.containsTokenWithValue(tokens, M)) {\n                 months +\u003d 12 * years;\n                 years \u003d 0;\n             } else {\n                 // TODO: this is a bit weak, needs work to know about leap years\n                 days +\u003d 365 * years;\n                 years \u003d 0;\n             }\n         }\n-        if(!Token.containsTokenWithValue(tokens, M) ) {\n+        if (!Token.containsTokenWithValue(tokens, M)) {\n             days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months \u003d 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, d) ) {\n+        if (!Token.containsTokenWithValue(tokens, d)) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, H) ) {\n+        if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, m) ) {\n+        if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, s) ) {\n+        if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n-        return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "dd2a1841fc7c9c95af1ce1e6ed3ed0ee3587df19": {
      "type": "Ybodychange",
      "commitMessage": "Calendar.setTimeInMillis(long) is a JDK 1.4 method, so reverting to an older variant\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137954 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004-10-01, 9:40 p.m.",
      "commitName": "dd2a1841fc7c9c95af1ce1e6ed3ed0ee3587df19",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2004-09-27, 12:49 a.m.",
      "commitNameOld": "f80cb56da1316d5cb977c07937c2794efc87a522",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 4.87,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n\n        long millis \u003d endMillis - startMillis;\n        if(millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n            return format(millis, format, padWithZeros, timezone);\n        }\n\n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        // each initial estimate is adjusted in case it is under 0\n        while(months \u003c 0) {\n            months +\u003d 12;\n            years -\u003d 1;\n        }\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        while(days \u003c 0) {\n            days +\u003d 31;  // such overshooting is taken care of later on\n            months -\u003d 1;\n        }\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        while(hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        while(minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        while(seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        while(milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n\n        // take estimates off of end to see if we can equal start, when it overshoots recalculate\n        milliseconds -\u003d reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n        seconds -\u003d reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n        minutes -\u003d reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n        hours -\u003d reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n        days -\u003d reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n        months -\u003d reduceAndCorrect( start, end, Calendar.MONTH, months );\n        years -\u003d reduceAndCorrect( start, end, Calendar.YEAR, years );\n\n        // This next block of code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n        if(!Token.containsTokenWithValue(tokens, y) ) {\n            if(Token.containsTokenWithValue(tokens, M) ) {\n                months +\u003d 12 * years;\n                years \u003d 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days +\u003d 365 * years;\n                years \u003d 0;\n            }\n        }\n        if(!Token.containsTokenWithValue(tokens, M) ) {\n            days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months \u003d 0;\n        }\n        if(!Token.containsTokenWithValue(tokens, d) ) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if(!Token.containsTokenWithValue(tokens, H) ) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if(!Token.containsTokenWithValue(tokens, m) ) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if(!Token.containsTokenWithValue(tokens, s) ) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
      "functionStartLine": 250,
      "functionName": "format",
      "diff": "@@ -1,95 +1,95 @@\n     public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n \n         long millis \u003d endMillis - startMillis;\n         if(millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n             return format(millis, format, padWithZeros, timezone);\n         }\n \n         Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start \u003d Calendar.getInstance(timezone);\n-        start.setTimeInMillis(startMillis);\n+        start.setTime(new Date(startMillis));\n         Calendar end \u003d Calendar.getInstance(timezone);\n-        end.setTimeInMillis(endMillis);\n+        end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         // each initial estimate is adjusted in case it is under 0\n         while(months \u003c 0) {\n             months +\u003d 12;\n             years -\u003d 1;\n         }\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         while(days \u003c 0) {\n             days +\u003d 31;  // such overshooting is taken care of later on\n             months -\u003d 1;\n         }\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         while(hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         while(minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         while(seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         while(milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n \n         // take estimates off of end to see if we can equal start, when it overshoots recalculate\n         milliseconds -\u003d reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n         seconds -\u003d reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n         minutes -\u003d reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n         hours -\u003d reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n         days -\u003d reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n         months -\u003d reduceAndCorrect( start, end, Calendar.MONTH, months );\n         years -\u003d reduceAndCorrect( start, end, Calendar.YEAR, years );\n \n         // This next block of code adds in values that \n         // aren\u0027t requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0-\u003e11.\n         if(!Token.containsTokenWithValue(tokens, y) ) {\n             if(Token.containsTokenWithValue(tokens, M) ) {\n                 months +\u003d 12 * years;\n                 years \u003d 0;\n             } else {\n                 // TODO: this is a bit weak, needs work to know about leap years\n                 days +\u003d 365 * years;\n                 years \u003d 0;\n             }\n         }\n         if(!Token.containsTokenWithValue(tokens, M) ) {\n             days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months \u003d 0;\n         }\n         if(!Token.containsTokenWithValue(tokens, d) ) {\n             hours +\u003d 24 * days;\n             days \u003d 0;\n         }\n         if(!Token.containsTokenWithValue(tokens, H) ) {\n             minutes +\u003d 60 * hours;\n             hours \u003d 0;\n         }\n         if(!Token.containsTokenWithValue(tokens, m) ) {\n             seconds +\u003d 60 * minutes;\n             minutes \u003d 0;\n         }\n         if(!Token.containsTokenWithValue(tokens, s) ) {\n             milliseconds +\u003d 1000 * seconds;\n             seconds \u003d 0;\n         }\n \n         return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f80cb56da1316d5cb977c07937c2794efc87a522": {
      "type": "Ybodychange",
      "commitMessage": "typo fixed, a couple of extra overload methods added (need javadoc) and formatting for start-\u003eend changed to match millis implementation, for a pattern of M, 4 years is reported as 48 months and not 0 months.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137940 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004-09-27, 12:49 a.m.",
      "commitName": "f80cb56da1316d5cb977c07937c2794efc87a522",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2004-09-26, 11:40 p.m.",
      "commitNameOld": "69ec8f4668a67921b6788837621e8f88cbcd7762",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n\n        long millis \u003d endMillis - startMillis;\n        if(millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n            return format(millis, format, padWithZeros, timezone);\n        }\n\n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTimeInMillis(startMillis);\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTimeInMillis(endMillis);\n\n        // initial estimates\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        // each initial estimate is adjusted in case it is under 0\n        while(months \u003c 0) {\n            months +\u003d 12;\n            years -\u003d 1;\n        }\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        while(days \u003c 0) {\n            days +\u003d 31;  // such overshooting is taken care of later on\n            months -\u003d 1;\n        }\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        while(hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        while(minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        while(seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        while(milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n\n        // take estimates off of end to see if we can equal start, when it overshoots recalculate\n        milliseconds -\u003d reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n        seconds -\u003d reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n        minutes -\u003d reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n        hours -\u003d reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n        days -\u003d reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n        months -\u003d reduceAndCorrect( start, end, Calendar.MONTH, months );\n        years -\u003d reduceAndCorrect( start, end, Calendar.YEAR, years );\n\n        // This next block of code adds in values that \n        // aren\u0027t requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0-\u003e11.\n        if(!Token.containsTokenWithValue(tokens, y) ) {\n            if(Token.containsTokenWithValue(tokens, M) ) {\n                months +\u003d 12 * years;\n                years \u003d 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days +\u003d 365 * years;\n                years \u003d 0;\n            }\n        }\n        if(!Token.containsTokenWithValue(tokens, M) ) {\n            days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months \u003d 0;\n        }\n        if(!Token.containsTokenWithValue(tokens, d) ) {\n            hours +\u003d 24 * days;\n            days \u003d 0;\n        }\n        if(!Token.containsTokenWithValue(tokens, H) ) {\n            minutes +\u003d 60 * hours;\n            hours \u003d 0;\n        }\n        if(!Token.containsTokenWithValue(tokens, m) ) {\n            seconds +\u003d 60 * minutes;\n            minutes \u003d 0;\n        }\n        if(!Token.containsTokenWithValue(tokens, s) ) {\n            milliseconds +\u003d 1000 * seconds;\n            seconds \u003d 0;\n        }\n\n        return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
      "functionStartLine": 249,
      "functionName": "format",
      "diff": "@@ -1,61 +1,95 @@\n     public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n \n         long millis \u003d endMillis - startMillis;\n         if(millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n             return format(millis, format, padWithZeros, timezone);\n         }\n \n         Token[] tokens \u003d lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start \u003d Calendar.getInstance(timezone);\n         start.setTimeInMillis(startMillis);\n         Calendar end \u003d Calendar.getInstance(timezone);\n         end.setTimeInMillis(endMillis);\n \n         // initial estimates\n         int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n         int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         // each initial estimate is adjusted in case it is under 0\n         while(months \u003c 0) {\n             months +\u003d 12;\n             years -\u003d 1;\n         }\n         int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         while(days \u003c 0) {\n             days +\u003d 31;  // such overshooting is taken care of later on\n-            days -\u003d 1;\n+            months -\u003d 1;\n         }\n         int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         while(hours \u003c 0) {\n             hours +\u003d 24;\n             days -\u003d 1;\n         }\n         int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         while(minutes \u003c 0) {\n             minutes +\u003d 60;\n             hours -\u003d 1;\n         }\n         int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         while(seconds \u003c 0) {\n             seconds +\u003d 60;\n             minutes -\u003d 1;\n         }\n         int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         while(milliseconds \u003c 0) {\n             milliseconds +\u003d 1000;\n             seconds -\u003d 1;\n         }\n \n         // take estimates off of end to see if we can equal start, when it overshoots recalculate\n         milliseconds -\u003d reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n         seconds -\u003d reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n         minutes -\u003d reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n         hours -\u003d reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n         days -\u003d reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n         months -\u003d reduceAndCorrect( start, end, Calendar.MONTH, months );\n         years -\u003d reduceAndCorrect( start, end, Calendar.YEAR, years );\n \n+        // This next block of code adds in values that \n+        // aren\u0027t requested. This allows the user to ask for the \n+        // number of months and get the real count and not just 0-\u003e11.\n+        if(!Token.containsTokenWithValue(tokens, y) ) {\n+            if(Token.containsTokenWithValue(tokens, M) ) {\n+                months +\u003d 12 * years;\n+                years \u003d 0;\n+            } else {\n+                // TODO: this is a bit weak, needs work to know about leap years\n+                days +\u003d 365 * years;\n+                years \u003d 0;\n+            }\n+        }\n+        if(!Token.containsTokenWithValue(tokens, M) ) {\n+            days +\u003d end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+            months \u003d 0;\n+        }\n+        if(!Token.containsTokenWithValue(tokens, d) ) {\n+            hours +\u003d 24 * days;\n+            days \u003d 0;\n+        }\n+        if(!Token.containsTokenWithValue(tokens, H) ) {\n+            minutes +\u003d 60 * hours;\n+            hours \u003d 0;\n+        }\n+        if(!Token.containsTokenWithValue(tokens, m) ) {\n+            seconds +\u003d 60 * minutes;\n+            minutes \u003d 0;\n+        }\n+        if(!Token.containsTokenWithValue(tokens, s) ) {\n+            milliseconds +\u003d 1000 * seconds;\n+            seconds \u003d 0;\n+        }\n+\n         return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "177d40989f45197fd9f9669f4eeb6033b73bc16e": {
      "type": "Yintroduced",
      "commitMessage": "removed the weak assumptions for number of millis in a month/year from DateUtils. Implemented a second format method that relies on a start and an end in DurationFormatUtils, though I found that TimeZone was very important in the overloaded millis version. The two methods hand off to each other depending on whether the time is \u003e or \u003c than 28 days\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137935 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004-09-26, 11:14 p.m.",
      "commitName": "177d40989f45197fd9f9669f4eeb6033b73bc16e",
      "commitAuthor": "Henri Yandell",
      "diff": "@@ -0,0 +1,61 @@\n+    public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n+\n+        long millis \u003d endMillis - startMillis;\n+        if(millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n+            return format(millis, format, padWithZeros, timezone);\n+        }\n+\n+        Token[] tokens \u003d lexx(format);\n+\n+        // timezones get funky around 0, so normalizing everything to GMT \n+        // stops the hours being off\n+        Calendar start \u003d Calendar.getInstance(timezone);\n+        start.setTimeInMillis(startMillis);\n+        Calendar end \u003d Calendar.getInstance(timezone);\n+        end.setTimeInMillis(endMillis);\n+\n+        // initial estimates\n+        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n+        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n+        // each initial estimate is adjusted in case it is under 0\n+        while(months \u003c 0) {\n+            months +\u003d 12;\n+            years -\u003d 1;\n+        }\n+        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n+        while(days \u003c 0) {\n+            days +\u003d 31;  // such overshooting is taken care of later on\n+            days -\u003d 1;\n+        }\n+        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n+        while(hours \u003c 0) {\n+            hours +\u003d 24;\n+            days -\u003d 1;\n+        }\n+        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n+        while(minutes \u003c 0) {\n+            minutes +\u003d 60;\n+            hours -\u003d 1;\n+        }\n+        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n+        while(seconds \u003c 0) {\n+            seconds +\u003d 60;\n+            minutes -\u003d 1;\n+        }\n+        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n+        while(milliseconds \u003c 0) {\n+            milliseconds +\u003d 1000;\n+            seconds -\u003d 1;\n+        }\n+\n+        // take estimates off of end to see if we can equal start, when it overshoots recalculate\n+        milliseconds -\u003d reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n+        seconds -\u003d reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n+        minutes -\u003d reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n+        hours -\u003d reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n+        days -\u003d reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n+        months -\u003d reduceAndCorrect( start, end, Calendar.MONTH, months );\n+        years -\u003d reduceAndCorrect( start, end, Calendar.YEAR, years );\n+\n+        return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n\n        long millis \u003d endMillis - startMillis;\n        if(millis \u003c 28 * DateUtils.MILLIS_PER_DAY) {\n            return format(millis, format, padWithZeros, timezone);\n        }\n\n        Token[] tokens \u003d lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start \u003d Calendar.getInstance(timezone);\n        start.setTimeInMillis(startMillis);\n        Calendar end \u003d Calendar.getInstance(timezone);\n        end.setTimeInMillis(endMillis);\n\n        // initial estimates\n        int years \u003d end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n        int months \u003d end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        // each initial estimate is adjusted in case it is under 0\n        while(months \u003c 0) {\n            months +\u003d 12;\n            years -\u003d 1;\n        }\n        int days \u003d end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        while(days \u003c 0) {\n            days +\u003d 31;  // such overshooting is taken care of later on\n            days -\u003d 1;\n        }\n        int hours \u003d end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        while(hours \u003c 0) {\n            hours +\u003d 24;\n            days -\u003d 1;\n        }\n        int minutes \u003d end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        while(minutes \u003c 0) {\n            minutes +\u003d 60;\n            hours -\u003d 1;\n        }\n        int seconds \u003d end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        while(seconds \u003c 0) {\n            seconds +\u003d 60;\n            minutes -\u003d 1;\n        }\n        int milliseconds \u003d end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        while(milliseconds \u003c 0) {\n            milliseconds +\u003d 1000;\n            seconds -\u003d 1;\n        }\n\n        // take estimates off of end to see if we can equal start, when it overshoots recalculate\n        milliseconds -\u003d reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n        seconds -\u003d reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n        minutes -\u003d reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n        hours -\u003d reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n        days -\u003d reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n        months -\u003d reduceAndCorrect( start, end, Calendar.MONTH, months );\n        years -\u003d reduceAndCorrect( start, end, Calendar.YEAR, years );\n\n        return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
      "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
      "functionStartLine": 210,
      "functionName": "format"
    }
  }
}