{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "H:\\Projects\\eclipse\\jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "PullCommand.java",
  "functionName": "call",
  "functionId": "call",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
  "functionStartLine": 206,
  "functionEndLine": 360,
  "numCommitsSeen": 38,
  "timeTaken": 3881,
  "changeHistory": [
    "df638e0cfc628469eee9a91df5b2b65634e274d7",
    "0d447b16604d934675d2dc8e958fa043e945dfc6",
    "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd",
    "5f902f07ccae32b82a36c05e1eca23b21a27da99",
    "1cda4faed425286fe5230a6b2b8454c376ba79f1",
    "aadbb158e10ccc3194c4e7f2c1b3885b3c40571c",
    "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
    "efacad0fc8e98505be6f007230ab2b1cdc1684f3",
    "2390531888af6dc9e4fda6cb026271dc068c40ab",
    "48544e27ae3808807dc1960083d8e42c05e62af3",
    "7424d58255340fa44d9191a7436fbe70d72a457c",
    "1eae309723be301a4f2fc12a3e07e7e7c9f30782",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
    "fa5231191d530afb24810080e89990913c8e8054",
    "5854ca091a22346e1c710ca9f875165afb3f2cc8",
    "b61d35e848e637ef85fde4ebe95d60ced171e963",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
    "c3fe50bb18ed4e4e5e563172be4076fa5901a18a",
    "da901c49688ef72858cd2b6904e0f8e478fa0ec3",
    "791a9fd691e5ae101650f27f39366ec7b23f3955",
    "6d293c7b06e219086959e80d495b5febe8ae530d",
    "770c733687d9f2f71f30822f9691427bf83b7577",
    "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
    "724af77c65c27eb24d41989bed3229910dbe063c",
    "b15b9d5df25b375108ca125b31338df637454865",
    "9fbda2239202ca9d3a20c84d7326f47c667aa920",
    "14ca80bc90ed85e3484fa28aa665fa0538096d30",
    "013cb8de3824c304645a9c5db87c2e80286872d1",
    "d36c80fd048fc55d7ac31ae62eb67fbac9b12e31",
    "7668a462829b12e4f6a192c43157152ef63ff305",
    "db55d13f5f4b641a9390076ced6b1775bcfcd6f6"
  ],
  "changeHistoryShort": {
    "df638e0cfc628469eee9a91df5b2b65634e274d7": "Ybodychange",
    "0d447b16604d934675d2dc8e958fa043e945dfc6": "Ybodychange",
    "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd": "Ymultichange(Yexceptionschange,Ybodychange)",
    "5f902f07ccae32b82a36c05e1eca23b21a27da99": "Ybodychange",
    "1cda4faed425286fe5230a6b2b8454c376ba79f1": "Ybodychange",
    "aadbb158e10ccc3194c4e7f2c1b3885b3c40571c": "Ybodychange",
    "1e1fb9fc596603a44b0fff6d19eeba2b005d659d": "Ybodychange",
    "efacad0fc8e98505be6f007230ab2b1cdc1684f3": "Ymultichange(Yexceptionschange,Ybodychange)",
    "2390531888af6dc9e4fda6cb026271dc068c40ab": "Ybodychange",
    "48544e27ae3808807dc1960083d8e42c05e62af3": "Ybodychange",
    "7424d58255340fa44d9191a7436fbe70d72a457c": "Ybodychange",
    "1eae309723be301a4f2fc12a3e07e7e7c9f30782": "Ybodychange",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": "Ybodychange",
    "fa5231191d530afb24810080e89990913c8e8054": "Ybodychange",
    "5854ca091a22346e1c710ca9f875165afb3f2cc8": "Ybodychange",
    "b61d35e848e637ef85fde4ebe95d60ced171e963": "Ymultichange(Yexceptionschange,Ybodychange)",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": "Yexceptionschange",
    "c3fe50bb18ed4e4e5e563172be4076fa5901a18a": "Ymultichange(Yexceptionschange,Ybodychange)",
    "da901c49688ef72858cd2b6904e0f8e478fa0ec3": "Ybodychange",
    "791a9fd691e5ae101650f27f39366ec7b23f3955": "Ybodychange",
    "6d293c7b06e219086959e80d495b5febe8ae530d": "Ybodychange",
    "770c733687d9f2f71f30822f9691427bf83b7577": "Ybodychange",
    "68459b646e6c8243dc5650cbe08ce1bcdb8a621d": "Ymultichange(Yexceptionschange,Ybodychange)",
    "724af77c65c27eb24d41989bed3229910dbe063c": "Ybodychange",
    "b15b9d5df25b375108ca125b31338df637454865": "Ybodychange",
    "9fbda2239202ca9d3a20c84d7326f47c667aa920": "Ybodychange",
    "14ca80bc90ed85e3484fa28aa665fa0538096d30": "Ybodychange",
    "013cb8de3824c304645a9c5db87c2e80286872d1": "Ybodychange",
    "d36c80fd048fc55d7ac31ae62eb67fbac9b12e31": "Ybodychange",
    "7668a462829b12e4f6a192c43157152ef63ff305": "Ybodychange",
    "db55d13f5f4b641a9390076ced6b1775bcfcd6f6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "df638e0cfc628469eee9a91df5b2b65634e274d7": {
      "type": "Ybodychange",
      "commitMessage": "Allow to programmatically set FastForwardMode for PullCommand\n\nBug: 517847\nChange-Id: I70d12dbe347a3d7a3528687ee04e52a2052bfb93\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2017-06-16, 5:20 p.m.",
      "commitName": "df638e0cfc628469eee9a91df5b2b65634e274d7",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2017-06-16, 5:20 p.m.",
      "commitNameOld": "0d447b16604d934675d2dc8e958fa043e945dfc6",
      "commitAuthorOld": "Mattias Neuling",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tInvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\t\tConfig repoConfig \u003d repo.getConfig();\n\n\t\tString branchName \u003d null;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch !\u003d null\n\t\t\t\t\t\u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\t\tif (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t}\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tremoteBranchName \u003d branchName;\n\t\t}\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tthrow new NoHeadException(\n\t\t\t\t\tJGitText.get().cannotCheckoutFromUnbornBranch);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tif (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\t\t}\n\n\t\t// determines whether rebase should be used after fetching\n\t\tif (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n\t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n\t\t}\n\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote)\n\t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n\t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d JGitText.get().localRepository;\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null) {\n\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n\t\t\t\t\t\tremoteBranchName));\n\t\t\t} else {\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d MessageFormat.format(\n\t\t\t\tJGitText.get().upstreamBranchName,\n\t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n\n\t\tPullResult result;\n\t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n\t\t\t\t\t.setPreserveMerges(\n\t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tMergeResult mergeRes \u003d merge.include(upstreamName, commitToMerge)\n\t\t\t\t\t.setStrategy(strategy).setProgressMonitor(monitor)\n\t\t\t\t\t.setFastForward(getFastForwardMode()).call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 209,
      "functionName": "call",
      "diff": "@@ -1,157 +1,155 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tInvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \t\tConfig repoConfig \u003d repo.getConfig();\n \n \t\tString branchName \u003d null;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch !\u003d null\n \t\t\t\t\t\u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \t\tif (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t}\n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tremoteBranchName \u003d branchName;\n \t\t}\n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tthrow new NoHeadException(\n \t\t\t\t\tJGitText.get().cannotCheckoutFromUnbornBranch);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tif (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\t\tremote \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote \u003d\u003d null) {\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \t\t}\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n \t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote)\n \t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n \t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d JGitText.get().localRepository;\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(\n \t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n-\t\t\tmerge.include(upstreamName, commitToMerge);\n-\t\t\tmerge.setStrategy(strategy);\n-\t\t\tmerge.setProgressMonitor(monitor);\n-\t\t\tmerge.setFastForward(getFastForwardMode());\n-\t\t\tMergeResult mergeRes \u003d merge.call();\n+\t\t\tMergeResult mergeRes \u003d merge.include(upstreamName, commitToMerge)\n+\t\t\t\t\t.setStrategy(strategy).setProgressMonitor(monitor)\n+\t\t\t\t\t.setFastForward(getFastForwardMode()).call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0d447b16604d934675d2dc8e958fa043e945dfc6": {
      "type": "Ybodychange",
      "commitMessage": "Add support for config \"pull.ff\n\nWhen the configuration entry \u0027pull.ff\u0027 exists the merge of the pull will\nuse the value as fast forward option.\n\nBug: 474174\nChange-Id: Ic8db2f00095ed81528667b064ff523911e6c122e\nSigned-off-by: Mattias Neuling \u003cneuling@dakosy.de\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2017-06-16, 5:20 p.m.",
      "commitName": "0d447b16604d934675d2dc8e958fa043e945dfc6",
      "commitAuthor": "Mattias Neuling",
      "commitDateOld": "2017-06-15, 11:52 p.m.",
      "commitNameOld": "b4a46b5ed0e33f0a958ba809c648f46e5a19abd7",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tInvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\t\tConfig repoConfig \u003d repo.getConfig();\n\n\t\tString branchName \u003d null;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch !\u003d null\n\t\t\t\t\t\u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\t\tif (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t}\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tremoteBranchName \u003d branchName;\n\t\t}\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tthrow new NoHeadException(\n\t\t\t\t\tJGitText.get().cannotCheckoutFromUnbornBranch);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tif (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\t\t}\n\n\t\t// determines whether rebase should be used after fetching\n\t\tif (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n\t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n\t\t}\n\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote)\n\t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n\t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d JGitText.get().localRepository;\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null) {\n\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n\t\t\t\t\t\tremoteBranchName));\n\t\t\t} else {\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d MessageFormat.format(\n\t\t\t\tJGitText.get().upstreamBranchName,\n\t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n\n\t\tPullResult result;\n\t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n\t\t\t\t\t.setPreserveMerges(\n\t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tmerge.setStrategy(strategy);\n\t\t\tmerge.setProgressMonitor(monitor);\n\t\t\tmerge.setFastForward(getFastForwardMode());\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 207,
      "functionName": "call",
      "diff": "@@ -1,156 +1,157 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tInvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \t\tConfig repoConfig \u003d repo.getConfig();\n \n \t\tString branchName \u003d null;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch !\u003d null\n \t\t\t\t\t\u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \t\tif (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t}\n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tremoteBranchName \u003d branchName;\n \t\t}\n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tthrow new NoHeadException(\n \t\t\t\t\tJGitText.get().cannotCheckoutFromUnbornBranch);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tif (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\t\tremote \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote \u003d\u003d null) {\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \t\t}\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n \t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote)\n \t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n \t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d JGitText.get().localRepository;\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(\n \t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tmerge.setProgressMonitor(monitor);\n+\t\t\tmerge.setFastForward(getFastForwardMode());\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Support pull on detached HEAD\n\nBug: 485396\nChange-Id: I82be09385c9b0bcc0054fea5a9cb9d178a41e278\nSigned-off-by: Mickael Istria \u003cmistria@redhat.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2017-05-07, 6:38 p.m.",
      "commitName": "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd",
      "commitAuthor": "Mickael Istria",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Support pull on detached HEAD\n\nBug: 485396\nChange-Id: I82be09385c9b0bcc0054fea5a9cb9d178a41e278\nSigned-off-by: Mickael Istria \u003cmistria@redhat.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2017-05-07, 6:38 p.m.",
          "commitName": "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd",
          "commitAuthor": "Mickael Istria",
          "commitDateOld": "2017-03-23, 7:02 p.m.",
          "commitNameOld": "5f902f07ccae32b82a36c05e1eca23b21a27da99",
          "commitAuthorOld": "David Pursehouse",
          "daysBetweenCommits": 44.98,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tInvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\t\tConfig repoConfig \u003d repo.getConfig();\n\n\t\tString branchName \u003d null;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch !\u003d null\n\t\t\t\t\t\u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\t\tif (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t}\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tremoteBranchName \u003d branchName;\n\t\t}\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tthrow new NoHeadException(\n\t\t\t\t\tJGitText.get().cannotCheckoutFromUnbornBranch);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tif (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\t\t}\n\n\t\t// determines whether rebase should be used after fetching\n\t\tif (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n\t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n\t\t}\n\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote)\n\t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n\t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d JGitText.get().localRepository;\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null) {\n\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n\t\t\t\t\t\tremoteBranchName));\n\t\t\t} else {\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d MessageFormat.format(\n\t\t\t\tJGitText.get().upstreamBranchName,\n\t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n\n\t\tPullResult result;\n\t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n\t\t\t\t\t.setPreserveMerges(\n\t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tmerge.setStrategy(strategy);\n\t\t\tmerge.setProgressMonitor(monitor);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 204,
          "functionName": "call",
          "diff": "@@ -1,155 +1,156 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n-\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n+\t\t\tInvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n+\t\tConfig repoConfig \u003d repo.getConfig();\n \n-\t\tString branchName;\n+\t\tString branchName \u003d null;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n-\t\t\tif (fullBranch \u003d\u003d null)\n-\t\t\t\tthrow new NoHeadException(\n-\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n-\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n-\t\t\t\t// we can not pull if HEAD is detached and branch is not\n-\t\t\t\t// specified explicitly\n-\t\t\t\tthrow new DetachedHeadException();\n+\t\t\tif (fullBranch !\u003d null\n+\t\t\t\t\t\u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n+\t\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t\t}\n-\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n+\t\tif (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n+\t\t\t// get the name of the branch in the remote repository\n+\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n+\t\t\tremoteBranchName \u003d repoConfig.getString(\n+\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\t}\n+\t\tif (remoteBranchName \u003d\u003d null) {\n+\t\t\tremoteBranchName \u003d branchName;\n+\t\t}\n+\t\tif (remoteBranchName \u003d\u003d null) {\n+\t\t\tthrow new NoHeadException(\n+\t\t\t\t\tJGitText.get().cannotCheckoutFromUnbornBranch);\n+\t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n-\t\tConfig repoConfig \u003d repo.getConfig();\n-\t\tif (remote \u003d\u003d null) {\n+\t\tif (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\t\tremote \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n-\t\tif (remote \u003d\u003d null)\n+\t\tif (remote \u003d\u003d null) {\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n-\n-\t\tif (remoteBranchName \u003d\u003d null)\n-\t\t\t// get the name of the branch in the remote repository\n-\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n-\t\t\tremoteBranchName \u003d repoConfig.getString(\n-\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\t}\n \n \t\t// determines whether rebase should be used after fetching\n-\t\tif (pullRebaseMode \u003d\u003d null) {\n+\t\tif (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n \t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n \t\t}\n \n-\t\tif (remoteBranchName \u003d\u003d null)\n-\t\t\tremoteBranchName \u003d branchName;\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote)\n \t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n \t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d JGitText.get().localRepository;\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(\n \t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tmerge.setProgressMonitor(monitor);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]",
            "newValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Support pull on detached HEAD\n\nBug: 485396\nChange-Id: I82be09385c9b0bcc0054fea5a9cb9d178a41e278\nSigned-off-by: Mickael Istria \u003cmistria@redhat.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2017-05-07, 6:38 p.m.",
          "commitName": "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd",
          "commitAuthor": "Mickael Istria",
          "commitDateOld": "2017-03-23, 7:02 p.m.",
          "commitNameOld": "5f902f07ccae32b82a36c05e1eca23b21a27da99",
          "commitAuthorOld": "David Pursehouse",
          "daysBetweenCommits": 44.98,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tInvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\t\tConfig repoConfig \u003d repo.getConfig();\n\n\t\tString branchName \u003d null;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch !\u003d null\n\t\t\t\t\t\u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\t\tif (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t}\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tremoteBranchName \u003d branchName;\n\t\t}\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tthrow new NoHeadException(\n\t\t\t\t\tJGitText.get().cannotCheckoutFromUnbornBranch);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tif (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\t\t}\n\n\t\t// determines whether rebase should be used after fetching\n\t\tif (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n\t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n\t\t}\n\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote)\n\t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n\t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d JGitText.get().localRepository;\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null) {\n\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n\t\t\t\t\t\tremoteBranchName));\n\t\t\t} else {\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d MessageFormat.format(\n\t\t\t\tJGitText.get().upstreamBranchName,\n\t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n\n\t\tPullResult result;\n\t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n\t\t\t\t\t.setPreserveMerges(\n\t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tmerge.setStrategy(strategy);\n\t\t\tmerge.setProgressMonitor(monitor);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 204,
          "functionName": "call",
          "diff": "@@ -1,155 +1,156 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n-\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n+\t\t\tInvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n+\t\tConfig repoConfig \u003d repo.getConfig();\n \n-\t\tString branchName;\n+\t\tString branchName \u003d null;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n-\t\t\tif (fullBranch \u003d\u003d null)\n-\t\t\t\tthrow new NoHeadException(\n-\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n-\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n-\t\t\t\t// we can not pull if HEAD is detached and branch is not\n-\t\t\t\t// specified explicitly\n-\t\t\t\tthrow new DetachedHeadException();\n+\t\t\tif (fullBranch !\u003d null\n+\t\t\t\t\t\u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n+\t\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t\t}\n-\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n+\t\tif (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n+\t\t\t// get the name of the branch in the remote repository\n+\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n+\t\t\tremoteBranchName \u003d repoConfig.getString(\n+\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\t}\n+\t\tif (remoteBranchName \u003d\u003d null) {\n+\t\t\tremoteBranchName \u003d branchName;\n+\t\t}\n+\t\tif (remoteBranchName \u003d\u003d null) {\n+\t\t\tthrow new NoHeadException(\n+\t\t\t\t\tJGitText.get().cannotCheckoutFromUnbornBranch);\n+\t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n-\t\tConfig repoConfig \u003d repo.getConfig();\n-\t\tif (remote \u003d\u003d null) {\n+\t\tif (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\t\tremote \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n-\t\tif (remote \u003d\u003d null)\n+\t\tif (remote \u003d\u003d null) {\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n-\n-\t\tif (remoteBranchName \u003d\u003d null)\n-\t\t\t// get the name of the branch in the remote repository\n-\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n-\t\t\tremoteBranchName \u003d repoConfig.getString(\n-\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\t}\n \n \t\t// determines whether rebase should be used after fetching\n-\t\tif (pullRebaseMode \u003d\u003d null) {\n+\t\tif (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n \t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n \t\t}\n \n-\t\tif (remoteBranchName \u003d\u003d null)\n-\t\t\tremoteBranchName \u003d branchName;\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote)\n \t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n \t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d JGitText.get().localRepository;\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(\n \t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tmerge.setProgressMonitor(monitor);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "5f902f07ccae32b82a36c05e1eca23b21a27da99": {
      "type": "Ybodychange",
      "commitMessage": "PullCommand: Add support for recursing into submodules\n\nAdd a new API method to set the recurse mode, and pass the mode into\nthe fetch command.\n\nExtend the existing FetchCommandRecurseSubmodulesTest to also perform\nthe same tests for fetch. Rename the test class accordingly.\n\nChange-Id: I12553af47774b4778f7011e1018bd575a7909bd0\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017-03-23, 7:02 p.m.",
      "commitName": "5f902f07ccae32b82a36c05e1eca23b21a27da99",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017-02-19, 7:05 p.m.",
      "commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 31.96,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\n\t\t// determines whether rebase should be used after fetching\n\t\tif (pullRebaseMode \u003d\u003d null) {\n\t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n\t\t}\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\tremoteBranchName \u003d branchName;\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote)\n\t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n\t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d JGitText.get().localRepository;\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null) {\n\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n\t\t\t\t\t\tremoteBranchName));\n\t\t\t} else {\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d MessageFormat.format(\n\t\t\t\tJGitText.get().upstreamBranchName,\n\t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n\n\t\tPullResult result;\n\t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n\t\t\t\t\t.setPreserveMerges(\n\t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tmerge.setStrategy(strategy);\n\t\t\tmerge.setProgressMonitor(monitor);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 204,
      "functionName": "call",
      "diff": "@@ -1,154 +1,155 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tif (remote \u003d\u003d null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\t\tremote \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode \u003d\u003d null) {\n \t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\tremoteBranchName \u003d branchName;\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote)\n-\t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption);\n+\t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n+\t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d JGitText.get().localRepository;\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(\n \t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tmerge.setProgressMonitor(monitor);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1cda4faed425286fe5230a6b2b8454c376ba79f1": {
      "type": "Ybodychange",
      "commitMessage": "PullCommand: Allow to set tag behavior\n\nAdd a new method setTagOpt which sets the annotated tag behavior during\nfetch. Pass the option to the fetch command.\n\nNo explicit tests are added; the fetch with tags functionality is already\ncovered by the tests of the fetch command.\n\nChange-Id: I131e1f68d8fcced178d8fa48abf7ffab17f8e173\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017-02-18, 9:21 a.m.",
      "commitName": "1cda4faed425286fe5230a6b2b8454c376ba79f1",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2016-09-14, 6:44 p.m.",
      "commitNameOld": "aadbb158e10ccc3194c4e7f2c1b3885b3c40571c",
      "commitAuthorOld": "Thomas Wolf",
      "daysBetweenCommits": 156.65,
      "commitsBetweenForRepo": 221,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\n\t\t// determines whether rebase should be used after fetching\n\t\tif (pullRebaseMode \u003d\u003d null) {\n\t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n\t\t}\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\tremoteBranchName \u003d branchName;\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote)\n\t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d JGitText.get().localRepository;\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null) {\n\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n\t\t\t\t\t\tremoteBranchName));\n\t\t\t} else {\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d MessageFormat.format(\n\t\t\t\tJGitText.get().upstreamBranchName,\n\t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n\n\t\tPullResult result;\n\t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n\t\t\t\t\t.setPreserveMerges(\n\t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tmerge.setStrategy(strategy);\n\t\t\tmerge.setProgressMonitor(monitor);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 200,
      "functionName": "call",
      "diff": "@@ -1,155 +1,154 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tif (remote \u003d\u003d null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\t\tremote \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode \u003d\u003d null) {\n \t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\tremoteBranchName \u003d branchName;\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n-\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n-\t\t\tfetch.setRemote(remote);\n-\t\t\tfetch.setProgressMonitor(monitor);\n+\t\t\tFetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote)\n+\t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d JGitText.get().localRepository;\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(\n \t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tmerge.setProgressMonitor(monitor);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aadbb158e10ccc3194c4e7f2c1b3885b3c40571c": {
      "type": "Ybodychange",
      "commitMessage": "Handle all values of branch.[name].rebase\n\nBranchConfig treated this config property as a boolean, but git also\nallows the values \"preserve\" and \"interactive\". Config property\npull.rebase also allows the same values.\n\nReplace private enum PullCommand.PullRebaseMode by new public enum\nBranchConfig.BranchRebaseMode and adapt all uses. Add a new setter to\nPullCommand.\n\nNote: PullCommand will treat \"interactive\" like \"true\", i.e., as a\nnon-interactive rebase. Not sure how \"interactive\" should be handled.\nAt least it won\u0027t balk on it.\n\nBug: 499482\nChange-Id: I7309360f5662b2c2efa1bd8ea6f112c63cf064af\nSigned-off-by: Thomas Wolf \u003cthomas.wolf@paranor.ch\u003e",
      "commitDate": "2016-09-14, 6:44 p.m.",
      "commitName": "aadbb158e10ccc3194c4e7f2c1b3885b3c40571c",
      "commitAuthor": "Thomas Wolf",
      "commitDateOld": "2016-01-21, 5:37 a.m.",
      "commitNameOld": "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
      "commitAuthorOld": "Laurent Delaigue",
      "daysBetweenCommits": 237.5,
      "commitsBetweenForRepo": 328,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\n\t\t// determines whether rebase should be used after fetching\n\t\tif (pullRebaseMode \u003d\u003d null) {\n\t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n\t\t}\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\tremoteBranchName \u003d branchName;\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d JGitText.get().localRepository;\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null) {\n\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n\t\t\t\t\t\tremoteBranchName));\n\t\t\t} else {\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d MessageFormat.format(\n\t\t\t\tJGitText.get().upstreamBranchName,\n\t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n\n\t\tPullResult result;\n\t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n\t\t\t\t\t.setPreserveMerges(\n\t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tmerge.setStrategy(strategy);\n\t\t\tmerge.setProgressMonitor(monitor);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 197,
      "functionName": "call",
      "diff": "@@ -1,154 +1,155 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tif (remote \u003d\u003d null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\t\tremote \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode \u003d\u003d null) {\n \t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\tremoteBranchName \u003d branchName;\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d JGitText.get().localRepository;\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n-\t\tif (pullRebaseMode.rebase) {\n+\t\tif (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n-\t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n+\t\t\t\t\t.setPreserveMerges(\n+\t\t\t\t\t\t\tpullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tmerge.setProgressMonitor(monitor);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1e1fb9fc596603a44b0fff6d19eeba2b005d659d": {
      "type": "Ybodychange",
      "commitMessage": "Add progress monitor to Merger\n\nMonitoring progress of merges can be useful for users for large\nrepositories or complex merge processes that take some time.\n\nThis enables setting a monitor. Existing merge implementations in jgit\ndo not yet report progress if a monitor is set. This will be added in a\nlater change.\n\nChange-Id: I17b978b3fc91750dd88649638b90a46820a0877c\nSigned-off-by: Laurent Delaigue \u003claurent.delaigue@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016-01-21, 5:37 a.m.",
      "commitName": "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
      "commitAuthor": "Laurent Delaigue",
      "commitDateOld": "2015-06-11, 1:44 p.m.",
      "commitNameOld": "bbfd9b0e5fc0160f5a1034ce23958a8040e88748",
      "commitAuthorOld": "Jonathan Nieder",
      "daysBetweenCommits": 223.7,
      "commitsBetweenForRepo": 350,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\n\t\t// determines whether rebase should be used after fetching\n\t\tif (pullRebaseMode \u003d\u003d null) {\n\t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n\t\t}\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\tremoteBranchName \u003d branchName;\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d JGitText.get().localRepository;\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null) {\n\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n\t\t\t\t\t\tremoteBranchName));\n\t\t\t} else {\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d MessageFormat.format(\n\t\t\t\tJGitText.get().upstreamBranchName,\n\t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n\n\t\tPullResult result;\n\t\tif (pullRebaseMode.rebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n\t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tmerge.setStrategy(strategy);\n\t\t\tmerge.setProgressMonitor(monitor);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 184,
      "functionName": "call",
      "diff": "@@ -1,153 +1,154 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tif (remote \u003d\u003d null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\t\tremote \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode \u003d\u003d null) {\n \t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\tremoteBranchName \u003d branchName;\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d JGitText.get().localRepository;\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode.rebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n+\t\t\tmerge.setProgressMonitor(monitor);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "efacad0fc8e98505be6f007230ab2b1cdc1684f3": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Improve exception thrown when pull can\u0027t find advertised ref\n\n- throw an API exception instead of an internal exception to allow\napplications to handle this problem\n- improve error message to give hints about possible root causes\n\nBug: 464660\nChange-Id: Ib7d18bb2eeeac0fc218daea375b290ea5034bda1\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015-05-28, 6:15 p.m.",
      "commitName": "efacad0fc8e98505be6f007230ab2b1cdc1684f3",
      "commitAuthor": "Matthias Sohn",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Improve exception thrown when pull can\u0027t find advertised ref\n\n- throw an API exception instead of an internal exception to allow\napplications to handle this problem\n- improve error message to give hints about possible root causes\n\nBug: 464660\nChange-Id: Ib7d18bb2eeeac0fc218daea375b290ea5034bda1\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015-05-28, 6:15 p.m.",
          "commitName": "efacad0fc8e98505be6f007230ab2b1cdc1684f3",
          "commitAuthor": "Matthias Sohn",
          "commitDateOld": "2015-05-26, 4:52 a.m.",
          "commitNameOld": "2390531888af6dc9e4fda6cb026271dc068c40ab",
          "commitAuthorOld": "Matthias Sohn",
          "daysBetweenCommits": 2.56,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\n\t\t// determines whether rebase should be used after fetching\n\t\tif (pullRebaseMode \u003d\u003d null) {\n\t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n\t\t}\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\tremoteBranchName \u003d branchName;\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d JGitText.get().localRepository;\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null) {\n\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n\t\t\t\t\t\tremoteBranchName));\n\t\t\t} else {\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d MessageFormat.format(\n\t\t\t\tJGitText.get().upstreamBranchName,\n\t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n\n\t\tPullResult result;\n\t\tif (pullRebaseMode.rebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n\t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tmerge.setStrategy(strategy);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 180,
          "functionName": "call",
          "diff": "@@ -1,151 +1,153 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n-\t\t\tRefNotFoundException, NoHeadException,\n+\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tif (remote \u003d\u003d null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\t\tremote \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode \u003d\u003d null) {\n \t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\tremoteBranchName \u003d branchName;\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d JGitText.get().localRepository;\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n-\t\t\tif (r \u003d\u003d null)\n-\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n-\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n-\t\t\telse\n+\t\t\tif (r \u003d\u003d null) {\n+\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n+\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n+\t\t\t\t\t\tremoteBranchName));\n+\t\t\t} else {\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n+\t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode.rebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]",
            "newValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Improve exception thrown when pull can\u0027t find advertised ref\n\n- throw an API exception instead of an internal exception to allow\napplications to handle this problem\n- improve error message to give hints about possible root causes\n\nBug: 464660\nChange-Id: Ib7d18bb2eeeac0fc218daea375b290ea5034bda1\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015-05-28, 6:15 p.m.",
          "commitName": "efacad0fc8e98505be6f007230ab2b1cdc1684f3",
          "commitAuthor": "Matthias Sohn",
          "commitDateOld": "2015-05-26, 4:52 a.m.",
          "commitNameOld": "2390531888af6dc9e4fda6cb026271dc068c40ab",
          "commitAuthorOld": "Matthias Sohn",
          "daysBetweenCommits": 2.56,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\n\t\t// determines whether rebase should be used after fetching\n\t\tif (pullRebaseMode \u003d\u003d null) {\n\t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n\t\t}\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\tremoteBranchName \u003d branchName;\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d JGitText.get().localRepository;\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null) {\n\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n\t\t\t\t\t\tremoteBranchName));\n\t\t\t} else {\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d MessageFormat.format(\n\t\t\t\tJGitText.get().upstreamBranchName,\n\t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n\n\t\tPullResult result;\n\t\tif (pullRebaseMode.rebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n\t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tmerge.setStrategy(strategy);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 180,
          "functionName": "call",
          "diff": "@@ -1,151 +1,153 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n-\t\t\tRefNotFoundException, NoHeadException,\n+\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tif (remote \u003d\u003d null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\t\tremote \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode \u003d\u003d null) {\n \t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\tremoteBranchName \u003d branchName;\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d JGitText.get().localRepository;\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n-\t\t\tif (r \u003d\u003d null)\n-\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n-\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n-\t\t\telse\n+\t\t\tif (r \u003d\u003d null) {\n+\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n+\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n+\t\t\t\t\t\tremoteBranchName));\n+\t\t\t} else {\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n+\t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode.rebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "2390531888af6dc9e4fda6cb026271dc068c40ab": {
      "type": "Ybodychange",
      "commitMessage": "Externalize translatable texts in org.eclipse.jgit\n\nChange-Id: Ibf4c299f9d203c78cae79e61f88d4bea60ea2795\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015-05-26, 4:52 a.m.",
      "commitName": "2390531888af6dc9e4fda6cb026271dc068c40ab",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2014-07-15, 7:08 p.m.",
      "commitNameOld": "48544e27ae3808807dc1960083d8e42c05e62af3",
      "commitAuthorOld": "Konrad Kgler",
      "daysBetweenCommits": 314.41,
      "commitsBetweenForRepo": 408,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\n\t\t// determines whether rebase should be used after fetching\n\t\tif (pullRebaseMode \u003d\u003d null) {\n\t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n\t\t}\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\tremoteBranchName \u003d branchName;\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d JGitText.get().localRepository;\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d MessageFormat.format(\n\t\t\t\tJGitText.get().upstreamBranchName,\n\t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n\n\t\tPullResult result;\n\t\tif (pullRebaseMode.rebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n\t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tmerge.setStrategy(strategy);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 178,
      "functionName": "call",
      "diff": "@@ -1,151 +1,151 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tif (remote \u003d\u003d null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\t\tremote \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode \u003d\u003d null) {\n \t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\tremoteBranchName \u003d branchName;\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n-\t\t\tremoteUri \u003d \"local repository\";\n+\t\t\tremoteUri \u003d JGitText.get().localRepository;\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n-\t\tString upstreamName \u003d \"branch \\\u0027\"\n-\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n-\t\t\t\t+ remoteUri;\n+\t\tString upstreamName \u003d MessageFormat.format(\n+\t\t\t\tJGitText.get().upstreamBranchName,\n+\t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode.rebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "48544e27ae3808807dc1960083d8e42c05e62af3": {
      "type": "Ybodychange",
      "commitMessage": "Preserve merges during pull if configured to do so\n\nSetting branch.\u003cname\u003e.rebase or pull.rebase to \u0027preserve\u0027 will preserve\nmerges during rebase. Also, pull.rebase is now consulted if there is no\nbranch-specific configuration.\n\nBug: 429664\nChange-Id: I345fa295c7e774e0d0a8e6aba30fbfc3552e0084\nSigned-off-by: Konrad Kgler \u003cswamblumat-eclipsebugs@yahoo.de\u003e\n",
      "commitDate": "2014-07-15, 7:08 p.m.",
      "commitName": "48544e27ae3808807dc1960083d8e42c05e62af3",
      "commitAuthor": "Konrad Kgler",
      "commitDateOld": "2014-05-06, 10:30 a.m.",
      "commitNameOld": "7424d58255340fa44d9191a7436fbe70d72a457c",
      "commitAuthorOld": "Laurent Goubet",
      "daysBetweenCommits": 70.36,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\n\t\t// determines whether rebase should be used after fetching\n\t\tif (pullRebaseMode \u003d\u003d null) {\n\t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n\t\t}\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\tremoteBranchName \u003d branchName;\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d \"branch \\\u0027\"\n\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t+ remoteUri;\n\n\t\tPullResult result;\n\t\tif (pullRebaseMode.rebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n\t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tmerge.setStrategy(strategy);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 178,
      "functionName": "call",
      "diff": "@@ -1,163 +1,151 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tif (remote \u003d\u003d null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\t\tremote \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n-        // determines whether rebase should be used after fetching\n-        boolean doRebase \u003d false;\n-        switch (pullRebaseMode) {\n-            case REBASE:\n-                doRebase \u003d true;\n-                break;\n-            case NO_REBASE:\n-                doRebase \u003d false;\n-                break;\n-            case USE_CONFIG:\n-            default:\n-                // check if the branch is configured for pull-rebase\n-                doRebase \u003d repoConfig.getBoolean(\n-                        ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-                        ConfigConstants.CONFIG_KEY_REBASE, false);\n-                break;\n-        }\n+\t\t// determines whether rebase should be used after fetching\n+\t\tif (pullRebaseMode \u003d\u003d null) {\n+\t\t\tpullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n+\t\t}\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\tremoteBranchName \u003d branchName;\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d \"branch \\\u0027\"\n \t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n \t\t\t\t+ remoteUri;\n \n \t\tPullResult result;\n-\t\tif (doRebase) {\n+\t\tif (pullRebaseMode.rebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n+\t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7424d58255340fa44d9191a7436fbe70d72a457c": {
      "type": "Ybodychange",
      "commitMessage": "Allow callers to use different merging strategies\n\nSigned-off-by: Laurent Goubet \u003claurent.goubet@obeo.fr\u003e\nChange-Id: I84e9d7b4b772b4ad7d3e7010aad78291d4d178fe\n",
      "commitDate": "2014-05-06, 10:30 a.m.",
      "commitName": "7424d58255340fa44d9191a7436fbe70d72a457c",
      "commitAuthor": "Laurent Goubet",
      "commitDateOld": "2014-03-29, 1:34 p.m.",
      "commitNameOld": "32ff57a2b2b9480f4d374a2592fada7f720b124f",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 37.87,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\n        // determines whether rebase should be used after fetching\n        boolean doRebase \u003d false;\n        switch (pullRebaseMode) {\n            case REBASE:\n                doRebase \u003d true;\n                break;\n            case NO_REBASE:\n                doRebase \u003d false;\n                break;\n            case USE_CONFIG:\n            default:\n                // check if the branch is configured for pull-rebase\n                doRebase \u003d repoConfig.getBoolean(\n                        ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n                        ConfigConstants.CONFIG_KEY_REBASE, false);\n                break;\n        }\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\tremoteBranchName \u003d branchName;\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d \"branch \\\u0027\"\n\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t+ remoteUri;\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tmerge.setStrategy(strategy);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 157,
      "functionName": "call",
      "diff": "@@ -1,162 +1,163 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tif (remote \u003d\u003d null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\t\tremote \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n         // determines whether rebase should be used after fetching\n         boolean doRebase \u003d false;\n         switch (pullRebaseMode) {\n             case REBASE:\n                 doRebase \u003d true;\n                 break;\n             case NO_REBASE:\n                 doRebase \u003d false;\n                 break;\n             case USE_CONFIG:\n             default:\n                 // check if the branch is configured for pull-rebase\n                 doRebase \u003d repoConfig.getBoolean(\n                         ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n                         ConfigConstants.CONFIG_KEY_REBASE, false);\n                 break;\n         }\n \n \t\tif (remoteBranchName \u003d\u003d null)\n \t\t\tremoteBranchName \u003d branchName;\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d \"branch \\\u0027\"\n \t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n \t\t\t\t+ remoteUri;\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n-\t\t\t\t\t.setUpstreamName(upstreamName)\n-\t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n+\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n+\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n+\t\t\tmerge.setStrategy(strategy);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1eae309723be301a4f2fc12a3e07e7e7c9f30782": {
      "type": "Ybodychange",
      "commitMessage": "Allow programmatic remote configuration for PullCommand\n\nAlso imply remoteBranchName to match current branch name if it wasn\u0027t\nconfigured in branch configuration.\n\nBug: 424812\nChange-Id: Id852cedaefb2a537b6aa3c330b9861efad052f11\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014-02-14, 10:10 a.m.",
      "commitName": "1eae309723be301a4f2fc12a3e07e7e7c9f30782",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2012-12-27, 10:57 a.m.",
      "commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 413.97,
      "commitsBetweenForRepo": 508,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tif (remote \u003d\u003d null) {\n\t\t\t// get the configured remote for the currently checked out branch\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\t\tremote \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\t}\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\t// get the name of the branch in the remote repository\n\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\n        // determines whether rebase should be used after fetching\n        boolean doRebase \u003d false;\n        switch (pullRebaseMode) {\n            case REBASE:\n                doRebase \u003d true;\n                break;\n            case NO_REBASE:\n                doRebase \u003d false;\n                break;\n            case USE_CONFIG:\n            default:\n                // check if the branch is configured for pull-rebase\n                doRebase \u003d repoConfig.getBoolean(\n                        ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n                        ConfigConstants.CONFIG_KEY_REBASE, false);\n                break;\n        }\n\n\t\tif (remoteBranchName \u003d\u003d null)\n\t\t\tremoteBranchName \u003d branchName;\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d \"branch \\\u0027\"\n\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t+ remoteUri;\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName)\n\t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 152,
      "functionName": "call",
      "diff": "@@ -1,163 +1,162 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n-\t\t// get the configured remote for the currently checked out branch\n-\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n-\t\tString remote \u003d repoConfig.getString(\n-\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n+\t\tif (remote \u003d\u003d null) {\n+\t\t\t// get the configured remote for the currently checked out branch\n+\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n+\t\t\tremote \u003d repoConfig.getString(\n+\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n+\t\t}\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n-\t\t// get the name of the branch in the remote repository\n-\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n-\t\tString remoteBranchName \u003d repoConfig.getString(\n-\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\tif (remoteBranchName \u003d\u003d null)\n+\t\t\t// get the name of the branch in the remote repository\n+\t\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n+\t\t\tremoteBranchName \u003d repoConfig.getString(\n+\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n         // determines whether rebase should be used after fetching\n         boolean doRebase \u003d false;\n         switch (pullRebaseMode) {\n             case REBASE:\n                 doRebase \u003d true;\n                 break;\n             case NO_REBASE:\n                 doRebase \u003d false;\n                 break;\n             case USE_CONFIG:\n             default:\n                 // check if the branch is configured for pull-rebase\n                 doRebase \u003d repoConfig.getBoolean(\n                         ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n                         ConfigConstants.CONFIG_KEY_REBASE, false);\n                 break;\n         }\n \n-\t\tif (remoteBranchName \u003d\u003d null) {\n-\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n-\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n-\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n-\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n-\t\t}\n+\t\tif (remoteBranchName \u003d\u003d null)\n+\t\t\tremoteBranchName \u003d branchName;\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d \"branch \\\u0027\"\n \t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n \t\t\t\t+ remoteUri;\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName)\n \t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": {
      "type": "Ybodychange",
      "commitMessage": "Mark non-externalizable strings as such\n\nA few classes such as Constanrs are marked with @SuppressWarnings, as are\ntoString() methods with many liternal, but otherwise $NLS-n$ is used for\nstring containing text that should not be translated. A few literals may\nfall into the gray zone, but mostly I\u0027ve tried to only tag the obvious\nones.\n\nChange-Id: I22e50a77e2bf9e0b842a66bdf674e8fa1692f590\n",
      "commitDate": "2012-12-27, 10:57 a.m.",
      "commitName": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012-11-16, 3:51 p.m.",
      "commitNameOld": "fa5231191d530afb24810080e89990913c8e8054",
      "commitAuthorOld": "Mikael Karlsson",
      "daysBetweenCommits": 40.8,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\n        // determines whether rebase should be used after fetching\n        boolean doRebase \u003d false;\n        switch (pullRebaseMode) {\n            case REBASE:\n                doRebase \u003d true;\n                break;\n            case NO_REBASE:\n                doRebase \u003d false;\n                break;\n            case USE_CONFIG:\n            default:\n                // check if the branch is configured for pull-rebase\n                doRebase \u003d repoConfig.getBoolean(\n                        ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n                        ConfigConstants.CONFIG_KEY_REBASE, false);\n                break;\n        }\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d \"branch \\\u0027\"\n\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t+ remoteUri;\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName)\n\t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 148,
      "functionName": "call",
      "diff": "@@ -1,163 +1,163 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n         // determines whether rebase should be used after fetching\n         boolean doRebase \u003d false;\n         switch (pullRebaseMode) {\n             case REBASE:\n                 doRebase \u003d true;\n                 break;\n             case NO_REBASE:\n                 doRebase \u003d false;\n                 break;\n             case USE_CONFIG:\n             default:\n                 // check if the branch is configured for pull-rebase\n                 doRebase \u003d repoConfig.getBoolean(\n                         ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n                         ConfigConstants.CONFIG_KEY_REBASE, false);\n                 break;\n         }\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n-\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n+\t\tfinal boolean isRemote \u003d !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d \"branch \\\u0027\"\n \t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n \t\t\t\t+ remoteUri;\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName)\n \t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fa5231191d530afb24810080e89990913c8e8054": {
      "type": "Ybodychange",
      "commitMessage": "Add support for pull with --rebase and --no-rebase\n\nBug: 394501\nChange-Id: I697e2fc82a46c03762111eb1de93e673a2643b4f\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2012-11-16, 3:51 p.m.",
      "commitName": "fa5231191d530afb24810080e89990913c8e8054",
      "commitAuthor": "Mikael Karlsson",
      "commitDateOld": "2012-08-17, 6:11 p.m.",
      "commitNameOld": "5854ca091a22346e1c710ca9f875165afb3f2cc8",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 90.94,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\n        // determines whether rebase should be used after fetching\n        boolean doRebase \u003d false;\n        switch (pullRebaseMode) {\n            case REBASE:\n                doRebase \u003d true;\n                break;\n            case NO_REBASE:\n                doRebase \u003d false;\n                break;\n            case USE_CONFIG:\n            default:\n                // check if the branch is configured for pull-rebase\n                doRebase \u003d repoConfig.getBoolean(\n                        ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n                        ConfigConstants.CONFIG_KEY_REBASE, false);\n                break;\n        }\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d \"branch \\\u0027\"\n\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t+ remoteUri;\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName)\n\t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 148,
      "functionName": "call",
      "diff": "@@ -1,149 +1,163 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n-\t\t// check if the branch is configured for pull-rebase\n-\t\tboolean doRebase \u003d repoConfig.getBoolean(\n-\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n+\n+        // determines whether rebase should be used after fetching\n+        boolean doRebase \u003d false;\n+        switch (pullRebaseMode) {\n+            case REBASE:\n+                doRebase \u003d true;\n+                break;\n+            case NO_REBASE:\n+                doRebase \u003d false;\n+                break;\n+            case USE_CONFIG:\n+            default:\n+                // check if the branch is configured for pull-rebase\n+                doRebase \u003d repoConfig.getBoolean(\n+                        ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+                        ConfigConstants.CONFIG_KEY_REBASE, false);\n+                break;\n+        }\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName \u003d \"branch \\\u0027\"\n \t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n \t\t\t\t+ remoteUri;\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName)\n \t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5854ca091a22346e1c710ca9f875165afb3f2cc8": {
      "type": "Ybodychange",
      "commitMessage": "Improve ours/theirs conflict markers for rebase, cherry-pick\n\nOn conflicts in rebase or cherry-pick, the conflict markers were like\nthis:\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c OURS\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e THEIRS\n\nThis is technically correct, but it could be better.\n\nIt\u0027s especially confusing during a rebase, where the meaning of\nOURS/THEIRS is not obvious. The intuition is that \"ours\" is the commits\nthat \"I\" did before the rebase, but it\u0027s the other way around because of\nthe way rebase works. See various bug reports and stackoverflow\ndiscussions.\n\nWith this change, in the case of a cherry-pick while on master, the\nmarkers will be like this:\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c master\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e bad1dea Message of the commit I\u0027m cherry-picking\n\nIn the case of a \"git rebase master\":\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c Upstream, based on master\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e b161dea Message of a commit I\u0027m rebasing\n\nIt\u0027s not \"master\" because that would only be correct for the first\ncherry-pick during a rebase, after that, it\u0027s master + already\ncherry-picked commits.\n\nAnd in the case of a \"git pull --rebase\":\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c Upstream, based on branch \u0027master\u0027 of git@example.org:repo\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e b161dea Message of a commit I\u0027m rebasing\n\nBug: 336819\nChange-Id: I1333a8dd170bb0077f491962013485efb6f2a926\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2012-08-17, 6:11 p.m.",
      "commitName": "5854ca091a22346e1c710ca9f875165afb3f2cc8",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2012-06-05, 10:55 a.m.",
      "commitNameOld": "b61d35e848e637ef85fde4ebe95d60ced171e963",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 73.3,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tString upstreamName \u003d \"branch \\\u0027\"\n\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t+ remoteUri;\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setUpstreamName(upstreamName)\n\t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(upstreamName, commitToMerge);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 118,
      "functionName": "call",
      "diff": "@@ -1,147 +1,149 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase \u003d repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n+\t\tString upstreamName \u003d \"branch \\\u0027\"\n+\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n+\t\t\t\t+ remoteUri;\n+\n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n+\t\t\t\t\t.setUpstreamName(upstreamName)\n \t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n \t\t\t\t\t.call();\n \t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n-\t\t\tString name \u003d \"branch \\\u0027\"\n-\t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n-\t\t\t\t\t+ remoteUri;\n-\t\t\tmerge.include(name, commitToMerge);\n+\t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tMergeResult mergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b61d35e848e637ef85fde4ebe95d60ced171e963": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2012-06-05, 10:55 a.m.",
      "commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
      "commitAuthor": "Robin Rosenberg",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2012-06-05, 10:55 a.m.",
          "commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2012-05-30, 4:08 p.m.",
          "commitNameOld": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
          "commitAuthorOld": "Robin Rosenberg",
          "daysBetweenCommits": 5.78,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tString name \u003d \"branch \\\u0027\"\n\t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t\t+ remoteUri;\n\t\t\tmerge.include(name, commitToMerge);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 118,
          "functionName": "call",
          "diff": "@@ -1,171 +1,147 @@\n-\tpublic PullResult call() throws GitAPIException, WrongRepositoryStateException,\n-\t\t\tInvalidConfigurationException, DetachedHeadException,\n-\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException,\n-\t\t\tNoHeadException {\n+\tpublic PullResult call() throws GitAPIException,\n+\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n+\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n+\t\t\tRefNotFoundException, NoHeadException,\n+\t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase \u003d repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n-\t\t\ttry {\n-\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n-\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n-\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n-\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n-\t\t\t} catch (NoHeadException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (RefNotFoundException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (JGitInternalException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (GitAPIException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t}\n+\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n+\t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n+\t\t\t\t\t.call();\n+\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tString name \u003d \"branch \\\u0027\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n-\t\t\tMergeResult mergeRes;\n-\t\t\ttry {\n-\t\t\t\tmergeRes \u003d merge.call();\n-\t\t\t\tmonitor.update(1);\n-\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n-\t\t\t} catch (NoHeadException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (ConcurrentRefUpdateException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (CheckoutConflictException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (InvalidMergeHeadsException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (WrongRepositoryStateException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (NoMessageException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t}\n+\t\t\tMergeResult mergeRes \u003d merge.call();\n+\t\t\tmonitor.update(1);\n+\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException]",
            "newValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2012-06-05, 10:55 a.m.",
          "commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2012-05-30, 4:08 p.m.",
          "commitNameOld": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
          "commitAuthorOld": "Robin Rosenberg",
          "daysBetweenCommits": 5.78,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic PullResult call() throws GitAPIException,\n\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n\t\t\tRefNotFoundException, NoHeadException,\n\t\t\torg.eclipse.jgit.api.errors.TransportException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n\t\t\t\t\t.call();\n\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tString name \u003d \"branch \\\u0027\"\n\t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t\t+ remoteUri;\n\t\t\tmerge.include(name, commitToMerge);\n\t\t\tMergeResult mergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 118,
          "functionName": "call",
          "diff": "@@ -1,171 +1,147 @@\n-\tpublic PullResult call() throws GitAPIException, WrongRepositoryStateException,\n-\t\t\tInvalidConfigurationException, DetachedHeadException,\n-\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException,\n-\t\t\tNoHeadException {\n+\tpublic PullResult call() throws GitAPIException,\n+\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n+\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n+\t\t\tRefNotFoundException, NoHeadException,\n+\t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase \u003d repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n-\t\t\ttry {\n-\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n-\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n-\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n-\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n-\t\t\t} catch (NoHeadException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (RefNotFoundException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (JGitInternalException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (GitAPIException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t}\n+\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n+\t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n+\t\t\t\t\t.call();\n+\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tString name \u003d \"branch \\\u0027\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n-\t\t\tMergeResult mergeRes;\n-\t\t\ttry {\n-\t\t\t\tmergeRes \u003d merge.call();\n-\t\t\t\tmonitor.update(1);\n-\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n-\t\t\t} catch (NoHeadException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (ConcurrentRefUpdateException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (CheckoutConflictException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (InvalidMergeHeadsException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (WrongRepositoryStateException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (NoMessageException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t}\n+\t\t\tMergeResult mergeRes \u003d merge.call();\n+\t\t\tmonitor.update(1);\n+\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": {
      "type": "Yexceptionschange",
      "commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2012-05-30, 4:08 p.m.",
      "commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012-03-12, 10:20 a.m.",
      "commitNameOld": "95d311f8886f42f31a4475f84aa23c6345ab7059",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 79.24,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws GitAPIException, WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException,\n\t\t\tNoHeadException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\ttry {\n\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (RefNotFoundException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (JGitInternalException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (GitAPIException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tString name \u003d \"branch \\\u0027\"\n\t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t\t+ remoteUri;\n\t\t\tmerge.include(name, commitToMerge);\n\t\t\tMergeResult mergeRes;\n\t\t\ttry {\n\t\t\t\tmergeRes \u003d merge.call();\n\t\t\t\tmonitor.update(1);\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (CheckoutConflictException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (WrongRepositoryStateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (NoMessageException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 113,
      "functionName": "call",
      "diff": "@@ -1,171 +1,171 @@\n-\tpublic PullResult call() throws WrongRepositoryStateException,\n+\tpublic PullResult call() throws GitAPIException, WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException, RefNotFoundException,\n \t\t\tNoHeadException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (fullBranch \u003d\u003d null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase \u003d repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tString name \u003d \"branch \\\u0027\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes \u003d merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException]",
        "newValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException]"
      }
    },
    "c3fe50bb18ed4e4e5e563172be4076fa5901a18a": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Guard against null branch in PullCommand\n\nThrow a NoHeadException when Repository.getFullBranch\nreturns null\n\nBug: 351543\nChange-Id: I666cd5b67781508a293ae553c6fe5c080c8f4d99\nSigned-off-by: Kevin Sawicki \u003ckevin@github.com\u003e",
      "commitDate": "2011-11-22, 7:29 p.m.",
      "commitName": "c3fe50bb18ed4e4e5e563172be4076fa5901a18a",
      "commitAuthor": "Kevin Sawicki",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Guard against null branch in PullCommand\n\nThrow a NoHeadException when Repository.getFullBranch\nreturns null\n\nBug: 351543\nChange-Id: I666cd5b67781508a293ae553c6fe5c080c8f4d99\nSigned-off-by: Kevin Sawicki \u003ckevin@github.com\u003e",
          "commitDate": "2011-11-22, 7:29 p.m.",
          "commitName": "c3fe50bb18ed4e4e5e563172be4076fa5901a18a",
          "commitAuthor": "Kevin Sawicki",
          "commitDateOld": "2011-11-10, 1:57 p.m.",
          "commitNameOld": "da901c49688ef72858cd2b6904e0f8e478fa0ec3",
          "commitAuthorOld": "Kevin Sawicki",
          "daysBetweenCommits": 12.23,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException,\n\t\t\tNoHeadException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\ttry {\n\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (RefNotFoundException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (JGitInternalException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (GitAPIException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tString name \u003d \"branch \\\u0027\"\n\t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t\t+ remoteUri;\n\t\t\tmerge.include(name, commitToMerge);\n\t\t\tMergeResult mergeRes;\n\t\t\ttry {\n\t\t\t\tmergeRes \u003d merge.call();\n\t\t\t\tmonitor.update(1);\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (CheckoutConflictException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (WrongRepositoryStateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (NoMessageException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 113,
          "functionName": "call",
          "diff": "@@ -1,167 +1,171 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n-\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n+\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException,\n+\t\t\tNoHeadException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n+\t\t\tif (fullBranch \u003d\u003d null)\n+\t\t\t\tthrow new NoHeadException(\n+\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase \u003d repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tString name \u003d \"branch \\\u0027\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes \u003d merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException]",
            "newValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Guard against null branch in PullCommand\n\nThrow a NoHeadException when Repository.getFullBranch\nreturns null\n\nBug: 351543\nChange-Id: I666cd5b67781508a293ae553c6fe5c080c8f4d99\nSigned-off-by: Kevin Sawicki \u003ckevin@github.com\u003e",
          "commitDate": "2011-11-22, 7:29 p.m.",
          "commitName": "c3fe50bb18ed4e4e5e563172be4076fa5901a18a",
          "commitAuthor": "Kevin Sawicki",
          "commitDateOld": "2011-11-10, 1:57 p.m.",
          "commitNameOld": "da901c49688ef72858cd2b6904e0f8e478fa0ec3",
          "commitAuthorOld": "Kevin Sawicki",
          "daysBetweenCommits": 12.23,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException,\n\t\t\tNoHeadException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (fullBranch \u003d\u003d null)\n\t\t\t\tthrow new NoHeadException(\n\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\ttry {\n\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (RefNotFoundException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (JGitInternalException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (GitAPIException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tString name \u003d \"branch \\\u0027\"\n\t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t\t+ remoteUri;\n\t\t\tmerge.include(name, commitToMerge);\n\t\t\tMergeResult mergeRes;\n\t\t\ttry {\n\t\t\t\tmergeRes \u003d merge.call();\n\t\t\t\tmonitor.update(1);\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (CheckoutConflictException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (WrongRepositoryStateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (NoMessageException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 113,
          "functionName": "call",
          "diff": "@@ -1,167 +1,171 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n-\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n+\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException,\n+\t\t\tNoHeadException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n+\t\t\tif (fullBranch \u003d\u003d null)\n+\t\t\t\tthrow new NoHeadException(\n+\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase \u003d repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tString name \u003d \"branch \\\u0027\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes \u003d merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "da901c49688ef72858cd2b6904e0f8e478fa0ec3": {
      "type": "Ybodychange",
      "commitMessage": "Support a configured credentials provider in LsRemoteCommand\n\nRefactored the three common transport configuration options:\ncredentials provider, timeout, and transport config callback\ninto a new TransportCommand base class which is now extended\nby all commands that use a Transport object during execution.\n\nBug: 349188\nChange-Id: I90c2c14fb4e3cc4712905158f9047153a0c235c2\nSigned-off-by: Kevin Sawicki \u003ckevin@github.com\u003e\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2011-11-10, 1:57 p.m.",
      "commitName": "da901c49688ef72858cd2b6904e0f8e478fa0ec3",
      "commitAuthor": "Kevin Sawicki",
      "commitDateOld": "2011-09-16, 11:04 a.m.",
      "commitNameOld": "791a9fd691e5ae101650f27f39366ec7b23f3955",
      "commitAuthorOld": "Roberto Tyley",
      "daysBetweenCommits": 55.16,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tconfigure(fetch);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\ttry {\n\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (RefNotFoundException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (JGitInternalException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (GitAPIException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tString name \u003d \"branch \\\u0027\"\n\t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t\t+ remoteUri;\n\t\t\tmerge.include(name, commitToMerge);\n\t\t\tMergeResult mergeRes;\n\t\t\ttry {\n\t\t\t\tmergeRes \u003d merge.call();\n\t\t\t\tmonitor.update(1);\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (CheckoutConflictException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (WrongRepositoryStateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (NoMessageException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 113,
      "functionName": "call",
      "diff": "@@ -1,169 +1,167 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase \u003d repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n-\t\t\tfetch.setTimeout(this.timeout);\n-\t\t\tfetch.setCredentialsProvider(credentialsProvider);\n-\t\t\tfetch.setTransportConfigCallback(transportConfigCallback);\n+\t\t\tconfigure(fetch);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tString name \u003d \"branch \\\u0027\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes \u003d merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "791a9fd691e5ae101650f27f39366ec7b23f3955": {
      "type": "Ybodychange",
      "commitMessage": "Enable full Transport configuration for JGit API commands\n\nAdd a TransportConfigCallback parameter to JGit API commands, to allow\nconsumers of the JGit command API to perform custom Transport configuration\nthat would be otherwise difficult to anticipate \u0026 expose on the API command\nbuilders.\n\n\nMy specific use-case is configuring additional properties on SshTransport\n- I need to take over the SshSessionFactory used by the transport. Using\nTransportConfigCallback I can simply do this (rather than reimplement the\nAPI command classes):\n\npublic void configure(Transport tn) {\n  if (tn instanceof SshTransport) {\n    ((SshTransport) tn).setSshSessionFactory(factoryProvider.get());\n  }\n}\n\nAdding an explicit setSshSessionFactory() method to the JGit command\nclasses would bloat the API. Also, creating the replacement\nSshSessionFactory is unnecessary if the transport is not SSH, but the type\nof the Transport is only known once the remote has been resolved and the\nURI parsed - consequently it makes sense to perform this step in a\ncallback, where the transport instance can be inspected to determine if\nit\u0027s of a relevant type.\n\n\nA note about where this leaves the API - there are now 4 commands:\n\nCloneCommand\nPullCommand\nFetchCommand\nPushCommand\n\n-that share 3 identical transport-related parameters:\n\ntimeout\ncredentialsProvider\ntransportConfigurator\n\nI think there\u0027s potential for introducing an interface or val-object to\nidentify/encapsulate this repetition, which I\u0027d be happy to do in a\nsubsequent commit.\n\nChange-Id: I8983c3627cdd7d7b2aeb0b6a3dadee553378b951\nSigned-off-by: Roberto Tyley \u003croberto.tyley@gmail.com\u003e\n",
      "commitDate": "2011-09-16, 11:04 a.m.",
      "commitName": "791a9fd691e5ae101650f27f39366ec7b23f3955",
      "commitAuthor": "Roberto Tyley",
      "commitDateOld": "2011-08-02, 10:19 a.m.",
      "commitNameOld": "6d293c7b06e219086959e80d495b5febe8ae530d",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 45.03,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tfetch.setTimeout(this.timeout);\n\t\t\tfetch.setCredentialsProvider(credentialsProvider);\n\t\t\tfetch.setTransportConfigCallback(transportConfigCallback);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\ttry {\n\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (RefNotFoundException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (JGitInternalException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (GitAPIException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tString name \u003d \"branch \\\u0027\"\n\t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t\t+ remoteUri;\n\t\t\tmerge.include(name, commitToMerge);\n\t\t\tMergeResult mergeRes;\n\t\t\ttry {\n\t\t\t\tmergeRes \u003d merge.call();\n\t\t\t\tmonitor.update(1);\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (CheckoutConflictException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (WrongRepositoryStateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (NoMessageException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 156,
      "functionName": "call",
      "diff": "@@ -1,168 +1,169 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase \u003d repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n+\t\t\tfetch.setTransportConfigCallback(transportConfigCallback);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tString name \u003d \"branch \\\u0027\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes \u003d merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6d293c7b06e219086959e80d495b5febe8ae530d": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t hard-code section names, use ConfigConstants instead\n\nChange-Id: Ie2dde43da491fa27b25a2ad8014866d77d484b24\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2011-08-02, 10:19 a.m.",
      "commitName": "6d293c7b06e219086959e80d495b5febe8ae530d",
      "commitAuthor": "Tomasz Zarna",
      "commitDateOld": "2011-03-22, 2:46 p.m.",
      "commitNameOld": "770c733687d9f2f71f30822f9691427bf83b7577",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 132.81,
      "commitsBetweenForRepo": 160,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tfetch.setTimeout(this.timeout);\n\t\t\tfetch.setCredentialsProvider(credentialsProvider);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\ttry {\n\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (RefNotFoundException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (JGitInternalException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (GitAPIException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tString name \u003d \"branch \\\u0027\"\n\t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t\t+ remoteUri;\n\t\t\tmerge.include(name, commitToMerge);\n\t\t\tMergeResult mergeRes;\n\t\t\ttry {\n\t\t\t\tmergeRes \u003d merge.call();\n\t\t\t\tmonitor.update(1);\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (CheckoutConflictException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (WrongRepositoryStateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (NoMessageException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 139,
      "functionName": "call",
      "diff": "@@ -1,167 +1,168 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase \u003d repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n-\t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n+\t\t\tremoteUri \u003d repoConfig.getString(\n+\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tString name \u003d \"branch \\\u0027\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes \u003d merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "770c733687d9f2f71f30822f9691427bf83b7577": {
      "type": "Ybodychange",
      "commitMessage": "PullCommand: Use short ref name in merge message\n\nAdd a test case for PullCommand for the successful merge case and test\nthat the short ref name is used.\n\nChange-Id: I16cbbc88595f73e5512f984e67f93f87ee0fe242\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\n",
      "commitDate": "2011-03-22, 2:46 p.m.",
      "commitName": "770c733687d9f2f71f30822f9691427bf83b7577",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2011-02-16, 9:46 a.m.",
      "commitNameOld": "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 34.17,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tfetch.setTimeout(this.timeout);\n\t\t\tfetch.setCredentialsProvider(credentialsProvider);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\ttry {\n\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (RefNotFoundException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (JGitInternalException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (GitAPIException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tString name \u003d \"branch \\\u0027\"\n\t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n\t\t\t\t\t+ remoteUri;\n\t\t\tmerge.include(name, commitToMerge);\n\t\t\tMergeResult mergeRes;\n\t\t\ttry {\n\t\t\t\tmergeRes \u003d merge.call();\n\t\t\t\tmonitor.update(1);\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (CheckoutConflictException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (WrongRepositoryStateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (NoMessageException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 139,
      "functionName": "call",
      "diff": "@@ -1,166 +1,167 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase \u003d repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge \u003d\u003d null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n-\t\t\tmerge.include(\n-\t\t\t\t\t\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n-\t\t\t\t\tcommitToMerge);\n+\t\t\tString name \u003d \"branch \\\u0027\"\n+\t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \"\n+\t\t\t\t\t+ remoteUri;\n+\t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes \u003d merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "68459b646e6c8243dc5650cbe08ce1bcdb8a621d": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Fix NullPointer when pulling from a deleted local branch\n\nA checked Exception is thrown instead. \n\nThe reason for throwing an Exception is that the state of the\nrepository is inconsistent in this case: There is a merge\nconfiguration containing a non-existing local branch. Ideally the\ndeletion of a local branch should also delete the corresponding\nmerge configuration.\n\nBug: 337315\nChange-Id: I71e56ffb90e11e6e3c1bbd964ad63972d67990c0\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e",
      "commitDate": "2011-02-16, 9:46 a.m.",
      "commitName": "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
      "commitAuthor": "Stefan Lay",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Fix NullPointer when pulling from a deleted local branch\n\nA checked Exception is thrown instead. \n\nThe reason for throwing an Exception is that the state of the\nrepository is inconsistent in this case: There is a merge\nconfiguration containing a non-existing local branch. Ideally the\ndeletion of a local branch should also delete the corresponding\nmerge configuration.\n\nBug: 337315\nChange-Id: I71e56ffb90e11e6e3c1bbd964ad63972d67990c0\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e",
          "commitDate": "2011-02-16, 9:46 a.m.",
          "commitName": "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
          "commitAuthor": "Stefan Lay",
          "commitDateOld": "2011-02-08, 2:56 a.m.",
          "commitNameOld": "724af77c65c27eb24d41989bed3229910dbe063c",
          "commitAuthorOld": "Mathias Kinzler",
          "daysBetweenCommits": 8.28,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tfetch.setTimeout(this.timeout);\n\t\t\tfetch.setCredentialsProvider(credentialsProvider);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\ttry {\n\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (RefNotFoundException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (JGitInternalException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (GitAPIException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(\n\t\t\t\t\t\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n\t\t\t\t\tcommitToMerge);\n\t\t\tMergeResult mergeRes;\n\t\t\ttry {\n\t\t\t\tmergeRes \u003d merge.call();\n\t\t\t\tmonitor.update(1);\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (CheckoutConflictException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (WrongRepositoryStateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (NoMessageException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 139,
          "functionName": "call",
          "diff": "@@ -1,163 +1,166 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n-\t\t\tInvalidRemoteException, CanceledException {\n+\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase \u003d repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n+\t\t\t\tif (commitToMerge \u003d\u003d null)\n+\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(\n \t\t\t\t\t\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n \t\t\t\t\tcommitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes \u003d merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException]",
            "newValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fix NullPointer when pulling from a deleted local branch\n\nA checked Exception is thrown instead. \n\nThe reason for throwing an Exception is that the state of the\nrepository is inconsistent in this case: There is a merge\nconfiguration containing a non-existing local branch. Ideally the\ndeletion of a local branch should also delete the corresponding\nmerge configuration.\n\nBug: 337315\nChange-Id: I71e56ffb90e11e6e3c1bbd964ad63972d67990c0\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e",
          "commitDate": "2011-02-16, 9:46 a.m.",
          "commitName": "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
          "commitAuthor": "Stefan Lay",
          "commitDateOld": "2011-02-08, 2:56 a.m.",
          "commitNameOld": "724af77c65c27eb24d41989bed3229910dbe063c",
          "commitAuthorOld": "Mathias Kinzler",
          "daysBetweenCommits": 8.28,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tfetch.setTimeout(this.timeout);\n\t\t\tfetch.setCredentialsProvider(credentialsProvider);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\tif (commitToMerge \u003d\u003d null)\n\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\ttry {\n\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (RefNotFoundException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (JGitInternalException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (GitAPIException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(\n\t\t\t\t\t\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n\t\t\t\t\tcommitToMerge);\n\t\t\tMergeResult mergeRes;\n\t\t\ttry {\n\t\t\t\tmergeRes \u003d merge.call();\n\t\t\t\tmonitor.update(1);\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (CheckoutConflictException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (WrongRepositoryStateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (NoMessageException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 139,
          "functionName": "call",
          "diff": "@@ -1,163 +1,166 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n-\t\t\tInvalidRemoteException, CanceledException {\n+\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null)\n \t\t\t// fall back to default remote\n \t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase \u003d repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n+\t\t\t\tif (commitToMerge \u003d\u003d null)\n+\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(\n \t\t\t\t\t\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n \t\t\t\t\tcommitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes \u003d merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "724af77c65c27eb24d41989bed3229910dbe063c": {
      "type": "Ybodychange",
      "commitMessage": "PullCommand: use default remote instead of throwing Exception\n\nWhen pulling into a local branch that has no upstream configuration,\npull should try to used the default remote (\"origin\") instead of\nthrowing an Exception.\n\nBug: 336504\nChange-Id: Ife75858e89ea79c0d6d88ba73877fe8400448e34\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2011-02-08, 2:56 a.m.",
      "commitName": "724af77c65c27eb24d41989bed3229910dbe063c",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2011-01-31, 6:12 a.m.",
      "commitNameOld": "b15b9d5df25b375108ca125b31338df637454865",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 7.86,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tString remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null)\n\t\t\t// fall back to default remote\n\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tfetch.setTimeout(this.timeout);\n\t\t\tfetch.setCredentialsProvider(credentialsProvider);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\ttry {\n\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (RefNotFoundException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (JGitInternalException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (GitAPIException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(\n\t\t\t\t\t\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n\t\t\t\t\tcommitToMerge);\n\t\t\tMergeResult mergeRes;\n\t\t\ttry {\n\t\t\t\tmergeRes \u003d merge.call();\n\t\t\t\tmonitor.update(1);\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (CheckoutConflictException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (WrongRepositoryStateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (NoMessageException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 139,
      "functionName": "call",
      "diff": "@@ -1,166 +1,163 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n-\t\tfinal String remote \u003d repoConfig.getString(\n+\t\tString remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n-\t\tif (remote \u003d\u003d null) {\n-\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n-\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n-\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n-\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n-\t\t}\n+\t\tif (remote \u003d\u003d null)\n+\t\t\t// fall back to default remote\n+\t\t\tremote \u003d Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase \u003d repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(\n \t\t\t\t\t\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n \t\t\t\t\tcommitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes \u003d merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b15b9d5df25b375108ca125b31338df637454865": {
      "type": "Ybodychange",
      "commitMessage": "Proper handling of rebase during pull\n\nAfter consulting with Christian Halstrick, it turned out that the\nhandling of rebase during pull was implemented incorrectly.\n\nChange-Id: I40f03409e080cdfeceb21460150f5e02a016e7f4\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2011-01-31, 6:12 a.m.",
      "commitName": "b15b9d5df25b375108ca125b31338df637454865",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2011-01-28, 3:06 p.m.",
      "commitNameOld": "9fbda2239202ca9d3a20c84d7326f47c667aa920",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 2.63,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tfinal String remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t// check if the branch is configured for pull-rebase\n\t\tboolean doRebase \u003d repoConfig.getBoolean(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tfetch.setTimeout(this.timeout);\n\t\t\tfetch.setCredentialsProvider(credentialsProvider);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t// we check the updates to see which of the updated branches\n\t\t// corresponds\n\t\t// to the remote branch name\n\t\tAnyObjectId commitToMerge;\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\ttry {\n\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (RefNotFoundException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (JGitInternalException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (GitAPIException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(\n\t\t\t\t\t\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n\t\t\t\t\tcommitToMerge);\n\t\t\tMergeResult mergeRes;\n\t\t\ttry {\n\t\t\t\tmergeRes \u003d merge.call();\n\t\t\t\tmonitor.update(1);\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (CheckoutConflictException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (WrongRepositoryStateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (NoMessageException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 139,
      "functionName": "call",
      "diff": "@@ -1,173 +1,166 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tfinal String remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n-\t\tboolean doRebase \u003d false;\n-\t\tif (remoteBranchName \u003d\u003d null) {\n-\t\t\t// check if the branch is configured for pull-rebase\n-\t\t\tremoteBranchName \u003d repoConfig.getString(\n-\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n-\t\t\tif (remoteBranchName !\u003d null) {\n-\t\t\t\tdoRebase \u003d true;\n-\t\t\t}\n-\t\t}\n+\t\t// check if the branch is configured for pull-rebase\n+\t\tboolean doRebase \u003d repoConfig.getBoolean(\n+\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n+\t\t// we check the updates to see which of the updated branches\n+\t\t// corresponds\n+\t\t// to the remote branch name\n+\t\tAnyObjectId commitToMerge;\n+\t\tif (isRemote) {\n+\t\t\tRef r \u003d null;\n+\t\t\tif (fetchRes !\u003d null) {\n+\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n+\t\t\t\tif (r \u003d\u003d null)\n+\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n+\t\t\t\t\t\t\t+ remoteBranchName);\n+\t\t\t}\n+\t\t\tif (r \u003d\u003d null)\n+\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n+\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n+\t\t\telse\n+\t\t\t\tcommitToMerge \u003d r.getObjectId();\n+\t\t} else {\n+\t\t\ttry {\n+\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new JGitInternalException(\n+\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n+\t\t\t\t\t\te);\n+\t\t\t}\n+\t\t}\n+\n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\ttry {\n-\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(remoteBranchName)\n+\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n-\t\t\t// we check the updates to see which of the updated branches\n-\t\t\t// corresponds\n-\t\t\t// to the remote branch name\n-\t\t\tAnyObjectId commitToMerge;\n-\n-\t\t\tif (isRemote) {\n-\t\t\t\tRef r \u003d null;\n-\t\t\t\tif (fetchRes !\u003d null) {\n-\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n-\t\t\t\t\tif (r \u003d\u003d null)\n-\t\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n-\t\t\t\t\t\t\t\t+ remoteBranchName);\n-\t\t\t\t}\n-\t\t\t\tif (r \u003d\u003d null)\n-\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n-\t\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef,\n-\t\t\t\t\t\t\tremoteBranchName));\n-\t\t\t\telse\n-\t\t\t\t\tcommitToMerge \u003d r.getObjectId();\n-\t\t\t} else {\n-\t\t\t\ttry {\n-\t\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tthrow new JGitInternalException(\n-\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n-\t\t\t\t\t\t\te);\n-\t\t\t\t}\n-\t\t\t}\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(\n \t\t\t\t\t\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n \t\t\t\t\tcommitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes \u003d merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9fbda2239202ca9d3a20c84d7326f47c667aa920": {
      "type": "Ybodychange",
      "commitMessage": "Add setCredentialsProvider to PullCommand\n\nBug: 335703\nChange-Id: Id9713a4849c772e030fca23dd64b993264f28366\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011-01-28, 3:06 p.m.",
      "commitName": "9fbda2239202ca9d3a20c84d7326f47c667aa920",
      "commitAuthor": "Tomasz Zarna",
      "commitDateOld": "2011-01-28, 9:04 a.m.",
      "commitNameOld": "14ca80bc90ed85e3484fa28aa665fa0538096d30",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tfinal String remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\tboolean doRebase \u003d false;\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\t// check if the branch is configured for pull-rebase\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n\t\t\tif (remoteBranchName !\u003d null) {\n\t\t\t\tdoRebase \u003d true;\n\t\t\t}\n\t\t}\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tfetch.setTimeout(this.timeout);\n\t\t\tfetch.setCredentialsProvider(credentialsProvider);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\ttry {\n\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(remoteBranchName)\n\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (RefNotFoundException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (JGitInternalException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (GitAPIException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t\t// we check the updates to see which of the updated branches\n\t\t\t// corresponds\n\t\t\t// to the remote branch name\n\t\t\tAnyObjectId commitToMerge;\n\n\t\t\tif (isRemote) {\n\t\t\t\tRef r \u003d null;\n\t\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t\t}\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef,\n\t\t\t\t\t\t\tremoteBranchName));\n\t\t\t\telse\n\t\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\t\te);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(\n\t\t\t\t\t\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n\t\t\t\t\tcommitToMerge);\n\t\t\tMergeResult mergeRes;\n\t\t\ttry {\n\t\t\t\tmergeRes \u003d merge.call();\n\t\t\t\tmonitor.update(1);\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (CheckoutConflictException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (WrongRepositoryStateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (NoMessageException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 139,
      "functionName": "call",
      "diff": "@@ -1,172 +1,173 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tfinal String remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\tboolean doRebase \u003d false;\n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\t// check if the branch is configured for pull-rebase\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n \t\t\tif (remoteBranchName !\u003d null) {\n \t\t\t\tdoRebase \u003d true;\n \t\t\t}\n \t\t}\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n+\t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(remoteBranchName)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\t// we check the updates to see which of the updated branches\n \t\t\t// corresponds\n \t\t\t// to the remote branch name\n \t\t\tAnyObjectId commitToMerge;\n \n \t\t\tif (isRemote) {\n \t\t\t\tRef r \u003d null;\n \t\t\t\tif (fetchRes !\u003d null) {\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t\t}\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef,\n \t\t\t\t\t\t\tremoteBranchName));\n \t\t\t\telse\n \t\t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t\t} else {\n \t\t\t\ttry {\n \t\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\t\te);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\t\tmerge.include(\n \t\t\t\t\t\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n \t\t\t\t\tcommitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes \u003d merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "14ca80bc90ed85e3484fa28aa665fa0538096d30": {
      "type": "Ybodychange",
      "commitMessage": "Make PullCommand work with Rebase\n\nRebase must honor the upstream configuration\n\nbranch.\u003cbranchname\u003e.rebase\n\nChange-Id: Ic94f263d3f47b630ad75bd5412cb4741bb1109ca\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2011-01-28, 9:04 a.m.",
      "commitName": "14ca80bc90ed85e3484fa28aa665fa0538096d30",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010-12-15, 6:14 p.m.",
      "commitNameOld": "013cb8de3824c304645a9c5db87c2e80286872d1",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 43.62,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tfinal String remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\tboolean doRebase \u003d false;\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\t// check if the branch is configured for pull-rebase\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n\t\t\tif (remoteBranchName !\u003d null) {\n\t\t\t\tdoRebase \u003d true;\n\t\t\t}\n\t\t}\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tfetch.setTimeout(this.timeout);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\tPullResult result;\n\t\tif (doRebase) {\n\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n\t\t\ttry {\n\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(remoteBranchName)\n\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (RefNotFoundException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (JGitInternalException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (GitAPIException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t\t// we check the updates to see which of the updated branches\n\t\t\t// corresponds\n\t\t\t// to the remote branch name\n\t\t\tAnyObjectId commitToMerge;\n\n\t\t\tif (isRemote) {\n\t\t\t\tRef r \u003d null;\n\t\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t\t}\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef,\n\t\t\t\t\t\t\tremoteBranchName));\n\t\t\t\telse\n\t\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\t\te);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\t\tmerge.include(\n\t\t\t\t\t\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n\t\t\t\t\tcommitToMerge);\n\t\t\tMergeResult mergeRes;\n\t\t\ttry {\n\t\t\t\tmergeRes \u003d merge.call();\n\t\t\t\tmonitor.update(1);\n\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n\t\t\t} catch (NoHeadException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (CheckoutConflictException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (WrongRepositoryStateException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t} catch (NoMessageException e) {\n\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn result;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 124,
      "functionName": "call",
      "diff": "@@ -1,152 +1,172 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tfinal String remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\tboolean doRebase \u003d false;\n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\t// check if the branch is configured for pull-rebase\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n \t\t\tif (remoteBranchName !\u003d null) {\n-\t\t\t\t// TODO implement pull-rebase\n-\t\t\t\tthrow new JGitInternalException(\n-\t\t\t\t\t\t\"Pull with rebase is not yet supported\");\n+\t\t\t\tdoRebase \u003d true;\n \t\t\t}\n \t\t}\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n-\t\t// we check the updates to see which of the updated branches corresponds\n-\t\t// to the remote branch name\n-\n-\t\tAnyObjectId commitToMerge;\n-\n-\t\tif (isRemote) {\n-\t\t\tRef r \u003d null;\n-\t\t\tif (fetchRes !\u003d null) {\n-\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n-\t\t\t\tif (r \u003d\u003d null)\n-\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n-\t\t\t\t\t\t\t+ remoteBranchName);\n-\t\t\t}\n-\t\t\tif (r \u003d\u003d null)\n-\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n-\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n-\t\t\telse\n-\t\t\t\tcommitToMerge \u003d r.getObjectId();\n-\t\t} else {\n-\t\t\ttry {\n-\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tthrow new JGitInternalException(\n-\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n-\t\t\t\t\t\te);\n-\t\t\t}\n-\t\t}\n-\n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n-\t\tMergeCommand merge \u003d new MergeCommand(repo);\n-\t\tmerge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n-\t\t\t\tcommitToMerge);\n-\t\tMergeResult mergeRes;\n-\t\ttry {\n-\t\t\tmergeRes \u003d merge.call();\n-\t\t\tmonitor.update(1);\n-\t\t} catch (NoHeadException e) {\n-\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t} catch (ConcurrentRefUpdateException e) {\n-\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t} catch (CheckoutConflictException e) {\n-\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t} catch (InvalidMergeHeadsException e) {\n-\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t} catch (WrongRepositoryStateException e) {\n-\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t} catch (NoMessageException e) {\n-\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\tPullResult result;\n+\t\tif (doRebase) {\n+\t\t\tRebaseCommand rebase \u003d new RebaseCommand(repo);\n+\t\t\ttry {\n+\t\t\t\tRebaseResult rebaseRes \u003d rebase.setUpstream(remoteBranchName)\n+\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n+\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n+\t\t\t\tresult \u003d new PullResult(fetchRes, remote, rebaseRes);\n+\t\t\t} catch (NoHeadException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (RefNotFoundException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (JGitInternalException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (GitAPIException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// we check the updates to see which of the updated branches\n+\t\t\t// corresponds\n+\t\t\t// to the remote branch name\n+\t\t\tAnyObjectId commitToMerge;\n+\n+\t\t\tif (isRemote) {\n+\t\t\t\tRef r \u003d null;\n+\t\t\t\tif (fetchRes !\u003d null) {\n+\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n+\t\t\t\t\tif (r \u003d\u003d null)\n+\t\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n+\t\t\t\t\t\t\t\t+ remoteBranchName);\n+\t\t\t\t}\n+\t\t\t\tif (r \u003d\u003d null)\n+\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef,\n+\t\t\t\t\t\t\tremoteBranchName));\n+\t\t\t\telse\n+\t\t\t\t\tcommitToMerge \u003d r.getObjectId();\n+\t\t\t} else {\n+\t\t\t\ttry {\n+\t\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n+\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\tthrow new JGitInternalException(\n+\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n+\t\t\t\t\t\t\te);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tMergeCommand merge \u003d new MergeCommand(repo);\n+\t\t\tmerge.include(\n+\t\t\t\t\t\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n+\t\t\t\t\tcommitToMerge);\n+\t\t\tMergeResult mergeRes;\n+\t\t\ttry {\n+\t\t\t\tmergeRes \u003d merge.call();\n+\t\t\t\tmonitor.update(1);\n+\t\t\t\tresult \u003d new PullResult(fetchRes, remote, mergeRes);\n+\t\t\t} catch (NoHeadException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (ConcurrentRefUpdateException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (CheckoutConflictException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (InvalidMergeHeadsException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (WrongRepositoryStateException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (NoMessageException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n-\t\treturn new PullResult(fetchRes, remote, mergeRes);\n+\t\treturn result;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "013cb8de3824c304645a9c5db87c2e80286872d1": {
      "type": "Ybodychange",
      "commitMessage": "Reduce calls to Repository.getConfig\n\nEach time getConfig() is called on FileRepository, it checks the\nlast modified time of both ~/.gitconfig and $GIT_DIR?config.  If\n$GIT_DIR/config appears to have been modified, it is read back in\nfrom disk and the current config is wiped out.\n\nWhen mutating a configuration file, this may cause in-memory edits\nto disappear.  To avoid that callers need to avoid calling getConfig\nuntil after the configuration has been saved to disk.\n\nUnfortunately the API is still horribly broken.  Configuration should\nbe modified only while a lock is held on the configuration file, very\nsimilar to the way a ref is updated via its locking protocol.  But our\nexisting API is really broken for that so we\u0027ll have to defer cleaning\nup the edit path for a future change.\n\nChange-Id: I5888dd97bac20ddf60456c81ffc1eb8df04ef410\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-12-15, 6:14 p.m.",
      "commitName": "013cb8de3824c304645a9c5db87c2e80286872d1",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-10-29, 9:12 a.m.",
      "commitNameOld": "d36c80fd048fc55d7ac31ae62eb67fbac9b12e31",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 47.42,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tfinal String remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\t// check if the branch is configured for pull-rebase\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n\t\t\tif (remoteBranchName !\u003d null) {\n\t\t\t\t// TODO implement pull-rebase\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\"Pull with rebase is not yet supported\");\n\t\t\t}\n\t\t}\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tfetch.setTimeout(this.timeout);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\t// we check the updates to see which of the updated branches corresponds\n\t\t// to the remote branch name\n\n\t\tAnyObjectId commitToMerge;\n\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\tmerge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n\t\t\t\tcommitToMerge);\n\t\tMergeResult mergeRes;\n\t\ttry {\n\t\t\tmergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t} catch (NoHeadException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (CheckoutConflictException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (WrongRepositoryStateException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (NoMessageException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn new PullResult(fetchRes, remote, mergeRes);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 121,
      "functionName": "call",
      "diff": "@@ -1,152 +1,152 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tfinal String remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\t// check if the branch is configured for pull-rebase\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n \t\t\tif (remoteBranchName !\u003d null) {\n \t\t\t\t// TODO implement pull-rebase\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\"Pull with rebase is not yet supported\");\n \t\t\t}\n \t\t}\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n-\t\t\tremoteUri \u003d repo.getConfig().getString(\"remote\", remote,\n+\t\t\tremoteUri \u003d repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\t// we check the updates to see which of the updated branches corresponds\n \t\t// to the remote branch name\n \n \t\tAnyObjectId commitToMerge;\n \n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\tmerge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n \t\t\t\tcommitToMerge);\n \t\tMergeResult mergeRes;\n \t\ttry {\n \t\t\tmergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t} catch (NoHeadException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (CheckoutConflictException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (InvalidMergeHeadsException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (WrongRepositoryStateException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (NoMessageException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn new PullResult(fetchRes, remote, mergeRes);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d36c80fd048fc55d7ac31ae62eb67fbac9b12e31": {
      "type": "Ybodychange",
      "commitMessage": "Remove unnecessary null check\n\nThe field monitor is never null, it\u0027s a NullProgressMonitor when not\nexplicitly set.\n\nChange-Id: I8ce703a32c28ce5c3455efeb7ed5f5c9a443cbef\n",
      "commitDate": "2010-10-29, 9:12 a.m.",
      "commitName": "d36c80fd048fc55d7ac31ae62eb67fbac9b12e31",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2010-10-28, 12:18 p.m.",
      "commitNameOld": "7668a462829b12e4f6a192c43157152ef63ff305",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tfinal String remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\t// check if the branch is configured for pull-rebase\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n\t\t\tif (remoteBranchName !\u003d null) {\n\t\t\t\t// TODO implement pull-rebase\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\"Pull with rebase is not yet supported\");\n\t\t\t}\n\t\t}\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repo.getConfig().getString(\"remote\", remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tfetch.setTimeout(this.timeout);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\t// we check the updates to see which of the updated branches corresponds\n\t\t// to the remote branch name\n\n\t\tAnyObjectId commitToMerge;\n\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\tmerge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n\t\t\t\tcommitToMerge);\n\t\tMergeResult mergeRes;\n\t\ttry {\n\t\t\tmergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t} catch (NoHeadException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (CheckoutConflictException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (WrongRepositoryStateException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (NoMessageException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn new PullResult(fetchRes, remote, mergeRes);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 121,
      "functionName": "call",
      "diff": "@@ -1,153 +1,152 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tfinal String remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\t// check if the branch is configured for pull-rebase\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n \t\t\tif (remoteBranchName !\u003d null) {\n \t\t\t\t// TODO implement pull-rebase\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\"Pull with rebase is not yet supported\");\n \t\t\t}\n \t\t}\n \n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri \u003d repo.getConfig().getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri \u003d\u003d null) {\n \t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n-\t\t\tif (monitor !\u003d null)\n-\t\t\t\tfetch.setProgressMonitor(monitor);\n+\t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \n \t\t\tfetchRes \u003d fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri \u003d \"local repository\";\n \t\t\tfetchRes \u003d null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\t// we check the updates to see which of the updated branches corresponds\n \t\t// to the remote branch name\n \n \t\tAnyObjectId commitToMerge;\n \n \t\tif (isRemote) {\n \t\t\tRef r \u003d null;\n \t\t\tif (fetchRes !\u003d null) {\n \t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r \u003d\u003d null)\n \t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r \u003d\u003d null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge \u003d r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\tmerge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n \t\t\t\tcommitToMerge);\n \t\tMergeResult mergeRes;\n \t\ttry {\n \t\t\tmergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t} catch (NoHeadException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (CheckoutConflictException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (InvalidMergeHeadsException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (WrongRepositoryStateException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (NoMessageException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn new PullResult(fetchRes, remote, mergeRes);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7668a462829b12e4f6a192c43157152ef63ff305": {
      "type": "Ybodychange",
      "commitMessage": "PullCommand: support upstream configuration for local branches\n\nWhen creating a local branch based on another local branch, the\nupstream configuration contains \".\" as origin and the source branch\nas \"merge\". The PullCommand should support this by skipping the\nfetch step altogether and use the base branch to merge with.\n\nChange-Id: I260a1771aeeffca5b0161d1494fd63c672ecc2a6\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2010-10-28, 12:18 p.m.",
      "commitName": "7668a462829b12e4f6a192c43157152ef63ff305",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010-10-08, 9:57 a.m.",
      "commitNameOld": "db55d13f5f4b641a9390076ced6b1775bcfcd6f6",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 20.1,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tfinal String remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\t// check if the branch is configured for pull-rebase\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n\t\t\tif (remoteBranchName !\u003d null) {\n\t\t\t\t// TODO implement pull-rebase\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\"Pull with rebase is not yet supported\");\n\t\t\t}\n\t\t}\n\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n\t\tString remoteUri;\n\t\tFetchResult fetchRes;\n\t\tif (isRemote) {\n\t\t\tremoteUri \u003d repo.getConfig().getString(\"remote\", remote,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\t\tif (remoteUri \u003d\u003d null) {\n\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t\t}\n\n\t\t\tif (monitor.isCancelled())\n\t\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\t\tfetch.setRemote(remote);\n\t\t\tif (monitor !\u003d null)\n\t\t\t\tfetch.setProgressMonitor(monitor);\n\t\t\tfetch.setTimeout(this.timeout);\n\n\t\t\tfetchRes \u003d fetch.call();\n\t\t} else {\n\t\t\t// we can skip the fetch altogether\n\t\t\tremoteUri \u003d \"local repository\";\n\t\t\tfetchRes \u003d null;\n\t\t}\n\n\t\tmonitor.update(1);\n\n\t\t// we check the updates to see which of the updated branches corresponds\n\t\t// to the remote branch name\n\n\t\tAnyObjectId commitToMerge;\n\n\t\tif (isRemote) {\n\t\t\tRef r \u003d null;\n\t\t\tif (fetchRes !\u003d null) {\n\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\t\t\tif (r \u003d\u003d null)\n\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n\t\t\t\t\t\t\t+ remoteBranchName);\n\t\t\t}\n\t\t\tif (r \u003d\u003d null)\n\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n\t\t\telse\n\t\t\t\tcommitToMerge \u003d r.getObjectId();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\tmerge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n\t\t\t\tcommitToMerge);\n\t\tMergeResult mergeRes;\n\t\ttry {\n\t\t\tmergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t} catch (NoHeadException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (CheckoutConflictException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (WrongRepositoryStateException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (NoMessageException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn new PullResult(fetchRes, remote, mergeRes);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 121,
      "functionName": "call",
      "diff": "@@ -1,139 +1,153 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch \u003d repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n \t\tConfig repoConfig \u003d repo.getConfig();\n \t\tfinal String remote \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n-\t\tfinal String remoteUri \u003d repo.getConfig().getString(\"remote\", remote,\n-\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n-\t\tif (remoteUri \u003d\u003d null) {\n-\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n-\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n-\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n-\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n-\t\t}\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n \t\tString remoteBranchName \u003d repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\t// check if the branch is configured for pull-rebase\n \t\t\tremoteBranchName \u003d repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n \t\t\tif (remoteBranchName !\u003d null) {\n \t\t\t\t// TODO implement pull-rebase\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\"Pull with rebase is not yet supported\");\n \t\t\t}\n \t\t}\n+\n \t\tif (remoteBranchName \u003d\u003d null) {\n \t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n-\t\tif (monitor.isCancelled())\n-\t\t\tthrow new CanceledException(MessageFormat.format(\n-\t\t\t\t\tJGitText.get().operationCanceled,\n-\t\t\t\t\tJGitText.get().pullTaskName));\n+\t\tfinal boolean isRemote \u003d !remote.equals(\".\");\n+\t\tString remoteUri;\n+\t\tFetchResult fetchRes;\n+\t\tif (isRemote) {\n+\t\t\tremoteUri \u003d repo.getConfig().getString(\"remote\", remote,\n+\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n+\t\t\tif (remoteUri \u003d\u003d null) {\n+\t\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n+\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n+\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n+\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n+\t\t\t}\n \n-\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n-\t\tfetch.setRemote(remote);\n-\t\tif (monitor !\u003d null)\n-\t\t\tfetch.setProgressMonitor(monitor);\n-\t\tfetch.setTimeout(this.timeout);\n+\t\t\tif (monitor.isCancelled())\n+\t\t\t\tthrow new CanceledException(MessageFormat.format(\n+\t\t\t\t\t\tJGitText.get().operationCanceled,\n+\t\t\t\t\t\tJGitText.get().pullTaskName));\n \n-\t\tFetchResult fetchRes \u003d fetch.call();\n+\t\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n+\t\t\tfetch.setRemote(remote);\n+\t\t\tif (monitor !\u003d null)\n+\t\t\t\tfetch.setProgressMonitor(monitor);\n+\t\t\tfetch.setTimeout(this.timeout);\n+\n+\t\t\tfetchRes \u003d fetch.call();\n+\t\t} else {\n+\t\t\t// we can skip the fetch altogether\n+\t\t\tremoteUri \u003d \"local repository\";\n+\t\t\tfetchRes \u003d null;\n+\t\t}\n \n \t\tmonitor.update(1);\n \n \t\t// we check the updates to see which of the updated branches corresponds\n \t\t// to the remote branch name\n \n-\t\tAnyObjectId commitToMerge \u003d null;\n+\t\tAnyObjectId commitToMerge;\n \n-\t\tRef r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n-\t\tif (r \u003d\u003d null)\n-\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n-\t\tif (r \u003d\u003d null) {\n-\t\t\t// TODO: we should be able to get the mapping also if nothing was\n-\t\t\t// updated by the fetch; for the time being, use the naming\n-\t\t\t// convention as fall back\n-\t\t\tString remoteTrackingBranch \u003d Constants.R_REMOTES + remote + \u0027/\u0027\n-\t\t\t\t\t+ branchName;\n+\t\tif (isRemote) {\n+\t\t\tRef r \u003d null;\n+\t\t\tif (fetchRes !\u003d null) {\n+\t\t\t\tr \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n+\t\t\t\tif (r \u003d\u003d null)\n+\t\t\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS\n+\t\t\t\t\t\t\t+ remoteBranchName);\n+\t\t\t}\n+\t\t\tif (r \u003d\u003d null)\n+\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n+\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n+\t\t\telse\n+\t\t\t\tcommitToMerge \u003d r.getObjectId();\n+\t\t} else {\n \t\t\ttry {\n-\t\t\t\tcommitToMerge \u003d repo.resolve(remoteTrackingBranch);\n+\t\t\t\tcommitToMerge \u003d repo.resolve(remoteBranchName);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n-\n-\t\t} else\n-\t\t\tcommitToMerge \u003d r.getObjectId();\n+\t\t}\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\tMergeCommand merge \u003d new MergeCommand(repo);\n \t\tmerge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n \t\t\t\tcommitToMerge);\n \t\tMergeResult mergeRes;\n \t\ttry {\n \t\t\tmergeRes \u003d merge.call();\n \t\t\tmonitor.update(1);\n \t\t} catch (NoHeadException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (CheckoutConflictException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (InvalidMergeHeadsException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (WrongRepositoryStateException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (NoMessageException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn new PullResult(fetchRes, remote, mergeRes);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "db55d13f5f4b641a9390076ced6b1775bcfcd6f6": {
      "type": "Yintroduced",
      "commitMessage": "Add \"Pull\" command\n\nThis is the minimal implementation of a \"Pull\" command. It does not\nhave any parameters besides the generic progress monitor and timeout.\nIt works on the currently checked-out branch and assumes that the\nconfiguration contains the keys \"branch.\u003cbranch name\u003e.remote\" and\n\"branch.\u003cbranch name\u003e.merge\" to determine the remote configuration\nfor the fetch and the remote branch name for the merge.\n\nBug: 303404\nChange-Id: I7fe09029996d0cfc09a7d8f097b5d6af1488fa93\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2010-10-08, 9:57 a.m.",
      "commitName": "db55d13f5f4b641a9390076ced6b1775bcfcd6f6",
      "commitAuthor": "Mathias Kinzler",
      "diff": "@@ -0,0 +1,139 @@\n+\tpublic PullResult call() throws WrongRepositoryStateException,\n+\t\t\tInvalidConfigurationException, DetachedHeadException,\n+\t\t\tInvalidRemoteException, CanceledException {\n+\t\tcheckCallable();\n+\n+\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n+\n+\t\tString branchName;\n+\t\ttry {\n+\t\t\tString fullBranch \u003d repo.getFullBranch();\n+\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n+\t\t\t\t// we can not pull if HEAD is detached and branch is not\n+\t\t\t\t// specified explicitly\n+\t\t\t\tthrow new DetachedHeadException();\n+\t\t\t}\n+\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new JGitInternalException(\n+\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n+\t\t\t\t\te);\n+\t\t}\n+\n+\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n+\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n+\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n+\t\t\t\t\t\t\t.getRepositoryState().name()));\n+\n+\t\t// get the configured remote for the currently checked out branch\n+\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n+\t\tConfig repoConfig \u003d repo.getConfig();\n+\t\tfinal String remote \u003d repoConfig.getString(\n+\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n+\t\tif (remote \u003d\u003d null) {\n+\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n+\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n+\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n+\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n+\t\t}\n+\t\tfinal String remoteUri \u003d repo.getConfig().getString(\"remote\", remote,\n+\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n+\t\tif (remoteUri \u003d\u003d null) {\n+\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n+\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n+\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n+\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n+\t\t}\n+\n+\t\t// get the name of the branch in the remote repository\n+\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n+\t\tString remoteBranchName \u003d repoConfig.getString(\n+\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\tif (remoteBranchName \u003d\u003d null) {\n+\t\t\t// check if the branch is configured for pull-rebase\n+\t\t\tremoteBranchName \u003d repoConfig.getString(\n+\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\t\tif (remoteBranchName !\u003d null) {\n+\t\t\t\t// TODO implement pull-rebase\n+\t\t\t\tthrow new JGitInternalException(\n+\t\t\t\t\t\t\"Pull with rebase is not yet supported\");\n+\t\t\t}\n+\t\t}\n+\t\tif (remoteBranchName \u003d\u003d null) {\n+\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n+\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n+\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n+\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n+\t\t}\n+\n+\t\tif (monitor.isCancelled())\n+\t\t\tthrow new CanceledException(MessageFormat.format(\n+\t\t\t\t\tJGitText.get().operationCanceled,\n+\t\t\t\t\tJGitText.get().pullTaskName));\n+\n+\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n+\t\tfetch.setRemote(remote);\n+\t\tif (monitor !\u003d null)\n+\t\t\tfetch.setProgressMonitor(monitor);\n+\t\tfetch.setTimeout(this.timeout);\n+\n+\t\tFetchResult fetchRes \u003d fetch.call();\n+\n+\t\tmonitor.update(1);\n+\n+\t\t// we check the updates to see which of the updated branches corresponds\n+\t\t// to the remote branch name\n+\n+\t\tAnyObjectId commitToMerge \u003d null;\n+\n+\t\tRef r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n+\t\tif (r \u003d\u003d null)\n+\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n+\t\tif (r \u003d\u003d null) {\n+\t\t\t// TODO: we should be able to get the mapping also if nothing was\n+\t\t\t// updated by the fetch; for the time being, use the naming\n+\t\t\t// convention as fall back\n+\t\t\tString remoteTrackingBranch \u003d Constants.R_REMOTES + remote + \u0027/\u0027\n+\t\t\t\t\t+ branchName;\n+\t\t\ttry {\n+\t\t\t\tcommitToMerge \u003d repo.resolve(remoteTrackingBranch);\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new JGitInternalException(\n+\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n+\t\t\t\t\t\te);\n+\t\t\t}\n+\n+\t\t} else\n+\t\t\tcommitToMerge \u003d r.getObjectId();\n+\n+\t\tif (monitor.isCancelled())\n+\t\t\tthrow new CanceledException(MessageFormat.format(\n+\t\t\t\t\tJGitText.get().operationCanceled,\n+\t\t\t\t\tJGitText.get().pullTaskName));\n+\n+\t\tMergeCommand merge \u003d new MergeCommand(repo);\n+\t\tmerge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n+\t\t\t\tcommitToMerge);\n+\t\tMergeResult mergeRes;\n+\t\ttry {\n+\t\t\tmergeRes \u003d merge.call();\n+\t\t\tmonitor.update(1);\n+\t\t} catch (NoHeadException e) {\n+\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t} catch (ConcurrentRefUpdateException e) {\n+\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t} catch (CheckoutConflictException e) {\n+\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t} catch (InvalidMergeHeadsException e) {\n+\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t} catch (WrongRepositoryStateException e) {\n+\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t} catch (NoMessageException e) {\n+\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t}\n+\t\tmonitor.endTask();\n+\t\treturn new PullResult(fetchRes, remote, mergeRes);\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic PullResult call() throws WrongRepositoryStateException,\n\t\t\tInvalidConfigurationException, DetachedHeadException,\n\t\t\tInvalidRemoteException, CanceledException {\n\t\tcheckCallable();\n\n\t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n\n\t\tString branchName;\n\t\ttry {\n\t\t\tString fullBranch \u003d repo.getFullBranch();\n\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n\t\t\t\t// we can not pull if HEAD is detached and branch is not\n\t\t\t\t// specified explicitly\n\t\t\t\tthrow new DetachedHeadException();\n\t\t\t}\n\t\t\tbranchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n\t\t} catch (IOException e) {\n\t\t\tthrow new JGitInternalException(\n\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\te);\n\t\t}\n\n\t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n\t\t\t\t\t\t\t.getRepositoryState().name()));\n\n\t\t// get the configured remote for the currently checked out branch\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.remote\n\t\tConfig repoConfig \u003d repo.getConfig();\n\t\tfinal String remote \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n\t\tif (remote \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\t\tfinal String remoteUri \u003d repo.getConfig().getString(\"remote\", remote,\n\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n\t\tif (remoteUri \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\t// get the name of the branch in the remote repository\n\t\t// stored in configuration key branch.\u003cbranch name\u003e.merge\n\t\tString remoteBranchName \u003d repoConfig.getString(\n\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\t// check if the branch is configured for pull-rebase\n\t\t\tremoteBranchName \u003d repoConfig.getString(\n\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n\t\t\tif (remoteBranchName !\u003d null) {\n\t\t\t\t// TODO implement pull-rebase\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\t\"Pull with rebase is not yet supported\");\n\t\t\t}\n\t\t}\n\t\tif (remoteBranchName \u003d\u003d null) {\n\t\t\tString missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n\t\t}\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\tFetchCommand fetch \u003d new FetchCommand(repo);\n\t\tfetch.setRemote(remote);\n\t\tif (monitor !\u003d null)\n\t\t\tfetch.setProgressMonitor(monitor);\n\t\tfetch.setTimeout(this.timeout);\n\n\t\tFetchResult fetchRes \u003d fetch.call();\n\n\t\tmonitor.update(1);\n\n\t\t// we check the updates to see which of the updated branches corresponds\n\t\t// to the remote branch name\n\n\t\tAnyObjectId commitToMerge \u003d null;\n\n\t\tRef r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n\t\tif (r \u003d\u003d null)\n\t\t\tr \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n\t\tif (r \u003d\u003d null) {\n\t\t\t// TODO: we should be able to get the mapping also if nothing was\n\t\t\t// updated by the fetch; for the time being, use the naming\n\t\t\t// convention as fall back\n\t\t\tString remoteTrackingBranch \u003d Constants.R_REMOTES + remote + \u0027/\u0027\n\t\t\t\t\t+ branchName;\n\t\t\ttry {\n\t\t\t\tcommitToMerge \u003d repo.resolve(remoteTrackingBranch);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new JGitInternalException(\n\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n\t\t\t\t\t\te);\n\t\t\t}\n\n\t\t} else\n\t\t\tcommitToMerge \u003d r.getObjectId();\n\n\t\tif (monitor.isCancelled())\n\t\t\tthrow new CanceledException(MessageFormat.format(\n\t\t\t\t\tJGitText.get().operationCanceled,\n\t\t\t\t\tJGitText.get().pullTaskName));\n\n\t\tMergeCommand merge \u003d new MergeCommand(repo);\n\t\tmerge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri,\n\t\t\t\tcommitToMerge);\n\t\tMergeResult mergeRes;\n\t\ttry {\n\t\t\tmergeRes \u003d merge.call();\n\t\t\tmonitor.update(1);\n\t\t} catch (NoHeadException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (ConcurrentRefUpdateException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (CheckoutConflictException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (InvalidMergeHeadsException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (WrongRepositoryStateException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t} catch (NoMessageException e) {\n\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n\t\t}\n\t\tmonitor.endTask();\n\t\treturn new PullResult(fetchRes, remote, mergeRes);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 121,
      "functionName": "call"
    }
  }
}