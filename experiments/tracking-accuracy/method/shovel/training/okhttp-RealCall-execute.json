{
  "origin": "codeshovel",
  "repositoryName": "okhttp",
  "repositoryPath": "H:\\Projects\\square\\okhttp/.git",
  "startCommitName": "5224f3045ba9b171fce521777edf389f9206173c",
  "sourceFileName": "RealCall.java",
  "functionName": "execute",
  "functionId": "$execute",
  "sourceFilePath": "okhttp/src/main/java/okhttp3/RealCall.java",
  "functionStartLine": 144,
  "functionEndLine": 166,
  "numCommitsSeen": 118,
  "timeTaken": 2020,
  "changeHistory": [
    "9b0d19f913465483d0942558eb21e37868040050",
    "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
    "7489193d5953bfba8c892e5aa98624e4ec73dbde",
    "51ca7c55da6fac733eb08a613c1c614ad2e66b5f",
    "c6a578ec7696430ecf5a4d4fd8f49c39b105b471",
    "576408374d58a3e9a63714b6f7761cb42a315102",
    "4f24a30c12032b7033884a630696014afd3e77cb",
    "8ff37250310e8d2f9e73293199b3b6e42ec45b0f",
    "38d570a6b28664b398cfa50c5c243c3631cde997",
    "fb700e20af6fa71a20656cd240df4df3c8f15976",
    "c9a89876de476983f273edbf108c365127c18c5e",
    "0c1481a2d3d7482a3e0c4e63f8d99ba6cea9c24b",
    "9631227619ffe9497c67d92d20428682e5df8862",
    "e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab",
    "6184a7f5cf2a1d97072aaccb9fc00e08003848e3",
    "b72c9567df964696afdf4335b9456c28d017afde",
    "40c2e6aec09d139a4e96b45856020a5b324b01ef",
    "36cff8b86438a3b0f3bd3e701b374a1404a9168d",
    "83e42cb9288896f88c934faa116b89165b3b9689",
    "aa7e7a751c8e0096e18f792f3a737ed21d265ead",
    "f6a46b8992e486fb881b77c2fd533dc4d71dfd5b",
    "53b9f84cb694a6267373b1fdd6d2144a6f05b68b",
    "c3e8a5d326f026ba6af20d0bf7da41c005ff1915",
    "63d4dfaaa622d4cce72a09cdeead267afa3453a6",
    "0b677ac70d37f9064d3a0c0914794f60f66d64be",
    "112dcc40900d503ea7e416e0da0a8fd9b08a9c17",
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
    "749a65b776c8fc4b39b6463695980275da34da51",
    "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
    "f3a450bf4f0e9428cf8b3c2780236162bbeb803a",
    "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa",
    "9417fa5c2e84580411e0fa4905b1f109e2d49533",
    "b21ea3a7daf9de0a5deb9bf7cf6d791c2ff63d3b",
    "0ef26ad2e9e6b28a181ebc128f96671cff295043",
    "dbca0acc6f8c188dfa48f07bb5886606bec8d28f",
    "14b6e76e7d7af9b99a7fdc1a56d7ee9309711722",
    "350c43b6fe02401a73f967d9ef322061638b372a",
    "e2bfa5dd6c0aee7d7e34b224a649500b9e5c267f",
    "37c01895cca5ec2bec26a3d381611f0938acd6d0"
  ],
  "changeHistoryShort": {
    "9b0d19f913465483d0942558eb21e37868040050": "Ybodychange",
    "1c98464839434a0fe7c7581cdae44bd3f2e6edd3": "Ybodychange",
    "7489193d5953bfba8c892e5aa98624e4ec73dbde": "Ybodychange",
    "51ca7c55da6fac733eb08a613c1c614ad2e66b5f": "Ybodychange",
    "c6a578ec7696430ecf5a4d4fd8f49c39b105b471": "Ybodychange",
    "576408374d58a3e9a63714b6f7761cb42a315102": "Ybodychange",
    "4f24a30c12032b7033884a630696014afd3e77cb": "Ybodychange",
    "8ff37250310e8d2f9e73293199b3b6e42ec45b0f": "Ybodychange",
    "38d570a6b28664b398cfa50c5c243c3631cde997": "Ybodychange",
    "fb700e20af6fa71a20656cd240df4df3c8f15976": "Ymovefromfile",
    "c9a89876de476983f273edbf108c365127c18c5e": "Yfilerename",
    "0c1481a2d3d7482a3e0c4e63f8d99ba6cea9c24b": "Ybodychange",
    "9631227619ffe9497c67d92d20428682e5df8862": "Ybodychange",
    "e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab": "Ybodychange",
    "6184a7f5cf2a1d97072aaccb9fc00e08003848e3": "Ybodychange",
    "b72c9567df964696afdf4335b9456c28d017afde": "Ybodychange",
    "40c2e6aec09d139a4e96b45856020a5b324b01ef": "Ybodychange",
    "36cff8b86438a3b0f3bd3e701b374a1404a9168d": "Ybodychange",
    "83e42cb9288896f88c934faa116b89165b3b9689": "Ybodychange",
    "aa7e7a751c8e0096e18f792f3a737ed21d265ead": "Ybodychange",
    "f6a46b8992e486fb881b77c2fd533dc4d71dfd5b": "Ybodychange",
    "53b9f84cb694a6267373b1fdd6d2144a6f05b68b": "Ybodychange",
    "c3e8a5d326f026ba6af20d0bf7da41c005ff1915": "Ybodychange",
    "63d4dfaaa622d4cce72a09cdeead267afa3453a6": "Ymovefromfile",
    "0b677ac70d37f9064d3a0c0914794f60f66d64be": "Ybodychange",
    "112dcc40900d503ea7e416e0da0a8fd9b08a9c17": "Ybodychange",
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": "Ybodychange",
    "749a65b776c8fc4b39b6463695980275da34da51": "Ymultichange(Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange)",
    "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a": "Ybodychange",
    "f3a450bf4f0e9428cf8b3c2780236162bbeb803a": "Ybodychange",
    "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa": "Ybodychange",
    "9417fa5c2e84580411e0fa4905b1f109e2d49533": "Ybodychange",
    "b21ea3a7daf9de0a5deb9bf7cf6d791c2ff63d3b": "Ybodychange",
    "0ef26ad2e9e6b28a181ebc128f96671cff295043": "Ybodychange",
    "dbca0acc6f8c188dfa48f07bb5886606bec8d28f": "Ybodychange",
    "14b6e76e7d7af9b99a7fdc1a56d7ee9309711722": "Ybodychange",
    "350c43b6fe02401a73f967d9ef322061638b372a": "Ybodychange",
    "e2bfa5dd6c0aee7d7e34b224a649500b9e5c267f": "Ybodychange",
    "37c01895cca5ec2bec26a3d381611f0938acd6d0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9b0d19f913465483d0942558eb21e37868040050": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t call callEnd until after the responseBody is done (#3551)\n\n",
      "commitDate": "2017-08-30, 1:14 a.m.",
      "commitName": "9b0d19f913465483d0942558eb21e37868040050",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2017-08-29, 4:14 p.m.",
      "commitNameOld": "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.37,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          eventListener.callFailed(RealCall.this, e);\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 144,
      "functionName": "execute",
      "diff": "@@ -1,24 +1,23 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponseWithInterceptorChain();\n         if (retryAndFollowUpInterceptor.isCanceled()) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n-        eventListener.callEnd(RealCall.this);\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           eventListener.callFailed(RealCall.this, e);\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1c98464839434a0fe7c7581cdae44bd3f2e6edd3": {
      "type": "Ybodychange",
      "commitMessage": "Move all failures into connectFailed and callFailed. (#3550)\n\nI think applications might be simple by tracking successful events\r\nseparately from failure events.",
      "commitDate": "2017-08-29, 4:14 p.m.",
      "commitName": "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2017-08-14, 10:29 a.m.",
      "commitNameOld": "7489193d5953bfba8c892e5aa98624e4ec73dbde",
      "commitAuthorOld": "Dave Roberge",
      "daysBetweenCommits": 15.24,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n        eventListener.callEnd(RealCall.this);\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          eventListener.callFailed(RealCall.this, e);\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 145,
      "functionName": "execute",
      "diff": "@@ -1,24 +1,24 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponseWithInterceptorChain();\n         if (retryAndFollowUpInterceptor.isCanceled()) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n-        eventListener.callEnd(RealCall.this, null);\n+        eventListener.callEnd(RealCall.this);\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-          eventListener.callEnd(RealCall.this, e);\n+          eventListener.callFailed(RealCall.this, e);\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7489193d5953bfba8c892e5aa98624e4ec73dbde": {
      "type": "Ybodychange",
      "commitMessage": "Rename fetchStart/fetchEnd to callStart/callEnd. (#3522)\n\n",
      "commitDate": "2017-08-14, 10:29 a.m.",
      "commitName": "7489193d5953bfba8c892e5aa98624e4ec73dbde",
      "commitAuthor": "Dave Roberge",
      "commitDateOld": "2017-08-05, 4:25 p.m.",
      "commitNameOld": "51ca7c55da6fac733eb08a613c1c614ad2e66b5f",
      "commitAuthorOld": "Yuri Schimke",
      "daysBetweenCommits": 8.75,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n        eventListener.callEnd(RealCall.this, null);\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          eventListener.callEnd(RealCall.this, e);\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 145,
      "functionName": "execute",
      "diff": "@@ -1,24 +1,24 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponseWithInterceptorChain();\n         if (retryAndFollowUpInterceptor.isCanceled()) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n-        eventListener.fetchEnd(RealCall.this, null);\n+        eventListener.callEnd(RealCall.this, null);\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-          eventListener.fetchEnd(RealCall.this, e);\n+          eventListener.callEnd(RealCall.this, e);\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "51ca7c55da6fac733eb08a613c1c614ad2e66b5f": {
      "type": "Ybodychange",
      "commitMessage": "Complete EventListener (#3476)\n\n\r\n\r\n* more docs\r\n\r\n* cleanup\r\n\r\n* log events\r\n\r\n* check end events and connectionReleased\r\n\r\n* change connectEnd signature\r\n\r\n* move response body events to codec\r\n\r\n* revert small changes\r\n\r\n* revert incidental change\r\n",
      "commitDate": "2017-08-05, 4:25 p.m.",
      "commitName": "51ca7c55da6fac733eb08a613c1c614ad2e66b5f",
      "commitAuthor": "Yuri Schimke",
      "commitDateOld": "2017-07-23, 6:59 p.m.",
      "commitNameOld": "1d8233ddb7a0dfa490a340a06433909148f21610",
      "commitAuthorOld": "ericaschulz",
      "daysBetweenCommits": 12.89,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n        eventListener.fetchEnd(RealCall.this, null);\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          eventListener.fetchEnd(RealCall.this, e);\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 145,
      "functionName": "execute",
      "diff": "@@ -1,22 +1,24 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponseWithInterceptorChain();\n         if (retryAndFollowUpInterceptor.isCanceled()) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n+        eventListener.fetchEnd(RealCall.this, null);\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n+          eventListener.fetchEnd(RealCall.this, e);\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c6a578ec7696430ecf5a4d4fd8f49c39b105b471": {
      "type": "Ybodychange",
      "commitMessage": "Move core interceptors into top level classes.\n\nNo behavior changes here.\n",
      "commitDate": "2016-06-25, 7:13 p.m.",
      "commitName": "c6a578ec7696430ecf5a4d4fd8f49c39b105b471",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-06-25, 6:04 p.m.",
      "commitNameOld": "15a5bc40a4520d935bbc02a3552f51dda77fcc9c",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 114,
      "functionName": "execute",
      "diff": "@@ -1,22 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponseWithInterceptorChain();\n-        if (canceled) {\n+        if (retryAndFollowUpInterceptor.isCanceled()) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "576408374d58a3e9a63714b6f7761cb42a315102": {
      "type": "Ybodychange",
      "commitMessage": "Begin to fold together parts of RealCall and HttpEngine.\n\nPreviously we had an awkward, arbitrary separation because RealCall contained\nthe stuff that wasn\u0027t in HttpURLConnection, and HttpEngine contained everything\nthat was shared.\n\nIt was also awkward because HttpEngine could be interrupted in various parts\nof the HttpURLConnection flow: after connecting, while transmitting the request\nbody, etc. With this change we no longer need to handle API calls while we\u0027re\nin these intermediate states, which means we can reduce the scope of certain\nthings from fields to local variables.\n\nThere\u0027s still a way to go here but this is more easy wins.\n",
      "commitDate": "2016-06-23, 10:54 p.m.",
      "commitName": "576408374d58a3e9a63714b6f7761cb42a315102",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-06-21, 4:18 p.m.",
      "commitNameOld": "0f5c5c6431cfe7e5227d90fc08e822cd3b2cec9f",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 2.28,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 117,
      "functionName": "execute",
      "diff": "@@ -1,22 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n-        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n+        Response response \u003d getResponseWithInterceptorChain();\n         if (canceled) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4f24a30c12032b7033884a630696014afd3e77cb": {
      "type": "Ybodychange",
      "commitMessage": "Make logging more consistent throughout OkHttp.\n\nAvoid using System.out.\n\nUse the best logging implementation on the host platform. On Java this is\njava.util.logging. On Android it\u0027s Android.util.Log.\n\nCloses https://github.com/square/okhttp/issues/2505\n",
      "commitDate": "2016-05-07, 9:08 p.m.",
      "commitName": "4f24a30c12032b7033884a630696014afd3e77cb",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-04-21, 8:52 a.m.",
      "commitNameOld": "047b56833ccd293ab8f9b1f61460d6d4cc1075da",
      "commitAuthorOld": "Dave Roberge",
      "daysBetweenCommits": 16.51,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 124,
      "functionName": "execute",
      "diff": "@@ -1,22 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n-          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n+          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8ff37250310e8d2f9e73293199b3b6e42ec45b0f": {
      "type": "Ybodychange",
      "commitMessage": "Change Callback to take a Call.\n\nThis makes it much easier to test if the call was canceled.\n\nNote that the Call\u0027s request is always the original user request.\nThis is different than the previous request that was passed in, as\nthat could have been the follow up to a redirect.\n",
      "commitDate": "2016-01-11, 6:40 p.m.",
      "commitName": "8ff37250310e8d2f9e73293199b3b6e42ec45b0f",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-01-01, 12:12 p.m.",
      "commitNameOld": "38d570a6b28664b398cfa50c5c243c3631cde997",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 10.27,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 124,
      "functionName": "execute",
      "diff": "@@ -1,23 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n           signalledCallback \u003d true;\n-          responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n+          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n-          responseCallback.onResponse(response);\n+          responseCallback.onResponse(RealCall.this, response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-          Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n-          responseCallback.onFailure(request, e);\n+          responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "38d570a6b28664b398cfa50c5c243c3631cde997": {
      "type": "Ybodychange",
      "commitMessage": "Drop get and set prefixes in OkHttpClient, OkHttpClient.Builder\n",
      "commitDate": "2016-01-01, 12:12 p.m.",
      "commitName": "38d570a6b28664b398cfa50c5c243c3631cde997",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-01-01, 10:55 a.m.",
      "commitNameOld": "71ec4917b51faeba98db149739576feb51b4d505",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n          responseCallback.onFailure(request, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 124,
      "functionName": "execute",
      "diff": "@@ -1,23 +1,23 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n           responseCallback.onFailure(request, e);\n         }\n       } finally {\n-        client.getDispatcher().finished(this);\n+        client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb700e20af6fa71a20656cd240df4df3c8f15976": {
      "type": "Ymovefromfile",
      "commitMessage": "Make call an interface, and introduce Call.Factory.\n\nMore documentation forthcoming.\n",
      "commitDate": "2015-12-23, 3:55 p.m.",
      "commitName": "fb700e20af6fa71a20656cd240df4df3c8f15976",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-12-22, 10:15 p.m.",
      "commitNameOld": "6aff563d5a730d49ced0663235b16331d6716f15",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n          responseCallback.onFailure(request, e);\n        }\n      } finally {\n        client.getDispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 122,
      "functionName": "execute",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/okhttp3/Call.java",
        "newPath": "okhttp/src/main/java/okhttp3/RealCall.java",
        "oldMethodName": "execute",
        "newMethodName": "execute"
      }
    },
    "c9a89876de476983f273edbf108c365127c18c5e": {
      "type": "Yfilerename",
      "commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
      "commitDate": "2015-12-16, 1:34 a.m.",
      "commitName": "c9a89876de476983f273edbf108c365127c18c5e",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-12-15, 9:36 p.m.",
      "commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n          responseCallback.onFailure(request, e);\n        }\n      } finally {\n        client.getDispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/okhttp3/Call.java",
      "functionStartLine": 168,
      "functionName": "execute",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
        "newPath": "okhttp/src/main/java/okhttp3/Call.java"
      }
    },
    "0c1481a2d3d7482a3e0c4e63f8d99ba6cea9c24b": {
      "type": "Ybodychange",
      "commitMessage": "Make AsyncCall handle interceptors that throws an IOException\n\nThis closes #1801\n",
      "commitDate": "2015-10-21, 1:41 a.m.",
      "commitName": "0c1481a2d3d7482a3e0c4e63f8d99ba6cea9c24b",
      "commitAuthor": "Nicklas Ansman Giertz",
      "commitDateOld": "2015-08-02, 9:01 p.m.",
      "commitNameOld": "4c90a2e04a83646597a506a80b5a885d5c515bf0",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 79.19,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n          responseCallback.onFailure(request, e);\n        }\n      } finally {\n        client.getDispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 159,
      "functionName": "execute",
      "diff": "@@ -1,22 +1,23 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-          responseCallback.onFailure(engine.getRequest(), e);\n+          Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n+          responseCallback.onFailure(request, e);\n         }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9631227619ffe9497c67d92d20428682e5df8862": {
      "type": "Ybodychange",
      "commitMessage": "Add a web socket call concept for connecting.\n\nSimilar to HTTP and Call, the WebSocketCall is a representation of a pending HTTP request and subsequent upgrade to speak web sockets. Upon synchronous execution you are handed a WebSocket instance for synchronous writing and also pass in a WebSocketListener for async callbacks due to reading.\n\nThe API changes in this commits also generalize WebSocket such that it\u0027s agnostic to being a client or server peer.\n",
      "commitDate": "2015-01-01, 2:13 a.m.",
      "commitName": "9631227619ffe9497c67d92d20428682e5df8862",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2014-12-30, 12:14 p.m.",
      "commitNameOld": "e49dd7a2f08deac92fab3de2b8a63e90b588f746",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 1.58,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(engine.getRequest(), e);\n        }\n      } finally {\n        client.getDispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 159,
      "functionName": "execute",
      "diff": "@@ -1,22 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n-        Response response \u003d getResponseWithInterceptorChain();\n+        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           responseCallback.onFailure(engine.getRequest(), e);\n         }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab": {
      "type": "Ybodychange",
      "commitMessage": "Move cache writing out of the transport.\n\nThis is necessary to unblock network interceptors, where the interceptor\nmay elect to rewrite the response body. If we\u0027ve already cached the\noriginal response body, we\u0027re too late.\n",
      "commitDate": "2014-12-21, 9:21 p.m.",
      "commitName": "e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-12-08, 1:25 p.m.",
      "commitNameOld": "6184a7f5cf2a1d97072aaccb9fc00e08003848e3",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 13.33,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(engine.getRequest(), e);\n        }\n      } finally {\n        client.getDispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 156,
      "functionName": "execute",
      "diff": "@@ -1,22 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponseWithInterceptorChain();\n         if (canceled) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-          responseCallback.onFailure(originalRequest, e);\n+          responseCallback.onFailure(engine.getRequest(), e);\n         }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6184a7f5cf2a1d97072aaccb9fc00e08003848e3": {
      "type": "Ybodychange",
      "commitMessage": "Initial implementation of interceptors.\n\nI\u0027m anticipating implementing interceptors at two independent parts\nof the API. The first is high-level interceptors, that intercept\nbefore the socket connection has been established.\n\nThe second set of interceptors will only execute for requests that\nrequire a socket connection. Those are forthcoming.\n",
      "commitDate": "2014-12-08, 1:25 p.m.",
      "commitName": "6184a7f5cf2a1d97072aaccb9fc00e08003848e3",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-11-30, 5:12 p.m.",
      "commitNameOld": "986b6b65bac1d825b1c09079625f50dbd67a1e32",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 7.84,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(originalRequest, e);\n        }\n      } finally {\n        client.getDispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 156,
      "functionName": "execute",
      "diff": "@@ -1,23 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n-        Response response \u003d getResponse(false);\n+        Response response \u003d getResponseWithInterceptorChain();\n         if (canceled) {\n           signalledCallback \u003d true;\n-          responseCallback.onFailure(request, new IOException(\"Canceled\"));\n+          responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n-          engine.releaseConnection();\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-          responseCallback.onFailure(request, e);\n+          responseCallback.onFailure(originalRequest, e);\n         }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b72c9567df964696afdf4335b9456c28d017afde": {
      "type": "Ybodychange",
      "commitMessage": "Hook up the web socket reader and writer together.\n\nAdd a simple real-world recipe which talks to an echo server.\n",
      "commitDate": "2014-11-05, 2:29 a.m.",
      "commitName": "b72c9567df964696afdf4335b9456c28d017afde",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2014-11-02, 12:48 p.m.",
      "commitNameOld": "5991ab1ecb9ea0b31826bab38ec855a893475562",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 2.57,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponse(false);\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          engine.releaseConnection();\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(request, e);\n        }\n      } finally {\n        client.getDispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 161,
      "functionName": "execute",
      "diff": "@@ -1,23 +1,23 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n-        Response response \u003d getResponse();\n+        Response response \u003d getResponse(false);\n         if (canceled) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           engine.releaseConnection();\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           responseCallback.onFailure(request, e);\n         }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "40c2e6aec09d139a4e96b45856020a5b324b01ef": {
      "type": "Ybodychange",
      "commitMessage": "Use one logger for all logging.\n\nThere was a concurrency problem in CallTest where multiple calls to\nLogger.getLogger() didn\u0027t return the same instance, leading to failures\nin the test.\n",
      "commitDate": "2014-10-26, 11:48 a.m.",
      "commitName": "40c2e6aec09d139a4e96b45856020a5b324b01ef",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-10-25, 10:50 p.m.",
      "commitNameOld": "9cc7a5219f8f88bec35a073feab96abab4a9b42f",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.54,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponse();\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          engine.releaseConnection();\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(request, e);\n        }\n      } finally {\n        client.getDispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 157,
      "functionName": "execute",
      "diff": "@@ -1,24 +1,23 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponse();\n         if (canceled) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           engine.releaseConnection();\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n-          Logger.getLogger(OkHttpClient.class.getName())\n-              .log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n+          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           responseCallback.onFailure(request, e);\n         }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "36cff8b86438a3b0f3bd3e701b374a1404a9168d": {
      "type": "Ybodychange",
      "commitMessage": "Log uncaught IOExceptions instead of rethrowing them.\n\nThe application layer can handle these with a try/catch block in their\nonResponse method if desired.\n\nThis prevents a crash for applications that haven\u0027t deliberately configured\ntheir uncaught exception handlers.\n\nCloses https://github.com/square/okhttp/issues/1049\n",
      "commitDate": "2014-10-25, 6:34 p.m.",
      "commitName": "36cff8b86438a3b0f3bd3e701b374a1404a9168d",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-10-11, 10:27 p.m.",
      "commitNameOld": "83090befcca69b44c257b96afb519ca66282ca63",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 13.84,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponse();\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          engine.releaseConnection();\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Logger.getLogger(OkHttpClient.class.getName())\n              .log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(request, e);\n        }\n      } finally {\n        client.getDispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 153,
      "functionName": "execute",
      "diff": "@@ -1,19 +1,24 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponse();\n         if (canceled) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           engine.releaseConnection();\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n-        if (signalledCallback) throw new RuntimeException(e); // Do not signal the callback twice!\n-        responseCallback.onFailure(request, e);\n+        if (signalledCallback) {\n+          // Do not signal the callback twice!\n+          Logger.getLogger(OkHttpClient.class.getName())\n+              .log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n+        } else {\n+          responseCallback.onFailure(request, e);\n+        }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "83e42cb9288896f88c934faa116b89165b3b9689": {
      "type": "Ybodychange",
      "commitMessage": "Make it possible to mock OkHttpClient and Call.\n\nCloses https://github.com/square/okhttp/issues/956\n",
      "commitDate": "2014-06-30, 1:46 a.m.",
      "commitName": "83e42cb9288896f88c934faa116b89165b3b9689",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-06-10, 7:45 p.m.",
      "commitNameOld": "aa7e7a751c8e0096e18f792f3a737ed21d265ead",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 19.25,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponse();\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          engine.releaseConnection();\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) throw new RuntimeException(e); // Do not signal the callback twice!\n        responseCallback.onFailure(request, e);\n      } finally {\n        client.getDispatcher().finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 140,
      "functionName": "execute",
      "diff": "@@ -1,19 +1,19 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponse();\n         if (canceled) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           engine.releaseConnection();\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) throw new RuntimeException(e); // Do not signal the callback twice!\n         responseCallback.onFailure(request, e);\n       } finally {\n-        dispatcher.finished(this);\n+        client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aa7e7a751c8e0096e18f792f3a737ed21d265ead": {
      "type": "Ybodychange",
      "commitMessage": "Keep the response body alive after the callback.\n",
      "commitDate": "2014-06-10, 7:45 p.m.",
      "commitName": "aa7e7a751c8e0096e18f792f3a737ed21d265ead",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-06-08, 11:29 a.m.",
      "commitNameOld": "baba1c090dde4d2e40479d9178bdcecafa76daa5",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 2.34,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponse();\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          engine.releaseConnection();\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) throw new RuntimeException(e); // Do not signal the callback twice!\n        responseCallback.onFailure(request, e);\n      } finally {\n        dispatcher.finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 140,
      "functionName": "execute",
      "diff": "@@ -1,19 +1,19 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponse();\n         if (canceled) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n+          engine.releaseConnection();\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) throw new RuntimeException(e); // Do not signal the callback twice!\n         responseCallback.onFailure(request, e);\n       } finally {\n-        engine.close(); // Close the connection if it isn\u0027t already.\n         dispatcher.finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f6a46b8992e486fb881b77c2fd533dc4d71dfd5b": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t lose uncaught exceptions.\n",
      "commitDate": "2014-05-27, 9:33 a.m.",
      "commitName": "f6a46b8992e486fb881b77c2fd533dc4d71dfd5b",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-05-19, 11:18 p.m.",
      "commitNameOld": "ed70981925e64fd0cb593d09bdd401ea4ea19848",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 7.43,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponse();\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) throw new RuntimeException(e); // Do not signal the callback twice!\n        responseCallback.onFailure(request, e);\n      } finally {\n        engine.close(); // Close the connection if it isn\u0027t already.\n        dispatcher.finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 140,
      "functionName": "execute",
      "diff": "@@ -1,19 +1,19 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponse();\n         if (canceled) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n-        if (signalledCallback) return; // Do not signal the callback twice!\n+        if (signalledCallback) throw new RuntimeException(e); // Do not signal the callback twice!\n         responseCallback.onFailure(request, e);\n       } finally {\n         engine.close(); // Close the connection if it isn\u0027t already.\n         dispatcher.finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53b9f84cb694a6267373b1fdd6d2144a6f05b68b": {
      "type": "Ybodychange",
      "commitMessage": "Remove Failure wrapper type.\n",
      "commitDate": "2014-05-19, 4:15 p.m.",
      "commitName": "53b9f84cb694a6267373b1fdd6d2144a6f05b68b",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2014-05-10, 11:20 a.m.",
      "commitNameOld": "84312bd93f895641f90900952dba6bb48d0b247e",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 9.21,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponse();\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) return; // Do not signal the callback twice!\n        responseCallback.onFailure(request, e);\n      } finally {\n        engine.close(); // Close the connection if it isn\u0027t already.\n        dispatcher.finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 140,
      "functionName": "execute",
      "diff": "@@ -1,25 +1,19 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponse();\n         if (canceled) {\n           signalledCallback \u003d true;\n-          responseCallback.onFailure(new Failure.Builder()\n-              .request(request)\n-              .exception(new IOException(\"Canceled\"))\n-              .build());\n+          responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) return; // Do not signal the callback twice!\n-        responseCallback.onFailure(new Failure.Builder()\n-            .request(request)\n-            .exception(e)\n-            .build());\n+        responseCallback.onFailure(request, e);\n       } finally {\n         engine.close(); // Close the connection if it isn\u0027t already.\n         dispatcher.finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c3e8a5d326f026ba6af20d0bf7da41c005ff1915": {
      "type": "Ybodychange",
      "commitMessage": "Use IOE for canceled streams.\n",
      "commitDate": "2014-04-25, 6:21 p.m.",
      "commitName": "c3e8a5d326f026ba6af20d0bf7da41c005ff1915",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014-04-25, 5:30 p.m.",
      "commitNameOld": "38ea820a73eb318254e9722653aac8878598c266",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponse();\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(new Failure.Builder()\n              .request(request)\n              .exception(new IOException(\"Canceled\"))\n              .build());\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) return; // Do not signal the callback twice!\n        responseCallback.onFailure(new Failure.Builder()\n            .request(request)\n            .exception(e)\n            .build());\n      } finally {\n        engine.close(); // Close the connection if it isn\u0027t already.\n        dispatcher.finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 137,
      "functionName": "execute",
      "diff": "@@ -1,25 +1,25 @@\n     @Override protected void execute() {\n       boolean signalledCallback \u003d false;\n       try {\n         Response response \u003d getResponse();\n         if (canceled) {\n           signalledCallback \u003d true;\n           responseCallback.onFailure(new Failure.Builder()\n               .request(request)\n-              .exception(new CancellationException(\"Canceled\"))\n+              .exception(new IOException(\"Canceled\"))\n               .build());\n         } else {\n           signalledCallback \u003d true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) return; // Do not signal the callback twice!\n         responseCallback.onFailure(new Failure.Builder()\n             .request(request)\n             .exception(e)\n             .build());\n       } finally {\n         engine.close(); // Close the connection if it isn\u0027t already.\n         dispatcher.finished(this);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "63d4dfaaa622d4cce72a09cdeead267afa3453a6": {
      "type": "Ymovefromfile",
      "commitMessage": "Merge Job into Call. CallTest \u003d AsyncApiTest + SyncApiTest.\n",
      "commitDate": "2014-04-25, 2:13 p.m.",
      "commitName": "63d4dfaaa622d4cce72a09cdeead267afa3453a6",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014-04-25, 11:18 a.m.",
      "commitNameOld": "f4c83e8eb86ac4afb224f91cd68bd9650351fe64",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override protected void execute() {\n      boolean signalledCallback \u003d false;\n      try {\n        Response response \u003d getResponse();\n        if (canceled) {\n          signalledCallback \u003d true;\n          responseCallback.onFailure(new Failure.Builder()\n              .request(request)\n              .exception(new CancellationException(\"Canceled\"))\n              .build());\n        } else {\n          signalledCallback \u003d true;\n          responseCallback.onResponse(response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) return; // Do not signal the callback twice!\n        responseCallback.onFailure(new Failure.Builder()\n            .request(request)\n            .exception(e)\n            .build());\n      } finally {\n        engine.close(); // Close the connection if it isn\u0027t already.\n        dispatcher.finished(this);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 139,
      "functionName": "execute",
      "diff": "@@ -1,25 +1,25 @@\n-  @Override protected void execute() {\n-    boolean signalledCallback \u003d false;\n-    try {\n-      Response response \u003d getResponse();\n-      if (canceled) {\n-        signalledCallback \u003d true;\n+    @Override protected void execute() {\n+      boolean signalledCallback \u003d false;\n+      try {\n+        Response response \u003d getResponse();\n+        if (canceled) {\n+          signalledCallback \u003d true;\n+          responseCallback.onFailure(new Failure.Builder()\n+              .request(request)\n+              .exception(new CancellationException(\"Canceled\"))\n+              .build());\n+        } else {\n+          signalledCallback \u003d true;\n+          responseCallback.onResponse(response);\n+        }\n+      } catch (IOException e) {\n+        if (signalledCallback) return; // Do not signal the callback twice!\n         responseCallback.onFailure(new Failure.Builder()\n             .request(request)\n-            .exception(new CancellationException(\"Canceled\"))\n+            .exception(e)\n             .build());\n-      } else {\n-        signalledCallback \u003d true;\n-        responseCallback.onResponse(response);\n+      } finally {\n+        engine.close(); // Close the connection if it isn\u0027t already.\n+        dispatcher.finished(this);\n       }\n-    } catch (IOException e) {\n-      if (signalledCallback) return; // Do not signal the callback twice!\n-      responseCallback.onFailure(new Failure.Builder()\n-          .request(request)\n-          .exception(e)\n-          .build());\n-    } finally {\n-      engine.close(); // Close the connection if it isn\u0027t already.\n-      dispatcher.finished(this);\n-    }\n-  }\n\\ No newline at end of file\n+    }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
        "newPath": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
        "oldMethodName": "execute",
        "newMethodName": "execute"
      }
    },
    "0b677ac70d37f9064d3a0c0914794f60f66d64be": {
      "type": "Ybodychange",
      "commitMessage": "Introduce Call for async invocations.\n",
      "commitDate": "2014-04-25, 12:25 a.m.",
      "commitName": "0b677ac70d37f9064d3a0c0914794f60f66d64be",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014-04-23, 12:55 a.m.",
      "commitNameOld": "5b6f64a46220911466350202ae974f167497225a",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 1.98,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "  @Override protected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n      Response response \u003d getResponse();\n      if (canceled) {\n        signalledCallback \u003d true;\n        responseCallback.onFailure(new Failure.Builder()\n            .request(request)\n            .exception(new CancellationException(\"Canceled\"))\n            .build());\n      } else {\n        signalledCallback \u003d true;\n        responseCallback.onResponse(response);\n      }\n    } catch (IOException e) {\n      if (signalledCallback) return; // Do not signal the callback twice!\n      responseCallback.onFailure(new Failure.Builder()\n          .request(request)\n          .exception(e)\n          .build());\n    } finally {\n      engine.close(); // Close the connection if it isn\u0027t already.\n      dispatcher.finished(this);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 62,
      "functionName": "execute",
      "diff": "@@ -1,25 +1,25 @@\n   @Override protected void execute() {\n-    boolean signalledReceiver \u003d false;\n+    boolean signalledCallback \u003d false;\n     try {\n       Response response \u003d getResponse();\n       if (canceled) {\n-        signalledReceiver \u003d true;\n-        responseReceiver.onFailure(new Failure.Builder()\n+        signalledCallback \u003d true;\n+        responseCallback.onFailure(new Failure.Builder()\n             .request(request)\n             .exception(new CancellationException(\"Canceled\"))\n             .build());\n       } else {\n-        signalledReceiver \u003d true;\n-        responseReceiver.onResponse(response);\n+        signalledCallback \u003d true;\n+        responseCallback.onResponse(response);\n       }\n     } catch (IOException e) {\n-      if (signalledReceiver) return; // Do not signal the receiver twice!\n-      responseReceiver.onFailure(new Failure.Builder()\n+      if (signalledCallback) return; // Do not signal the callback twice!\n+      responseCallback.onFailure(new Failure.Builder()\n           .request(request)\n           .exception(e)\n           .build());\n     } finally {\n       engine.close(); // Close the connection if it isn\u0027t already.\n       dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "112dcc40900d503ea7e416e0da0a8fd9b08a9c17": {
      "type": "Ybodychange",
      "commitMessage": "Clarified behavior of AsyncApi when a request is canceled, including its implied disconnect.\n",
      "commitDate": "2014-04-22, 11:39 a.m.",
      "commitName": "112dcc40900d503ea7e416e0da0a8fd9b08a9c17",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014-04-22, 12:14 a.m.",
      "commitNameOld": "9146c579dd9110d0028144c59515da9be1ce7108",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.48,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  @Override protected void execute() {\n    boolean signalledReceiver \u003d false;\n    try {\n      Response response \u003d getResponse();\n      if (canceled) {\n        signalledReceiver \u003d true;\n        responseReceiver.onFailure(new Failure.Builder()\n            .request(request)\n            .exception(new CancellationException(\"Canceled\"))\n            .build());\n      } else {\n        signalledReceiver \u003d true;\n        responseReceiver.onResponse(response);\n      }\n    } catch (IOException e) {\n      if (signalledReceiver) return; // Do not signal the receiver twice!\n      responseReceiver.onFailure(new Failure.Builder()\n          .request(request)\n          .exception(e)\n          .build());\n    } finally {\n      engine.close(); // Close the connection if it isn\u0027t already.\n      dispatcher.finished(this);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 62,
      "functionName": "execute",
      "diff": "@@ -1,16 +1,25 @@\n   @Override protected void execute() {\n+    boolean signalledReceiver \u003d false;\n     try {\n       Response response \u003d getResponse();\n-      if (response !\u003d null \u0026\u0026 !canceled) {\n+      if (canceled) {\n+        signalledReceiver \u003d true;\n+        responseReceiver.onFailure(new Failure.Builder()\n+            .request(request)\n+            .exception(new CancellationException(\"Canceled\"))\n+            .build());\n+      } else {\n+        signalledReceiver \u003d true;\n         responseReceiver.onResponse(response);\n       }\n     } catch (IOException e) {\n+      if (signalledReceiver) return; // Do not signal the receiver twice!\n       responseReceiver.onFailure(new Failure.Builder()\n           .request(request)\n           .exception(e)\n           .build());\n     } finally {\n       engine.close(); // Close the connection if it isn\u0027t already.\n       dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": {
      "type": "Ybodychange",
      "commitMessage": "Move connection pooling logic.\n\nPreviously we had this ugly, awkward release() method that\nattempted to manage connection pooling, discarding streams\nfor caching, and closing broken streams.\n\nMove connection reuse to HttpConnection, with policy informed\nby HttpEngine. It specifies what to do when the connection\nbecomes idle: pool, close or hold. The connection does what\nit\u0027s told.\n",
      "commitDate": "2014-02-15, 6:44 p.m.",
      "commitName": "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-01-13, 11:10 p.m.",
      "commitNameOld": "8972a94aee5b1a8732b4f8246c6ce43fd9e5e1cb",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 32.82,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "  @Override protected void execute() {\n    try {\n      Response response \u003d getResponse();\n      if (response !\u003d null \u0026\u0026 !canceled) {\n        responseReceiver.onResponse(response);\n      }\n    } catch (IOException e) {\n      responseReceiver.onFailure(new Failure.Builder()\n          .request(request)\n          .exception(e)\n          .build());\n    } finally {\n      engine.close(); // Close the connection if it isn\u0027t already.\n      dispatcher.finished(this);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 71,
      "functionName": "execute",
      "diff": "@@ -1,16 +1,16 @@\n   @Override protected void execute() {\n     try {\n       Response response \u003d getResponse();\n       if (response !\u003d null \u0026\u0026 !canceled) {\n         responseReceiver.onResponse(response);\n       }\n     } catch (IOException e) {\n       responseReceiver.onFailure(new Failure.Builder()\n           .request(request)\n           .exception(e)\n           .build());\n     } finally {\n-      engine.release(true); // Release the connection if it isn\u0027t already released.\n+      engine.close(); // Close the connection if it isn\u0027t already.\n       dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "749a65b776c8fc4b39b6463695980275da34da51": {
      "type": "Ymultichange(Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
      "commitDate": "2014-01-12, 9:47 a.m.",
      "commitName": "749a65b776c8fc4b39b6463695980275da34da51",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
          "commitDate": "2014-01-12, 9:47 a.m.",
          "commitName": "749a65b776c8fc4b39b6463695980275da34da51",
          "commitAuthor": "jwilson",
          "commitDateOld": "2014-01-07, 10:41 p.m.",
          "commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.46,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "  @Override protected void execute() {\n    try {\n      Response response \u003d getResponse();\n      if (response !\u003d null \u0026\u0026 !canceled) {\n        responseReceiver.onResponse(response);\n      }\n    } catch (IOException e) {\n      responseReceiver.onFailure(new Failure.Builder()\n          .request(request)\n          .exception(e)\n          .build());\n    } finally {\n      engine.release(true); // Release the connection if it isn\u0027t already released.\n      dispatcher.finished(this);\n    }\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
          "functionStartLine": 71,
          "functionName": "execute",
          "diff": "@@ -1,57 +1,16 @@\n-  private Response execute() throws IOException {\n-    Connection connection \u003d null;\n-    Response redirectedBy \u003d null;\n-\n-    while (true) {\n-      if (canceled) return null;\n-\n-      Request.Body body \u003d request.body();\n-      if (body !\u003d null) {\n-        MediaType contentType \u003d body.contentType();\n-        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-\n-        Request.Builder requestBuilder \u003d request.newBuilder();\n-        requestBuilder.header(\"Content-Type\", contentType.toString());\n-\n-        long contentLength \u003d body.contentLength();\n-        if (contentLength !\u003d -1) {\n-          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-          requestBuilder.removeHeader(\"Transfer-Encoding\");\n-        } else {\n-          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-          requestBuilder.removeHeader(\"Content-Length\");\n-        }\n-\n-        request \u003d requestBuilder.build();\n+  @Override protected void execute() {\n+    try {\n+      Response response \u003d getResponse();\n+      if (response !\u003d null \u0026\u0026 !canceled) {\n+        responseReceiver.onResponse(response);\n       }\n-\n-      engine \u003d new HttpEngine(client, request, false, connection, null);\n-      engine.sendRequest();\n-\n-      if (body !\u003d null) {\n-        body.writeTo(engine.getRequestBody());\n-      }\n-\n-      engine.readResponse();\n-\n-      Response response \u003d engine.getResponse();\n-      Request redirect \u003d processResponse(engine, response);\n-\n-      if (redirect \u003d\u003d null) {\n-        engine.automaticallyReleaseConnectionToPool();\n-        return response.newBuilder()\n-            .body(new RealResponseBody(response, engine.getResponseBody()))\n-            .redirectedBy(redirectedBy)\n-            .build();\n-      }\n-\n-      if (!sameConnection(request, redirect)) {\n-        engine.automaticallyReleaseConnectionToPool();\n-      }\n-\n-      engine.release(false);\n-      connection \u003d engine.getConnection();\n-      redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n-      request \u003d redirect;\n+    } catch (IOException e) {\n+      responseReceiver.onFailure(new Failure.Builder()\n+          .request(request)\n+          .exception(e)\n+          .build());\n+    } finally {\n+      engine.release(true); // Release the connection if it isn\u0027t already released.\n+      dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Response",
            "newValue": "void"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
          "commitDate": "2014-01-12, 9:47 a.m.",
          "commitName": "749a65b776c8fc4b39b6463695980275da34da51",
          "commitAuthor": "jwilson",
          "commitDateOld": "2014-01-07, 10:41 p.m.",
          "commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.46,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "  @Override protected void execute() {\n    try {\n      Response response \u003d getResponse();\n      if (response !\u003d null \u0026\u0026 !canceled) {\n        responseReceiver.onResponse(response);\n      }\n    } catch (IOException e) {\n      responseReceiver.onFailure(new Failure.Builder()\n          .request(request)\n          .exception(e)\n          .build());\n    } finally {\n      engine.release(true); // Release the connection if it isn\u0027t already released.\n      dispatcher.finished(this);\n    }\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
          "functionStartLine": 71,
          "functionName": "execute",
          "diff": "@@ -1,57 +1,16 @@\n-  private Response execute() throws IOException {\n-    Connection connection \u003d null;\n-    Response redirectedBy \u003d null;\n-\n-    while (true) {\n-      if (canceled) return null;\n-\n-      Request.Body body \u003d request.body();\n-      if (body !\u003d null) {\n-        MediaType contentType \u003d body.contentType();\n-        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-\n-        Request.Builder requestBuilder \u003d request.newBuilder();\n-        requestBuilder.header(\"Content-Type\", contentType.toString());\n-\n-        long contentLength \u003d body.contentLength();\n-        if (contentLength !\u003d -1) {\n-          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-          requestBuilder.removeHeader(\"Transfer-Encoding\");\n-        } else {\n-          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-          requestBuilder.removeHeader(\"Content-Length\");\n-        }\n-\n-        request \u003d requestBuilder.build();\n+  @Override protected void execute() {\n+    try {\n+      Response response \u003d getResponse();\n+      if (response !\u003d null \u0026\u0026 !canceled) {\n+        responseReceiver.onResponse(response);\n       }\n-\n-      engine \u003d new HttpEngine(client, request, false, connection, null);\n-      engine.sendRequest();\n-\n-      if (body !\u003d null) {\n-        body.writeTo(engine.getRequestBody());\n-      }\n-\n-      engine.readResponse();\n-\n-      Response response \u003d engine.getResponse();\n-      Request redirect \u003d processResponse(engine, response);\n-\n-      if (redirect \u003d\u003d null) {\n-        engine.automaticallyReleaseConnectionToPool();\n-        return response.newBuilder()\n-            .body(new RealResponseBody(response, engine.getResponseBody()))\n-            .redirectedBy(redirectedBy)\n-            .build();\n-      }\n-\n-      if (!sameConnection(request, redirect)) {\n-        engine.automaticallyReleaseConnectionToPool();\n-      }\n-\n-      engine.release(false);\n-      connection \u003d engine.getConnection();\n-      redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n-      request \u003d redirect;\n+    } catch (IOException e) {\n+      responseReceiver.onFailure(new Failure.Builder()\n+          .request(request)\n+          .exception(e)\n+          .build());\n+    } finally {\n+      engine.release(true); // Release the connection if it isn\u0027t already released.\n+      dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
          "commitDate": "2014-01-12, 9:47 a.m.",
          "commitName": "749a65b776c8fc4b39b6463695980275da34da51",
          "commitAuthor": "jwilson",
          "commitDateOld": "2014-01-07, 10:41 p.m.",
          "commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.46,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "  @Override protected void execute() {\n    try {\n      Response response \u003d getResponse();\n      if (response !\u003d null \u0026\u0026 !canceled) {\n        responseReceiver.onResponse(response);\n      }\n    } catch (IOException e) {\n      responseReceiver.onFailure(new Failure.Builder()\n          .request(request)\n          .exception(e)\n          .build());\n    } finally {\n      engine.release(true); // Release the connection if it isn\u0027t already released.\n      dispatcher.finished(this);\n    }\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
          "functionStartLine": 71,
          "functionName": "execute",
          "diff": "@@ -1,57 +1,16 @@\n-  private Response execute() throws IOException {\n-    Connection connection \u003d null;\n-    Response redirectedBy \u003d null;\n-\n-    while (true) {\n-      if (canceled) return null;\n-\n-      Request.Body body \u003d request.body();\n-      if (body !\u003d null) {\n-        MediaType contentType \u003d body.contentType();\n-        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-\n-        Request.Builder requestBuilder \u003d request.newBuilder();\n-        requestBuilder.header(\"Content-Type\", contentType.toString());\n-\n-        long contentLength \u003d body.contentLength();\n-        if (contentLength !\u003d -1) {\n-          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-          requestBuilder.removeHeader(\"Transfer-Encoding\");\n-        } else {\n-          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-          requestBuilder.removeHeader(\"Content-Length\");\n-        }\n-\n-        request \u003d requestBuilder.build();\n+  @Override protected void execute() {\n+    try {\n+      Response response \u003d getResponse();\n+      if (response !\u003d null \u0026\u0026 !canceled) {\n+        responseReceiver.onResponse(response);\n       }\n-\n-      engine \u003d new HttpEngine(client, request, false, connection, null);\n-      engine.sendRequest();\n-\n-      if (body !\u003d null) {\n-        body.writeTo(engine.getRequestBody());\n-      }\n-\n-      engine.readResponse();\n-\n-      Response response \u003d engine.getResponse();\n-      Request redirect \u003d processResponse(engine, response);\n-\n-      if (redirect \u003d\u003d null) {\n-        engine.automaticallyReleaseConnectionToPool();\n-        return response.newBuilder()\n-            .body(new RealResponseBody(response, engine.getResponseBody()))\n-            .redirectedBy(redirectedBy)\n-            .build();\n-      }\n-\n-      if (!sameConnection(request, redirect)) {\n-        engine.automaticallyReleaseConnectionToPool();\n-      }\n-\n-      engine.release(false);\n-      connection \u003d engine.getConnection();\n-      redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n-      request \u003d redirect;\n+    } catch (IOException e) {\n+      responseReceiver.onFailure(new Failure.Builder()\n+          .request(request)\n+          .exception(e)\n+          .build());\n+    } finally {\n+      engine.release(true); // Release the connection if it isn\u0027t already released.\n+      dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
          "commitDate": "2014-01-12, 9:47 a.m.",
          "commitName": "749a65b776c8fc4b39b6463695980275da34da51",
          "commitAuthor": "jwilson",
          "commitDateOld": "2014-01-07, 10:41 p.m.",
          "commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.46,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "  @Override protected void execute() {\n    try {\n      Response response \u003d getResponse();\n      if (response !\u003d null \u0026\u0026 !canceled) {\n        responseReceiver.onResponse(response);\n      }\n    } catch (IOException e) {\n      responseReceiver.onFailure(new Failure.Builder()\n          .request(request)\n          .exception(e)\n          .build());\n    } finally {\n      engine.release(true); // Release the connection if it isn\u0027t already released.\n      dispatcher.finished(this);\n    }\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
          "functionStartLine": 71,
          "functionName": "execute",
          "diff": "@@ -1,57 +1,16 @@\n-  private Response execute() throws IOException {\n-    Connection connection \u003d null;\n-    Response redirectedBy \u003d null;\n-\n-    while (true) {\n-      if (canceled) return null;\n-\n-      Request.Body body \u003d request.body();\n-      if (body !\u003d null) {\n-        MediaType contentType \u003d body.contentType();\n-        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-\n-        Request.Builder requestBuilder \u003d request.newBuilder();\n-        requestBuilder.header(\"Content-Type\", contentType.toString());\n-\n-        long contentLength \u003d body.contentLength();\n-        if (contentLength !\u003d -1) {\n-          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-          requestBuilder.removeHeader(\"Transfer-Encoding\");\n-        } else {\n-          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-          requestBuilder.removeHeader(\"Content-Length\");\n-        }\n-\n-        request \u003d requestBuilder.build();\n+  @Override protected void execute() {\n+    try {\n+      Response response \u003d getResponse();\n+      if (response !\u003d null \u0026\u0026 !canceled) {\n+        responseReceiver.onResponse(response);\n       }\n-\n-      engine \u003d new HttpEngine(client, request, false, connection, null);\n-      engine.sendRequest();\n-\n-      if (body !\u003d null) {\n-        body.writeTo(engine.getRequestBody());\n-      }\n-\n-      engine.readResponse();\n-\n-      Response response \u003d engine.getResponse();\n-      Request redirect \u003d processResponse(engine, response);\n-\n-      if (redirect \u003d\u003d null) {\n-        engine.automaticallyReleaseConnectionToPool();\n-        return response.newBuilder()\n-            .body(new RealResponseBody(response, engine.getResponseBody()))\n-            .redirectedBy(redirectedBy)\n-            .build();\n-      }\n-\n-      if (!sameConnection(request, redirect)) {\n-        engine.automaticallyReleaseConnectionToPool();\n-      }\n-\n-      engine.release(false);\n-      connection \u003d engine.getConnection();\n-      redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n-      request \u003d redirect;\n+    } catch (IOException e) {\n+      responseReceiver.onFailure(new Failure.Builder()\n+          .request(request)\n+          .exception(e)\n+          .build());\n+    } finally {\n+      engine.release(true); // Release the connection if it isn\u0027t already released.\n+      dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a": {
      "type": "Ybodychange",
      "commitMessage": "Cleanup when a job finishes, cleanly or otherwise.\n\nThis also names the job thread.\n",
      "commitDate": "2014-01-07, 10:41 p.m.",
      "commitName": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-01-05, 7:28 p.m.",
      "commitNameOld": "f3a450bf4f0e9428cf8b3c2780236162bbeb803a",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 2.13,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "  private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n\n    while (true) {\n      if (canceled) return null;\n\n      Request.Body body \u003d request.body();\n      if (body !\u003d null) {\n        MediaType contentType \u003d body.contentType();\n        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n\n        Request.Builder requestBuilder \u003d request.newBuilder();\n        requestBuilder.header(\"Content-Type\", contentType.toString());\n\n        long contentLength \u003d body.contentLength();\n        if (contentLength !\u003d -1) {\n          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n          requestBuilder.removeHeader(\"Transfer-Encoding\");\n        } else {\n          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n          requestBuilder.removeHeader(\"Content-Length\");\n        }\n\n        request \u003d requestBuilder.build();\n      }\n\n      engine \u003d new HttpEngine(client, request, false, connection, null);\n      engine.sendRequest();\n\n      if (body !\u003d null) {\n        body.writeTo(engine.getRequestBody());\n      }\n\n      engine.readResponse();\n\n      Response response \u003d engine.getResponse();\n      Request redirect \u003d processResponse(engine, response);\n\n      if (redirect \u003d\u003d null) {\n        engine.automaticallyReleaseConnectionToPool();\n        return response.newBuilder()\n            .body(new RealResponseBody(response, engine.getResponseBody()))\n            .redirectedBy(redirectedBy)\n            .build();\n      }\n\n      if (!sameConnection(request, redirect)) {\n        engine.automaticallyReleaseConnectionToPool();\n      }\n\n      engine.release(false);\n      connection \u003d engine.getConnection();\n      redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n      request \u003d redirect;\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 93,
      "functionName": "execute",
      "diff": "@@ -1,57 +1,57 @@\n   private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n \n     while (true) {\n       if (canceled) return null;\n \n       Request.Body body \u003d request.body();\n       if (body !\u003d null) {\n         MediaType contentType \u003d body.contentType();\n         if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n \n         Request.Builder requestBuilder \u003d request.newBuilder();\n         requestBuilder.header(\"Content-Type\", contentType.toString());\n \n         long contentLength \u003d body.contentLength();\n         if (contentLength !\u003d -1) {\n           requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n           requestBuilder.removeHeader(\"Transfer-Encoding\");\n         } else {\n           requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n           requestBuilder.removeHeader(\"Content-Length\");\n         }\n \n         request \u003d requestBuilder.build();\n       }\n \n-      HttpEngine engine \u003d new HttpEngine(client, request, false, connection, null);\n+      engine \u003d new HttpEngine(client, request, false, connection, null);\n       engine.sendRequest();\n \n       if (body !\u003d null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       Response response \u003d engine.getResponse();\n       Request redirect \u003d processResponse(engine, response);\n \n       if (redirect \u003d\u003d null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response.newBuilder()\n             .body(new RealResponseBody(response, engine.getResponseBody()))\n             .redirectedBy(redirectedBy)\n             .build();\n       }\n \n       if (!sameConnection(request, redirect)) {\n         engine.automaticallyReleaseConnectionToPool();\n       }\n \n       engine.release(false);\n       connection \u003d engine.getConnection();\n       redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n       request \u003d redirect;\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f3a450bf4f0e9428cf8b3c2780236162bbeb803a": {
      "type": "Ybodychange",
      "commitMessage": "Code to handle redirect limits in the async API.\n",
      "commitDate": "2014-01-05, 7:28 p.m.",
      "commitName": "f3a450bf4f0e9428cf8b3c2780236162bbeb803a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-01-05, 10:06 a.m.",
      "commitNameOld": "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.39,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "  private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n\n    while (true) {\n      if (canceled) return null;\n\n      Request.Body body \u003d request.body();\n      if (body !\u003d null) {\n        MediaType contentType \u003d body.contentType();\n        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n\n        Request.Builder requestBuilder \u003d request.newBuilder();\n        requestBuilder.header(\"Content-Type\", contentType.toString());\n\n        long contentLength \u003d body.contentLength();\n        if (contentLength !\u003d -1) {\n          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n          requestBuilder.removeHeader(\"Transfer-Encoding\");\n        } else {\n          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n          requestBuilder.removeHeader(\"Content-Length\");\n        }\n\n        request \u003d requestBuilder.build();\n      }\n\n      HttpEngine engine \u003d new HttpEngine(client, request, false, connection, null);\n      engine.sendRequest();\n\n      if (body !\u003d null) {\n        body.writeTo(engine.getRequestBody());\n      }\n\n      engine.readResponse();\n\n      Response response \u003d engine.getResponse();\n      Request redirect \u003d processResponse(engine, response);\n\n      if (redirect \u003d\u003d null) {\n        engine.automaticallyReleaseConnectionToPool();\n        return response.newBuilder()\n            .body(new RealResponseBody(response, engine.getResponseBody()))\n            .redirectedBy(redirectedBy)\n            .build();\n      }\n\n      if (!sameConnection(request, redirect)) {\n        engine.automaticallyReleaseConnectionToPool();\n      }\n\n      engine.release(false);\n      connection \u003d engine.getConnection();\n      redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n      request \u003d redirect;\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 90,
      "functionName": "execute",
      "diff": "@@ -1,56 +1,57 @@\n   private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n \n     while (true) {\n       if (canceled) return null;\n \n       Request.Body body \u003d request.body();\n       if (body !\u003d null) {\n         MediaType contentType \u003d body.contentType();\n         if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n \n         Request.Builder requestBuilder \u003d request.newBuilder();\n         requestBuilder.header(\"Content-Type\", contentType.toString());\n \n         long contentLength \u003d body.contentLength();\n         if (contentLength !\u003d -1) {\n           requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n           requestBuilder.removeHeader(\"Transfer-Encoding\");\n         } else {\n           requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n           requestBuilder.removeHeader(\"Content-Length\");\n         }\n \n         request \u003d requestBuilder.build();\n       }\n \n       HttpEngine engine \u003d new HttpEngine(client, request, false, connection, null);\n       engine.sendRequest();\n \n       if (body !\u003d null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       Response response \u003d engine.getResponse();\n       Request redirect \u003d processResponse(engine, response);\n \n       if (redirect \u003d\u003d null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response.newBuilder()\n             .body(new RealResponseBody(response, engine.getResponseBody()))\n             .redirectedBy(redirectedBy)\n             .build();\n       }\n \n-      // TODO: fail if too many redirects\n-      // TODO: fail if not following redirects\n-      engine.release(false);\n+      if (!sameConnection(request, redirect)) {\n+        engine.automaticallyReleaseConnectionToPool();\n+      }\n \n-      connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n+      engine.release(false);\n+      connection \u003d engine.getConnection();\n       redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n       request \u003d redirect;\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa": {
      "type": "Ybodychange",
      "commitMessage": "Implement simple limits in the dispatcher.\n\nThis adds Dispatcher to the public API so that application\ncode can tweak the policy.\n",
      "commitDate": "2014-01-05, 10:06 a.m.",
      "commitName": "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-01-03, 5:36 p.m.",
      "commitNameOld": "9417fa5c2e84580411e0fa4905b1f109e2d49533",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.69,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "  private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n\n    while (true) {\n      if (canceled) return null;\n\n      Request.Body body \u003d request.body();\n      if (body !\u003d null) {\n        MediaType contentType \u003d body.contentType();\n        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n\n        Request.Builder requestBuilder \u003d request.newBuilder();\n        requestBuilder.header(\"Content-Type\", contentType.toString());\n\n        long contentLength \u003d body.contentLength();\n        if (contentLength !\u003d -1) {\n          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n          requestBuilder.removeHeader(\"Transfer-Encoding\");\n        } else {\n          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n          requestBuilder.removeHeader(\"Content-Length\");\n        }\n\n        request \u003d requestBuilder.build();\n      }\n\n      HttpEngine engine \u003d new HttpEngine(client, request, false, connection, null);\n      engine.sendRequest();\n\n      if (body !\u003d null) {\n        body.writeTo(engine.getRequestBody());\n      }\n\n      engine.readResponse();\n\n      Response response \u003d engine.getResponse();\n      Request redirect \u003d processResponse(engine, response);\n\n      if (redirect \u003d\u003d null) {\n        engine.automaticallyReleaseConnectionToPool();\n        return response.newBuilder()\n            .body(new RealResponseBody(response, engine.getResponseBody()))\n            .redirectedBy(redirectedBy)\n            .build();\n      }\n\n      // TODO: fail if too many redirects\n      // TODO: fail if not following redirects\n      engine.release(false);\n\n      connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n      redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n      request \u003d redirect;\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 88,
      "functionName": "execute",
      "diff": "@@ -1,54 +1,56 @@\n   private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n \n     while (true) {\n+      if (canceled) return null;\n+\n       Request.Body body \u003d request.body();\n       if (body !\u003d null) {\n         MediaType contentType \u003d body.contentType();\n         if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n \n         Request.Builder requestBuilder \u003d request.newBuilder();\n         requestBuilder.header(\"Content-Type\", contentType.toString());\n \n         long contentLength \u003d body.contentLength();\n         if (contentLength !\u003d -1) {\n           requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n           requestBuilder.removeHeader(\"Transfer-Encoding\");\n         } else {\n           requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n           requestBuilder.removeHeader(\"Content-Length\");\n         }\n \n         request \u003d requestBuilder.build();\n       }\n \n-      HttpEngine engine \u003d newEngine(connection);\n+      HttpEngine engine \u003d new HttpEngine(client, request, false, connection, null);\n       engine.sendRequest();\n \n       if (body !\u003d null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       Response response \u003d engine.getResponse();\n       Request redirect \u003d processResponse(engine, response);\n \n       if (redirect \u003d\u003d null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response.newBuilder()\n             .body(new RealResponseBody(response, engine.getResponseBody()))\n             .redirectedBy(redirectedBy)\n             .build();\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       engine.release(false);\n \n       connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n       request \u003d redirect;\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9417fa5c2e84580411e0fa4905b1f109e2d49533": {
      "type": "Ybodychange",
      "commitMessage": "Another round of header APIs cleanup.\n\nThis promotes Headers to a public API from the internal package.\nIt moves some of its methods to OkHeaders, which has been renamed\nfrom SyntheticHeaders.\n\nMaking the Headers class public API makes it possible to remove\nmore exotic APIs from Request and Response like the APIs to track\nheaders by index rather than by name.\n",
      "commitDate": "2014-01-03, 5:36 p.m.",
      "commitName": "9417fa5c2e84580411e0fa4905b1f109e2d49533",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-01-03, 12:52 a.m.",
      "commitNameOld": "b21ea3a7daf9de0a5deb9bf7cf6d791c2ff63d3b",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.7,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n\n    while (true) {\n      Request.Body body \u003d request.body();\n      if (body !\u003d null) {\n        MediaType contentType \u003d body.contentType();\n        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n\n        Request.Builder requestBuilder \u003d request.newBuilder();\n        requestBuilder.header(\"Content-Type\", contentType.toString());\n\n        long contentLength \u003d body.contentLength();\n        if (contentLength !\u003d -1) {\n          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n          requestBuilder.removeHeader(\"Transfer-Encoding\");\n        } else {\n          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n          requestBuilder.removeHeader(\"Content-Length\");\n        }\n\n        request \u003d requestBuilder.build();\n      }\n\n      HttpEngine engine \u003d newEngine(connection);\n      engine.sendRequest();\n\n      if (body !\u003d null) {\n        body.writeTo(engine.getRequestBody());\n      }\n\n      engine.readResponse();\n\n      Response response \u003d engine.getResponse();\n      Request redirect \u003d processResponse(engine, response);\n\n      if (redirect \u003d\u003d null) {\n        engine.automaticallyReleaseConnectionToPool();\n        return response.newBuilder()\n            .body(new RealResponseBody(response, engine.getResponseBody()))\n            .redirectedBy(redirectedBy)\n            .build();\n      }\n\n      // TODO: fail if too many redirects\n      // TODO: fail if not following redirects\n      engine.release(false);\n\n      connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n      redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n      request \u003d redirect;\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 72,
      "functionName": "execute",
      "diff": "@@ -1,54 +1,54 @@\n   private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n \n     while (true) {\n       Request.Body body \u003d request.body();\n       if (body !\u003d null) {\n         MediaType contentType \u003d body.contentType();\n         if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n \n         Request.Builder requestBuilder \u003d request.newBuilder();\n         requestBuilder.header(\"Content-Type\", contentType.toString());\n \n         long contentLength \u003d body.contentLength();\n         if (contentLength !\u003d -1) {\n-          requestBuilder.setContentLength(contentLength);\n+          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n           requestBuilder.removeHeader(\"Transfer-Encoding\");\n         } else {\n           requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n           requestBuilder.removeHeader(\"Content-Length\");\n         }\n \n         request \u003d requestBuilder.build();\n       }\n \n       HttpEngine engine \u003d newEngine(connection);\n       engine.sendRequest();\n \n       if (body !\u003d null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       Response response \u003d engine.getResponse();\n       Request redirect \u003d processResponse(engine, response);\n \n       if (redirect \u003d\u003d null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response.newBuilder()\n-            .body(new Dispatcher.RealResponseBody(response, engine.getResponseBody()))\n+            .body(new RealResponseBody(response, engine.getResponseBody()))\n             .redirectedBy(redirectedBy)\n             .build();\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       engine.release(false);\n \n       connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n       request \u003d redirect;\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b21ea3a7daf9de0a5deb9bf7cf6d791c2ff63d3b": {
      "type": "Ybodychange",
      "commitMessage": "Make redirects work with the async API.\n",
      "commitDate": "2014-01-03, 12:52 a.m.",
      "commitName": "b21ea3a7daf9de0a5deb9bf7cf6d791c2ff63d3b",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-01-02, 10:23 a.m.",
      "commitNameOld": "0ef26ad2e9e6b28a181ebc128f96671cff295043",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.6,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "  private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n\n    while (true) {\n      Request.Body body \u003d request.body();\n      if (body !\u003d null) {\n        MediaType contentType \u003d body.contentType();\n        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n\n        Request.Builder requestBuilder \u003d request.newBuilder();\n        requestBuilder.header(\"Content-Type\", contentType.toString());\n\n        long contentLength \u003d body.contentLength();\n        if (contentLength !\u003d -1) {\n          requestBuilder.setContentLength(contentLength);\n          requestBuilder.removeHeader(\"Transfer-Encoding\");\n        } else {\n          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n          requestBuilder.removeHeader(\"Content-Length\");\n        }\n\n        request \u003d requestBuilder.build();\n      }\n\n      HttpEngine engine \u003d newEngine(connection);\n      engine.sendRequest();\n\n      if (body !\u003d null) {\n        body.writeTo(engine.getRequestBody());\n      }\n\n      engine.readResponse();\n\n      Response response \u003d engine.getResponse();\n      Request redirect \u003d processResponse(engine, response);\n\n      if (redirect \u003d\u003d null) {\n        engine.automaticallyReleaseConnectionToPool();\n        return response.newBuilder()\n            .body(new Dispatcher.RealResponseBody(response, engine.getResponseBody()))\n            .redirectedBy(redirectedBy)\n            .build();\n      }\n\n      // TODO: fail if too many redirects\n      // TODO: fail if not following redirects\n      engine.release(false);\n\n      connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n      redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n      request \u003d redirect;\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 70,
      "functionName": "execute",
      "diff": "@@ -1,56 +1,54 @@\n   private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n \n     while (true) {\n       Request.Body body \u003d request.body();\n       if (body !\u003d null) {\n         MediaType contentType \u003d body.contentType();\n         if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n \n         Request.Builder requestBuilder \u003d request.newBuilder();\n         requestBuilder.header(\"Content-Type\", contentType.toString());\n \n         long contentLength \u003d body.contentLength();\n         if (contentLength !\u003d -1) {\n           requestBuilder.setContentLength(contentLength);\n           requestBuilder.removeHeader(\"Transfer-Encoding\");\n         } else {\n           requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n           requestBuilder.removeHeader(\"Content-Length\");\n         }\n \n         request \u003d requestBuilder.build();\n       }\n \n       HttpEngine engine \u003d newEngine(connection);\n       engine.sendRequest();\n \n       if (body !\u003d null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n-      Response engineResponse \u003d engine.getResponse();\n-      Response response \u003d engineResponse.newBuilder()\n-          .body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody()))\n-          .redirectedBy(redirectedBy)\n-          .build();\n-\n+      Response response \u003d engine.getResponse();\n       Request redirect \u003d processResponse(engine, response);\n \n       if (redirect \u003d\u003d null) {\n         engine.automaticallyReleaseConnectionToPool();\n-        return response;\n+        return response.newBuilder()\n+            .body(new Dispatcher.RealResponseBody(response, engine.getResponseBody()))\n+            .redirectedBy(redirectedBy)\n+            .build();\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n-      // TODO: release engine\n+      engine.release(false);\n \n       connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n-      redirectedBy \u003d response;\n+      redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n       request \u003d redirect;\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0ef26ad2e9e6b28a181ebc128f96671cff295043": {
      "type": "Ybodychange",
      "commitMessage": "Remove some \u0027implementation detail\u0027 headers from the public API.\n\nApplication code doesn\u0027t need to worry about headers like\n\u0027Connection\u0027 or \u0027Transfer-Encoding\u0027, so don\u0027t include them\nin the API.\n",
      "commitDate": "2014-01-02, 10:23 a.m.",
      "commitName": "0ef26ad2e9e6b28a181ebc128f96671cff295043",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-01-01, 10:30 a.m.",
      "commitNameOld": "dbca0acc6f8c188dfa48f07bb5886606bec8d28f",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "  private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n\n    while (true) {\n      Request.Body body \u003d request.body();\n      if (body !\u003d null) {\n        MediaType contentType \u003d body.contentType();\n        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n\n        Request.Builder requestBuilder \u003d request.newBuilder();\n        requestBuilder.header(\"Content-Type\", contentType.toString());\n\n        long contentLength \u003d body.contentLength();\n        if (contentLength !\u003d -1) {\n          requestBuilder.setContentLength(contentLength);\n          requestBuilder.removeHeader(\"Transfer-Encoding\");\n        } else {\n          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n          requestBuilder.removeHeader(\"Content-Length\");\n        }\n\n        request \u003d requestBuilder.build();\n      }\n\n      HttpEngine engine \u003d newEngine(connection);\n      engine.sendRequest();\n\n      if (body !\u003d null) {\n        body.writeTo(engine.getRequestBody());\n      }\n\n      engine.readResponse();\n\n      Response engineResponse \u003d engine.getResponse();\n      Response response \u003d engineResponse.newBuilder()\n          .body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody()))\n          .redirectedBy(redirectedBy)\n          .build();\n\n      Request redirect \u003d processResponse(engine, response);\n\n      if (redirect \u003d\u003d null) {\n        engine.automaticallyReleaseConnectionToPool();\n        return response;\n      }\n\n      // TODO: fail if too many redirects\n      // TODO: fail if not following redirects\n      // TODO: release engine\n\n      connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n      redirectedBy \u003d response;\n      request \u003d redirect;\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 70,
      "functionName": "execute",
      "diff": "@@ -1,56 +1,56 @@\n   private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n \n     while (true) {\n       Request.Body body \u003d request.body();\n       if (body !\u003d null) {\n         MediaType contentType \u003d body.contentType();\n         if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n \n         Request.Builder requestBuilder \u003d request.newBuilder();\n         requestBuilder.header(\"Content-Type\", contentType.toString());\n \n         long contentLength \u003d body.contentLength();\n         if (contentLength !\u003d -1) {\n           requestBuilder.setContentLength(contentLength);\n           requestBuilder.removeHeader(\"Transfer-Encoding\");\n         } else {\n-          requestBuilder.setChunked();\n+          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n           requestBuilder.removeHeader(\"Content-Length\");\n         }\n \n         request \u003d requestBuilder.build();\n       }\n \n       HttpEngine engine \u003d newEngine(connection);\n       engine.sendRequest();\n \n       if (body !\u003d null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       Response engineResponse \u003d engine.getResponse();\n       Response response \u003d engineResponse.newBuilder()\n           .body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody()))\n           .redirectedBy(redirectedBy)\n           .build();\n \n       Request redirect \u003d processResponse(engine, response);\n \n       if (redirect \u003d\u003d null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response;\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       // TODO: release engine\n \n       connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy \u003d response;\n       request \u003d redirect;\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dbca0acc6f8c188dfa48f07bb5886606bec8d28f": {
      "type": "Ybodychange",
      "commitMessage": "Kill the Policy interface.\n\nThis interface was necessary while cleaning up the delicate\nintertwined relationship between HttpURLConnection and HttpEngine.\nWith this change HttpEngine no longer has a reverse dependency\non HttpURLConnection.\n",
      "commitDate": "2014-01-01, 10:30 a.m.",
      "commitName": "dbca0acc6f8c188dfa48f07bb5886606bec8d28f",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-12-31, 1:15 a.m.",
      "commitNameOld": "60f20dc23cb08d598d605f51f7526725ec42abd9",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.39,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "  private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n\n    while (true) {\n      Request.Body body \u003d request.body();\n      if (body !\u003d null) {\n        MediaType contentType \u003d body.contentType();\n        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n\n        Request.Builder requestBuilder \u003d request.newBuilder();\n        requestBuilder.header(\"Content-Type\", contentType.toString());\n\n        long contentLength \u003d body.contentLength();\n        if (contentLength !\u003d -1) {\n          requestBuilder.setContentLength(contentLength);\n          requestBuilder.removeHeader(\"Transfer-Encoding\");\n        } else {\n          requestBuilder.setChunked();\n          requestBuilder.removeHeader(\"Content-Length\");\n        }\n\n        request \u003d requestBuilder.build();\n      }\n\n      HttpEngine engine \u003d newEngine(connection);\n      engine.sendRequest();\n\n      if (body !\u003d null) {\n        body.writeTo(engine.getRequestBody());\n      }\n\n      engine.readResponse();\n\n      Response engineResponse \u003d engine.getResponse();\n      Response response \u003d engineResponse.newBuilder()\n          .body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody()))\n          .redirectedBy(redirectedBy)\n          .build();\n\n      Request redirect \u003d processResponse(engine, response);\n\n      if (redirect \u003d\u003d null) {\n        engine.automaticallyReleaseConnectionToPool();\n        return response;\n      }\n\n      // TODO: fail if too many redirects\n      // TODO: fail if not following redirects\n      // TODO: release engine\n\n      connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n      redirectedBy \u003d response;\n      request \u003d redirect;\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 70,
      "functionName": "execute",
      "diff": "@@ -1,45 +1,56 @@\n   private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n \n     while (true) {\n       Request.Body body \u003d request.body();\n       if (body !\u003d null) {\n         MediaType contentType \u003d body.contentType();\n         if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-        if (request.header(\"Content-Type\") \u003d\u003d null) {\n-          request \u003d request.newBuilder().header(\"Content-Type\", contentType.toString()).build();\n+\n+        Request.Builder requestBuilder \u003d request.newBuilder();\n+        requestBuilder.header(\"Content-Type\", contentType.toString());\n+\n+        long contentLength \u003d body.contentLength();\n+        if (contentLength !\u003d -1) {\n+          requestBuilder.setContentLength(contentLength);\n+          requestBuilder.removeHeader(\"Transfer-Encoding\");\n+        } else {\n+          requestBuilder.setChunked();\n+          requestBuilder.removeHeader(\"Content-Length\");\n         }\n+\n+        request \u003d requestBuilder.build();\n       }\n \n       HttpEngine engine \u003d newEngine(connection);\n       engine.sendRequest();\n \n       if (body !\u003d null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       Response engineResponse \u003d engine.getResponse();\n       Response response \u003d engineResponse.newBuilder()\n           .body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody()))\n           .redirectedBy(redirectedBy)\n           .build();\n \n       Request redirect \u003d processResponse(engine, response);\n \n       if (redirect \u003d\u003d null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response;\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       // TODO: release engine\n \n       connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy \u003d response;\n       request \u003d redirect;\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "14b6e76e7d7af9b99a7fdc1a56d7ee9309711722": {
      "type": "Ybodychange",
      "commitMessage": "Combine Request+RequestHeaders and Response+ResponseHeaders.\n\nThis cleans up a lot of the unnecessary moving parts in\nHttpEngine. That class is still stuck with some complexity\naround request and response bodies, but it\u0027s getting better.\n\nWe\u0027re also stuck escalating the visibility of a lot of\nmembers in Request and Response. I\u0027ve got some ideas on\nhow to fix this; that\u0027ll have to wait for a follow up.\n",
      "commitDate": "2013-12-30, 5:08 p.m.",
      "commitName": "14b6e76e7d7af9b99a7fdc1a56d7ee9309711722",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-12-29, 9:17 p.m.",
      "commitNameOld": "350c43b6fe02401a73f967d9ef322061638b372a",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.83,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n\n    while (true) {\n      Request.Body body \u003d request.body();\n      if (body !\u003d null) {\n        MediaType contentType \u003d body.contentType();\n        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n        if (request.header(\"Content-Type\") \u003d\u003d null) {\n          request \u003d request.newBuilder().header(\"Content-Type\", contentType.toString()).build();\n        }\n      }\n\n      HttpEngine engine \u003d newEngine(connection);\n      engine.sendRequest();\n\n      if (body !\u003d null) {\n        body.writeTo(engine.getRequestBody());\n      }\n\n      engine.readResponse();\n\n      Response engineResponse \u003d engine.getResponse();\n      Response response \u003d engineResponse.newBuilder()\n          .body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody()))\n          .redirectedBy(redirectedBy)\n          .build();\n\n      Request redirect \u003d processResponse(engine, response);\n\n      if (redirect \u003d\u003d null) {\n        engine.automaticallyReleaseConnectionToPool();\n        return response;\n      }\n\n      // TODO: fail if too many redirects\n      // TODO: fail if not following redirects\n      // TODO: release engine\n\n      connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n      redirectedBy \u003d response;\n      request \u003d redirect;\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 102,
      "functionName": "execute",
      "diff": "@@ -1,50 +1,45 @@\n   private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n \n     while (true) {\n       Request.Body body \u003d request.body();\n       if (body !\u003d null) {\n         MediaType contentType \u003d body.contentType();\n         if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n         if (request.header(\"Content-Type\") \u003d\u003d null) {\n           request \u003d request.newBuilder().header(\"Content-Type\", contentType.toString()).build();\n         }\n       }\n \n       HttpEngine engine \u003d newEngine(connection);\n       engine.sendRequest();\n \n       if (body !\u003d null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n-      int responseCode \u003d engine.getResponseCode();\n-      Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(\n-          engine.getResponseHeaders(), engine.getResponseBody());\n-\n-      Response response \u003d new Response.Builder(request, responseCode)\n-          .handshake(engine.getHandshake())\n-          .rawHeaders(engine.getResponseHeaders().getHeaders())\n-          .body(responseBody)\n+      Response engineResponse \u003d engine.getResponse();\n+      Response response \u003d engineResponse.newBuilder()\n+          .body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody()))\n           .redirectedBy(redirectedBy)\n           .build();\n \n       Request redirect \u003d processResponse(engine, response);\n \n       if (redirect \u003d\u003d null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response;\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       // TODO: release engine\n \n       connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy \u003d response;\n       request \u003d redirect;\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "350c43b6fe02401a73f967d9ef322061638b372a": {
      "type": "Ybodychange",
      "commitMessage": "Make RawHeaders, RequestHeaders and ResponseHeaders immutable.\n\nThis introduces a new, poorly-named class ResponseStrategy\nthat pulls some code out of ResponseHeaders. That was necessary\nbecause the old method mutated itself and its parameters in\nplace.\n\nObvious follow-up for this is to combine ResponseHeaders with\nResponse, and RequestHeaders with Response.\n",
      "commitDate": "2013-12-29, 9:17 p.m.",
      "commitName": "350c43b6fe02401a73f967d9ef322061638b372a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-12-29, 6:57 p.m.",
      "commitNameOld": "30ecba897fb624df201f0a014b54a604418a0e73",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n\n    while (true) {\n      Request.Body body \u003d request.body();\n      if (body !\u003d null) {\n        MediaType contentType \u003d body.contentType();\n        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n        if (request.header(\"Content-Type\") \u003d\u003d null) {\n          request \u003d request.newBuilder().header(\"Content-Type\", contentType.toString()).build();\n        }\n      }\n\n      HttpEngine engine \u003d newEngine(connection);\n      engine.sendRequest();\n\n      if (body !\u003d null) {\n        body.writeTo(engine.getRequestBody());\n      }\n\n      engine.readResponse();\n\n      int responseCode \u003d engine.getResponseCode();\n      Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(\n          engine.getResponseHeaders(), engine.getResponseBody());\n\n      Response response \u003d new Response.Builder(request, responseCode)\n          .handshake(engine.getHandshake())\n          .rawHeaders(engine.getResponseHeaders().getHeaders())\n          .body(responseBody)\n          .redirectedBy(redirectedBy)\n          .build();\n\n      Request redirect \u003d processResponse(engine, response);\n\n      if (redirect \u003d\u003d null) {\n        engine.automaticallyReleaseConnectionToPool();\n        return response;\n      }\n\n      // TODO: fail if too many redirects\n      // TODO: fail if not following redirects\n      // TODO: release engine\n\n      connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n      redirectedBy \u003d response;\n      request \u003d redirect;\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 102,
      "functionName": "execute",
      "diff": "@@ -1,51 +1,50 @@\n   private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n \n     while (true) {\n-      HttpEngine engine \u003d newEngine(connection);\n-\n       Request.Body body \u003d request.body();\n       if (body !\u003d null) {\n         MediaType contentType \u003d body.contentType();\n         if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-        if (engine.getRequestHeaders().getContentType() \u003d\u003d null) {\n-          engine.getRequestHeaders().setContentType(contentType.toString());\n+        if (request.header(\"Content-Type\") \u003d\u003d null) {\n+          request \u003d request.newBuilder().header(\"Content-Type\", contentType.toString()).build();\n         }\n       }\n \n+      HttpEngine engine \u003d newEngine(connection);\n       engine.sendRequest();\n \n       if (body !\u003d null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       int responseCode \u003d engine.getResponseCode();\n       Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(\n           engine.getResponseHeaders(), engine.getResponseBody());\n \n       Response response \u003d new Response.Builder(request, responseCode)\n           .handshake(engine.getHandshake())\n           .rawHeaders(engine.getResponseHeaders().getHeaders())\n           .body(responseBody)\n           .redirectedBy(redirectedBy)\n           .build();\n \n       Request redirect \u003d processResponse(engine, response);\n \n       if (redirect \u003d\u003d null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response;\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       // TODO: release engine\n \n       connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy \u003d response;\n       request \u003d redirect;\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e2bfa5dd6c0aee7d7e34b224a649500b9e5c267f": {
      "type": "Ybodychange",
      "commitMessage": "Introduce Handshake as a value object.\n\nI needed a non-terrible way to provide the HTTPS handshake\ninformation to the async API. Previously we were passing the\nlive socket around, which was leaky and gross.\n\nThis creates a new value object that captures the relevant\nbits of the handshake. We can use it in the response, the\nconnection, and also in the cache. It\u0027s plausible that in\nthe future we can use it to allow the application to block\nrequests if the handshake is insufficient.\n",
      "commitDate": "2013-12-29, 12:35 a.m.",
      "commitName": "e2bfa5dd6c0aee7d7e34b224a649500b9e5c267f",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-12-28, 8:24 p.m.",
      "commitNameOld": "37c01895cca5ec2bec26a3d381611f0938acd6d0",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n\n    while (true) {\n      HttpEngine engine \u003d newEngine(connection);\n\n      Request.Body body \u003d request.body();\n      if (body !\u003d null) {\n        MediaType contentType \u003d body.contentType();\n        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n        if (engine.getRequestHeaders().getContentType() \u003d\u003d null) {\n          engine.getRequestHeaders().setContentType(contentType.toString());\n        }\n      }\n\n      engine.sendRequest();\n\n      if (body !\u003d null) {\n        body.writeTo(engine.getRequestBody());\n      }\n\n      engine.readResponse();\n\n      int responseCode \u003d engine.getResponseCode();\n      Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(\n          engine.getResponseHeaders(), engine.getResponseBody());\n\n      Response response \u003d new Response.Builder(request, responseCode)\n          .handshake(engine.getHandshake())\n          .rawHeaders(engine.getResponseHeaders().getHeaders())\n          .body(responseBody)\n          .redirectedBy(redirectedBy)\n          .build();\n\n      Request redirect \u003d processResponse(engine, response);\n\n      if (redirect \u003d\u003d null) {\n        engine.automaticallyReleaseConnectionToPool();\n        return response;\n      }\n\n      // TODO: fail if too many redirects\n      // TODO: fail if not following redirects\n      // TODO: release engine\n\n      connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n      redirectedBy \u003d response;\n      request \u003d redirect;\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 107,
      "functionName": "execute",
      "diff": "@@ -1,50 +1,51 @@\n   private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n \n     while (true) {\n       HttpEngine engine \u003d newEngine(connection);\n \n       Request.Body body \u003d request.body();\n       if (body !\u003d null) {\n         MediaType contentType \u003d body.contentType();\n         if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n         if (engine.getRequestHeaders().getContentType() \u003d\u003d null) {\n           engine.getRequestHeaders().setContentType(contentType.toString());\n         }\n       }\n \n       engine.sendRequest();\n \n       if (body !\u003d null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       int responseCode \u003d engine.getResponseCode();\n       Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(\n           engine.getResponseHeaders(), engine.getResponseBody());\n \n       Response response \u003d new Response.Builder(request, responseCode)\n+          .handshake(engine.getHandshake())\n           .rawHeaders(engine.getResponseHeaders().getHeaders())\n           .body(responseBody)\n           .redirectedBy(redirectedBy)\n           .build();\n \n       Request redirect \u003d processResponse(engine, response);\n \n       if (redirect \u003d\u003d null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response;\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       // TODO: release engine\n \n       connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy \u003d response;\n       request \u003d redirect;\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "37c01895cca5ec2bec26a3d381611f0938acd6d0": {
      "type": "Yintroduced",
      "commitMessage": "Define async APIs and switch Job to use HttpEngine directly.\n\nUsing HttpEngine directly introduces some duplicated code with\nHttpURLConnection. It also breaks the response cache. I think\nthis is the best route going forward; and eventually we could\ninvert this relationship to have HttpURLConnection depending on\nJob directly rather than vice versa.\n",
      "commitDate": "2013-12-28, 8:24 p.m.",
      "commitName": "37c01895cca5ec2bec26a3d381611f0938acd6d0",
      "commitAuthor": "jwilson",
      "diff": "@@ -0,0 +1,50 @@\n+  private Response execute() throws IOException {\n+    Connection connection \u003d null;\n+    Response redirectedBy \u003d null;\n+\n+    while (true) {\n+      HttpEngine engine \u003d newEngine(connection);\n+\n+      Request.Body body \u003d request.body();\n+      if (body !\u003d null) {\n+        MediaType contentType \u003d body.contentType();\n+        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n+        if (engine.getRequestHeaders().getContentType() \u003d\u003d null) {\n+          engine.getRequestHeaders().setContentType(contentType.toString());\n+        }\n+      }\n+\n+      engine.sendRequest();\n+\n+      if (body !\u003d null) {\n+        body.writeTo(engine.getRequestBody());\n+      }\n+\n+      engine.readResponse();\n+\n+      int responseCode \u003d engine.getResponseCode();\n+      Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(\n+          engine.getResponseHeaders(), engine.getResponseBody());\n+\n+      Response response \u003d new Response.Builder(request, responseCode)\n+          .rawHeaders(engine.getResponseHeaders().getHeaders())\n+          .body(responseBody)\n+          .redirectedBy(redirectedBy)\n+          .build();\n+\n+      Request redirect \u003d processResponse(engine, response);\n+\n+      if (redirect \u003d\u003d null) {\n+        engine.automaticallyReleaseConnectionToPool();\n+        return response;\n+      }\n+\n+      // TODO: fail if too many redirects\n+      // TODO: fail if not following redirects\n+      // TODO: release engine\n+\n+      connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n+      redirectedBy \u003d response;\n+      request \u003d redirect;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n\n    while (true) {\n      HttpEngine engine \u003d newEngine(connection);\n\n      Request.Body body \u003d request.body();\n      if (body !\u003d null) {\n        MediaType contentType \u003d body.contentType();\n        if (contentType \u003d\u003d null) throw new IllegalStateException(\"contentType \u003d\u003d null\");\n        if (engine.getRequestHeaders().getContentType() \u003d\u003d null) {\n          engine.getRequestHeaders().setContentType(contentType.toString());\n        }\n      }\n\n      engine.sendRequest();\n\n      if (body !\u003d null) {\n        body.writeTo(engine.getRequestBody());\n      }\n\n      engine.readResponse();\n\n      int responseCode \u003d engine.getResponseCode();\n      Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(\n          engine.getResponseHeaders(), engine.getResponseBody());\n\n      Response response \u003d new Response.Builder(request, responseCode)\n          .rawHeaders(engine.getResponseHeaders().getHeaders())\n          .body(responseBody)\n          .redirectedBy(redirectedBy)\n          .build();\n\n      Request redirect \u003d processResponse(engine, response);\n\n      if (redirect \u003d\u003d null) {\n        engine.automaticallyReleaseConnectionToPool();\n        return response;\n      }\n\n      // TODO: fail if too many redirects\n      // TODO: fail if not following redirects\n      // TODO: release engine\n\n      connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n      redirectedBy \u003d response;\n      request \u003d redirect;\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 107,
      "functionName": "execute"
    }
  }
}