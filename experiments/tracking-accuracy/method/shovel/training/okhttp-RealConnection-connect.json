{
  "origin": "codeshovel",
  "repositoryName": "okhttp",
  "repositoryPath": "H:\\Projects\\square\\okhttp/.git",
  "startCommitName": "5224f3045ba9b171fce521777edf389f9206173c",
  "sourceFileName": "RealConnection.java",
  "functionName": "connect",
  "functionId": "connect___connectTimeout-int__readTimeout-int__writeTimeout-int__pingIntervalMillis-int__connectionRetryEnabled-boolean__call-Call__eventListener-EventListener",
  "sourceFilePath": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
  "functionStartLine": 130,
  "functionEndLine": 206,
  "numCommitsSeen": 482,
  "timeTaken": 3932,
  "changeHistory": [
    "db18f0e404ab35c7b23e8ecc27913d717e96eb84",
    "abb0a790802996d1039c35424b70b0f3f06b94b7",
    "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
    "29267ac4e8eae099064483dc4c4b246690a92009",
    "c7d508b79c9e201c91ec23f5eec47c18be206567",
    "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
    "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
    "8331b2d75a51631bee622daf2175854fe49ce29a",
    "1f58b14bd18565b3dc4aaf15c072033e68b69660",
    "c5187583bbfe93fe58db80f95b5b478c84180c29",
    "576408374d58a3e9a63714b6f7761cb42a315102",
    "03a840de533b1f1c201aa4e99f95f42f9a8269a4",
    "c9a89876de476983f273edbf108c365127c18c5e",
    "b63841d3a3922440c258098190371f1e17d977c1",
    "71ae4df298f42039579fd6e3c6d9d9060ac91214",
    "c5f58e45454d1ffc621c65e377cb91345018e087",
    "ee87f8036f99fdfd63f8ef145f4478907682db29",
    "c358656c8799d30fd422448153e99a5dd37e298a",
    "529c4a36bb21b3fb7717c27f8a31c39c1b603e9d",
    "457fb428a729c50c562822571ea9b13e689648f3",
    "b42e73f497eafe147667117202267ec756adff26",
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
    "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
    "6d9f9cbdf8069e504cb58908db23b4f327d1826c",
    "1044d9eea21d8be54c195fff75ca0a7b9bba79b3",
    "b60875421b0f67575970b6b63582b7e5e31c4a06",
    "da484932625ab15681e469c1680b6371b8f67080",
    "41aa4b6805141369d614964152d329a686aabdb8",
    "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f",
    "8d78da7ce7e60d93fe8e299a83b963cd220a60ad",
    "c16436f8b2020e4bb2cbdddbd0eddd5ae5c528c4",
    "ab78dadb4bb94db74770e179e04e2ed791c4a51e",
    "a669069599893a774748181a238e0b009a4f3e87",
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
    "504b9cf55afd9d642e2a5323e18f79db607ad1a9",
    "ed2ee02570bac36b89bd93836e200840cb8fa59d",
    "dbca0acc6f8c188dfa48f07bb5886606bec8d28f",
    "35ead0f5d17b0c53610b0947aa9bd8fee6da50fa",
    "13c06879f4e98c86436bdca765046ef815e34838",
    "d66810bf0efbfad5c2afb9b304e1091ac6107a65",
    "3ba54eed34c9d5e41965587660a76a06806180a0",
    "bb1b1a2c5c6c93df75526a2d5bf5c19817402fbc",
    "13d8b5f7bfc73c8f4064a57f634b6155991eb961",
    "1ece746c815a26782042b1fca6069eb527d1029b",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3",
    "194290e5f3819bf91d87c5d08c152946b6aa3509",
    "78c6624b11d5f33504dae8211b4592383468343e",
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
    "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
    "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
    "5aa2456a145883f6688c6ee325635ed0c6339076",
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e"
  ],
  "changeHistoryShort": {
    "db18f0e404ab35c7b23e8ecc27913d717e96eb84": "Ybodychange",
    "abb0a790802996d1039c35424b70b0f3f06b94b7": "Ymultichange(Yparameterchange,Ybodychange)",
    "1c98464839434a0fe7c7581cdae44bd3f2e6edd3": "Ybodychange",
    "29267ac4e8eae099064483dc4c4b246690a92009": "Ybodychange",
    "c7d508b79c9e201c91ec23f5eec47c18be206567": "Ybodychange",
    "5fb5ab50a77efc761489493d4a0b8b9de85feec7": "Ymultichange(Yparameterchange,Ybodychange)",
    "98443a9ca8ca9ad82d5fb9b05b32f180bb510601": "Ymultichange(Yparameterchange,Ybodychange)",
    "8331b2d75a51631bee622daf2175854fe49ce29a": "Ybodychange",
    "1f58b14bd18565b3dc4aaf15c072033e68b69660": "Ybodychange",
    "c5187583bbfe93fe58db80f95b5b478c84180c29": "Yfilerename",
    "576408374d58a3e9a63714b6f7761cb42a315102": "Yexceptionschange",
    "03a840de533b1f1c201aa4e99f95f42f9a8269a4": "Ybodychange",
    "c9a89876de476983f273edbf108c365127c18c5e": "Ymultichange(Yfilerename,Ybodychange)",
    "b63841d3a3922440c258098190371f1e17d977c1": "Ybodychange",
    "71ae4df298f42039579fd6e3c6d9d9060ac91214": "Ybodychange",
    "c5f58e45454d1ffc621c65e377cb91345018e087": "Ybodychange",
    "ee87f8036f99fdfd63f8ef145f4478907682db29": "Ybodychange",
    "c358656c8799d30fd422448153e99a5dd37e298a": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
    "529c4a36bb21b3fb7717c27f8a31c39c1b603e9d": "Ybodychange",
    "457fb428a729c50c562822571ea9b13e689648f3": "Ymultichange(Yparameterchange,Ybodychange)",
    "b42e73f497eafe147667117202267ec756adff26": "Ybodychange",
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80": "Ybodychange",
    "60f5406dcc094d0431420139bd002e8bdd4ea5d5": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "6d9f9cbdf8069e504cb58908db23b4f327d1826c": "Ybodychange",
    "1044d9eea21d8be54c195fff75ca0a7b9bba79b3": "Ymodifierchange",
    "b60875421b0f67575970b6b63582b7e5e31c4a06": "Ybodychange",
    "da484932625ab15681e469c1680b6371b8f67080": "Yparameterchange",
    "41aa4b6805141369d614964152d329a686aabdb8": "Ymultichange(Yparameterchange,Ybodychange)",
    "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f": "Ybodychange",
    "8d78da7ce7e60d93fe8e299a83b963cd220a60ad": "Ybodychange",
    "c16436f8b2020e4bb2cbdddbd0eddd5ae5c528c4": "Ybodychange",
    "ab78dadb4bb94db74770e179e04e2ed791c4a51e": "Ybodychange",
    "a669069599893a774748181a238e0b009a4f3e87": "Ybodychange",
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": "Ybodychange",
    "504b9cf55afd9d642e2a5323e18f79db607ad1a9": "Ybodychange",
    "ed2ee02570bac36b89bd93836e200840cb8fa59d": "Ybodychange",
    "dbca0acc6f8c188dfa48f07bb5886606bec8d28f": "Ybodychange",
    "35ead0f5d17b0c53610b0947aa9bd8fee6da50fa": "Ybodychange",
    "13c06879f4e98c86436bdca765046ef815e34838": "Ybodychange",
    "d66810bf0efbfad5c2afb9b304e1091ac6107a65": "Ybodychange",
    "3ba54eed34c9d5e41965587660a76a06806180a0": "Ybodychange",
    "bb1b1a2c5c6c93df75526a2d5bf5c19817402fbc": "Ybodychange",
    "13d8b5f7bfc73c8f4064a57f634b6155991eb961": "Ybodychange",
    "1ece746c815a26782042b1fca6069eb527d1029b": "Ybodychange",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": "Yfilerename",
    "194290e5f3819bf91d87c5d08c152946b6aa3509": "Ybodychange",
    "78c6624b11d5f33504dae8211b4592383468343e": "Ymultichange(Yfilerename,Ybodychange,Yparameterchange)",
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": "Yfilerename",
    "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
    "40ff76547064c3fb5acb9047a6f679dd4379a4d0": "Ymultichange(Yparameterchange,Ybodychange)",
    "5aa2456a145883f6688c6ee325635ed0c6339076": "Ymultichange(Yparameterchange,Ybodychange)",
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "db18f0e404ab35c7b23e8ecc27913d717e96eb84": {
      "type": "Ybodychange",
      "commitMessage": "Rename H2C to H2_PRIOR_KNOWLEDGE. (#3996)\n\nThe string h2c is used with cleartext upgrades. We\u0027re not doing those here,\r\nso that identifier isn\u0027t appropriate.",
      "commitDate": "2018-05-12, 4:29 a.m.",
      "commitName": "db18f0e404ab35c7b23e8ecc27913d717e96eb84",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2018-02-26, 6:55 p.m.",
      "commitNameOld": "9a6f88dc34cb68d341ec1a7e4c79546fa1c18c96",
      "commitAuthorOld": "Jaye Pitzeruse",
      "daysBetweenCommits": 74.36,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,\n      EventListener eventListener) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication not enabled for client\"));\n      }\n      String host \u003d route.address().url().host();\n      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n      }\n    } else {\n      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {\n        throw new RouteException(new UnknownServiceException(\n            \"H2_PRIOR_KNOWLEDGE cannot be used with HTTPS\"));\n      }\n    }\n\n    while (true) {\n      try {\n        if (route.requiresTunnel()) {\n          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n          if (rawSocket \u003d\u003d null) {\n            // We were unable to connect the tunnel but properly closed down our resources.\n            break;\n          }\n        } else {\n          connectSocket(connectTimeout, readTimeout, call, eventListener);\n        }\n        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n        break;\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        http2Connection \u003d null;\n\n        eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n\n    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n      ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \"\n          + MAX_TUNNEL_ATTEMPTS);\n      throw new RouteException(exception);\n    }\n\n    if (http2Connection !\u003d null) {\n      synchronized (connectionPool) {\n        allocationLimit \u003d http2Connection.maxConcurrentStreams();\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 130,
      "functionName": "connect",
      "diff": "@@ -1,72 +1,77 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       int pingIntervalMillis, boolean connectionRetryEnabled, Call call,\n       EventListener eventListener) {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host \u003d route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n+    } else {\n+      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {\n+        throw new RouteException(new UnknownServiceException(\n+            \"H2_PRIOR_KNOWLEDGE cannot be used with HTTPS\"));\n+      }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n           if (rawSocket \u003d\u003d null) {\n             // We were unable to connect the tunnel but properly closed down our resources.\n             break;\n           }\n         } else {\n           connectSocket(connectTimeout, readTimeout, call, eventListener);\n         }\n         establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n         eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n         http2Connection \u003d null;\n \n         eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n       ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \"\n           + MAX_TUNNEL_ATTEMPTS);\n       throw new RouteException(exception);\n     }\n \n     if (http2Connection !\u003d null) {\n       synchronized (connectionPool) {\n         allocationLimit \u003d http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "abb0a790802996d1039c35424b70b0f3f06b94b7": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "First step towards HTTP/2 automatic pings. (#3874)\n\nThis changes the executor services in HTTP/2 connection to split up\r\nlistener executors (of which there may be many threads) from writer\r\nexecutors (of which there is one per connection).\r\n\r\nThis adds a scheduled executor job to send pings on an interval. We\r\ndon\u0027t yet fail the connection if pongs are not received.\r\n\r\nFor follow-up there\u0027s some work to remove exising APIs to send pings\r\nthrough the HTTP/2 APIs. These are unused and make it awkard to\r\nconfirm that only the automatic pings are being replied to.\r\n\r\nSee https://github.com/square/okhttp/issues/3261",
      "commitDate": "2018-02-21, 8:17 p.m.",
      "commitName": "abb0a790802996d1039c35424b70b0f3f06b94b7",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "First step towards HTTP/2 automatic pings. (#3874)\n\nThis changes the executor services in HTTP/2 connection to split up\r\nlistener executors (of which there may be many threads) from writer\r\nexecutors (of which there is one per connection).\r\n\r\nThis adds a scheduled executor job to send pings on an interval. We\r\ndon\u0027t yet fail the connection if pongs are not received.\r\n\r\nFor follow-up there\u0027s some work to remove exising APIs to send pings\r\nthrough the HTTP/2 APIs. These are unused and make it awkard to\r\nconfirm that only the automatic pings are being replied to.\r\n\r\nSee https://github.com/square/okhttp/issues/3261",
          "commitDate": "2018-02-21, 8:17 p.m.",
          "commitName": "abb0a790802996d1039c35424b70b0f3f06b94b7",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2018-02-17, 5:24 a.m.",
          "commitNameOld": "19726969aabbd0791d315994384a0cc46bf41648",
          "commitAuthorOld": "Yuri Schimke",
          "daysBetweenCommits": 4.62,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,\n      EventListener eventListener) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication not enabled for client\"));\n      }\n      String host \u003d route.address().url().host();\n      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n      }\n    }\n\n    while (true) {\n      try {\n        if (route.requiresTunnel()) {\n          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n          if (rawSocket \u003d\u003d null) {\n            // We were unable to connect the tunnel but properly closed down our resources.\n            break;\n          }\n        } else {\n          connectSocket(connectTimeout, readTimeout, call, eventListener);\n        }\n        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n        break;\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        http2Connection \u003d null;\n\n        eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n\n    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n      ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \"\n          + MAX_TUNNEL_ATTEMPTS);\n      throw new RouteException(exception);\n    }\n\n    if (http2Connection !\u003d null) {\n      synchronized (connectionPool) {\n        allocationLimit \u003d http2Connection.maxConcurrentStreams();\n      }\n    }\n  }",
          "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
          "functionStartLine": 130,
          "functionName": "connect",
          "diff": "@@ -1,71 +1,72 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n-      boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n+      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,\n+      EventListener eventListener) {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host \u003d route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n           if (rawSocket \u003d\u003d null) {\n             // We were unable to connect the tunnel but properly closed down our resources.\n             break;\n           }\n         } else {\n           connectSocket(connectTimeout, readTimeout, call, eventListener);\n         }\n-        establishProtocol(connectionSpecSelector, call, eventListener);\n+        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n         eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n         http2Connection \u003d null;\n \n         eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n       ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \"\n           + MAX_TUNNEL_ATTEMPTS);\n       throw new RouteException(exception);\n     }\n \n     if (http2Connection !\u003d null) {\n       synchronized (connectionPool) {\n         allocationLimit \u003d http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionRetryEnabled-boolean, call-Call, eventListener-EventListener]",
            "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, pingIntervalMillis-int, connectionRetryEnabled-boolean, call-Call, eventListener-EventListener]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "First step towards HTTP/2 automatic pings. (#3874)\n\nThis changes the executor services in HTTP/2 connection to split up\r\nlistener executors (of which there may be many threads) from writer\r\nexecutors (of which there is one per connection).\r\n\r\nThis adds a scheduled executor job to send pings on an interval. We\r\ndon\u0027t yet fail the connection if pongs are not received.\r\n\r\nFor follow-up there\u0027s some work to remove exising APIs to send pings\r\nthrough the HTTP/2 APIs. These are unused and make it awkard to\r\nconfirm that only the automatic pings are being replied to.\r\n\r\nSee https://github.com/square/okhttp/issues/3261",
          "commitDate": "2018-02-21, 8:17 p.m.",
          "commitName": "abb0a790802996d1039c35424b70b0f3f06b94b7",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2018-02-17, 5:24 a.m.",
          "commitNameOld": "19726969aabbd0791d315994384a0cc46bf41648",
          "commitAuthorOld": "Yuri Schimke",
          "daysBetweenCommits": 4.62,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,\n      EventListener eventListener) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication not enabled for client\"));\n      }\n      String host \u003d route.address().url().host();\n      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n      }\n    }\n\n    while (true) {\n      try {\n        if (route.requiresTunnel()) {\n          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n          if (rawSocket \u003d\u003d null) {\n            // We were unable to connect the tunnel but properly closed down our resources.\n            break;\n          }\n        } else {\n          connectSocket(connectTimeout, readTimeout, call, eventListener);\n        }\n        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n        break;\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        http2Connection \u003d null;\n\n        eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n\n    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n      ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \"\n          + MAX_TUNNEL_ATTEMPTS);\n      throw new RouteException(exception);\n    }\n\n    if (http2Connection !\u003d null) {\n      synchronized (connectionPool) {\n        allocationLimit \u003d http2Connection.maxConcurrentStreams();\n      }\n    }\n  }",
          "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
          "functionStartLine": 130,
          "functionName": "connect",
          "diff": "@@ -1,71 +1,72 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n-      boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n+      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,\n+      EventListener eventListener) {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host \u003d route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n           if (rawSocket \u003d\u003d null) {\n             // We were unable to connect the tunnel but properly closed down our resources.\n             break;\n           }\n         } else {\n           connectSocket(connectTimeout, readTimeout, call, eventListener);\n         }\n-        establishProtocol(connectionSpecSelector, call, eventListener);\n+        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n         eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n         http2Connection \u003d null;\n \n         eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n       ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \"\n           + MAX_TUNNEL_ATTEMPTS);\n       throw new RouteException(exception);\n     }\n \n     if (http2Connection !\u003d null) {\n       synchronized (connectionPool) {\n         allocationLimit \u003d http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "1c98464839434a0fe7c7581cdae44bd3f2e6edd3": {
      "type": "Ybodychange",
      "commitMessage": "Move all failures into connectFailed and callFailed. (#3550)\n\nI think applications might be simple by tracking successful events\r\nseparately from failure events.",
      "commitDate": "2017-08-29, 4:14 p.m.",
      "commitName": "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2017-08-28, 12:35 p.m.",
      "commitNameOld": "cdc48ba8b0e4bdfccc208985bfef200220096d9d",
      "commitAuthorOld": "Yuri Schimke",
      "daysBetweenCommits": 1.15,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication not enabled for client\"));\n      }\n      String host \u003d route.address().url().host();\n      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n      }\n    }\n\n    while (true) {\n      try {\n        if (route.requiresTunnel()) {\n          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n          if (rawSocket \u003d\u003d null) {\n            // We were unable to connect the tunnel but properly closed down our resources.\n            break;\n          }\n        } else {\n          connectSocket(connectTimeout, readTimeout, call, eventListener);\n        }\n        establishProtocol(connectionSpecSelector, call, eventListener);\n        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n        break;\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        http2Connection \u003d null;\n\n        eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n\n    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n      ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \"\n          + MAX_TUNNEL_ATTEMPTS);\n      throw new RouteException(exception);\n    }\n\n    if (http2Connection !\u003d null) {\n      synchronized (connectionPool) {\n        allocationLimit \u003d http2Connection.maxConcurrentStreams();\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 129,
      "functionName": "connect",
      "diff": "@@ -1,71 +1,71 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host \u003d route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n           if (rawSocket \u003d\u003d null) {\n             // We were unable to connect the tunnel but properly closed down our resources.\n             break;\n           }\n         } else {\n           connectSocket(connectTimeout, readTimeout, call, eventListener);\n         }\n         establishProtocol(connectionSpecSelector, call, eventListener);\n-        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol, null);\n+        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n         http2Connection \u003d null;\n \n-        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null, e);\n+        eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n       ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \"\n           + MAX_TUNNEL_ATTEMPTS);\n       throw new RouteException(exception);\n     }\n \n     if (http2Connection !\u003d null) {\n       synchronized (connectionPool) {\n         allocationLimit \u003d http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "29267ac4e8eae099064483dc4c4b246690a92009": {
      "type": "Ybodychange",
      "commitMessage": "Fill out documentation for EventListener (#3475)\n\n* Fill out documentation for EventListener\r\n\r\n* rename connectionFound\r\n\r\n* tests for connectionFound updated\r\n\r\n* cleanup\r\n\r\n* address comment on body calls\r\n\r\n* Update EventListener.java\r\n\r\n* connect end event added a Proxy to match against start event\r\n",
      "commitDate": "2017-07-29, 10:32 a.m.",
      "commitName": "29267ac4e8eae099064483dc4c4b246690a92009",
      "commitAuthor": "Yuri Schimke",
      "commitDateOld": "2017-07-23, 6:59 p.m.",
      "commitNameOld": "1d8233ddb7a0dfa490a340a06433909148f21610",
      "commitAuthorOld": "ericaschulz",
      "daysBetweenCommits": 5.65,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication not enabled for client\"));\n      }\n      String host \u003d route.address().url().host();\n      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n      }\n    }\n\n    while (true) {\n      try {\n        if (route.requiresTunnel()) {\n          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n          if (rawSocket \u003d\u003d null) {\n            // We were unable to connect the tunnel but properly closed down our resources.\n            break;\n          }\n        } else {\n          connectSocket(connectTimeout, readTimeout, call, eventListener);\n        }\n        establishProtocol(connectionSpecSelector, call, eventListener);\n        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol, null);\n        break;\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        http2Connection \u003d null;\n\n        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null, e);\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n\n    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n      ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \"\n          + MAX_TUNNEL_ATTEMPTS);\n      throw new RouteException(exception);\n    }\n\n    if (http2Connection !\u003d null) {\n      synchronized (connectionPool) {\n        allocationLimit \u003d http2Connection.maxConcurrentStreams();\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 129,
      "functionName": "connect",
      "diff": "@@ -1,71 +1,71 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host \u003d route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n           if (rawSocket \u003d\u003d null) {\n             // We were unable to connect the tunnel but properly closed down our resources.\n             break;\n           }\n         } else {\n           connectSocket(connectTimeout, readTimeout, call, eventListener);\n         }\n         establishProtocol(connectionSpecSelector, call, eventListener);\n-        eventListener.connectEnd(call, route.socketAddress(), protocol, null);\n+        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol, null);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n         http2Connection \u003d null;\n \n-        eventListener.connectEnd(call, route.socketAddress(), null, e);\n+        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null, e);\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n       ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \"\n           + MAX_TUNNEL_ATTEMPTS);\n       throw new RouteException(exception);\n     }\n \n     if (http2Connection !\u003d null) {\n       synchronized (connectionPool) {\n         allocationLimit \u003d http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c7d508b79c9e201c91ec23f5eec47c18be206567": {
      "type": "Ybodychange",
      "commitMessage": "Add support for connect start/end events. (#3434)\n\n",
      "commitDate": "2017-07-06, 9:55 a.m.",
      "commitName": "c7d508b79c9e201c91ec23f5eec47c18be206567",
      "commitAuthor": "Dave Roberge",
      "commitDateOld": "2017-07-02, 10:10 a.m.",
      "commitNameOld": "a32b1044a480aabbf4716d5c90b907c5ec46056c",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 3.99,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication not enabled for client\"));\n      }\n      String host \u003d route.address().url().host();\n      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n      }\n    }\n\n    while (true) {\n      try {\n        if (route.requiresTunnel()) {\n          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n          if (rawSocket \u003d\u003d null) {\n            // We were unable to connect the tunnel but properly closed down our resources.\n            break;\n          }\n        } else {\n          connectSocket(connectTimeout, readTimeout, call, eventListener);\n        }\n        establishProtocol(connectionSpecSelector, call, eventListener);\n        eventListener.connectEnd(call, route.socketAddress(), protocol, null);\n        break;\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        http2Connection \u003d null;\n\n        eventListener.connectEnd(call, route.socketAddress(), null, e);\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n\n    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n      ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \"\n          + MAX_TUNNEL_ATTEMPTS);\n      throw new RouteException(exception);\n    }\n\n    if (http2Connection !\u003d null) {\n      synchronized (connectionPool) {\n        allocationLimit \u003d http2Connection.maxConcurrentStreams();\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 129,
      "functionName": "connect",
      "diff": "@@ -1,58 +1,71 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host \u003d route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n-          connectTunnel(connectTimeout, readTimeout, writeTimeout);\n+          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n+          if (rawSocket \u003d\u003d null) {\n+            // We were unable to connect the tunnel but properly closed down our resources.\n+            break;\n+          }\n         } else {\n-          connectSocket(connectTimeout, readTimeout);\n+          connectSocket(connectTimeout, readTimeout, call, eventListener);\n         }\n         establishProtocol(connectionSpecSelector, call, eventListener);\n+        eventListener.connectEnd(call, route.socketAddress(), protocol, null);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n         http2Connection \u003d null;\n \n+        eventListener.connectEnd(call, route.socketAddress(), null, e);\n+\n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n+    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n+      ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \"\n+          + MAX_TUNNEL_ATTEMPTS);\n+      throw new RouteException(exception);\n+    }\n+\n     if (http2Connection !\u003d null) {\n       synchronized (connectionPool) {\n         allocationLimit \u003d http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5fb5ab50a77efc761489493d4a0b8b9de85feec7": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Added support for secure connect events.\n\nhttps://github.com/square/okhttp/issues/270\n",
      "commitDate": "2017-06-20, 9:14 a.m.",
      "commitName": "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
      "commitAuthor": "Dave Roberge",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Added support for secure connect events.\n\nhttps://github.com/square/okhttp/issues/270\n",
          "commitDate": "2017-06-20, 9:14 a.m.",
          "commitName": "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
          "commitAuthor": "Dave Roberge",
          "commitDateOld": "2017-05-11, 6:53 p.m.",
          "commitNameOld": "b8a0352d524b3d339e71a83b04c63eee8aa3f291",
          "commitAuthorOld": "Kasra Bigdeli",
          "daysBetweenCommits": 39.6,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication not enabled for client\"));\n      }\n      String host \u003d route.address().url().host();\n      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n      }\n    }\n\n    while (true) {\n      try {\n        if (route.requiresTunnel()) {\n          connectTunnel(connectTimeout, readTimeout, writeTimeout);\n        } else {\n          connectSocket(connectTimeout, readTimeout);\n        }\n        establishProtocol(connectionSpecSelector, call, eventListener);\n        break;\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        http2Connection \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n\n    if (http2Connection !\u003d null) {\n      synchronized (connectionPool) {\n        allocationLimit \u003d http2Connection.maxConcurrentStreams();\n      }\n    }\n  }",
          "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
          "functionStartLine": 126,
          "functionName": "connect",
          "diff": "@@ -1,58 +1,58 @@\n-  public void connect(\n-      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+      boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host \u003d route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout);\n         } else {\n           connectSocket(connectTimeout, readTimeout);\n         }\n-        establishProtocol(connectionSpecSelector);\n+        establishProtocol(connectionSpecSelector, call, eventListener);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n         http2Connection \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (http2Connection !\u003d null) {\n       synchronized (connectionPool) {\n         allocationLimit \u003d http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionRetryEnabled-boolean]",
            "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionRetryEnabled-boolean, call-Call, eventListener-EventListener]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Added support for secure connect events.\n\nhttps://github.com/square/okhttp/issues/270\n",
          "commitDate": "2017-06-20, 9:14 a.m.",
          "commitName": "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
          "commitAuthor": "Dave Roberge",
          "commitDateOld": "2017-05-11, 6:53 p.m.",
          "commitNameOld": "b8a0352d524b3d339e71a83b04c63eee8aa3f291",
          "commitAuthorOld": "Kasra Bigdeli",
          "daysBetweenCommits": 39.6,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication not enabled for client\"));\n      }\n      String host \u003d route.address().url().host();\n      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n      }\n    }\n\n    while (true) {\n      try {\n        if (route.requiresTunnel()) {\n          connectTunnel(connectTimeout, readTimeout, writeTimeout);\n        } else {\n          connectSocket(connectTimeout, readTimeout);\n        }\n        establishProtocol(connectionSpecSelector, call, eventListener);\n        break;\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        http2Connection \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n\n    if (http2Connection !\u003d null) {\n      synchronized (connectionPool) {\n        allocationLimit \u003d http2Connection.maxConcurrentStreams();\n      }\n    }\n  }",
          "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
          "functionStartLine": 126,
          "functionName": "connect",
          "diff": "@@ -1,58 +1,58 @@\n-  public void connect(\n-      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+      boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host \u003d route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout);\n         } else {\n           connectSocket(connectTimeout, readTimeout);\n         }\n-        establishProtocol(connectionSpecSelector);\n+        establishProtocol(connectionSpecSelector, call, eventListener);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n         http2Connection \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (http2Connection !\u003d null) {\n       synchronized (connectionPool) {\n         allocationLimit \u003d http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "98443a9ca8ca9ad82d5fb9b05b32f180bb510601": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Release duplicated multiplexed connections.\n\nIf we make concurrent requests to an HTTP/2 server, close all but\nthe first connection. Creating multiple connections and then later\nreleasing them is somewhat pessimistic; it\u0027s also much safer for\nawkward cases like connect attempts being canceled.\n\nCloses: https://github.com/square/okhttp/issues/373\n",
      "commitDate": "2017-01-07, 2:15 p.m.",
      "commitName": "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Release duplicated multiplexed connections.\n\nIf we make concurrent requests to an HTTP/2 server, close all but\nthe first connection. Creating multiple connections and then later\nreleasing them is somewhat pessimistic; it\u0027s also much safer for\nawkward cases like connect attempts being canceled.\n\nCloses: https://github.com/square/okhttp/issues/373\n",
          "commitDate": "2017-01-07, 2:15 p.m.",
          "commitName": "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
          "commitAuthor": "jwilson",
          "commitDateOld": "2017-01-02, 12:36 p.m.",
          "commitNameOld": "8331b2d75a51631bee622daf2175854fe49ce29a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 5.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "  public void connect(\n      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication not enabled for client\"));\n      }\n      String host \u003d route.address().url().host();\n      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n      }\n    }\n\n    while (true) {\n      try {\n        if (route.requiresTunnel()) {\n          connectTunnel(connectTimeout, readTimeout, writeTimeout);\n        } else {\n          connectSocket(connectTimeout, readTimeout);\n        }\n        establishProtocol(connectionSpecSelector);\n        break;\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        http2Connection \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n\n    if (http2Connection !\u003d null) {\n      synchronized (connectionPool) {\n        allocationLimit \u003d http2Connection.maxConcurrentStreams();\n      }\n    }\n  }",
          "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
          "functionStartLine": 121,
          "functionName": "connect",
          "diff": "@@ -1,57 +1,58 @@\n-  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n-      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n+  public void connect(\n+      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n+    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host \u003d route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout);\n         } else {\n           connectSocket(connectTimeout, readTimeout);\n         }\n         establishProtocol(connectionSpecSelector);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n         http2Connection \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (http2Connection !\u003d null) {\n       synchronized (connectionPool) {\n         allocationLimit \u003d http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionSpecs-List\u003cConnectionSpec\u003e, connectionRetryEnabled-boolean]",
            "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionRetryEnabled-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Release duplicated multiplexed connections.\n\nIf we make concurrent requests to an HTTP/2 server, close all but\nthe first connection. Creating multiple connections and then later\nreleasing them is somewhat pessimistic; it\u0027s also much safer for\nawkward cases like connect attempts being canceled.\n\nCloses: https://github.com/square/okhttp/issues/373\n",
          "commitDate": "2017-01-07, 2:15 p.m.",
          "commitName": "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
          "commitAuthor": "jwilson",
          "commitDateOld": "2017-01-02, 12:36 p.m.",
          "commitNameOld": "8331b2d75a51631bee622daf2175854fe49ce29a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 5.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "  public void connect(\n      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication not enabled for client\"));\n      }\n      String host \u003d route.address().url().host();\n      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n      }\n    }\n\n    while (true) {\n      try {\n        if (route.requiresTunnel()) {\n          connectTunnel(connectTimeout, readTimeout, writeTimeout);\n        } else {\n          connectSocket(connectTimeout, readTimeout);\n        }\n        establishProtocol(connectionSpecSelector);\n        break;\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        http2Connection \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n\n    if (http2Connection !\u003d null) {\n      synchronized (connectionPool) {\n        allocationLimit \u003d http2Connection.maxConcurrentStreams();\n      }\n    }\n  }",
          "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
          "functionStartLine": 121,
          "functionName": "connect",
          "diff": "@@ -1,57 +1,58 @@\n-  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n-      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n+  public void connect(\n+      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n+    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host \u003d route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout);\n         } else {\n           connectSocket(connectTimeout, readTimeout);\n         }\n         establishProtocol(connectionSpecSelector);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n         http2Connection \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (http2Connection !\u003d null) {\n       synchronized (connectionPool) {\n         allocationLimit \u003d http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "8331b2d75a51631bee622daf2175854fe49ce29a": {
      "type": "Ybodychange",
      "commitMessage": "Fix RealConnection to guard allocationLimit by connectionPool.\n\nI\u0027m working towards making OkHttp limit itself to a single HTTP/2 connection\nto a single host. In this work I found we\u0027re not sufficiently safe on\nallocationLimit - connections are added to the pool when this is 0, and\nthe value is updated without any synchronization.\n\nThis change also reduces the visibility of some connection fields in\nRealConnection and organizes the fields into two sets: those that are\nimmutable after connect and those that are guarded by connectionPool.\n\nhttps://github.com/square/okhttp/issues/373\n",
      "commitDate": "2017-01-02, 12:36 p.m.",
      "commitName": "8331b2d75a51631bee622daf2175854fe49ce29a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-12-26, 8:24 p.m.",
      "commitNameOld": "a589b8170333476233d48476587a1d4363c90bd0",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 6.68,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication not enabled for client\"));\n      }\n      String host \u003d route.address().url().host();\n      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n      }\n    }\n\n    while (true) {\n      try {\n        if (route.requiresTunnel()) {\n          connectTunnel(connectTimeout, readTimeout, writeTimeout);\n        } else {\n          connectSocket(connectTimeout, readTimeout);\n        }\n        establishProtocol(connectionSpecSelector);\n        break;\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        http2Connection \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n\n    if (http2Connection !\u003d null) {\n      synchronized (connectionPool) {\n        allocationLimit \u003d http2Connection.maxConcurrentStreams();\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 121,
      "functionName": "connect",
      "diff": "@@ -1,49 +1,57 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host \u003d route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n-    while (protocol \u003d\u003d null) {\n+    while (true) {\n       try {\n         if (route.requiresTunnel()) {\n-          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,\n-              connectionSpecSelector);\n+          connectTunnel(connectTimeout, readTimeout, writeTimeout);\n         } else {\n-          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n+          connectSocket(connectTimeout, readTimeout);\n         }\n+        establishProtocol(connectionSpecSelector);\n+        break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n+        http2Connection \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n+\n+    if (http2Connection !\u003d null) {\n+      synchronized (connectionPool) {\n+        allocationLimit \u003d http2Connection.maxConcurrentStreams();\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1f58b14bd18565b3dc4aaf15c072033e68b69660": {
      "type": "Ybodychange",
      "commitMessage": "Always pass a host to NetworkSecurityPolicy.isCleartextTrafficPermitted().\n\nPreviously we were misinterpretting which hosts this method applied to.\nSuppose an Android app was configured to require TLS for bank.com and\nnot for any other address. The NetworkSecurityPolicy.isCleartextTrafficPermitted()\nmethod would return false because cleartext traffic wasn\u0027t universally\npermitted. And OkHttp would incorrectly forbid cleartext communication\nto other hosts like puppies.com.\n\nCloses: https://github.com/square/okhttp/issues/2640\n",
      "commitDate": "2016-07-02, 1:39 p.m.",
      "commitName": "1f58b14bd18565b3dc4aaf15c072033e68b69660",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-06-26, 11:04 p.m.",
      "commitNameOld": "c5187583bbfe93fe58db80f95b5b478c84180c29",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 5.61,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication not enabled for client\"));\n      }\n      String host \u003d route.address().url().host();\n      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n        throw new RouteException(new UnknownServiceException(\n            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n      }\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        if (route.requiresTunnel()) {\n          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,\n              connectionSpecSelector);\n        } else {\n          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        }\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 89,
      "functionName": "connect",
      "diff": "@@ -1,43 +1,49 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n \n-    if (route.address().sslSocketFactory() \u003d\u003d null\n-        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n-      throw new RouteException(new UnknownServiceException(\n-          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n+    if (route.address().sslSocketFactory() \u003d\u003d null) {\n+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+        throw new RouteException(new UnknownServiceException(\n+            \"CLEARTEXT communication not enabled for client\"));\n+      }\n+      String host \u003d route.address().url().host();\n+      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n+        throw new RouteException(new UnknownServiceException(\n+            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n+      }\n     }\n \n     while (protocol \u003d\u003d null) {\n       try {\n         if (route.requiresTunnel()) {\n           buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,\n               connectionSpecSelector);\n         } else {\n           buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n         }\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c5187583bbfe93fe58db80f95b5b478c84180c29": {
      "type": "Yfilerename",
      "commitMessage": "Add connection, cache, and platform subpackages.\n",
      "commitDate": "2016-06-26, 11:04 p.m.",
      "commitName": "c5187583bbfe93fe58db80f95b5b478c84180c29",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-06-26, 9:10 p.m.",
      "commitNameOld": "81b3a99aea8571942e5fb18b5c189c4596087076",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        if (route.requiresTunnel()) {\n          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,\n              connectionSpecSelector);\n        } else {\n          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        }\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 89,
      "functionName": "connect",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java",
        "newPath": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java"
      }
    },
    "576408374d58a3e9a63714b6f7761cb42a315102": {
      "type": "Yexceptionschange",
      "commitMessage": "Begin to fold together parts of RealCall and HttpEngine.\n\nPreviously we had an awkward, arbitrary separation because RealCall contained\nthe stuff that wasn\u0027t in HttpURLConnection, and HttpEngine contained everything\nthat was shared.\n\nIt was also awkward because HttpEngine could be interrupted in various parts\nof the HttpURLConnection flow: after connecting, while transmitting the request\nbody, etc. With this change we no longer need to handle API calls while we\u0027re\nin these intermediate states, which means we can reduce the scope of certain\nthings from fields to local variables.\n\nThere\u0027s still a way to go here but this is more easy wins.\n",
      "commitDate": "2016-06-23, 10:54 p.m.",
      "commitName": "576408374d58a3e9a63714b6f7761cb42a315102",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-04-10, 3:02 p.m.",
      "commitNameOld": "c9ad163e92fe252f23b743d694f68967a29eae7c",
      "commitAuthorOld": "",
      "daysBetweenCommits": 74.33,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        if (route.requiresTunnel()) {\n          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,\n              connectionSpecSelector);\n        } else {\n          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        }\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java",
      "functionStartLine": 92,
      "functionName": "connect",
      "diff": "@@ -1,43 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n-      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n+      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol \u003d\u003d null) {\n       try {\n         if (route.requiresTunnel()) {\n           buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,\n               connectionSpecSelector);\n         } else {\n           buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n         }\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[RouteException]",
        "newValue": "[]"
      }
    },
    "03a840de533b1f1c201aa4e99f95f42f9a8269a4": {
      "type": "Ybodychange",
      "commitMessage": "Accommodate tunneling proxies that close the connection after an auth challenge.\n",
      "commitDate": "2016-04-08, 7:56 a.m.",
      "commitName": "03a840de533b1f1c201aa4e99f95f42f9a8269a4",
      "commitAuthor": "Dave Roberge",
      "commitDateOld": "2016-02-22, 12:13 a.m.",
      "commitNameOld": "7ceaa2387f0be853222f5a1496f1f743fa6f8c6d",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 46.28,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n\n    if (route.address().sslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        if (route.requiresTunnel()) {\n          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,\n              connectionSpecSelector);\n        } else {\n          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        }\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java",
      "functionStartLine": 92,
      "functionName": "connect",
      "diff": "@@ -1,43 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n-    Proxy proxy \u003d route.proxy();\n-    Address address \u003d route.address();\n \n     if (route.address().sslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol \u003d\u003d null) {\n       try {\n-        rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n-            ? address.socketFactory().createSocket()\n-            : new Socket(proxy);\n-        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n+        if (route.requiresTunnel()) {\n+          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,\n+              connectionSpecSelector);\n+        } else {\n+          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n+        }\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9a89876de476983f273edbf108c365127c18c5e": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
      "commitDate": "2015-12-16, 1:34 a.m.",
      "commitName": "c9a89876de476983f273edbf108c365127c18c5e",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
          "commitDate": "2015-12-16, 1:34 a.m.",
          "commitName": "c9a89876de476983f273edbf108c365127c18c5e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015-12-15, 9:36 p.m.",
          "commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.proxy();\n    Address address \u003d route.address();\n\n    if (route.address().sslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n            ? address.socketFactory().createSocket()\n            : new Socket(proxy);\n        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
          "path": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java",
          "functionStartLine": 88,
          "functionName": "connect",
          "diff": "@@ -1,43 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.proxy();\n     Address address \u003d route.address();\n \n     if (route.address().sslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol \u003d\u003d null) {\n       try {\n         rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n             ? address.socketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n-        Util.closeQuietly(socket);\n-        Util.closeQuietly(rawSocket);\n+        closeQuietly(socket);\n+        closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
            "newPath": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
          "commitDate": "2015-12-16, 1:34 a.m.",
          "commitName": "c9a89876de476983f273edbf108c365127c18c5e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015-12-15, 9:36 p.m.",
          "commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.proxy();\n    Address address \u003d route.address();\n\n    if (route.address().sslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n            ? address.socketFactory().createSocket()\n            : new Socket(proxy);\n        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n      } catch (IOException e) {\n        closeQuietly(socket);\n        closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
          "path": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java",
          "functionStartLine": 88,
          "functionName": "connect",
          "diff": "@@ -1,43 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.proxy();\n     Address address \u003d route.address();\n \n     if (route.address().sslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol \u003d\u003d null) {\n       try {\n         rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n             ? address.socketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n-        Util.closeQuietly(socket);\n-        Util.closeQuietly(rawSocket);\n+        closeQuietly(socket);\n+        closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "b63841d3a3922440c258098190371f1e17d977c1": {
      "type": "Ybodychange",
      "commitMessage": "Drop \u0027get\u0027 prefixed on Address value type.\n",
      "commitDate": "2015-12-15, 12:57 a.m.",
      "commitName": "b63841d3a3922440c258098190371f1e17d977c1",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2015-12-15, 12:45 a.m.",
      "commitNameOld": "71ae4df298f42039579fd6e3c6d9d9060ac91214",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.proxy();\n    Address address \u003d route.address();\n\n    if (route.address().sslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n            ? address.socketFactory().createSocket()\n            : new Socket(proxy);\n        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n      } catch (IOException e) {\n        Util.closeQuietly(socket);\n        Util.closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
      "functionStartLine": 88,
      "functionName": "connect",
      "diff": "@@ -1,43 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.proxy();\n     Address address \u003d route.address();\n \n-    if (route.address().getSslSocketFactory() \u003d\u003d null\n+    if (route.address().sslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol \u003d\u003d null) {\n       try {\n         rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n-            ? address.getSocketFactory().createSocket()\n+            ? address.socketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         Util.closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "71ae4df298f42039579fd6e3c6d9d9060ac91214": {
      "type": "Ybodychange",
      "commitMessage": "Drop \u0027get\u0027 prefixed on Route value type.\n",
      "commitDate": "2015-12-15, 12:45 a.m.",
      "commitName": "71ae4df298f42039579fd6e3c6d9d9060ac91214",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2015-12-14, 3:11 p.m.",
      "commitNameOld": "93d547dcdaecddfa456aee0571131db2342e5abb",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.4,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.proxy();\n    Address address \u003d route.address();\n\n    if (route.address().getSslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n            ? address.getSocketFactory().createSocket()\n            : new Socket(proxy);\n        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n      } catch (IOException e) {\n        Util.closeQuietly(socket);\n        Util.closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
      "functionStartLine": 88,
      "functionName": "connect",
      "diff": "@@ -1,43 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n-    Proxy proxy \u003d route.getProxy();\n-    Address address \u003d route.getAddress();\n+    Proxy proxy \u003d route.proxy();\n+    Address address \u003d route.address();\n \n-    if (route.getAddress().getSslSocketFactory() \u003d\u003d null\n+    if (route.address().getSslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol \u003d\u003d null) {\n       try {\n         rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         Util.closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c5f58e45454d1ffc621c65e377cb91345018e087": {
      "type": "Ybodychange",
      "commitMessage": "Honor the max concurrent streams setting.\n\nCloses https://github.com/square/okhttp/issues/1484\n",
      "commitDate": "2015-12-02, 12:44 p.m.",
      "commitName": "c5f58e45454d1ffc621c65e377cb91345018e087",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-11-30, 10:57 p.m.",
      "commitNameOld": "7fc2993c427ef7c36430a4efa5d5c1d5dd5e0dc9",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.57,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n\n    if (route.getAddress().getSslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n            ? address.getSocketFactory().createSocket()\n            : new Socket(proxy);\n        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n      } catch (IOException e) {\n        Util.closeQuietly(socket);\n        Util.closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
      "functionStartLine": 84,
      "functionName": "connect",
      "diff": "@@ -1,44 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n \n     if (route.getAddress().getSslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol \u003d\u003d null) {\n       try {\n         rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         Util.closeQuietly(rawSocket);\n         socket \u003d null;\n         rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n-        framedConnection \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ee87f8036f99fdfd63f8ef145f4478907682db29": {
      "type": "Ybodychange",
      "commitMessage": "Change async cancel to cancel the raw socket only.\n\nPreviously we could close an SSL socket which does synchronous I/O. This\nmade it unreasonable to cancel a call on a UI thread.\n\nCloses: https://github.com/square/okhttp/issues/1592\n",
      "commitDate": "2015-11-29, 10:58 p.m.",
      "commitName": "ee87f8036f99fdfd63f8ef145f4478907682db29",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-11-28, 9:36 a.m.",
      "commitNameOld": "c358656c8799d30fd422448153e99a5dd37e298a",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.56,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n\n    if (route.getAddress().getSslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n            ? address.getSocketFactory().createSocket()\n            : new Socket(proxy);\n        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n      } catch (IOException e) {\n        Util.closeQuietly(socket);\n        Util.closeQuietly(rawSocket);\n        socket \u003d null;\n        rawSocket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        framedConnection \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
      "functionStartLine": 86,
      "functionName": "connect",
      "diff": "@@ -1,42 +1,44 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n \n     if (route.getAddress().getSslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol \u003d\u003d null) {\n       try {\n-        socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n+        rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n+        Util.closeQuietly(rawSocket);\n         socket \u003d null;\n+        rawSocket \u003d null;\n         source \u003d null;\n         sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n         framedConnection \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c358656c8799d30fd422448153e99a5dd37e298a": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
      "commitMessage": "First draft of the new new stream allocations model.\n",
      "commitDate": "2015-11-28, 9:36 a.m.",
      "commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "First draft of the new new stream allocations model.\n",
          "commitDate": "2015-11-28, 9:36 a.m.",
          "commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015-11-26, 11:28 p.m.",
          "commitNameOld": "e0d34ebdd7aba18149d195804075a87b97f3c02d",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 1.42,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n\n    if (route.getAddress().getSslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n            ? address.getSocketFactory().createSocket()\n            : new Socket(proxy);\n        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n      } catch (IOException e) {\n        Util.closeQuietly(socket);\n        socket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        framedConnection \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
          "functionStartLine": 78,
          "functionName": "connect",
          "diff": "@@ -1,41 +1,42 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n \n-    if (route.address.getSslSocketFactory() \u003d\u003d null\n+    if (route.getAddress().getSslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol \u003d\u003d null) {\n       try {\n         socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         socket \u003d null;\n+        source \u003d null;\n+        sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n-        httpConnection \u003d null;\n         framedConnection \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
            "newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
            "oldMethodName": "connect",
            "newMethodName": "connect"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "First draft of the new new stream allocations model.\n",
          "commitDate": "2015-11-28, 9:36 a.m.",
          "commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015-11-26, 11:28 p.m.",
          "commitNameOld": "e0d34ebdd7aba18149d195804075a87b97f3c02d",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 1.42,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n\n    if (route.getAddress().getSslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n            ? address.getSocketFactory().createSocket()\n            : new Socket(proxy);\n        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n      } catch (IOException e) {\n        Util.closeQuietly(socket);\n        socket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        framedConnection \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
          "functionStartLine": 78,
          "functionName": "connect",
          "diff": "@@ -1,41 +1,42 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n \n-    if (route.address.getSslSocketFactory() \u003d\u003d null\n+    if (route.getAddress().getSslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol \u003d\u003d null) {\n       try {\n         socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         socket \u003d null;\n+        source \u003d null;\n+        sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n-        httpConnection \u003d null;\n         framedConnection \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "First draft of the new new stream allocations model.\n",
          "commitDate": "2015-11-28, 9:36 a.m.",
          "commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015-11-26, 11:28 p.m.",
          "commitNameOld": "e0d34ebdd7aba18149d195804075a87b97f3c02d",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 1.42,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n\n    if (route.getAddress().getSslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n            ? address.getSocketFactory().createSocket()\n            : new Socket(proxy);\n        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n      } catch (IOException e) {\n        Util.closeQuietly(socket);\n        socket \u003d null;\n        source \u003d null;\n        sink \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        framedConnection \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
          "functionStartLine": 78,
          "functionName": "connect",
          "diff": "@@ -1,41 +1,42 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n \n-    if (route.address.getSslSocketFactory() \u003d\u003d null\n+    if (route.getAddress().getSslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol \u003d\u003d null) {\n       try {\n         socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         socket \u003d null;\n+        source \u003d null;\n+        sink \u003d null;\n         handshake \u003d null;\n         protocol \u003d null;\n-        httpConnection \u003d null;\n         framedConnection \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "529c4a36bb21b3fb7717c27f8a31c39c1b603e9d": {
      "type": "Ybodychange",
      "commitMessage": "Stop returning HTTP/1.0 from Connection.getProtocol().\n\nThis was updating the protocol as a side-effect of an HTTP/1.0 response.\nThis made the protocol field mutable, and the code more difficult to\ntrace.\n\nOne consequence of this change is that OkHttp will attempt HTTP/1.1 for\nall requests, even if a server returns HTTP/1.0 from the first response.\nThis is closer to our implementation anyway.\n",
      "commitDate": "2015-11-18, 12:01 a.m.",
      "commitName": "529c4a36bb21b3fb7717c27f8a31c39c1b603e9d",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-11-14, 10:28 p.m.",
      "commitNameOld": "457fb428a729c50c562822571ea9b13e689648f3",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 3.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "  void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n\n    if (route.address.getSslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (protocol \u003d\u003d null) {\n      try {\n        socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n            ? address.getSocketFactory().createSocket()\n            : new Socket(proxy);\n        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n      } catch (IOException e) {\n        Util.closeQuietly(socket);\n        socket \u003d null;\n        handshake \u003d null;\n        protocol \u003d null;\n        httpConnection \u003d null;\n        framedConnection \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 152,
      "functionName": "connect",
      "diff": "@@ -1,39 +1,41 @@\n   void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n-    if (connected) throw new IllegalStateException(\"already connected\");\n+    if (protocol !\u003d null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n \n     if (route.address.getSslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n-    while (!connected) {\n+    while (protocol \u003d\u003d null) {\n       try {\n         socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n-        connectSocket(connectTimeout, readTimeout, writeTimeout,\n-            connectionSpecSelector);\n-        connected \u003d true; // Success!\n+        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         socket \u003d null;\n+        handshake \u003d null;\n+        protocol \u003d null;\n+        httpConnection \u003d null;\n+        framedConnection \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "457fb428a729c50c562822571ea9b13e689648f3": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Don\u0027t use the request to build the proxy tunnel.\n\nThe tunnel is shared between requests, and it\u0027s awkward to build that with the\nfirst request that needs it.\n",
      "commitDate": "2015-11-14, 10:28 p.m.",
      "commitName": "457fb428a729c50c562822571ea9b13e689648f3",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Don\u0027t use the request to build the proxy tunnel.\n\nThe tunnel is shared between requests, and it\u0027s awkward to build that with the\nfirst request that needs it.\n",
          "commitDate": "2015-11-14, 10:28 p.m.",
          "commitName": "457fb428a729c50c562822571ea9b13e689648f3",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015-08-24, 10:43 p.m.",
          "commitNameOld": "ebaaf10ec1f861b2d4b455e01d3118568f4c6f51",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 82.03,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "actualSource": "  void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n\n    if (route.address.getSslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (!connected) {\n      try {\n        socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n            ? address.getSocketFactory().createSocket()\n            : new Socket(proxy);\n        connectSocket(connectTimeout, readTimeout, writeTimeout,\n            connectionSpecSelector);\n        connected \u003d true; // Success!\n      } catch (IOException e) {\n        Util.closeQuietly(socket);\n        socket \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 153,
          "functionName": "connect",
          "diff": "@@ -1,39 +1,39 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n+  void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n \n     if (route.address.getSslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (!connected) {\n       try {\n         socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n-        connectSocket(connectTimeout, readTimeout, writeTimeout, request,\n+        connectSocket(connectTimeout, readTimeout, writeTimeout,\n             connectionSpecSelector);\n         connected \u003d true; // Success!\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         socket \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, request-Request, connectionSpecs-List\u003cConnectionSpec\u003e, connectionRetryEnabled-boolean]",
            "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionSpecs-List\u003cConnectionSpec\u003e, connectionRetryEnabled-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Don\u0027t use the request to build the proxy tunnel.\n\nThe tunnel is shared between requests, and it\u0027s awkward to build that with the\nfirst request that needs it.\n",
          "commitDate": "2015-11-14, 10:28 p.m.",
          "commitName": "457fb428a729c50c562822571ea9b13e689648f3",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015-08-24, 10:43 p.m.",
          "commitNameOld": "ebaaf10ec1f861b2d4b455e01d3118568f4c6f51",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 82.03,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "actualSource": "  void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n\n    if (route.address.getSslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (!connected) {\n      try {\n        socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n            ? address.getSocketFactory().createSocket()\n            : new Socket(proxy);\n        connectSocket(connectTimeout, readTimeout, writeTimeout,\n            connectionSpecSelector);\n        connected \u003d true; // Success!\n      } catch (IOException e) {\n        Util.closeQuietly(socket);\n        socket \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 153,
          "functionName": "connect",
          "diff": "@@ -1,39 +1,39 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n+  void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n \n     if (route.address.getSslSocketFactory() \u003d\u003d null\n         \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (!connected) {\n       try {\n         socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n-        connectSocket(connectTimeout, readTimeout, writeTimeout, request,\n+        connectSocket(connectTimeout, readTimeout, writeTimeout,\n             connectionSpecSelector);\n         connected \u003d true; // Success!\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         socket \u003d null;\n \n         if (routeException \u003d\u003d null) {\n           routeException \u003d new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "b42e73f497eafe147667117202267ec756adff26": {
      "type": "Ybodychange",
      "commitMessage": "Make call canceling more reliable.\n\nWe had a bug where the socket-being-connected wasn\u0027t being closed when the\napplication used Call.cancel(). The problem is that the SocketConnector model\nassumes the Connection doesn\u0027t want a Socket instance until it\u0027s fully\nconnected.\n\nThis moves the SocketConnector code back into Connection, removes a lot of\nnested try/catch blocks, and assigns a Socket instance as soon as its created.\n\nThis also likely fixes some bugs where sockets weren\u0027t being closed when\nan IOException or RouteException was thrown during connection. Now we always\nclose at the top level of connect() unless the connection is successful.\n\nhttps://github.com/square/okhttp/issues/1779\n",
      "commitDate": "2015-08-01, 7:54 p.m.",
      "commitName": "b42e73f497eafe147667117202267ec756adff26",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-06-17, 6:40 p.m.",
      "commitNameOld": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 45.05,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n\n    if (route.address.getSslSocketFactory() \u003d\u003d null\n        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n      throw new RouteException(new UnknownServiceException(\n          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n\n    while (!connected) {\n      try {\n        socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n            ? address.getSocketFactory().createSocket()\n            : new Socket(proxy);\n        connectSocket(connectTimeout, readTimeout, writeTimeout, request,\n            connectionSpecSelector);\n        connected \u003d true; // Success!\n      } catch (IOException e) {\n        Util.closeQuietly(socket);\n        socket \u003d null;\n\n        if (routeException \u003d\u003d null) {\n          routeException \u003d new RouteException(e);\n        } else {\n          routeException.addConnectException(e);\n        }\n\n        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n          throw routeException;\n        }\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 153,
      "functionName": "connect",
      "diff": "@@ -1,39 +1,39 @@\n   void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n-    SocketConnector.ConnectedSocket connectedSocket;\n-    if (route.address.getSslSocketFactory() !\u003d null) {\n-      // https:// communication\n-      connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n-          request, route, connectionSpecs, connectionRetryEnabled);\n-    } else {\n-      // http:// communication.\n-      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n-        throw new RouteException(\n-            new UnknownServiceException(\n-                \"CLEARTEXT communication not supported: \" + connectionSpecs));\n-      }\n-      connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n+    RouteException routeException \u003d null;\n+    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n+    Proxy proxy \u003d route.getProxy();\n+    Address address \u003d route.getAddress();\n+\n+    if (route.address.getSslSocketFactory() \u003d\u003d null\n+        \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+      throw new RouteException(new UnknownServiceException(\n+          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n-    socket \u003d connectedSocket.socket;\n-    handshake \u003d connectedSocket.handshake;\n-    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null\n-        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n+    while (!connected) {\n+      try {\n+        socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP\n+            ? address.getSocketFactory().createSocket()\n+            : new Socket(proxy);\n+        connectSocket(connectTimeout, readTimeout, writeTimeout, request,\n+            connectionSpecSelector);\n+        connected \u003d true; // Success!\n+      } catch (IOException e) {\n+        Util.closeQuietly(socket);\n+        socket \u003d null;\n \n-    try {\n-      if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n-        socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.\n-        framedConnection \u003d new FramedConnection.Builder(route.address.uriHost, true, socket)\n-            .protocol(protocol).build();\n-        framedConnection.sendConnectionPreface();\n-      } else {\n-        httpConnection \u003d new HttpConnection(pool, this, socket);\n+        if (routeException \u003d\u003d null) {\n+          routeException \u003d new RouteException(e);\n+        } else {\n+          routeException.addConnectException(e);\n+        }\n+\n+        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n+          throw routeException;\n+        }\n       }\n-    } catch (IOException e) {\n-      throw new RouteException(e);\n     }\n-    connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80": {
      "type": "Ybodychange",
      "commitMessage": "Rename \u0027spdy\u0027 references to \u0027framed\u0027 where appropriate.\n",
      "commitDate": "2015-06-17, 6:40 p.m.",
      "commitName": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2015-04-20, 10:09 p.m.",
      "commitNameOld": "b0b000e29668517d21c37c696100bc8331117516",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 57.85,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "actualSource": "  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n    SocketConnector.ConnectedSocket connectedSocket;\n    if (route.address.getSslSocketFactory() !\u003d null) {\n      // https:// communication\n      connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n          request, route, connectionSpecs, connectionRetryEnabled);\n    } else {\n      // http:// communication.\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(\n            new UnknownServiceException(\n                \"CLEARTEXT communication not supported: \" + connectionSpecs));\n      }\n      connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n    }\n\n    socket \u003d connectedSocket.socket;\n    handshake \u003d connectedSocket.handshake;\n    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null\n        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n\n    try {\n      if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n        socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.\n        framedConnection \u003d new FramedConnection.Builder(route.address.uriHost, true, socket)\n            .protocol(protocol).build();\n        framedConnection.sendConnectionPreface();\n      } else {\n        httpConnection \u003d new HttpConnection(pool, this, socket);\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n    connected \u003d true;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 135,
      "functionName": "connect",
      "diff": "@@ -1,39 +1,39 @@\n   void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n       List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n     SocketConnector.ConnectedSocket connectedSocket;\n     if (route.address.getSslSocketFactory() !\u003d null) {\n       // https:// communication\n       connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n           request, route, connectionSpecs, connectionRetryEnabled);\n     } else {\n       // http:// communication.\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(\n             new UnknownServiceException(\n                 \"CLEARTEXT communication not supported: \" + connectionSpecs));\n       }\n       connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n     }\n \n     socket \u003d connectedSocket.socket;\n     handshake \u003d connectedSocket.handshake;\n     protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null\n         ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n \n     try {\n       if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n-        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.\n-        spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket)\n+        socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.\n+        framedConnection \u003d new FramedConnection.Builder(route.address.uriHost, true, socket)\n             .protocol(protocol).build();\n-        spdyConnection.sendConnectionPreface();\n+        framedConnection.sendConnectionPreface();\n       } else {\n         httpConnection \u003d new HttpConnection(pool, this, socket);\n       }\n     } catch (IOException e) {\n       throw new RouteException(e);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "60f5406dcc094d0431420139bd002e8bdd4ea5d5": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "Move TLS retries / fallback into Connection.\n\nAPI changes:\n1) Added: Address.getCertificatePinner()\n2) Incompatible API change: Address constructor no longer\nincludes ConnectionSpecs. Removed getConnectionSpecs().\n3) Added: ConnectionSpec.isCompatible(SSLSocket)\n4) Added: TlsVersion.javaName()\n\nImplicit / semantic / internal changes:\n\n1) Connection now handles all attempts to connect via a route\n(effectively a {proxy, socket address} pair), rather than just\none attempt. i.e. Connection now handles all the TLS negotiation\nfallbacks internally.\n\n2) Route no longer deals with TLS versions. Individual TLS\nfailures are not counted against a Route. If no connection\nattempts to a route were successful the failure is counted\nagainst the route.\n\n3) The code makes a distinction between when various\nIOExceptions occur, with the intention making retries a bit\nsmarter. It is now more obvious which exceptions happen during\nsetup (RequestException), connection (RouteException),\nHTTP communication and thus which can be retried and whether\nthe request might have been sent.\n",
      "commitDate": "2015-03-18, 11:59 a.m.",
      "commitName": "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
      "commitAuthor": "Neil Fuller",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Move TLS retries / fallback into Connection.\n\nAPI changes:\n1) Added: Address.getCertificatePinner()\n2) Incompatible API change: Address constructor no longer\nincludes ConnectionSpecs. Removed getConnectionSpecs().\n3) Added: ConnectionSpec.isCompatible(SSLSocket)\n4) Added: TlsVersion.javaName()\n\nImplicit / semantic / internal changes:\n\n1) Connection now handles all attempts to connect via a route\n(effectively a {proxy, socket address} pair), rather than just\none attempt. i.e. Connection now handles all the TLS negotiation\nfallbacks internally.\n\n2) Route no longer deals with TLS versions. Individual TLS\nfailures are not counted against a Route. If no connection\nattempts to a route were successful the failure is counted\nagainst the route.\n\n3) The code makes a distinction between when various\nIOExceptions occur, with the intention making retries a bit\nsmarter. It is now more obvious which exceptions happen during\nsetup (RequestException), connection (RouteException),\nHTTP communication and thus which can be retried and whether\nthe request might have been sent.\n",
          "commitDate": "2015-03-18, 11:59 a.m.",
          "commitName": "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
          "commitAuthor": "Neil Fuller",
          "commitDateOld": "2015-02-09, 11:30 p.m.",
          "commitNameOld": "cc94dea6d7fad79e531ee723c31e2d92fb7ccf98",
          "commitAuthorOld": "Kirill Boyarshinov",
          "daysBetweenCommits": 36.48,
          "commitsBetweenForRepo": 41,
          "commitsBetweenForFile": 1,
          "actualSource": "  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n    SocketConnector.ConnectedSocket connectedSocket;\n    if (route.address.getSslSocketFactory() !\u003d null) {\n      // https:// communication\n      connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n          request, route, connectionSpecs, connectionRetryEnabled);\n    } else {\n      // http:// communication.\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(\n            new UnknownServiceException(\n                \"CLEARTEXT communication not supported: \" + connectionSpecs));\n      }\n      connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n    }\n\n    socket \u003d connectedSocket.socket;\n    handshake \u003d connectedSocket.handshake;\n    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null\n        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n\n    try {\n      if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.\n        spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket)\n            .protocol(protocol).build();\n        spdyConnection.sendConnectionPreface();\n      } else {\n        httpConnection \u003d new HttpConnection(pool, this, socket);\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n    connected \u003d true;\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 133,
          "functionName": "connect",
          "diff": "@@ -1,20 +1,39 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n-      throws IOException {\n+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n+      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    if (route.proxy.type() \u003d\u003d Proxy.Type.DIRECT || route.proxy.type() \u003d\u003d Proxy.Type.HTTP) {\n-      socket \u003d route.address.socketFactory.createSocket();\n+    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n+    SocketConnector.ConnectedSocket connectedSocket;\n+    if (route.address.getSslSocketFactory() !\u003d null) {\n+      // https:// communication\n+      connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n+          request, route, connectionSpecs, connectionRetryEnabled);\n     } else {\n-      socket \u003d new Socket(route.proxy);\n+      // http:// communication.\n+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+        throw new RouteException(\n+            new UnknownServiceException(\n+                \"CLEARTEXT communication not supported: \" + connectionSpecs));\n+      }\n+      connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n     }\n \n-    socket.setSoTimeout(readTimeout);\n-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n+    socket \u003d connectedSocket.socket;\n+    handshake \u003d connectedSocket.handshake;\n+    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null\n+        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n \n-    if (route.address.sslSocketFactory !\u003d null) {\n-      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n-    } else {\n-      httpConnection \u003d new HttpConnection(pool, this, socket);\n+    try {\n+      if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n+        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.\n+        spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket)\n+            .protocol(protocol).build();\n+        spdyConnection.sendConnectionPreface();\n+      } else {\n+        httpConnection \u003d new HttpConnection(pool, this, socket);\n+      }\n+    } catch (IOException e) {\n+      throw new RouteException(e);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, tunnelRequest-Request]",
            "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, request-Request, connectionSpecs-List\u003cConnectionSpec\u003e, connectionRetryEnabled-boolean]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "Move TLS retries / fallback into Connection.\n\nAPI changes:\n1) Added: Address.getCertificatePinner()\n2) Incompatible API change: Address constructor no longer\nincludes ConnectionSpecs. Removed getConnectionSpecs().\n3) Added: ConnectionSpec.isCompatible(SSLSocket)\n4) Added: TlsVersion.javaName()\n\nImplicit / semantic / internal changes:\n\n1) Connection now handles all attempts to connect via a route\n(effectively a {proxy, socket address} pair), rather than just\none attempt. i.e. Connection now handles all the TLS negotiation\nfallbacks internally.\n\n2) Route no longer deals with TLS versions. Individual TLS\nfailures are not counted against a Route. If no connection\nattempts to a route were successful the failure is counted\nagainst the route.\n\n3) The code makes a distinction between when various\nIOExceptions occur, with the intention making retries a bit\nsmarter. It is now more obvious which exceptions happen during\nsetup (RequestException), connection (RouteException),\nHTTP communication and thus which can be retried and whether\nthe request might have been sent.\n",
          "commitDate": "2015-03-18, 11:59 a.m.",
          "commitName": "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
          "commitAuthor": "Neil Fuller",
          "commitDateOld": "2015-02-09, 11:30 p.m.",
          "commitNameOld": "cc94dea6d7fad79e531ee723c31e2d92fb7ccf98",
          "commitAuthorOld": "Kirill Boyarshinov",
          "daysBetweenCommits": 36.48,
          "commitsBetweenForRepo": 41,
          "commitsBetweenForFile": 1,
          "actualSource": "  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n    SocketConnector.ConnectedSocket connectedSocket;\n    if (route.address.getSslSocketFactory() !\u003d null) {\n      // https:// communication\n      connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n          request, route, connectionSpecs, connectionRetryEnabled);\n    } else {\n      // http:// communication.\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(\n            new UnknownServiceException(\n                \"CLEARTEXT communication not supported: \" + connectionSpecs));\n      }\n      connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n    }\n\n    socket \u003d connectedSocket.socket;\n    handshake \u003d connectedSocket.handshake;\n    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null\n        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n\n    try {\n      if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.\n        spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket)\n            .protocol(protocol).build();\n        spdyConnection.sendConnectionPreface();\n      } else {\n        httpConnection \u003d new HttpConnection(pool, this, socket);\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n    connected \u003d true;\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 133,
          "functionName": "connect",
          "diff": "@@ -1,20 +1,39 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n-      throws IOException {\n+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n+      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    if (route.proxy.type() \u003d\u003d Proxy.Type.DIRECT || route.proxy.type() \u003d\u003d Proxy.Type.HTTP) {\n-      socket \u003d route.address.socketFactory.createSocket();\n+    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n+    SocketConnector.ConnectedSocket connectedSocket;\n+    if (route.address.getSslSocketFactory() !\u003d null) {\n+      // https:// communication\n+      connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n+          request, route, connectionSpecs, connectionRetryEnabled);\n     } else {\n-      socket \u003d new Socket(route.proxy);\n+      // http:// communication.\n+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+        throw new RouteException(\n+            new UnknownServiceException(\n+                \"CLEARTEXT communication not supported: \" + connectionSpecs));\n+      }\n+      connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n     }\n \n-    socket.setSoTimeout(readTimeout);\n-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n+    socket \u003d connectedSocket.socket;\n+    handshake \u003d connectedSocket.handshake;\n+    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null\n+        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n \n-    if (route.address.sslSocketFactory !\u003d null) {\n-      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n-    } else {\n-      httpConnection \u003d new HttpConnection(pool, this, socket);\n+    try {\n+      if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n+        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.\n+        spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket)\n+            .protocol(protocol).build();\n+        spdyConnection.sendConnectionPreface();\n+      } else {\n+        httpConnection \u003d new HttpConnection(pool, this, socket);\n+      }\n+    } catch (IOException e) {\n+      throw new RouteException(e);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[RouteException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Move TLS retries / fallback into Connection.\n\nAPI changes:\n1) Added: Address.getCertificatePinner()\n2) Incompatible API change: Address constructor no longer\nincludes ConnectionSpecs. Removed getConnectionSpecs().\n3) Added: ConnectionSpec.isCompatible(SSLSocket)\n4) Added: TlsVersion.javaName()\n\nImplicit / semantic / internal changes:\n\n1) Connection now handles all attempts to connect via a route\n(effectively a {proxy, socket address} pair), rather than just\none attempt. i.e. Connection now handles all the TLS negotiation\nfallbacks internally.\n\n2) Route no longer deals with TLS versions. Individual TLS\nfailures are not counted against a Route. If no connection\nattempts to a route were successful the failure is counted\nagainst the route.\n\n3) The code makes a distinction between when various\nIOExceptions occur, with the intention making retries a bit\nsmarter. It is now more obvious which exceptions happen during\nsetup (RequestException), connection (RouteException),\nHTTP communication and thus which can be retried and whether\nthe request might have been sent.\n",
          "commitDate": "2015-03-18, 11:59 a.m.",
          "commitName": "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
          "commitAuthor": "Neil Fuller",
          "commitDateOld": "2015-02-09, 11:30 p.m.",
          "commitNameOld": "cc94dea6d7fad79e531ee723c31e2d92fb7ccf98",
          "commitAuthorOld": "Kirill Boyarshinov",
          "daysBetweenCommits": 36.48,
          "commitsBetweenForRepo": 41,
          "commitsBetweenForFile": 1,
          "actualSource": "  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n    SocketConnector.ConnectedSocket connectedSocket;\n    if (route.address.getSslSocketFactory() !\u003d null) {\n      // https:// communication\n      connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n          request, route, connectionSpecs, connectionRetryEnabled);\n    } else {\n      // http:// communication.\n      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(\n            new UnknownServiceException(\n                \"CLEARTEXT communication not supported: \" + connectionSpecs));\n      }\n      connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n    }\n\n    socket \u003d connectedSocket.socket;\n    handshake \u003d connectedSocket.handshake;\n    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null\n        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n\n    try {\n      if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.\n        spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket)\n            .protocol(protocol).build();\n        spdyConnection.sendConnectionPreface();\n      } else {\n        httpConnection \u003d new HttpConnection(pool, this, socket);\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n    connected \u003d true;\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 133,
          "functionName": "connect",
          "diff": "@@ -1,20 +1,39 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n-      throws IOException {\n+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n+      List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    if (route.proxy.type() \u003d\u003d Proxy.Type.DIRECT || route.proxy.type() \u003d\u003d Proxy.Type.HTTP) {\n-      socket \u003d route.address.socketFactory.createSocket();\n+    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n+    SocketConnector.ConnectedSocket connectedSocket;\n+    if (route.address.getSslSocketFactory() !\u003d null) {\n+      // https:// communication\n+      connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n+          request, route, connectionSpecs, connectionRetryEnabled);\n     } else {\n-      socket \u003d new Socket(route.proxy);\n+      // http:// communication.\n+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+        throw new RouteException(\n+            new UnknownServiceException(\n+                \"CLEARTEXT communication not supported: \" + connectionSpecs));\n+      }\n+      connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n     }\n \n-    socket.setSoTimeout(readTimeout);\n-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n+    socket \u003d connectedSocket.socket;\n+    handshake \u003d connectedSocket.handshake;\n+    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null\n+        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n \n-    if (route.address.sslSocketFactory !\u003d null) {\n-      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n-    } else {\n-      httpConnection \u003d new HttpConnection(pool, this, socket);\n+    try {\n+      if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n+        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.\n+        spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket)\n+            .protocol(protocol).build();\n+        spdyConnection.sendConnectionPreface();\n+      } else {\n+        httpConnection \u003d new HttpConnection(pool, this, socket);\n+      }\n+    } catch (IOException e) {\n+      throw new RouteException(e);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6d9f9cbdf8069e504cb58908db23b4f327d1826c": {
      "type": "Ybodychange",
      "commitMessage": "Use the socket factory for direct connections as well.\n\nCurrently, the passed-in socket factory is only used for\nconnections to HTTP proxies. I think this was not the intent of\nthe original socket factory change, because the commit message\nsaid that the \"socket factory will be used for all non-proxy\nconnections and HTTP proxy connections\".  So use it for DIRECT\nconnections as well.\n\nAlso add a test to check that a socket factory is used if\nspecified.\n\nChange-Id: I811b08442d1c80be1a0a268eb51c9aa365febf00\n",
      "commitDate": "2014-07-21, 3:34 p.m.",
      "commitName": "6d9f9cbdf8069e504cb58908db23b4f327d1826c",
      "commitAuthor": "Lorenzo Colitti",
      "commitDateOld": "2014-06-28, 10:57 a.m.",
      "commitNameOld": "7bb06e78bac05e0e24c6ea81b34aa11f498ad61f",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 23.19,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n      throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    if (route.proxy.type() \u003d\u003d Proxy.Type.DIRECT || route.proxy.type() \u003d\u003d Proxy.Type.HTTP) {\n      socket \u003d route.address.socketFactory.createSocket();\n    } else {\n      socket \u003d new Socket(route.proxy);\n    }\n\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n    } else {\n      httpConnection \u003d new HttpConnection(pool, this, socket);\n    }\n    connected \u003d true;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 139,
      "functionName": "connect",
      "diff": "@@ -1,20 +1,20 @@\n   void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n-      socket \u003d new Socket(route.proxy);\n-    } else {\n+    if (route.proxy.type() \u003d\u003d Proxy.Type.DIRECT || route.proxy.type() \u003d\u003d Proxy.Type.HTTP) {\n       socket \u003d route.address.socketFactory.createSocket();\n+    } else {\n+      socket \u003d new Socket(route.proxy);\n     }\n \n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n       httpConnection \u003d new HttpConnection(pool, this, socket);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1044d9eea21d8be54c195fff75ca0a7b9bba79b3": {
      "type": "Ymodifierchange",
      "commitMessage": "Hide more APIs with Internal.access.\n\nThe callsite is uglier but the API is neater. I think overall\nit\u0027s a small win.\n",
      "commitDate": "2014-04-30, 9:36 p.m.",
      "commitName": "1044d9eea21d8be54c195fff75ca0a7b9bba79b3",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-04-30, 12:16 p.m.",
      "commitNameOld": "853b4e35f1ddbf3c5db1d91c7ff02c2d979da86f",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.39,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n      throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n      socket \u003d new Socket(route.proxy);\n    } else {\n      socket \u003d route.address.socketFactory.createSocket();\n    }\n\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n    } else {\n      httpConnection \u003d new HttpConnection(pool, this, socket);\n    }\n    connected \u003d true;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 138,
      "functionName": "connect",
      "diff": "@@ -1,20 +1,20 @@\n-  public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n       socket \u003d new Socket(route.proxy);\n     } else {\n       socket \u003d route.address.socketFactory.createSocket();\n     }\n \n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n       httpConnection \u003d new HttpConnection(pool, this, socket);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[]"
      }
    },
    "b60875421b0f67575970b6b63582b7e5e31c4a06": {
      "type": "Ybodychange",
      "commitMessage": "Update Okio timeouts when recycling connections.\n",
      "commitDate": "2014-04-20, 11:49 a.m.",
      "commitName": "b60875421b0f67575970b6b63582b7e5e31c4a06",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-04-20, 10:10 a.m.",
      "commitNameOld": "da484932625ab15681e469c1680b6371b8f67080",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n      throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n      socket \u003d new Socket(route.proxy);\n    } else {\n      socket \u003d route.address.socketFactory.createSocket();\n    }\n\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n    } else {\n      httpConnection \u003d new HttpConnection(pool, this, socket);\n    }\n    connected \u003d true;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 137,
      "functionName": "connect",
      "diff": "@@ -1,20 +1,20 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n       socket \u003d new Socket(route.proxy);\n     } else {\n       socket \u003d route.address.socketFactory.createSocket();\n     }\n \n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n-      httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n+      httpConnection \u003d new HttpConnection(pool, this, socket);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "da484932625ab15681e469c1680b6371b8f67080": {
      "type": "Yparameterchange",
      "commitMessage": "Replace TunnelRequest with a regular Request.\n",
      "commitDate": "2014-04-20, 10:10 a.m.",
      "commitName": "da484932625ab15681e469c1680b6371b8f67080",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-04-20, 3:27 a.m.",
      "commitNameOld": "a9b4ec6bb771472136fb86562ab4a3d9baee0390",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n      throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n      socket \u003d new Socket(route.proxy);\n    } else {\n      socket \u003d route.address.socketFactory.createSocket();\n    }\n\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n    } else {\n      httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n    }\n    connected \u003d true;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 137,
      "functionName": "connect",
      "diff": "@@ -1,20 +1,20 @@\n-  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n-      TunnelRequest tunnelRequest) throws IOException {\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n+      throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n       socket \u003d new Socket(route.proxy);\n     } else {\n       socket \u003d route.address.socketFactory.createSocket();\n     }\n \n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n       httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, tunnelRequest-TunnelRequest]",
        "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, tunnelRequest-Request]"
      }
    },
    "41aa4b6805141369d614964152d329a686aabdb8": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Implement write timeouts for HTTP/1.1 streams.\n",
      "commitDate": "2014-04-18, 5:06 p.m.",
      "commitName": "41aa4b6805141369d614964152d329a686aabdb8",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Implement write timeouts for HTTP/1.1 streams.\n",
          "commitDate": "2014-04-18, 5:06 p.m.",
          "commitName": "41aa4b6805141369d614964152d329a686aabdb8",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2014-04-15, 3:53 a.m.",
          "commitNameOld": "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 3.55,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      TunnelRequest tunnelRequest) throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n      socket \u003d new Socket(route.proxy);\n    } else {\n      socket \u003d route.address.socketFactory.createSocket();\n    }\n\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n    } else {\n      httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n    }\n    connected \u003d true;\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 137,
          "functionName": "connect",
          "diff": "@@ -1,20 +1,20 @@\n-  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n-      throws IOException {\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+      TunnelRequest tunnelRequest) throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n       socket \u003d new Socket(route.proxy);\n     } else {\n       socket \u003d route.address.socketFactory.createSocket();\n     }\n \n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory !\u003d null) {\n-      upgradeToTls(tunnelRequest);\n+      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n-      httpConnection \u003d new HttpConnection(pool, this, socket);\n+      httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, tunnelRequest-TunnelRequest]",
            "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, tunnelRequest-TunnelRequest]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Implement write timeouts for HTTP/1.1 streams.\n",
          "commitDate": "2014-04-18, 5:06 p.m.",
          "commitName": "41aa4b6805141369d614964152d329a686aabdb8",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2014-04-15, 3:53 a.m.",
          "commitNameOld": "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 3.55,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "actualSource": "  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n      TunnelRequest tunnelRequest) throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n      socket \u003d new Socket(route.proxy);\n    } else {\n      socket \u003d route.address.socketFactory.createSocket();\n    }\n\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n    } else {\n      httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n    }\n    connected \u003d true;\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 137,
          "functionName": "connect",
          "diff": "@@ -1,20 +1,20 @@\n-  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n-      throws IOException {\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+      TunnelRequest tunnelRequest) throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n       socket \u003d new Socket(route.proxy);\n     } else {\n       socket \u003d route.address.socketFactory.createSocket();\n     }\n \n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory !\u003d null) {\n-      upgradeToTls(tunnelRequest);\n+      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n-      httpConnection \u003d new HttpConnection(pool, this, socket);\n+      httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f": {
      "type": "Ybodychange",
      "commitMessage": "Allow specifying a socket factory for connections.\n\nThis socket factory will be used for all non-proxy connections and HTTP proxy connections.\n",
      "commitDate": "2014-04-15, 3:53 a.m.",
      "commitName": "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2014-03-30, 8:09 p.m.",
      "commitNameOld": "6c57d76915a7e79cc8b8f743ccd8ecc35889ce7c",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 15.32,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n      socket \u003d new Socket(route.proxy);\n    } else {\n      socket \u003d route.address.socketFactory.createSocket();\n    }\n\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    } else {\n      httpConnection \u003d new HttpConnection(pool, this, socket);\n    }\n    connected \u003d true;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 137,
      "functionName": "connect",
      "diff": "@@ -1,15 +1,20 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n+    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n+      socket \u003d new Socket(route.proxy);\n+    } else {\n+      socket \u003d route.address.socketFactory.createSocket();\n+    }\n+\n     socket.setSoTimeout(readTimeout);\n+    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n       httpConnection \u003d new HttpConnection(pool, this, socket);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8d78da7ce7e60d93fe8e299a83b963cd220a60ad": {
      "type": "Ybodychange",
      "commitMessage": "Push Socket into HttpConnection/SpdyConnection.\n",
      "commitDate": "2014-03-12, 12:20 a.m.",
      "commitName": "8d78da7ce7e60d93fe8e299a83b963cd220a60ad",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-03-03, 2:14 a.m.",
      "commitNameOld": "98f60cc9f0b1af08803dde269386877b9cf1c7d3",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 8.88,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    } else {\n      httpConnection \u003d new HttpConnection(pool, this, socket);\n    }\n    connected \u003d true;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 80,
      "functionName": "connect",
      "diff": "@@ -1,18 +1,15 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n-    in \u003d socket.getInputStream();\n-    out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n-      initSourceAndSink();\n-      httpConnection \u003d new HttpConnection(pool, this, source, sink);\n+      httpConnection \u003d new HttpConnection(pool, this, socket);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c16436f8b2020e4bb2cbdddbd0eddd5ae5c528c4": {
      "type": "Ybodychange",
      "commitMessage": "Use BufferedSink in HttpConnection.\n",
      "commitDate": "2014-02-23, 12:55 p.m.",
      "commitName": "c16436f8b2020e4bb2cbdddbd0eddd5ae5c528c4",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-02-23, 11:42 a.m.",
      "commitNameOld": "ab78dadb4bb94db74770e179e04e2ed791c4a51e",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    } else {\n      initSourceAndSink();\n      httpConnection \u003d new HttpConnection(pool, this, source, sink);\n    }\n    connected \u003d true;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 89,
      "functionName": "connect",
      "diff": "@@ -1,18 +1,18 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n-      streamWrapper(true);\n-      httpConnection \u003d new HttpConnection(pool, this, source, out);\n+      initSourceAndSink();\n+      httpConnection \u003d new HttpConnection(pool, this, source, sink);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ab78dadb4bb94db74770e179e04e2ed791c4a51e": {
      "type": "Ybodychange",
      "commitMessage": "Use BufferedSink in SPDY and HTTP/2.\n",
      "commitDate": "2014-02-23, 11:42 a.m.",
      "commitName": "ab78dadb4bb94db74770e179e04e2ed791c4a51e",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-02-22, 4:08 p.m.",
      "commitNameOld": "095448552ee41e62e58994be0f424df750c6822f",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.82,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    } else {\n      streamWrapper(true);\n      httpConnection \u003d new HttpConnection(pool, this, source, out);\n    }\n    connected \u003d true;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 90,
      "functionName": "connect",
      "diff": "@@ -1,18 +1,18 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n-      streamWrapper();\n+      streamWrapper(true);\n       httpConnection \u003d new HttpConnection(pool, this, source, out);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a669069599893a774748181a238e0b009a4f3e87": {
      "type": "Ybodychange",
      "commitMessage": "Use OkBuffer+Source in HttpEngine.\n",
      "commitDate": "2014-02-18, 2:33 a.m.",
      "commitName": "a669069599893a774748181a238e0b009a4f3e87",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-02-15, 6:44 p.m.",
      "commitNameOld": "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 2.33,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    } else {\n      streamWrapper();\n      httpConnection \u003d new HttpConnection(pool, this, source, out);\n    }\n    connected \u003d true;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 89,
      "functionName": "connect",
      "diff": "@@ -1,18 +1,18 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n       streamWrapper();\n-      httpConnection \u003d new HttpConnection(pool, this, in, out);\n+      httpConnection \u003d new HttpConnection(pool, this, source, out);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": {
      "type": "Ybodychange",
      "commitMessage": "Move connection pooling logic.\n\nPreviously we had this ugly, awkward release() method that\nattempted to manage connection pooling, discarding streams\nfor caching, and closing broken streams.\n\nMove connection reuse to HttpConnection, with policy informed\nby HttpEngine. It specifies what to do when the connection\nbecomes idle: pool, close or hold. The connection does what\nit\u0027s told.\n",
      "commitDate": "2014-02-15, 6:44 p.m.",
      "commitName": "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-02-15, 1:30 p.m.",
      "commitNameOld": "322e9f3700be4b9ebcf8b004d82868da71f919c5",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.22,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    } else {\n      streamWrapper();\n      httpConnection \u003d new HttpConnection(pool, this, in, out);\n    }\n    connected \u003d true;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 86,
      "functionName": "connect",
      "diff": "@@ -1,18 +1,18 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n       streamWrapper();\n-      httpConnection \u003d new HttpConnection(in, out);\n+      httpConnection \u003d new HttpConnection(pool, this, in, out);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "504b9cf55afd9d642e2a5323e18f79db607ad1a9": {
      "type": "Ybodychange",
      "commitMessage": "Split HttpTransport in two.\n\nThe new (awkwardly-named) HttpConnection class now owns the\nsocket, and stays around between HTTP requests. It matches\nSpdyConnection in lifecycle: it is tied to the socket.\n\nThe HTTP transport class is a dumb adapter that adapts the\nprotocol-specific decisions (chunked-encoding, content-length\nstuff).\n\nThis should make it possible to make significant simplifications\nto how connection recycling works: in a follow up change the\nHttpConnection class will know when it can be recycled and take\nthat action automatically.\n",
      "commitDate": "2014-02-14, 4:23 p.m.",
      "commitName": "504b9cf55afd9d642e2a5323e18f79db607ad1a9",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-01-26, 6:09 p.m.",
      "commitNameOld": "32a2b1d8d000a19d4a340cc1d77a68973a9d65dc",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 18.93,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    } else {\n      streamWrapper();\n      httpConnection \u003d new HttpConnection(in, out);\n    }\n    connected \u003d true;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 85,
      "functionName": "connect",
      "diff": "@@ -1,17 +1,18 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n       streamWrapper();\n+      httpConnection \u003d new HttpConnection(in, out);\n     }\n     connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ed2ee02570bac36b89bd93836e200840cb8fa59d": {
      "type": "Ybodychange",
      "commitMessage": "Connected after everything is initialized\n",
      "commitDate": "2014-01-08, 10:10 p.m.",
      "commitName": "ed2ee02570bac36b89bd93836e200840cb8fa59d",
      "commitAuthor": "lingming.yb",
      "commitDateOld": "2014-01-05, 6:56 p.m.",
      "commitNameOld": "656bca2dc8bc9f2f13b8aa42e0bdd3b94202f527",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 3.13,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    } else {\n      streamWrapper();\n    }\n    connected \u003d true;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 108,
      "functionName": "connect",
      "diff": "@@ -1,17 +1,17 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n       streamWrapper();\n     }\n+    connected \u003d true;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dbca0acc6f8c188dfa48f07bb5886606bec8d28f": {
      "type": "Ybodychange",
      "commitMessage": "Kill the Policy interface.\n\nThis interface was necessary while cleaning up the delicate\nintertwined relationship between HttpURLConnection and HttpEngine.\nWith this change HttpEngine no longer has a reverse dependency\non HttpURLConnection.\n",
      "commitDate": "2014-01-01, 10:30 a.m.",
      "commitName": "dbca0acc6f8c188dfa48f07bb5886606bec8d28f",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-12-31, 8:52 p.m.",
      "commitNameOld": "957537774b319bb0109819258a11af78a98bcb97",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.57,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) throw new IllegalStateException(\"already connected\");\n\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    } else {\n      streamWrapper();\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 93,
      "functionName": "connect",
      "diff": "@@ -1,18 +1,17 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n-    if (connected) {\n-      throw new IllegalStateException(\"already connected\");\n-    }\n+    if (connected) throw new IllegalStateException(\"already connected\");\n+\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n       streamWrapper();\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "35ead0f5d17b0c53610b0947aa9bd8fee6da50fa": {
      "type": "Ybodychange",
      "commitMessage": "extract a method\n",
      "commitDate": "2013-12-23, 4:02 a.m.",
      "commitName": "35ead0f5d17b0c53610b0947aa9bd8fee6da50fa",
      "commitAuthor": "lingming.yb",
      "commitDateOld": "2013-12-21, 10:22 p.m.",
      "commitNameOld": "13c06879f4e98c86436bdca765046ef815e34838",
      "commitAuthorOld": "lingming.yb",
      "daysBetweenCommits": 1.24,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) {\n      throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    }\n    else{\n      streamWrapper();\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 94,
      "functionName": "connect",
      "diff": "@@ -1,24 +1,19 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     }\n     else{\n-      // Use MTU-sized buffers to send fewer packets.\n-      int mtu \u003d Platform.get().getMtu(socket);\n-      if (mtu \u003c 1024) mtu \u003d 1024;\n-      if (mtu \u003e 8192) mtu \u003d 8192;\n-      in \u003d new BufferedInputStream(in, mtu);\n-      out \u003d new BufferedOutputStream(out, mtu);\n+      streamWrapper();\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "13c06879f4e98c86436bdca765046ef815e34838": {
      "type": "Ybodychange",
      "commitMessage": "Buffered Stream wrapper should be taken place before SpdyConnection build.\n",
      "commitDate": "2013-12-21, 10:22 p.m.",
      "commitName": "13c06879f4e98c86436bdca765046ef815e34838",
      "commitAuthor": "lingming.yb",
      "commitDateOld": "2013-09-29, 4:08 p.m.",
      "commitNameOld": "29ab48bf0dfbac1b249f2233de08fa948bad11d8",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 83.3,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) {\n      throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    }\n    else{\n      // Use MTU-sized buffers to send fewer packets.\n      int mtu \u003d Platform.get().getMtu(socket);\n      if (mtu \u003c 1024) mtu \u003d 1024;\n      if (mtu \u003e 8192) mtu \u003d 8192;\n      in \u003d new BufferedInputStream(in, mtu);\n      out \u003d new BufferedOutputStream(out, mtu);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 94,
      "functionName": "connect",
      "diff": "@@ -1,23 +1,24 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     }\n-\n-    // Use MTU-sized buffers to send fewer packets.\n-    int mtu \u003d Platform.get().getMtu(socket);\n-    if (mtu \u003c 1024) mtu \u003d 1024;\n-    if (mtu \u003e 8192) mtu \u003d 8192;\n-    in \u003d new BufferedInputStream(in, mtu);\n-    out \u003d new BufferedOutputStream(out, mtu);\n+    else{\n+      // Use MTU-sized buffers to send fewer packets.\n+      int mtu \u003d Platform.get().getMtu(socket);\n+      if (mtu \u003c 1024) mtu \u003d 1024;\n+      if (mtu \u003e 8192) mtu \u003d 8192;\n+      in \u003d new BufferedInputStream(in, mtu);\n+      out \u003d new BufferedOutputStream(out, mtu);\n+    }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d66810bf0efbfad5c2afb9b304e1091ac6107a65": {
      "type": "Ybodychange",
      "commitMessage": "Catch SecurityExceptions from socket connects.\n\nVersions of android prior to 4.3 would throw RTEs\nif the underlying socket threw an EACCES error.\n\nSee change 50144 on the Android Open Source Project.\n",
      "commitDate": "2013-07-11, 6:39 a.m.",
      "commitName": "d66810bf0efbfad5c2afb9b304e1091ac6107a65",
      "commitAuthor": "Narayan Kamath",
      "commitDateOld": "2013-05-10, 9:06 a.m.",
      "commitNameOld": "3ba54eed34c9d5e41965587660a76a06806180a0",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 61.9,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) {\n      throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    }\n\n    // Use MTU-sized buffers to send fewer packets.\n    int mtu \u003d Platform.get().getMtu(socket);\n    if (mtu \u003c 1024) mtu \u003d 1024;\n    if (mtu \u003e 8192) mtu \u003d 8192;\n    in \u003d new BufferedInputStream(in, mtu);\n    out \u003d new BufferedOutputStream(out, mtu);\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 93,
      "functionName": "connect",
      "diff": "@@ -1,23 +1,23 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n-    socket.connect(route.inetSocketAddress, connectTimeout);\n+    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     }\n \n     // Use MTU-sized buffers to send fewer packets.\n     int mtu \u003d Platform.get().getMtu(socket);\n     if (mtu \u003c 1024) mtu \u003d 1024;\n     if (mtu \u003e 8192) mtu \u003d 8192;\n     in \u003d new BufferedInputStream(in, mtu);\n     out \u003d new BufferedOutputStream(out, mtu);\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3ba54eed34c9d5e41965587660a76a06806180a0": {
      "type": "Ybodychange",
      "commitMessage": "Bump the minimum MTU up to 1KiB.\n\nIf anyone is getting -1 from getMtu, we should give them a more\nreasonable default.\n",
      "commitDate": "2013-05-10, 9:06 a.m.",
      "commitName": "3ba54eed34c9d5e41965587660a76a06806180a0",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-05-10, 8:53 a.m.",
      "commitNameOld": "bb1b1a2c5c6c93df75526a2d5bf5c19817402fbc",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) {\n      throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    socket.connect(route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    }\n\n    // Use MTU-sized buffers to send fewer packets.\n    int mtu \u003d Platform.get().getMtu(socket);\n    if (mtu \u003c 1024) mtu \u003d 1024;\n    if (mtu \u003e 8192) mtu \u003d 8192;\n    in \u003d new BufferedInputStream(in, mtu);\n    out \u003d new BufferedOutputStream(out, mtu);\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 93,
      "functionName": "connect",
      "diff": "@@ -1,23 +1,23 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     socket.connect(route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     }\n \n     // Use MTU-sized buffers to send fewer packets.\n     int mtu \u003d Platform.get().getMtu(socket);\n-    if (mtu \u003c 256) mtu \u003d 256;\n+    if (mtu \u003c 1024) mtu \u003d 1024;\n     if (mtu \u003e 8192) mtu \u003d 8192;\n     in \u003d new BufferedInputStream(in, mtu);\n     out \u003d new BufferedOutputStream(out, mtu);\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bb1b1a2c5c6c93df75526a2d5bf5c19817402fbc": {
      "type": "Ybodychange",
      "commitMessage": "Clamp the MTU to a reasonable range.\n\nhttps://github.com/square/okhttp/issues/183\n",
      "commitDate": "2013-05-10, 8:53 a.m.",
      "commitName": "bb1b1a2c5c6c93df75526a2d5bf5c19817402fbc",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-05-03, 7:36 p.m.",
      "commitNameOld": "aee4bff8044f4189eedacb78be37d48cc7ef226f",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 6.55,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) {\n      throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    socket.connect(route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    }\n\n    // Use MTU-sized buffers to send fewer packets.\n    int mtu \u003d Platform.get().getMtu(socket);\n    if (mtu \u003c 256) mtu \u003d 256;\n    if (mtu \u003e 8192) mtu \u003d 8192;\n    in \u003d new BufferedInputStream(in, mtu);\n    out \u003d new BufferedOutputStream(out, mtu);\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 93,
      "functionName": "connect",
      "diff": "@@ -1,21 +1,23 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     socket.connect(route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     }\n \n     // Use MTU-sized buffers to send fewer packets.\n     int mtu \u003d Platform.get().getMtu(socket);\n+    if (mtu \u003c 256) mtu \u003d 256;\n+    if (mtu \u003e 8192) mtu \u003d 8192;\n     in \u003d new BufferedInputStream(in, mtu);\n     out \u003d new BufferedOutputStream(out, mtu);\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "13d8b5f7bfc73c8f4064a57f634b6155991eb961": {
      "type": "Ybodychange",
      "commitMessage": "Use an MTU-sized buffer for socket access.\n\nPreviously we attempted to avoid buffers in some situations\nand create aggressive buffers in other situations. This was\na bad policy, and meant we had some subtle performance bugs.\nThe one that prompted this is that chunked uploads make\nseparate network writes for the chunk size, chunk, and newline\nseparators.\n\nThis avoids that problem and the corresponding complexity.\nUnfortunately getting the MTU isn\u0027t a standard API until\nJava 6 / Gingerbread. I tested my own networks and saw 1500\nin use (for 3G and WiFi) and 1400 (for VPN over WiFi).\n",
      "commitDate": "2013-04-21, 11:10 p.m.",
      "commitName": "13d8b5f7bfc73c8f4064a57f634b6155991eb961",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-04-15, 9:42 a.m.",
      "commitNameOld": "242be7e5781be67fc0b570f02adaa522e48ee49a",
      "commitAuthorOld": "Marcelo Cortes",
      "daysBetweenCommits": 6.56,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) {\n      throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    socket.connect(route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    }\n\n    // Use MTU-sized buffers to send fewer packets.\n    int mtu \u003d Platform.get().getMtu(socket);\n    in \u003d new BufferedInputStream(in, mtu);\n    out \u003d new BufferedOutputStream(out, mtu);\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 93,
      "functionName": "connect",
      "diff": "@@ -1,22 +1,21 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     socket.connect(route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n     if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     }\n \n-    // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n-    if (!isSpdy()) {\n-      int bufferSize \u003d 128;\n-      in \u003d new BufferedInputStream(in, bufferSize);\n-    }\n+    // Use MTU-sized buffers to send fewer packets.\n+    int mtu \u003d Platform.get().getMtu(socket);\n+    in \u003d new BufferedInputStream(in, mtu);\n+    out \u003d new BufferedOutputStream(out, mtu);\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1ece746c815a26782042b1fca6069eb527d1029b": {
      "type": "Ybodychange",
      "commitMessage": "RouteSelector tries previously failed routes last #106\n",
      "commitDate": "2013-04-10, 6:19 p.m.",
      "commitName": "1ece746c815a26782042b1fca6069eb527d1029b",
      "commitAuthor": "Marcelo Cortes",
      "commitDateOld": "2013-03-25, 11:04 p.m.",
      "commitNameOld": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 15.8,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) {\n      throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    socket.connect(route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (route.address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    }\n\n    // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n    if (!isSpdy()) {\n      int bufferSize \u003d 128;\n      in \u003d new BufferedInputStream(in, bufferSize);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 92,
      "functionName": "connect",
      "diff": "@@ -1,22 +1,22 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n-    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n-    socket.connect(inetSocketAddress, connectTimeout);\n+    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n+    socket.connect(route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n \n-    if (address.sslSocketFactory !\u003d null) {\n+    if (route.address.sslSocketFactory !\u003d null) {\n       upgradeToTls(tunnelRequest);\n     }\n \n     // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n     if (!isSpdy()) {\n       int bufferSize \u003d 128;\n       in \u003d new BufferedInputStream(in, bufferSize);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": {
      "type": "Yfilerename",
      "commitMessage": "Move library into a module. Introduce sample module with simple GitHub client.\n",
      "commitDate": "2013-03-25, 11:04 p.m.",
      "commitName": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2013-03-15, 10:39 a.m.",
      "commitNameOld": "ba2b7432cb9fabfc725b09a9f14878cb128ef208",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 10.52,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n      throws IOException {\n    if (connected) {\n      throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n    socket.connect(inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n\n    if (address.sslSocketFactory !\u003d null) {\n      upgradeToTls(tunnelRequest);\n    }\n\n    // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n    if (!isSpdy()) {\n      int bufferSize \u003d 128;\n      in \u003d new BufferedInputStream(in, bufferSize);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 103,
      "functionName": "connect",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/com/squareup/okhttp/Connection.java",
        "newPath": "okhttp/src/main/java/com/squareup/okhttp/Connection.java"
      }
    },
    "194290e5f3819bf91d87c5d08c152946b6aa3509": {
      "type": "Ybodychange",
      "commitMessage": "Improve SPDY+HTTP integration.\n\nWriting tests shook out a few bugs:\n - Pooling wasn\u0027t working well. We were trying to connect\n   after already having been connected.\n - We weren\u0027t writing response bodies to the cache.\n - We weren\u0027t capturing the request time for the cache.\n - MockSpdyServer wasn\u0027t trimming headers.\n\nNew files in this change aren\u0027t new, they\u0027re just inner classes promoted\nto top-level classes for better sharing.\n",
      "commitDate": "2013-01-22, 4:14 p.m.",
      "commitName": "194290e5f3819bf91d87c5d08c152946b6aa3509",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-01-06, 6:30 p.m.",
      "commitNameOld": "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 15.91,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n            throws IOException {\n        if (connected) {\n            throw new IllegalStateException(\"already connected\");\n        }\n        connected \u003d true;\n        socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n                ? new Socket(proxy)\n                : new Socket();\n        socket.connect(inetSocketAddress, connectTimeout);\n        socket.setSoTimeout(readTimeout);\n        in \u003d socket.getInputStream();\n        out \u003d socket.getOutputStream();\n\n        if (address.sslSocketFactory !\u003d null) {\n            upgradeToTls(tunnelRequest);\n        }\n\n        // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n        if (!isSpdy()) {\n            int bufferSize \u003d 128;\n            in \u003d new BufferedInputStream(in, bufferSize);\n        }\n    }",
      "path": "src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 102,
      "functionName": "connect",
      "diff": "@@ -1,20 +1,24 @@\n     public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n             throws IOException {\n+        if (connected) {\n+            throw new IllegalStateException(\"already connected\");\n+        }\n+        connected \u003d true;\n         socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n                 ? new Socket(proxy)\n                 : new Socket();\n         socket.connect(inetSocketAddress, connectTimeout);\n         socket.setSoTimeout(readTimeout);\n         in \u003d socket.getInputStream();\n         out \u003d socket.getOutputStream();\n \n         if (address.sslSocketFactory !\u003d null) {\n             upgradeToTls(tunnelRequest);\n         }\n \n         // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n         if (!isSpdy()) {\n             int bufferSize \u003d 128;\n             in \u003d new BufferedInputStream(in, bufferSize);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "78c6624b11d5f33504dae8211b4592383468343e": {
      "type": "Ymultichange(Yfilerename,Ybodychange,Yparameterchange)",
      "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
      "commitDate": "2012-12-24, 12:39 a.m.",
      "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012-12-24, 12:39 a.m.",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012-12-23, 4:38 p.m.",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n            throws IOException {\n        socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n                ? new Socket(proxy)\n                : new Socket();\n        socket.connect(inetSocketAddress, connectTimeout);\n        socket.setSoTimeout(readTimeout);\n        in \u003d socket.getInputStream();\n        out \u003d socket.getOutputStream();\n\n        if (address.sslSocketFactory !\u003d null) {\n            upgradeToTls(tunnelRequest);\n        }\n\n        // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n        if (!isSpdy()) {\n            int bufferSize \u003d 128;\n            in \u003d new BufferedInputStream(in, bufferSize);\n        }\n    }",
          "path": "src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 101,
          "functionName": "connect",
          "diff": "@@ -1,24 +1,20 @@\n-    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+    public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n             throws IOException {\n         socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n                 ? new Socket(proxy)\n                 : new Socket();\n         socket.connect(inetSocketAddress, connectTimeout);\n         socket.setSoTimeout(readTimeout);\n         in \u003d socket.getInputStream();\n         out \u003d socket.getOutputStream();\n \n         if (address.sslSocketFactory !\u003d null) {\n-            upgradeToTls(tunnelConfig);\n+            upgradeToTls(tunnelRequest);\n         }\n \n-        /*\n-         * Buffer the socket stream to permit efficient parsing of HTTP headers\n-         * and chunk sizes. This also masks SSL InputStream\u0027s degenerate\n-         * available() implementation. That way we can read the end of a chunked\n-         * response without blocking and will recycle connections more reliably.\n-         * http://code.google.com/p/android/issues/detail?id\u003d38817\n-         */\n-        int bufferSize \u003d 128;\n-        in \u003d new BufferedInputStream(in, bufferSize);\n+        // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n+        if (!isSpdy()) {\n+            int bufferSize \u003d 128;\n+            in \u003d new BufferedInputStream(in, bufferSize);\n+        }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnection.java",
            "newPath": "src/main/java/com/squareup/okhttp/Connection.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012-12-24, 12:39 a.m.",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012-12-23, 4:38 p.m.",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n            throws IOException {\n        socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n                ? new Socket(proxy)\n                : new Socket();\n        socket.connect(inetSocketAddress, connectTimeout);\n        socket.setSoTimeout(readTimeout);\n        in \u003d socket.getInputStream();\n        out \u003d socket.getOutputStream();\n\n        if (address.sslSocketFactory !\u003d null) {\n            upgradeToTls(tunnelRequest);\n        }\n\n        // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n        if (!isSpdy()) {\n            int bufferSize \u003d 128;\n            in \u003d new BufferedInputStream(in, bufferSize);\n        }\n    }",
          "path": "src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 101,
          "functionName": "connect",
          "diff": "@@ -1,24 +1,20 @@\n-    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+    public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n             throws IOException {\n         socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n                 ? new Socket(proxy)\n                 : new Socket();\n         socket.connect(inetSocketAddress, connectTimeout);\n         socket.setSoTimeout(readTimeout);\n         in \u003d socket.getInputStream();\n         out \u003d socket.getOutputStream();\n \n         if (address.sslSocketFactory !\u003d null) {\n-            upgradeToTls(tunnelConfig);\n+            upgradeToTls(tunnelRequest);\n         }\n \n-        /*\n-         * Buffer the socket stream to permit efficient parsing of HTTP headers\n-         * and chunk sizes. This also masks SSL InputStream\u0027s degenerate\n-         * available() implementation. That way we can read the end of a chunked\n-         * response without blocking and will recycle connections more reliably.\n-         * http://code.google.com/p/android/issues/detail?id\u003d38817\n-         */\n-        int bufferSize \u003d 128;\n-        in \u003d new BufferedInputStream(in, bufferSize);\n+        // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n+        if (!isSpdy()) {\n+            int bufferSize \u003d 128;\n+            in \u003d new BufferedInputStream(in, bufferSize);\n+        }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012-12-24, 12:39 a.m.",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012-12-23, 4:38 p.m.",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n            throws IOException {\n        socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n                ? new Socket(proxy)\n                : new Socket();\n        socket.connect(inetSocketAddress, connectTimeout);\n        socket.setSoTimeout(readTimeout);\n        in \u003d socket.getInputStream();\n        out \u003d socket.getOutputStream();\n\n        if (address.sslSocketFactory !\u003d null) {\n            upgradeToTls(tunnelRequest);\n        }\n\n        // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n        if (!isSpdy()) {\n            int bufferSize \u003d 128;\n            in \u003d new BufferedInputStream(in, bufferSize);\n        }\n    }",
          "path": "src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 101,
          "functionName": "connect",
          "diff": "@@ -1,24 +1,20 @@\n-    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+    public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n             throws IOException {\n         socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n                 ? new Socket(proxy)\n                 : new Socket();\n         socket.connect(inetSocketAddress, connectTimeout);\n         socket.setSoTimeout(readTimeout);\n         in \u003d socket.getInputStream();\n         out \u003d socket.getOutputStream();\n \n         if (address.sslSocketFactory !\u003d null) {\n-            upgradeToTls(tunnelConfig);\n+            upgradeToTls(tunnelRequest);\n         }\n \n-        /*\n-         * Buffer the socket stream to permit efficient parsing of HTTP headers\n-         * and chunk sizes. This also masks SSL InputStream\u0027s degenerate\n-         * available() implementation. That way we can read the end of a chunked\n-         * response without blocking and will recycle connections more reliably.\n-         * http://code.google.com/p/android/issues/detail?id\u003d38817\n-         */\n-        int bufferSize \u003d 128;\n-        in \u003d new BufferedInputStream(in, bufferSize);\n+        // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n+        if (!isSpdy()) {\n+            int bufferSize \u003d 128;\n+            in \u003d new BufferedInputStream(in, bufferSize);\n+        }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, tunnelConfig-TunnelConfig]",
            "newValue": "[connectTimeout-int, readTimeout-int, tunnelRequest-TunnelRequest]"
          }
        }
      ]
    },
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": {
      "type": "Yfilerename",
      "commitMessage": "Move out of the libcore package.\n\nTo promote the code into AOSP, we\u0027ll keep this package as-is\nand do the jarjar in Android instead.\n",
      "commitDate": "2012-12-15, 4:55 p.m.",
      "commitName": "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012-12-15, 4:17 p.m.",
      "commitNameOld": "7f7aa90bc5d41d8f818fc988d2a91d22393c7329",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n            throws IOException {\n        socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n                ? new Socket(proxy)\n                : new Socket();\n        socket.connect(inetSocketAddress, connectTimeout);\n        socket.setSoTimeout(readTimeout);\n        in \u003d socket.getInputStream();\n        out \u003d socket.getOutputStream();\n\n        if (address.sslSocketFactory !\u003d null) {\n            upgradeToTls(tunnelConfig);\n        }\n\n        /*\n         * Buffer the socket stream to permit efficient parsing of HTTP headers\n         * and chunk sizes. This also masks SSL InputStream\u0027s degenerate\n         * available() implementation. That way we can read the end of a chunked\n         * response without blocking and will recycle connections more reliably.\n         * http://code.google.com/p/android/issues/detail?id\u003d38817\n         */\n        int bufferSize \u003d 128;\n        in \u003d new BufferedInputStream(in, bufferSize);\n    }",
      "path": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnection.java",
      "functionStartLine": 105,
      "functionName": "connect",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/libcore/net/http/HttpConnection.java",
        "newPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnection.java"
      }
    },
    "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
      "commitMessage": "New route selector to support multiple routes.\n",
      "commitDate": "2012-11-10, 4:05 p.m.",
      "commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "New route selector to support multiple routes.\n",
          "commitDate": "2012-11-10, 4:05 p.m.",
          "commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012-11-07, 5:18 p.m.",
          "commitNameOld": "e5b78cabad22ffdfbbe2755fece9c6c535438cdc",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 2.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n            throws IOException {\n        socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n                ? new Socket(proxy)\n                : new Socket();\n        socket.connect(inetSocketAddress, connectTimeout);\n        socket.setSoTimeout(readTimeout);\n        in \u003d socket.getInputStream();\n        out \u003d socket.getOutputStream();\n\n        if (address.sslSocketFactory !\u003d null) {\n            upgradeToTls(tunnelConfig);\n        }\n\n        /*\n         * Buffer the socket stream to permit efficient parsing of HTTP headers\n         * and chunk sizes. This also masks SSL InputStream\u0027s degenerate\n         * available() implementation. That way we can read the end of a chunked\n         * response without blocking and will recycle connections more reliably.\n         * http://code.google.com/p/android/issues/detail?id\u003d38817\n         */\n        int bufferSize \u003d 128;\n        in \u003d new BufferedInputStream(in, bufferSize);\n    }",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 104,
          "functionName": "connect",
          "diff": "@@ -1,8 +1,24 @@\n-    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n-            TunnelConfig tunnelConfig) throws IOException {\n-        HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n-                connectTimeout, tunnelConfig);\n-        result.socket.setSoTimeout(readTimeout);\n-        return result;\n+    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+            throws IOException {\n+        socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n+                ? new Socket(proxy)\n+                : new Socket();\n+        socket.connect(inetSocketAddress, connectTimeout);\n+        socket.setSoTimeout(readTimeout);\n+        in \u003d socket.getInputStream();\n+        out \u003d socket.getOutputStream();\n+\n+        if (address.sslSocketFactory !\u003d null) {\n+            upgradeToTls(tunnelConfig);\n+        }\n+\n+        /*\n+         * Buffer the socket stream to permit efficient parsing of HTTP headers\n+         * and chunk sizes. This also masks SSL InputStream\u0027s degenerate\n+         * available() implementation. That way we can read the end of a chunked\n+         * response without blocking and will recycle connections more reliably.\n+         * http://code.google.com/p/android/issues/detail?id\u003d38817\n+         */\n+        int bufferSize \u003d 128;\n+        in \u003d new BufferedInputStream(in, bufferSize);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, hostnameVerifier-HostnameVerifier, proxy-Proxy, connectTimeout-int, readTimeout-int, tunnelConfig-TunnelConfig]",
            "newValue": "[connectTimeout-int, readTimeout-int, tunnelConfig-TunnelConfig]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "New route selector to support multiple routes.\n",
          "commitDate": "2012-11-10, 4:05 p.m.",
          "commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012-11-07, 5:18 p.m.",
          "commitNameOld": "e5b78cabad22ffdfbbe2755fece9c6c535438cdc",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 2.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n            throws IOException {\n        socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n                ? new Socket(proxy)\n                : new Socket();\n        socket.connect(inetSocketAddress, connectTimeout);\n        socket.setSoTimeout(readTimeout);\n        in \u003d socket.getInputStream();\n        out \u003d socket.getOutputStream();\n\n        if (address.sslSocketFactory !\u003d null) {\n            upgradeToTls(tunnelConfig);\n        }\n\n        /*\n         * Buffer the socket stream to permit efficient parsing of HTTP headers\n         * and chunk sizes. This also masks SSL InputStream\u0027s degenerate\n         * available() implementation. That way we can read the end of a chunked\n         * response without blocking and will recycle connections more reliably.\n         * http://code.google.com/p/android/issues/detail?id\u003d38817\n         */\n        int bufferSize \u003d 128;\n        in \u003d new BufferedInputStream(in, bufferSize);\n    }",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 104,
          "functionName": "connect",
          "diff": "@@ -1,8 +1,24 @@\n-    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n-            TunnelConfig tunnelConfig) throws IOException {\n-        HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n-                connectTimeout, tunnelConfig);\n-        result.socket.setSoTimeout(readTimeout);\n-        return result;\n+    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+            throws IOException {\n+        socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n+                ? new Socket(proxy)\n+                : new Socket();\n+        socket.connect(inetSocketAddress, connectTimeout);\n+        socket.setSoTimeout(readTimeout);\n+        in \u003d socket.getInputStream();\n+        out \u003d socket.getOutputStream();\n+\n+        if (address.sslSocketFactory !\u003d null) {\n+            upgradeToTls(tunnelConfig);\n+        }\n+\n+        /*\n+         * Buffer the socket stream to permit efficient parsing of HTTP headers\n+         * and chunk sizes. This also masks SSL InputStream\u0027s degenerate\n+         * available() implementation. That way we can read the end of a chunked\n+         * response without blocking and will recycle connections more reliably.\n+         * http://code.google.com/p/android/issues/detail?id\u003d38817\n+         */\n+        int bufferSize \u003d 128;\n+        in \u003d new BufferedInputStream(in, bufferSize);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "HttpConnection",
            "newValue": "void"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "New route selector to support multiple routes.\n",
          "commitDate": "2012-11-10, 4:05 p.m.",
          "commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012-11-07, 5:18 p.m.",
          "commitNameOld": "e5b78cabad22ffdfbbe2755fece9c6c535438cdc",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 2.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n            throws IOException {\n        socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n                ? new Socket(proxy)\n                : new Socket();\n        socket.connect(inetSocketAddress, connectTimeout);\n        socket.setSoTimeout(readTimeout);\n        in \u003d socket.getInputStream();\n        out \u003d socket.getOutputStream();\n\n        if (address.sslSocketFactory !\u003d null) {\n            upgradeToTls(tunnelConfig);\n        }\n\n        /*\n         * Buffer the socket stream to permit efficient parsing of HTTP headers\n         * and chunk sizes. This also masks SSL InputStream\u0027s degenerate\n         * available() implementation. That way we can read the end of a chunked\n         * response without blocking and will recycle connections more reliably.\n         * http://code.google.com/p/android/issues/detail?id\u003d38817\n         */\n        int bufferSize \u003d 128;\n        in \u003d new BufferedInputStream(in, bufferSize);\n    }",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 104,
          "functionName": "connect",
          "diff": "@@ -1,8 +1,24 @@\n-    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n-            TunnelConfig tunnelConfig) throws IOException {\n-        HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n-                connectTimeout, tunnelConfig);\n-        result.socket.setSoTimeout(readTimeout);\n-        return result;\n+    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+            throws IOException {\n+        socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n+                ? new Socket(proxy)\n+                : new Socket();\n+        socket.connect(inetSocketAddress, connectTimeout);\n+        socket.setSoTimeout(readTimeout);\n+        in \u003d socket.getInputStream();\n+        out \u003d socket.getOutputStream();\n+\n+        if (address.sslSocketFactory !\u003d null) {\n+            upgradeToTls(tunnelConfig);\n+        }\n+\n+        /*\n+         * Buffer the socket stream to permit efficient parsing of HTTP headers\n+         * and chunk sizes. This also masks SSL InputStream\u0027s degenerate\n+         * available() implementation. That way we can read the end of a chunked\n+         * response without blocking and will recycle connections more reliably.\n+         * http://code.google.com/p/android/issues/detail?id\u003d38817\n+         */\n+        int bufferSize \u003d 128;\n+        in \u003d new BufferedInputStream(in, bufferSize);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public, static]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "New route selector to support multiple routes.\n",
          "commitDate": "2012-11-10, 4:05 p.m.",
          "commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012-11-07, 5:18 p.m.",
          "commitNameOld": "e5b78cabad22ffdfbbe2755fece9c6c535438cdc",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 2.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n            throws IOException {\n        socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n                ? new Socket(proxy)\n                : new Socket();\n        socket.connect(inetSocketAddress, connectTimeout);\n        socket.setSoTimeout(readTimeout);\n        in \u003d socket.getInputStream();\n        out \u003d socket.getOutputStream();\n\n        if (address.sslSocketFactory !\u003d null) {\n            upgradeToTls(tunnelConfig);\n        }\n\n        /*\n         * Buffer the socket stream to permit efficient parsing of HTTP headers\n         * and chunk sizes. This also masks SSL InputStream\u0027s degenerate\n         * available() implementation. That way we can read the end of a chunked\n         * response without blocking and will recycle connections more reliably.\n         * http://code.google.com/p/android/issues/detail?id\u003d38817\n         */\n        int bufferSize \u003d 128;\n        in \u003d new BufferedInputStream(in, bufferSize);\n    }",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 104,
          "functionName": "connect",
          "diff": "@@ -1,8 +1,24 @@\n-    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n-            TunnelConfig tunnelConfig) throws IOException {\n-        HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n-                connectTimeout, tunnelConfig);\n-        result.socket.setSoTimeout(readTimeout);\n-        return result;\n+    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+            throws IOException {\n+        socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP)\n+                ? new Socket(proxy)\n+                : new Socket();\n+        socket.connect(inetSocketAddress, connectTimeout);\n+        socket.setSoTimeout(readTimeout);\n+        in \u003d socket.getInputStream();\n+        out \u003d socket.getOutputStream();\n+\n+        if (address.sslSocketFactory !\u003d null) {\n+            upgradeToTls(tunnelConfig);\n+        }\n+\n+        /*\n+         * Buffer the socket stream to permit efficient parsing of HTTP headers\n+         * and chunk sizes. This also masks SSL InputStream\u0027s degenerate\n+         * available() implementation. That way we can read the end of a chunked\n+         * response without blocking and will recycle connections more reliably.\n+         * http://code.google.com/p/android/issues/detail?id\u003d38817\n+         */\n+        int bufferSize \u003d 128;\n+        in \u003d new BufferedInputStream(in, bufferSize);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "40ff76547064c3fb5acb9047a6f679dd4379a4d0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
      "commitDate": "2012-11-05, 11:25 p.m.",
      "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
          "commitDate": "2012-11-05, 11:25 p.m.",
          "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012-10-25, 12:03 p.m.",
          "commitNameOld": "2f5e25e4dcac2f7d62a4ac5ee8d49e92de005866",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 11.52,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n            TunnelConfig tunnelConfig) throws IOException {\n        HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n                connectTimeout, tunnelConfig);\n        result.socket.setSoTimeout(readTimeout);\n        return result;\n    }",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 89,
          "functionName": "connect",
          "diff": "@@ -1,40 +1,8 @@\n     public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            Proxy proxy, int connectTimeout) throws IOException {\n-        /*\n-         * Try an explicitly-specified proxy.\n-         */\n-        if (proxy !\u003d null) {\n-            Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT)\n-                    ? new Address(uri, sslSocketFactory)\n-                    : new Address(uri, sslSocketFactory, proxy);\n-            return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n-        }\n-\n-        /*\n-         * Try connecting to each of the proxies provided by the ProxySelector\n-         * until a connection succeeds.\n-         */\n-        ProxySelector selector \u003d ProxySelector.getDefault();\n-        List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n-        if (proxyList !\u003d null) {\n-            for (Proxy selectedProxy : proxyList) {\n-                if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n-                    // the same as NO_PROXY\n-                    // TODO: if the selector recommends a direct connection, attempt that?\n-                    continue;\n-                }\n-                try {\n-                    Address address \u003d new Address(uri, sslSocketFactory, selectedProxy);\n-                    return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n-                } catch (IOException e) {\n-                    // failed to connect, tell it to the selector\n-                    selector.connectFailed(uri, selectedProxy.address(), e);\n-                }\n-            }\n-        }\n-\n-        /*\n-         * Try a direct connection. If this fails, this method will throw.\n-         */\n-        return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n+            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n+            TunnelConfig tunnelConfig) throws IOException {\n+        HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n+                connectTimeout, tunnelConfig);\n+        result.socket.setSoTimeout(readTimeout);\n+        return result;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, proxy-Proxy, connectTimeout-int]",
            "newValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, hostnameVerifier-HostnameVerifier, proxy-Proxy, connectTimeout-int, readTimeout-int, tunnelConfig-TunnelConfig]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
          "commitDate": "2012-11-05, 11:25 p.m.",
          "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012-10-25, 12:03 p.m.",
          "commitNameOld": "2f5e25e4dcac2f7d62a4ac5ee8d49e92de005866",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 11.52,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n            TunnelConfig tunnelConfig) throws IOException {\n        HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n                connectTimeout, tunnelConfig);\n        result.socket.setSoTimeout(readTimeout);\n        return result;\n    }",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 89,
          "functionName": "connect",
          "diff": "@@ -1,40 +1,8 @@\n     public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            Proxy proxy, int connectTimeout) throws IOException {\n-        /*\n-         * Try an explicitly-specified proxy.\n-         */\n-        if (proxy !\u003d null) {\n-            Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT)\n-                    ? new Address(uri, sslSocketFactory)\n-                    : new Address(uri, sslSocketFactory, proxy);\n-            return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n-        }\n-\n-        /*\n-         * Try connecting to each of the proxies provided by the ProxySelector\n-         * until a connection succeeds.\n-         */\n-        ProxySelector selector \u003d ProxySelector.getDefault();\n-        List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n-        if (proxyList !\u003d null) {\n-            for (Proxy selectedProxy : proxyList) {\n-                if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n-                    // the same as NO_PROXY\n-                    // TODO: if the selector recommends a direct connection, attempt that?\n-                    continue;\n-                }\n-                try {\n-                    Address address \u003d new Address(uri, sslSocketFactory, selectedProxy);\n-                    return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n-                } catch (IOException e) {\n-                    // failed to connect, tell it to the selector\n-                    selector.connectFailed(uri, selectedProxy.address(), e);\n-                }\n-            }\n-        }\n-\n-        /*\n-         * Try a direct connection. If this fails, this method will throw.\n-         */\n-        return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n+            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n+            TunnelConfig tunnelConfig) throws IOException {\n+        HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n+                connectTimeout, tunnelConfig);\n+        result.socket.setSoTimeout(readTimeout);\n+        return result;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "5aa2456a145883f6688c6ee325635ed0c6339076": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Fix TLS requiresTunnel which was being computed incorrectly.\n\nWe were only returning \u0027true\u0027 once we were already in a tunnel.\nThis was bogus. In theory a TLS tunnel sending extra data could\nbe corrupted due to this bug.\n\nAlso migrate one of the TLS tunnel tests to use SslContextBuilder\ninstead of TestSSLContext.\n",
      "commitDate": "2012-09-20, 4:01 p.m.",
      "commitName": "5aa2456a145883f6688c6ee325635ed0c6339076",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fix TLS requiresTunnel which was being computed incorrectly.\n\nWe were only returning \u0027true\u0027 once we were already in a tunnel.\nThis was bogus. In theory a TLS tunnel sending extra data could\nbe corrupted due to this bug.\n\nAlso migrate one of the TLS tunnel tests to use SslContextBuilder\ninstead of TestSSLContext.\n",
          "commitDate": "2012-09-20, 4:01 p.m.",
          "commitName": "5aa2456a145883f6688c6ee325635ed0c6339076",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012-09-19, 3:48 p.m.",
          "commitNameOld": "faeff7f10548151cb2310351b3975f719037f217",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.01,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n            Proxy proxy, int connectTimeout) throws IOException {\n        /*\n         * Try an explicitly-specified proxy.\n         */\n        if (proxy !\u003d null) {\n            Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT)\n                    ? new Address(uri, sslSocketFactory)\n                    : new Address(uri, sslSocketFactory, proxy);\n            return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n        }\n\n        /*\n         * Try connecting to each of the proxies provided by the ProxySelector\n         * until a connection succeeds.\n         */\n        ProxySelector selector \u003d ProxySelector.getDefault();\n        List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n        if (proxyList !\u003d null) {\n            for (Proxy selectedProxy : proxyList) {\n                if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n                    // the same as NO_PROXY\n                    // TODO: if the selector recommends a direct connection, attempt that?\n                    continue;\n                }\n                try {\n                    Address address \u003d new Address(uri, sslSocketFactory, selectedProxy);\n                    return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n                } catch (IOException e) {\n                    // failed to connect, tell it to the selector\n                    selector.connectFailed(uri, selectedProxy.address(), e);\n                }\n            }\n        }\n\n        /*\n         * Try a direct connection. If this fails, this method will throw.\n         */\n        return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n    }",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 125,
          "functionName": "connect",
          "diff": "@@ -1,41 +1,40 @@\n     public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            Proxy proxy, boolean requiresTunnel, int connectTimeout) throws IOException {\n+            Proxy proxy, int connectTimeout) throws IOException {\n         /*\n          * Try an explicitly-specified proxy.\n          */\n         if (proxy !\u003d null) {\n             Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT)\n                     ? new Address(uri, sslSocketFactory)\n-                    : new Address(uri, sslSocketFactory, proxy, requiresTunnel);\n+                    : new Address(uri, sslSocketFactory, proxy);\n             return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n         }\n \n         /*\n          * Try connecting to each of the proxies provided by the ProxySelector\n          * until a connection succeeds.\n          */\n         ProxySelector selector \u003d ProxySelector.getDefault();\n         List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n         if (proxyList !\u003d null) {\n             for (Proxy selectedProxy : proxyList) {\n                 if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n                     // the same as NO_PROXY\n                     // TODO: if the selector recommends a direct connection, attempt that?\n                     continue;\n                 }\n                 try {\n-                    Address address \u003d new Address(uri, sslSocketFactory,\n-                            selectedProxy, requiresTunnel);\n+                    Address address \u003d new Address(uri, sslSocketFactory, selectedProxy);\n                     return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n                 } catch (IOException e) {\n                     // failed to connect, tell it to the selector\n                     selector.connectFailed(uri, selectedProxy.address(), e);\n                 }\n             }\n         }\n \n         /*\n          * Try a direct connection. If this fails, this method will throw.\n          */\n         return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, proxy-Proxy, requiresTunnel-boolean, connectTimeout-int]",
            "newValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, proxy-Proxy, connectTimeout-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fix TLS requiresTunnel which was being computed incorrectly.\n\nWe were only returning \u0027true\u0027 once we were already in a tunnel.\nThis was bogus. In theory a TLS tunnel sending extra data could\nbe corrupted due to this bug.\n\nAlso migrate one of the TLS tunnel tests to use SslContextBuilder\ninstead of TestSSLContext.\n",
          "commitDate": "2012-09-20, 4:01 p.m.",
          "commitName": "5aa2456a145883f6688c6ee325635ed0c6339076",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012-09-19, 3:48 p.m.",
          "commitNameOld": "faeff7f10548151cb2310351b3975f719037f217",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.01,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n            Proxy proxy, int connectTimeout) throws IOException {\n        /*\n         * Try an explicitly-specified proxy.\n         */\n        if (proxy !\u003d null) {\n            Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT)\n                    ? new Address(uri, sslSocketFactory)\n                    : new Address(uri, sslSocketFactory, proxy);\n            return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n        }\n\n        /*\n         * Try connecting to each of the proxies provided by the ProxySelector\n         * until a connection succeeds.\n         */\n        ProxySelector selector \u003d ProxySelector.getDefault();\n        List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n        if (proxyList !\u003d null) {\n            for (Proxy selectedProxy : proxyList) {\n                if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n                    // the same as NO_PROXY\n                    // TODO: if the selector recommends a direct connection, attempt that?\n                    continue;\n                }\n                try {\n                    Address address \u003d new Address(uri, sslSocketFactory, selectedProxy);\n                    return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n                } catch (IOException e) {\n                    // failed to connect, tell it to the selector\n                    selector.connectFailed(uri, selectedProxy.address(), e);\n                }\n            }\n        }\n\n        /*\n         * Try a direct connection. If this fails, this method will throw.\n         */\n        return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n    }",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 125,
          "functionName": "connect",
          "diff": "@@ -1,41 +1,40 @@\n     public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            Proxy proxy, boolean requiresTunnel, int connectTimeout) throws IOException {\n+            Proxy proxy, int connectTimeout) throws IOException {\n         /*\n          * Try an explicitly-specified proxy.\n          */\n         if (proxy !\u003d null) {\n             Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT)\n                     ? new Address(uri, sslSocketFactory)\n-                    : new Address(uri, sslSocketFactory, proxy, requiresTunnel);\n+                    : new Address(uri, sslSocketFactory, proxy);\n             return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n         }\n \n         /*\n          * Try connecting to each of the proxies provided by the ProxySelector\n          * until a connection succeeds.\n          */\n         ProxySelector selector \u003d ProxySelector.getDefault();\n         List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n         if (proxyList !\u003d null) {\n             for (Proxy selectedProxy : proxyList) {\n                 if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n                     // the same as NO_PROXY\n                     // TODO: if the selector recommends a direct connection, attempt that?\n                     continue;\n                 }\n                 try {\n-                    Address address \u003d new Address(uri, sslSocketFactory,\n-                            selectedProxy, requiresTunnel);\n+                    Address address \u003d new Address(uri, sslSocketFactory, selectedProxy);\n                     return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n                 } catch (IOException e) {\n                     // failed to connect, tell it to the selector\n                     selector.connectFailed(uri, selectedProxy.address(), e);\n                 }\n             }\n         }\n \n         /*\n          * Try a direct connection. If this fails, this method will throw.\n          */\n         return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": {
      "type": "Yintroduced",
      "commitMessage": "Initial import.\n\nThis is a fork of okhttp from http://code.google.com/p/okhttp.\nI\u0027m moving it to Github since that\u0027s where my code reviewers\nare. I\u0027ve renamed the core package from com.google.okhttp to\ncom.squareup.okhttp because Square is where I expect ongoing\ndevelopment of this project to take place.\n\nAll code in this project is subject to be contributed upstream\nto AOSP. In particular, all code in the libcore package is\nderived from AOSP and intended to be contributed back to AOSP\non an ongoing basis.\n",
      "commitDate": "2012-07-23, 10:02 a.m.",
      "commitName": "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,41 @@\n+    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n+            Proxy proxy, boolean requiresTunnel, int connectTimeout) throws IOException {\n+        /*\n+         * Try an explicitly-specified proxy.\n+         */\n+        if (proxy !\u003d null) {\n+            Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT)\n+                    ? new Address(uri, sslSocketFactory)\n+                    : new Address(uri, sslSocketFactory, proxy, requiresTunnel);\n+            return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n+        }\n+\n+        /*\n+         * Try connecting to each of the proxies provided by the ProxySelector\n+         * until a connection succeeds.\n+         */\n+        ProxySelector selector \u003d ProxySelector.getDefault();\n+        List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n+        if (proxyList !\u003d null) {\n+            for (Proxy selectedProxy : proxyList) {\n+                if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n+                    // the same as NO_PROXY\n+                    // TODO: if the selector recommends a direct connection, attempt that?\n+                    continue;\n+                }\n+                try {\n+                    Address address \u003d new Address(uri, sslSocketFactory,\n+                            selectedProxy, requiresTunnel);\n+                    return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n+                } catch (IOException e) {\n+                    // failed to connect, tell it to the selector\n+                    selector.connectFailed(uri, selectedProxy.address(), e);\n+                }\n+            }\n+        }\n+\n+        /*\n+         * Try a direct connection. If this fails, this method will throw.\n+         */\n+        return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n            Proxy proxy, boolean requiresTunnel, int connectTimeout) throws IOException {\n        /*\n         * Try an explicitly-specified proxy.\n         */\n        if (proxy !\u003d null) {\n            Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT)\n                    ? new Address(uri, sslSocketFactory)\n                    : new Address(uri, sslSocketFactory, proxy, requiresTunnel);\n            return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n        }\n\n        /*\n         * Try connecting to each of the proxies provided by the ProxySelector\n         * until a connection succeeds.\n         */\n        ProxySelector selector \u003d ProxySelector.getDefault();\n        List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n        if (proxyList !\u003d null) {\n            for (Proxy selectedProxy : proxyList) {\n                if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n                    // the same as NO_PROXY\n                    // TODO: if the selector recommends a direct connection, attempt that?\n                    continue;\n                }\n                try {\n                    Address address \u003d new Address(uri, sslSocketFactory,\n                            selectedProxy, requiresTunnel);\n                    return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n                } catch (IOException e) {\n                    // failed to connect, tell it to the selector\n                    selector.connectFailed(uri, selectedProxy.address(), e);\n                }\n            }\n        }\n\n        /*\n         * Try a direct connection. If this fails, this method will throw.\n         */\n        return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n    }",
      "path": "src/main/java/libcore/net/http/HttpConnection.java",
      "functionStartLine": 126,
      "functionName": "connect"
    }
  }
}