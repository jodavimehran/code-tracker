{
  "origin": "codeshovel",
  "repositoryName": "okhttp",
  "repositoryPath": "H:\\Projects\\square\\okhttp/.git",
  "startCommitName": "5224f3045ba9b171fce521777edf389f9206173c",
  "sourceFileName": "Http2Connection.java",
  "functionName": "headers",
  "functionId": "$headers___inFinished-boolean__streamId-int__associatedStreamId-int__headerBlock-List__Header__",
  "sourceFilePath": "okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java",
  "functionStartLine": 644,
  "functionEndLine": 689,
  "numCommitsSeen": 210,
  "timeTaken": 5549,
  "changeHistory": [
    "abb0a790802996d1039c35424b70b0f3f06b94b7",
    "cd22113332cdeeedac8d6bda3297194f983b4aaf",
    "3931dc8df0c57c7f50d23f8de532da0a51434f26",
    "3d43a8dba89ccd7333c3ebcf74928e441790d943",
    "0c04821a25c83fddebb29e8cd590609142ba20a2",
    "4f24a30c12032b7033884a630696014afd3e77cb",
    "2dade17682071a3e1d60df4113795117e5c1833c",
    "c9a89876de476983f273edbf108c365127c18c5e",
    "38aaf7bca6d998d0d1a1839d2b8816735f9b8914",
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
    "8fe27a50c2c88d382e6dc6600836bcc57fc7b0cf",
    "fb155c47661ede5da395dfb4e620867263b8c8e7",
    "f78f74f5a2cf1f73f974487816f998a6e37a9cf1",
    "cc38140be4c7e41330cf7749c3eeba23c85f9522",
    "a5ba3e9062f3bde4bb6896f1db433a2408119e94",
    "110a4fac4257fe2df0e23149fbef76e750604cf4",
    "358169b89f32c00bf229b4e42ccef756588da71f",
    "d4508141fc9fa1b816c5a1ff3f39149d4dfb22de",
    "f214cf9670339b850f97da4a2d4ad64758fd0e4d",
    "b95a0ccbcae50f92acc923d62fc6c9cecc6bbb63",
    "ef30f7efc61ac249c1a8b43e41dba03a2bf0bef8",
    "749a65b776c8fc4b39b6463695980275da34da51",
    "5c787a0b9d5c83c764880da4b1503a65ee0ff267",
    "a91124b6d4e2eb1bb3c71a7a8ddff7d40b7db55a",
    "2f31d7122d8806b6c32d2d1e181ca635fb80bba7",
    "3c0faa9ca18de3be0a178e590086888f4f89612a",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3",
    "b9580d68e9bc34eef397e9bc7f13091f1e3f1528",
    "689f66222bd8984dd69229a4ee9caf8da528ae12",
    "7a28500a72d6914c6be7d9d8ee47d23f92f35d64"
  ],
  "changeHistoryShort": {
    "abb0a790802996d1039c35424b70b0f3f06b94b7": "Ybodychange",
    "cd22113332cdeeedac8d6bda3297194f983b4aaf": "Ybodychange",
    "3931dc8df0c57c7f50d23f8de532da0a51434f26": "Ybodychange",
    "3d43a8dba89ccd7333c3ebcf74928e441790d943": "Ymultichange(Yfilerename,Ybodychange)",
    "0c04821a25c83fddebb29e8cd590609142ba20a2": "Ymultichange(Yparameterchange,Ybodychange)",
    "4f24a30c12032b7033884a630696014afd3e77cb": "Ybodychange",
    "2dade17682071a3e1d60df4113795117e5c1833c": "Ybodychange",
    "c9a89876de476983f273edbf108c365127c18c5e": "Yfilerename",
    "38aaf7bca6d998d0d1a1839d2b8816735f9b8914": "Ybodychange",
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80": "Ymultichange(Yfilerename,Ybodychange)",
    "8fe27a50c2c88d382e6dc6600836bcc57fc7b0cf": "Ybodychange",
    "fb155c47661ede5da395dfb4e620867263b8c8e7": "Ybodychange",
    "f78f74f5a2cf1f73f974487816f998a6e37a9cf1": "Ybodychange",
    "cc38140be4c7e41330cf7749c3eeba23c85f9522": "Ymultichange(Yparameterchange,Ybodychange)",
    "a5ba3e9062f3bde4bb6896f1db433a2408119e94": "Ybodychange",
    "110a4fac4257fe2df0e23149fbef76e750604cf4": "Yfilerename",
    "358169b89f32c00bf229b4e42ccef756588da71f": "Ybodychange",
    "d4508141fc9fa1b816c5a1ff3f39149d4dfb22de": "Ybodychange",
    "f214cf9670339b850f97da4a2d4ad64758fd0e4d": "Ymultichange(Yparameterchange,Ybodychange)",
    "b95a0ccbcae50f92acc923d62fc6c9cecc6bbb63": "Yparameterchange",
    "ef30f7efc61ac249c1a8b43e41dba03a2bf0bef8": "Ybodychange",
    "749a65b776c8fc4b39b6463695980275da34da51": "Ybodychange",
    "5c787a0b9d5c83c764880da4b1503a65ee0ff267": "Yparameterchange",
    "a91124b6d4e2eb1bb3c71a7a8ddff7d40b7db55a": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "2f31d7122d8806b6c32d2d1e181ca635fb80bba7": "Yparameterchange",
    "3c0faa9ca18de3be0a178e590086888f4f89612a": "Yfilerename",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": "Yfilerename",
    "b9580d68e9bc34eef397e9bc7f13091f1e3f1528": "Ybodychange",
    "689f66222bd8984dd69229a4ee9caf8da528ae12": "Yfilerename",
    "7a28500a72d6914c6be7d9d8ee47d23f92f35d64": "Yintroduced"
  },
  "changeHistoryDetails": {
    "abb0a790802996d1039c35424b70b0f3f06b94b7": {
      "type": "Ybodychange",
      "commitMessage": "First step towards HTTP/2 automatic pings. (#3874)\n\nThis changes the executor services in HTTP/2 connection to split up\r\nlistener executors (of which there may be many threads) from writer\r\nexecutors (of which there is one per connection).\r\n\r\nThis adds a scheduled executor job to send pings on an interval. We\r\ndon\u0027t yet fail the connection if pongs are not received.\r\n\r\nFor follow-up there\u0027s some work to remove exising APIs to send pings\r\nthrough the HTTP/2 APIs. These are unused and make it awkard to\r\nconfirm that only the automatic pings are being replied to.\r\n\r\nSee https://github.com/square/okhttp/issues/3261",
      "commitDate": "2018-02-21, 8:17 p.m.",
      "commitName": "abb0a790802996d1039c35424b70b0f3f06b94b7",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2018-02-19, 6:04 p.m.",
      "commitNameOld": "64df3922164136ac4587df235222d564b016ce25",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 2.09,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n        List\u003cHeader\u003e headerBlock) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      Http2Stream stream;\n      synchronized (Http2Connection.this) {\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // If we\u0027re shutdown, don\u0027t bother with this stream.\n          if (shutdown) return;\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final Http2Stream newStream \u003d new Http2Stream(streamId, Http2Connection.this,\n              false, inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          listenerExecutor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n            @Override public void execute() {\n              try {\n                listener.onStream(newStream);\n              } catch (IOException e) {\n                Platform.get().log(INFO, \"Http2Connection.Listener failure for \" + hostname, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java",
      "functionStartLine": 648,
      "functionName": "headers",
      "diff": "@@ -1,46 +1,46 @@\n     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n         List\u003cHeader\u003e headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       Http2Stream stream;\n       synchronized (Http2Connection.this) {\n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // If we\u0027re shutdown, don\u0027t bother with this stream.\n           if (shutdown) return;\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final Http2Stream newStream \u003d new Http2Stream(streamId, Http2Connection.this,\n               false, inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n-          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n+          listenerExecutor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n                 Platform.get().log(INFO, \"Http2Connection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cd22113332cdeeedac8d6bda3297194f983b4aaf": {
      "type": "Ybodychange",
      "commitMessage": "Fix occasional hang with http2 goaway frames\n\nHttp2Connection was dropping headers of healthy streams\nafter GOAWAY frame.\n\nFixes #3422\n\nSigned-off-by: Igor Fedorenko \u003cifedorenko@salesforce.com\u003e\n",
      "commitDate": "2017-08-14, 10:43 a.m.",
      "commitName": "cd22113332cdeeedac8d6bda3297194f983b4aaf",
      "commitAuthor": "Igor Fedorenko",
      "commitDateOld": "2017-06-20, 9:14 a.m.",
      "commitNameOld": "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
      "commitAuthorOld": "Dave Roberge",
      "daysBetweenCommits": 55.06,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n        List\u003cHeader\u003e headerBlock) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      Http2Stream stream;\n      synchronized (Http2Connection.this) {\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // If we\u0027re shutdown, don\u0027t bother with this stream.\n          if (shutdown) return;\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final Http2Stream newStream \u003d new Http2Stream(streamId, Http2Connection.this,\n              false, inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n            @Override public void execute() {\n              try {\n                listener.onStream(newStream);\n              } catch (IOException e) {\n                Platform.get().log(INFO, \"Http2Connection.Listener failure for \" + hostname, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java",
      "functionStartLine": 600,
      "functionName": "headers",
      "diff": "@@ -1,46 +1,46 @@\n     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n         List\u003cHeader\u003e headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       Http2Stream stream;\n       synchronized (Http2Connection.this) {\n-        // If we\u0027re shutdown, don\u0027t bother with this stream.\n-        if (shutdown) return;\n-\n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n+          // If we\u0027re shutdown, don\u0027t bother with this stream.\n+          if (shutdown) return;\n+\n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final Http2Stream newStream \u003d new Http2Stream(streamId, Http2Connection.this,\n               false, inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n                 Platform.get().log(INFO, \"Http2Connection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3931dc8df0c57c7f50d23f8de532da0a51434f26": {
      "type": "Ybodychange",
      "commitMessage": "Fix some classnames to use Http2 instead of Framed\n",
      "commitDate": "2017-01-29, 12:09 p.m.",
      "commitName": "3931dc8df0c57c7f50d23f8de532da0a51434f26",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-12-26, 8:24 p.m.",
      "commitNameOld": "a589b8170333476233d48476587a1d4363c90bd0",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 33.66,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n        List\u003cHeader\u003e headerBlock) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      Http2Stream stream;\n      synchronized (Http2Connection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final Http2Stream newStream \u003d new Http2Stream(streamId, Http2Connection.this,\n              false, inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n            @Override public void execute() {\n              try {\n                listener.onStream(newStream);\n              } catch (IOException e) {\n                Platform.get().log(INFO, \"Http2Connection.Listener failure for \" + hostname, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java",
      "functionStartLine": 600,
      "functionName": "headers",
      "diff": "@@ -1,46 +1,46 @@\n     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n         List\u003cHeader\u003e headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       Http2Stream stream;\n       synchronized (Http2Connection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final Http2Stream newStream \u003d new Http2Stream(streamId, Http2Connection.this,\n               false, inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n-                Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n+                Platform.get().log(INFO, \"Http2Connection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3d43a8dba89ccd7333c3ebcf74928e441790d943": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "Rename FramedConnection to Http2Connection.\n\nAlso rename HttpStream to HttpCodec. This is the interface implemented\nfor both HTTP/1.1 and HTTP/2. The HTTP/2 codec creates a stream when\nit is used.\n",
      "commitDate": "2016-07-09, 6:09 p.m.",
      "commitName": "3d43a8dba89ccd7333c3ebcf74928e441790d943",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "Rename FramedConnection to Http2Connection.\n\nAlso rename HttpStream to HttpCodec. This is the interface implemented\nfor both HTTP/1.1 and HTTP/2. The HTTP/2 codec creates a stream when\nit is used.\n",
          "commitDate": "2016-07-09, 6:09 p.m.",
          "commitName": "3d43a8dba89ccd7333c3ebcf74928e441790d943",
          "commitAuthor": "jwilson",
          "commitDateOld": "2016-07-09, 5:27 p.m.",
          "commitNameOld": "33660bf58babd09521d19ef0ed1b09c15a5e27bb",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n        List\u003cHeader\u003e headerBlock) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      Http2Stream stream;\n      synchronized (Http2Connection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final Http2Stream newStream \u003d new Http2Stream(streamId, Http2Connection.this,\n              false, inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n            @Override public void execute() {\n              try {\n                listener.onStream(newStream);\n              } catch (IOException e) {\n                Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock);\n      if (inFinished) stream.receiveFin();\n    }",
          "path": "okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java",
          "functionStartLine": 597,
          "functionName": "headers",
          "diff": "@@ -1,46 +1,46 @@\n     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n         List\u003cHeader\u003e headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n-      FramedStream stream;\n-      synchronized (FramedConnection.this) {\n+      Http2Stream stream;\n+      synchronized (Http2Connection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n-          final FramedStream newStream \u003d new FramedStream(streamId, FramedConnection.this,\n+          final Http2Stream newStream \u003d new Http2Stream(streamId, Http2Connection.this,\n               false, inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n                 Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java",
            "newPath": "okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Rename FramedConnection to Http2Connection.\n\nAlso rename HttpStream to HttpCodec. This is the interface implemented\nfor both HTTP/1.1 and HTTP/2. The HTTP/2 codec creates a stream when\nit is used.\n",
          "commitDate": "2016-07-09, 6:09 p.m.",
          "commitName": "3d43a8dba89ccd7333c3ebcf74928e441790d943",
          "commitAuthor": "jwilson",
          "commitDateOld": "2016-07-09, 5:27 p.m.",
          "commitNameOld": "33660bf58babd09521d19ef0ed1b09c15a5e27bb",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n        List\u003cHeader\u003e headerBlock) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      Http2Stream stream;\n      synchronized (Http2Connection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final Http2Stream newStream \u003d new Http2Stream(streamId, Http2Connection.this,\n              false, inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n            @Override public void execute() {\n              try {\n                listener.onStream(newStream);\n              } catch (IOException e) {\n                Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock);\n      if (inFinished) stream.receiveFin();\n    }",
          "path": "okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java",
          "functionStartLine": 597,
          "functionName": "headers",
          "diff": "@@ -1,46 +1,46 @@\n     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n         List\u003cHeader\u003e headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n-      FramedStream stream;\n-      synchronized (FramedConnection.this) {\n+      Http2Stream stream;\n+      synchronized (Http2Connection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n-          final FramedStream newStream \u003d new FramedStream(streamId, FramedConnection.this,\n+          final Http2Stream newStream \u003d new Http2Stream(streamId, Http2Connection.this,\n               false, inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n                 Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "0c04821a25c83fddebb29e8cd590609142ba20a2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Drop support for SPDY/3.\n\nIt\u0027s redundant with HTTP/2.\n",
      "commitDate": "2016-07-09, 5:19 p.m.",
      "commitName": "0c04821a25c83fddebb29e8cd590609142ba20a2",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Drop support for SPDY/3.\n\nIt\u0027s redundant with HTTP/2.\n",
          "commitDate": "2016-07-09, 5:19 p.m.",
          "commitName": "0c04821a25c83fddebb29e8cd590609142ba20a2",
          "commitAuthor": "jwilson",
          "commitDateOld": "2016-07-06, 10:02 p.m.",
          "commitNameOld": "1267cb958c507f123ab135cac638768009dc84b5",
          "commitAuthorOld": "Dave Roberge",
          "daysBetweenCommits": 2.8,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n        List\u003cHeader\u003e headerBlock) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      FramedStream stream;\n      synchronized (FramedConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final FramedStream newStream \u003d new FramedStream(streamId, FramedConnection.this,\n              false, inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n            @Override public void execute() {\n              try {\n                listener.onStream(newStream);\n              } catch (IOException e) {\n                Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock);\n      if (inFinished) stream.receiveFin();\n    }",
          "path": "okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java",
          "functionStartLine": 597,
          "functionName": "headers",
          "diff": "@@ -1,60 +1,46 @@\n-    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n+    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n+        List\u003cHeader\u003e headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       FramedStream stream;\n       synchronized (FramedConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n-          // The headers claim to be for an existing stream, but we don\u0027t have one.\n-          if (headersMode.failIfStreamAbsent()) {\n-            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n-            return;\n-          }\n-\n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n-          final FramedStream\n-              newStream \u003d new FramedStream(streamId, FramedConnection.this, outFinished,\n-              inFinished, headerBlock);\n+          final FramedStream newStream \u003d new FramedStream(streamId, FramedConnection.this,\n+              false, inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n                 Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n-      // The headers claim to be for a new stream, but we already have one.\n-      if (headersMode.failIfStreamPresent()) {\n-        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n-        removeStream(streamId);\n-        return;\n-      }\n-\n       // Update an existing stream.\n-      stream.receiveHeaders(headerBlock, headersMode);\n+      stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, headerBlock-List\u003cHeader\u003e, headersMode-HeadersMode]",
            "newValue": "[inFinished-boolean, streamId-int, associatedStreamId-int, headerBlock-List\u003cHeader\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Drop support for SPDY/3.\n\nIt\u0027s redundant with HTTP/2.\n",
          "commitDate": "2016-07-09, 5:19 p.m.",
          "commitName": "0c04821a25c83fddebb29e8cd590609142ba20a2",
          "commitAuthor": "jwilson",
          "commitDateOld": "2016-07-06, 10:02 p.m.",
          "commitNameOld": "1267cb958c507f123ab135cac638768009dc84b5",
          "commitAuthorOld": "Dave Roberge",
          "daysBetweenCommits": 2.8,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n        List\u003cHeader\u003e headerBlock) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      FramedStream stream;\n      synchronized (FramedConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final FramedStream newStream \u003d new FramedStream(streamId, FramedConnection.this,\n              false, inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n            @Override public void execute() {\n              try {\n                listener.onStream(newStream);\n              } catch (IOException e) {\n                Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock);\n      if (inFinished) stream.receiveFin();\n    }",
          "path": "okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java",
          "functionStartLine": 597,
          "functionName": "headers",
          "diff": "@@ -1,60 +1,46 @@\n-    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n+    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n+        List\u003cHeader\u003e headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       FramedStream stream;\n       synchronized (FramedConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n-          // The headers claim to be for an existing stream, but we don\u0027t have one.\n-          if (headersMode.failIfStreamAbsent()) {\n-            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n-            return;\n-          }\n-\n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n-          final FramedStream\n-              newStream \u003d new FramedStream(streamId, FramedConnection.this, outFinished,\n-              inFinished, headerBlock);\n+          final FramedStream newStream \u003d new FramedStream(streamId, FramedConnection.this,\n+              false, inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n                 Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n-      // The headers claim to be for a new stream, but we already have one.\n-      if (headersMode.failIfStreamPresent()) {\n-        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n-        removeStream(streamId);\n-        return;\n-      }\n-\n       // Update an existing stream.\n-      stream.receiveHeaders(headerBlock, headersMode);\n+      stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "4f24a30c12032b7033884a630696014afd3e77cb": {
      "type": "Ybodychange",
      "commitMessage": "Make logging more consistent throughout OkHttp.\n\nAvoid using System.out.\n\nUse the best logging implementation on the host platform. On Java this is\njava.util.logging. On Android it\u0027s Android.util.Log.\n\nCloses https://github.com/square/okhttp/issues/2505\n",
      "commitDate": "2016-05-07, 9:08 p.m.",
      "commitName": "4f24a30c12032b7033884a630696014afd3e77cb",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-04-28, 10:35 p.m.",
      "commitNameOld": "4b0c09eb6f931c7ba9a5735c81af115a302ed336",
      "commitAuthorOld": "Venil Noronha",
      "daysBetweenCommits": 8.94,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      FramedStream stream;\n      synchronized (FramedConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final FramedStream\n              newStream \u003d new FramedStream(streamId, FramedConnection.this, outFinished,\n              inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n            @Override public void execute() {\n              try {\n                listener.onStream(newStream);\n              } catch (IOException e) {\n                Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java",
      "functionStartLine": 644,
      "functionName": "headers",
      "diff": "@@ -1,60 +1,60 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       FramedStream stream;\n       synchronized (FramedConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final FramedStream\n               newStream \u003d new FramedStream(streamId, FramedConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n-                logger.log(Level.INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n+                Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2dade17682071a3e1d60df4113795117e5c1833c": {
      "type": "Ybodychange",
      "commitMessage": "Prefer hostname over hostName.\n\nUnfortunately MockWebServer exposes a method getHostName() so I can\u0027t\nfix it everywhere without breaking the API. But that\u0027s a mistake, we\nreally want it to be hostname going forward.\n\nAlso fix some missing copyright statements.\n",
      "commitDate": "2016-02-06, 12:38 p.m.",
      "commitName": "2dade17682071a3e1d60df4113795117e5c1833c",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-12-23, 7:34 p.m.",
      "commitNameOld": "98ae0fb92c9335ec17f8710376183e18f5edd355",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 44.71,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      FramedStream stream;\n      synchronized (FramedConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final FramedStream\n              newStream \u003d new FramedStream(streamId, FramedConnection.this, outFinished,\n              inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n            @Override public void execute() {\n              try {\n                listener.onStream(newStream);\n              } catch (IOException e) {\n                logger.log(Level.INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java",
      "functionStartLine": 634,
      "functionName": "headers",
      "diff": "@@ -1,60 +1,60 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       FramedStream stream;\n       synchronized (FramedConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final FramedStream\n               newStream \u003d new FramedStream(streamId, FramedConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n-          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n+          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n-                logger.log(Level.INFO, \"FramedConnection.Listener failure for \" + hostName, e);\n+                logger.log(Level.INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9a89876de476983f273edbf108c365127c18c5e": {
      "type": "Yfilerename",
      "commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
      "commitDate": "2015-12-16, 1:34 a.m.",
      "commitName": "c9a89876de476983f273edbf108c365127c18c5e",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-12-15, 9:36 p.m.",
      "commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      FramedStream stream;\n      synchronized (FramedConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final FramedStream\n              newStream \u003d new FramedStream(streamId, FramedConnection.this, outFinished,\n              inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                listener.onStream(newStream);\n              } catch (IOException e) {\n                logger.log(Level.INFO, \"FramedConnection.Listener failure for \" + hostName, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java",
      "functionStartLine": 640,
      "functionName": "headers",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java",
        "newPath": "okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java"
      }
    },
    "38aaf7bca6d998d0d1a1839d2b8816735f9b8914": {
      "type": "Ybodychange",
      "commitMessage": "Turn IncomingStreamHandler into FramedConnection.Listener.\n\nAdd a callback invoked on settings changes. The concurrency here\nis a little awkward because the calls into the listener are not\nserialized.\n\nThis is going to be used in a follow up change to keep the\nconnection\u0027s allocation limit in sync.\n",
      "commitDate": "2015-12-06, 9:59 a.m.",
      "commitName": "38aaf7bca6d998d0d1a1839d2b8816735f9b8914",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-12-02, 12:44 p.m.",
      "commitNameOld": "c5f58e45454d1ffc621c65e377cb91345018e087",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 3.89,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      FramedStream stream;\n      synchronized (FramedConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final FramedStream\n              newStream \u003d new FramedStream(streamId, FramedConnection.this, outFinished,\n              inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                listener.onStream(newStream);\n              } catch (IOException e) {\n                logger.log(Level.INFO, \"FramedConnection.Listener failure for \" + hostName, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java",
      "functionStartLine": 640,
      "functionName": "headers",
      "diff": "@@ -1,60 +1,60 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       FramedStream stream;\n       synchronized (FramedConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final FramedStream\n               newStream \u003d new FramedStream(streamId, FramedConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n-                handler.receive(newStream);\n+                listener.onStream(newStream);\n               } catch (IOException e) {\n-                logger.log(Level.INFO, \"StreamHandler failure for \" + hostName, e);\n+                logger.log(Level.INFO, \"FramedConnection.Listener failure for \" + hostName, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "Rename \u0027spdy\u0027 references to \u0027framed\u0027 where appropriate.\n",
      "commitDate": "2015-06-17, 6:40 p.m.",
      "commitName": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
      "commitAuthor": "Jake Wharton",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "Rename \u0027spdy\u0027 references to \u0027framed\u0027 where appropriate.\n",
          "commitDate": "2015-06-17, 6:40 p.m.",
          "commitName": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
          "commitAuthor": "Jake Wharton",
          "commitDateOld": "2015-06-16, 12:46 p.m.",
          "commitNameOld": "b262f2a03001cd990568b929b2739dd3c7adb75f",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.25,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      FramedStream stream;\n      synchronized (FramedConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final FramedStream\n              newStream \u003d new FramedStream(streamId, FramedConnection.this, outFinished,\n              inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                logger.log(Level.INFO, \"StreamHandler failure for \" + hostName, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java",
          "functionStartLine": 613,
          "functionName": "headers",
          "diff": "@@ -1,59 +1,60 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n-      SpdyStream stream;\n-      synchronized (SpdyConnection.this) {\n+      FramedStream stream;\n+      synchronized (FramedConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n-          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n+          final FramedStream\n+              newStream \u003d new FramedStream(streamId, FramedConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 logger.log(Level.INFO, \"StreamHandler failure for \" + hostName, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
            "newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Rename \u0027spdy\u0027 references to \u0027framed\u0027 where appropriate.\n",
          "commitDate": "2015-06-17, 6:40 p.m.",
          "commitName": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
          "commitAuthor": "Jake Wharton",
          "commitDateOld": "2015-06-16, 12:46 p.m.",
          "commitNameOld": "b262f2a03001cd990568b929b2739dd3c7adb75f",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.25,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      FramedStream stream;\n      synchronized (FramedConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final FramedStream\n              newStream \u003d new FramedStream(streamId, FramedConnection.this, outFinished,\n              inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                logger.log(Level.INFO, \"StreamHandler failure for \" + hostName, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java",
          "functionStartLine": 613,
          "functionName": "headers",
          "diff": "@@ -1,59 +1,60 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n-      SpdyStream stream;\n-      synchronized (SpdyConnection.this) {\n+      FramedStream stream;\n+      synchronized (FramedConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n-          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n+          final FramedStream\n+              newStream \u003d new FramedStream(streamId, FramedConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 logger.log(Level.INFO, \"StreamHandler failure for \" + hostName, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "8fe27a50c2c88d382e6dc6600836bcc57fc7b0cf": {
      "type": "Ybodychange",
      "commitMessage": "Crash on unexpected RuntimeExceptions.\n\nCurrently we\u0027re sweeping these under the rug.\n",
      "commitDate": "2015-05-17, 6:05 p.m.",
      "commitName": "8fe27a50c2c88d382e6dc6600836bcc57fc7b0cf",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-05-01, 10:54 a.m.",
      "commitNameOld": "c8bd6f834d848c0a51245e263f81a7b2f6c7c11c",
      "commitAuthorOld": "",
      "daysBetweenCommits": 16.3,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                logger.log(Level.INFO, \"StreamHandler failure for \" + hostName, e);\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 613,
      "functionName": "headers",
      "diff": "@@ -1,58 +1,59 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n-              } catch (RuntimeException | IOException e) {\n+              } catch (IOException e) {\n+                logger.log(Level.INFO, \"StreamHandler failure for \" + hostName, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb155c47661ede5da395dfb4e620867263b8c8e7": {
      "type": "Ybodychange",
      "commitMessage": "Fix MockWebServer with SPDY on Android.\n\nFix for issue #1552\nRelated to commit f78f74f from issue #1294\n\nBefore this change:\nSpdyConnection creates threads to handle the reading and writing. If\nthose threads die from a RuntimeException it triggers Android\u0027s default\nUncaughtExceptionHandler, which kills the test process. Previously exceptions\nwere being swallowed, but commit f78f74f caused the exceptions to be\npropagated.\n\nThis change adds extra handling for RuntimeException to stop them escaping.\n",
      "commitDate": "2015-04-14, 11:54 a.m.",
      "commitName": "fb155c47661ede5da395dfb4e620867263b8c8e7",
      "commitAuthor": "Neil Fuller",
      "commitDateOld": "2015-03-11, 11:18 a.m.",
      "commitNameOld": "60b1dfc169156f300045fd0e01e89b890661b5a7",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 34.03,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (RuntimeException | IOException e) {\n                try {\n                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n                } catch (IOException ignored) {\n                }\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 608,
      "functionName": "headers",
      "diff": "@@ -1,55 +1,58 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n-              } catch (IOException e) {\n-                throw new RuntimeException(e);\n+              } catch (RuntimeException | IOException e) {\n+                try {\n+                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n+                } catch (IOException ignored) {\n+                }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f78f74f5a2cf1f73f974487816f998a6e37a9cf1": {
      "type": "Ybodychange",
      "commitMessage": "Use ExecutorService.execute, not ExecutorService.submit.\n\nThe latter returns a Future that we never call get() on, and\nnever get the exception from.\n\nFixes: https://github.com/square/okhttp/issues/1294\n",
      "commitDate": "2015-03-10, 10:01 p.m.",
      "commitName": "f78f74f5a2cf1f73f974487816f998a6e37a9cf1",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-12-26, 6:12 p.m.",
      "commitNameOld": "955934836fc466d93d6e41d1ff9391d9e5b3f09a",
      "commitAuthorOld": "",
      "daysBetweenCommits": 74.12,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 608,
      "functionName": "headers",
      "diff": "@@ -1,55 +1,55 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n-          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n+          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc38140be4c7e41330cf7749c3eeba23c85f9522": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Added support for http/2 draft 12, which is incompatible with previous priority schemes.\n",
      "commitDate": "2014-05-04, 2:53 p.m.",
      "commitName": "cc38140be4c7e41330cf7749c3eeba23c85f9522",
      "commitAuthor": "Adrian Cole",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Added support for http/2 draft 12, which is incompatible with previous priority schemes.\n",
          "commitDate": "2014-05-04, 2:53 p.m.",
          "commitName": "cc38140be4c7e41330cf7749c3eeba23c85f9522",
          "commitAuthor": "Adrian Cole",
          "commitDateOld": "2014-04-18, 11:58 a.m.",
          "commitNameOld": "889bc764a5f1627090a69e6e100bcd18474dfb86",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 16.12,
          "commitsBetweenForRepo": 65,
          "commitsBetweenForFile": 1,
          "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
          "functionStartLine": 589,
          "functionName": "headers",
          "diff": "@@ -1,55 +1,55 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n+        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, headerBlock);\n+              inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, headerBlock-List\u003cHeader\u003e, headersMode-HeadersMode]",
            "newValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, headerBlock-List\u003cHeader\u003e, headersMode-HeadersMode]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Added support for http/2 draft 12, which is incompatible with previous priority schemes.\n",
          "commitDate": "2014-05-04, 2:53 p.m.",
          "commitName": "cc38140be4c7e41330cf7749c3eeba23c85f9522",
          "commitAuthor": "Adrian Cole",
          "commitDateOld": "2014-04-18, 11:58 a.m.",
          "commitNameOld": "889bc764a5f1627090a69e6e100bcd18474dfb86",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 16.12,
          "commitsBetweenForRepo": 65,
          "commitsBetweenForFile": 1,
          "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
          "functionStartLine": 589,
          "functionName": "headers",
          "diff": "@@ -1,55 +1,55 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n+        int associatedStreamId, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, headerBlock);\n+              inFinished, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "a5ba3e9062f3bde4bb6896f1db433a2408119e94": {
      "type": "Ybodychange",
      "commitMessage": "Add HTTP/2 PushObserver.\n",
      "commitDate": "2014-03-02, 12:23 a.m.",
      "commitName": "a5ba3e9062f3bde4bb6896f1db433a2408119e94",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014-02-27, 11:28 p.m.",
      "commitNameOld": "110a4fac4257fe2df0e23149fbef76e750604cf4",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 2.04,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n      if (pushedStream(streamId)) {\n        pushHeadersLater(streamId, headerBlock, inFinished);\n        return;\n      }\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, priority, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 588,
      "functionName": "headers",
      "diff": "@@ -1,52 +1,55 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock,\n-        HeadersMode headersMode) {\n+        int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock, HeadersMode headersMode) {\n+      if (pushedStream(streamId)) {\n+        pushHeadersLater(streamId, headerBlock, inFinished);\n+        return;\n+      }\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, priority, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "110a4fac4257fe2df0e23149fbef76e750604cf4": {
      "type": "Yfilerename",
      "commitMessage": "Rearrange OkHttp modules.\n\nThe HTTP client and SPDY code are now a single module that\nmockwebserver depends upon.\n\nThe tests are now in a separate module that depends on both\nOkHttp and mockwebserver.\n",
      "commitDate": "2014-02-27, 11:28 p.m.",
      "commitName": "110a4fac4257fe2df0e23149fbef76e750604cf4",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-02-25, 10:34 p.m.",
      "commitNameOld": "d5cbd0aebe090d956f54b6697068fcbff6d668e7",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 2.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock,\n        HeadersMode headersMode) {\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, priority, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 572,
      "functionName": "headers",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
        "newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java"
      }
    },
    "358169b89f32c00bf229b4e42ccef756588da71f": {
      "type": "Ybodychange",
      "commitMessage": "Send window update after the peer sends half the limit on a stream or connection.\n",
      "commitDate": "2014-01-27, 12:54 a.m.",
      "commitName": "358169b89f32c00bf229b4e42ccef756588da71f",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014-01-26, 5:01 p.m.",
      "commitNameOld": "d990b5819cd6282923134564f3bcc59263eb0616",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 0.33,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock,\n        HeadersMode headersMode) {\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, priority, headerBlock);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 552,
      "functionName": "headers",
      "diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, headerBlock, initialWindowSize);\n+              inFinished, priority, headerBlock);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d4508141fc9fa1b816c5a1ff3f39149d4dfb22de": {
      "type": "Ybodychange",
      "commitMessage": "Honor change in connection-level initial write window from peer settings.\n",
      "commitDate": "2014-01-26, 2:48 p.m.",
      "commitName": "d4508141fc9fa1b816c5a1ff3f39149d4dfb22de",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014-01-26, 12:36 p.m.",
      "commitNameOld": "b9b5c8462da2abe26dcf157d2df483ba61e3d379",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock,\n        HeadersMode headersMode) {\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, priority, headerBlock, initialWindowSize);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 527,
      "functionName": "headers",
      "diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, headerBlock, peerSettings);\n+              inFinished, priority, headerBlock, initialWindowSize);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f214cf9670339b850f97da4a2d4ad64758fd0e4d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Framing of headers blocks happen after compression.\n",
      "commitDate": "2014-01-21, 11:27 a.m.",
      "commitName": "f214cf9670339b850f97da4a2d4ad64758fd0e4d",
      "commitAuthor": "Adrian Cole",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Framing of headers blocks happen after compression.\n",
          "commitDate": "2014-01-21, 11:27 a.m.",
          "commitName": "f214cf9670339b850f97da4a2d4ad64758fd0e4d",
          "commitAuthor": "Adrian Cole",
          "commitDateOld": "2014-01-20, 5:17 p.m.",
          "commitNameOld": "9110ef83bf35a006368ae251ccd170cd72ba6415",
          "commitAuthorOld": "Adrian Cole",
          "daysBetweenCommits": 0.76,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock,\n        HeadersMode headersMode) {\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, priority, headerBlock, peerSettings);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
          "path": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
          "functionStartLine": 484,
          "functionName": "headers",
          "diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List\u003cHeader\u003e nameValueBlock,\n+        int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, nameValueBlock, peerSettings);\n+              inFinished, priority, headerBlock, peerSettings);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n-      stream.receiveHeaders(nameValueBlock, headersMode);\n+      stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, nameValueBlock-List\u003cHeader\u003e, headersMode-HeadersMode]",
            "newValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, headerBlock-List\u003cHeader\u003e, headersMode-HeadersMode]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Framing of headers blocks happen after compression.\n",
          "commitDate": "2014-01-21, 11:27 a.m.",
          "commitName": "f214cf9670339b850f97da4a2d4ad64758fd0e4d",
          "commitAuthor": "Adrian Cole",
          "commitDateOld": "2014-01-20, 5:17 p.m.",
          "commitNameOld": "9110ef83bf35a006368ae251ccd170cd72ba6415",
          "commitAuthorOld": "Adrian Cole",
          "daysBetweenCommits": 0.76,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock,\n        HeadersMode headersMode) {\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, priority, headerBlock, peerSettings);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(headerBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
          "path": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
          "functionStartLine": 484,
          "functionName": "headers",
          "diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List\u003cHeader\u003e nameValueBlock,\n+        int associatedStreamId, int priority, List\u003cHeader\u003e headerBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, nameValueBlock, peerSettings);\n+              inFinished, priority, headerBlock, peerSettings);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n-      stream.receiveHeaders(nameValueBlock, headersMode);\n+      stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "b95a0ccbcae50f92acc923d62fc6c9cecc6bbb63": {
      "type": "Yparameterchange",
      "commitMessage": "Top-level immutable, internal HeaderEntry class to reduce duplication around header names.  Do not emit :version in http/2.\n",
      "commitDate": "2014-01-19, 1:35 p.m.",
      "commitName": "b95a0ccbcae50f92acc923d62fc6c9cecc6bbb63",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014-01-18, 11:46 p.m.",
      "commitNameOld": "ef30f7efc61ac249c1a8b43e41dba03a2bf0bef8",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 0.58,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, int priority, List\u003cHeader\u003e nameValueBlock,\n        HeadersMode headersMode) {\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, priority, nameValueBlock, peerSettings);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(nameValueBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 481,
      "functionName": "headers",
      "diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List\u003cByteString\u003e nameValueBlock,\n+        int associatedStreamId, int priority, List\u003cHeader\u003e nameValueBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, priority, nameValueBlock, peerSettings);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(nameValueBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, nameValueBlock-List\u003cByteString\u003e, headersMode-HeadersMode]",
        "newValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, nameValueBlock-List\u003cHeader\u003e, headersMode-HeadersMode]"
      }
    },
    "ef30f7efc61ac249c1a8b43e41dba03a2bf0bef8": {
      "type": "Ybodychange",
      "commitMessage": "Extract default settings to variants.  Read windowSize (spdy/3) and headerTableSize (http/2) from peer.\n",
      "commitDate": "2014-01-18, 11:46 p.m.",
      "commitName": "ef30f7efc61ac249c1a8b43e41dba03a2bf0bef8",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014-01-16, 11:39 a.m.",
      "commitNameOld": "9766de54dc8be4560b45d89452b016998277dae3",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 2.51,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, int priority, List\u003cByteString\u003e nameValueBlock,\n        HeadersMode headersMode) {\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, priority, nameValueBlock, peerSettings);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(nameValueBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 482,
      "functionName": "headers",
      "diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, int priority, List\u003cByteString\u003e nameValueBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, nameValueBlock, settings);\n+              inFinished, priority, nameValueBlock, peerSettings);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(nameValueBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "749a65b776c8fc4b39b6463695980275da34da51": {
      "type": "Ybodychange",
      "commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
      "commitDate": "2014-01-12, 9:47 a.m.",
      "commitName": "749a65b776c8fc4b39b6463695980275da34da51",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-01-06, 9:51 p.m.",
      "commitNameOld": "5c787a0b9d5c83c764880da4b1503a65ee0ff267",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 5.5,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, int priority, List\u003cByteString\u003e nameValueBlock,\n        HeadersMode headersMode) {\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, priority, nameValueBlock, settings);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(nameValueBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 479,
      "functionName": "headers",
      "diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, int priority, List\u003cByteString\u003e nameValueBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, priority, nameValueBlock, settings);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n-          executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n+          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(nameValueBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5c787a0b9d5c83c764880da4b1503a65ee0ff267": {
      "type": "Yparameterchange",
      "commitMessage": "Refactor SPDY code to use ByteString for headers.\n",
      "commitDate": "2014-01-06, 9:51 p.m.",
      "commitName": "5c787a0b9d5c83c764880da4b1503a65ee0ff267",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014-01-05, 7:53 p.m.",
      "commitNameOld": "d7444f5fc4414b51b2708606257381cc0de404e1",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, int priority, List\u003cByteString\u003e nameValueBlock,\n        HeadersMode headersMode) {\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, priority, nameValueBlock, settings);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(nameValueBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
      "path": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 475,
      "functionName": "headers",
      "diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List\u003cString\u003e nameValueBlock,\n+        int associatedStreamId, int priority, List\u003cByteString\u003e nameValueBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we\u0027re shutdown, don\u0027t bother with this stream.\n         if (shutdown) return;\n \n         stream \u003d getStream(streamId);\n \n         if (stream \u003d\u003d null) {\n           // The headers claim to be for an existing stream, but we don\u0027t have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n           if (streamId \u003c\u003d lastGoodStreamId) return;\n \n           // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n           if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, priority, nameValueBlock, settings);\n           lastGoodStreamId \u003d streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(nameValueBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, nameValueBlock-List\u003cString\u003e, headersMode-HeadersMode]",
        "newValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, nameValueBlock-List\u003cByteString\u003e, headersMode-HeadersMode]"
      }
    },
    "a91124b6d4e2eb1bb3c71a7a8ddff7d40b7db55a": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "Use one callback for SYN_STREAM, SYN_REPLY and HEADERS.\n\nThis is closer to the semantics of HTTP/2.0, which uses the HEADERS\nframe for all three types. SPDY is a bit more strict because it\nrelies on redundancy; it\u0027s an error to send a SYN_REPLY after a\nHEADERS frame. With HTTP/2.0, there\u0027s only one type so there\u0027s\nno error to detect.\n",
      "commitDate": "2013-09-01, 1:57 p.m.",
      "commitName": "a91124b6d4e2eb1bb3c71a7a8ddff7d40b7db55a",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Use one callback for SYN_STREAM, SYN_REPLY and HEADERS.\n\nThis is closer to the semantics of HTTP/2.0, which uses the HEADERS\nframe for all three types. SPDY is a bit more strict because it\nrelies on redundancy; it\u0027s an error to send a SYN_REPLY after a\nHEADERS frame. With HTTP/2.0, there\u0027s only one type so there\u0027s\nno error to detect.\n",
          "commitDate": "2013-09-01, 1:57 p.m.",
          "commitName": "a91124b6d4e2eb1bb3c71a7a8ddff7d40b7db55a",
          "commitAuthor": "jwilson",
          "commitDateOld": "2013-08-27, 10:25 a.m.",
          "commitNameOld": "5663f815af072160f344712d5b353439bd2066f1",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 5.15,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, int priority, List\u003cString\u003e nameValueBlock,\n        HeadersMode headersMode) {\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, priority, nameValueBlock, settings);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(nameValueBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
          "path": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
          "functionStartLine": 459,
          "functionName": "headers",
          "diff": "@@ -1,7 +1,52 @@\n-    @Override public void headers(int streamId, List\u003cString\u003e nameValueBlock)\n-        throws IOException {\n-      SpdyStream replyStream \u003d getStream(streamId);\n-      if (replyStream !\u003d null) {\n-        replyStream.receiveHeaders(nameValueBlock);\n+    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n+        int associatedStreamId, int priority, List\u003cString\u003e nameValueBlock,\n+        HeadersMode headersMode) {\n+      SpdyStream stream;\n+      synchronized (SpdyConnection.this) {\n+        // If we\u0027re shutdown, don\u0027t bother with this stream.\n+        if (shutdown) return;\n+\n+        stream \u003d getStream(streamId);\n+\n+        if (stream \u003d\u003d null) {\n+          // The headers claim to be for an existing stream, but we don\u0027t have one.\n+          if (headersMode.failIfStreamAbsent()) {\n+            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n+            return;\n+          }\n+\n+          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n+          if (streamId \u003c\u003d lastGoodStreamId) return;\n+\n+          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n+          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n+\n+          // Create a stream.\n+          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n+              inFinished, priority, nameValueBlock, settings);\n+          lastGoodStreamId \u003d streamId;\n+          streams.put(streamId, newStream);\n+          executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n+            @Override public void execute() {\n+              try {\n+                handler.receive(newStream);\n+              } catch (IOException e) {\n+                throw new RuntimeException(e);\n+              }\n+            }\n+          });\n+          return;\n+        }\n       }\n+\n+      // The headers claim to be for a new stream, but we already have one.\n+      if (headersMode.failIfStreamPresent()) {\n+        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n+        removeStream(streamId);\n+        return;\n+      }\n+\n+      // Update an existing stream.\n+      stream.receiveHeaders(nameValueBlock, headersMode);\n+      if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[streamId-int, nameValueBlock-List\u003cString\u003e]",
            "newValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, nameValueBlock-List\u003cString\u003e, headersMode-HeadersMode]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "Use one callback for SYN_STREAM, SYN_REPLY and HEADERS.\n\nThis is closer to the semantics of HTTP/2.0, which uses the HEADERS\nframe for all three types. SPDY is a bit more strict because it\nrelies on redundancy; it\u0027s an error to send a SYN_REPLY after a\nHEADERS frame. With HTTP/2.0, there\u0027s only one type so there\u0027s\nno error to detect.\n",
          "commitDate": "2013-09-01, 1:57 p.m.",
          "commitName": "a91124b6d4e2eb1bb3c71a7a8ddff7d40b7db55a",
          "commitAuthor": "jwilson",
          "commitDateOld": "2013-08-27, 10:25 a.m.",
          "commitNameOld": "5663f815af072160f344712d5b353439bd2066f1",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 5.15,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, int priority, List\u003cString\u003e nameValueBlock,\n        HeadersMode headersMode) {\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, priority, nameValueBlock, settings);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(nameValueBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
          "path": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
          "functionStartLine": 459,
          "functionName": "headers",
          "diff": "@@ -1,7 +1,52 @@\n-    @Override public void headers(int streamId, List\u003cString\u003e nameValueBlock)\n-        throws IOException {\n-      SpdyStream replyStream \u003d getStream(streamId);\n-      if (replyStream !\u003d null) {\n-        replyStream.receiveHeaders(nameValueBlock);\n+    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n+        int associatedStreamId, int priority, List\u003cString\u003e nameValueBlock,\n+        HeadersMode headersMode) {\n+      SpdyStream stream;\n+      synchronized (SpdyConnection.this) {\n+        // If we\u0027re shutdown, don\u0027t bother with this stream.\n+        if (shutdown) return;\n+\n+        stream \u003d getStream(streamId);\n+\n+        if (stream \u003d\u003d null) {\n+          // The headers claim to be for an existing stream, but we don\u0027t have one.\n+          if (headersMode.failIfStreamAbsent()) {\n+            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n+            return;\n+          }\n+\n+          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n+          if (streamId \u003c\u003d lastGoodStreamId) return;\n+\n+          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n+          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n+\n+          // Create a stream.\n+          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n+              inFinished, priority, nameValueBlock, settings);\n+          lastGoodStreamId \u003d streamId;\n+          streams.put(streamId, newStream);\n+          executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n+            @Override public void execute() {\n+              try {\n+                handler.receive(newStream);\n+              } catch (IOException e) {\n+                throw new RuntimeException(e);\n+              }\n+            }\n+          });\n+          return;\n+        }\n       }\n+\n+      // The headers claim to be for a new stream, but we already have one.\n+      if (headersMode.failIfStreamPresent()) {\n+        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n+        removeStream(streamId);\n+        return;\n+      }\n+\n+      // Update an existing stream.\n+      stream.receiveHeaders(nameValueBlock, headersMode);\n+      if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Use one callback for SYN_STREAM, SYN_REPLY and HEADERS.\n\nThis is closer to the semantics of HTTP/2.0, which uses the HEADERS\nframe for all three types. SPDY is a bit more strict because it\nrelies on redundancy; it\u0027s an error to send a SYN_REPLY after a\nHEADERS frame. With HTTP/2.0, there\u0027s only one type so there\u0027s\nno error to detect.\n",
          "commitDate": "2013-09-01, 1:57 p.m.",
          "commitName": "a91124b6d4e2eb1bb3c71a7a8ddff7d40b7db55a",
          "commitAuthor": "jwilson",
          "commitDateOld": "2013-08-27, 10:25 a.m.",
          "commitNameOld": "5663f815af072160f344712d5b353439bd2066f1",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 5.15,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n        int associatedStreamId, int priority, List\u003cString\u003e nameValueBlock,\n        HeadersMode headersMode) {\n      SpdyStream stream;\n      synchronized (SpdyConnection.this) {\n        // If we\u0027re shutdown, don\u0027t bother with this stream.\n        if (shutdown) return;\n\n        stream \u003d getStream(streamId);\n\n        if (stream \u003d\u003d null) {\n          // The headers claim to be for an existing stream, but we don\u0027t have one.\n          if (headersMode.failIfStreamAbsent()) {\n            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n            return;\n          }\n\n          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n          if (streamId \u003c\u003d lastGoodStreamId) return;\n\n          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n\n          // Create a stream.\n          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n              inFinished, priority, nameValueBlock, settings);\n          lastGoodStreamId \u003d streamId;\n          streams.put(streamId, newStream);\n          executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n            @Override public void execute() {\n              try {\n                handler.receive(newStream);\n              } catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n          return;\n        }\n      }\n\n      // The headers claim to be for a new stream, but we already have one.\n      if (headersMode.failIfStreamPresent()) {\n        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n        removeStream(streamId);\n        return;\n      }\n\n      // Update an existing stream.\n      stream.receiveHeaders(nameValueBlock, headersMode);\n      if (inFinished) stream.receiveFin();\n    }",
          "path": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
          "functionStartLine": 459,
          "functionName": "headers",
          "diff": "@@ -1,7 +1,52 @@\n-    @Override public void headers(int streamId, List\u003cString\u003e nameValueBlock)\n-        throws IOException {\n-      SpdyStream replyStream \u003d getStream(streamId);\n-      if (replyStream !\u003d null) {\n-        replyStream.receiveHeaders(nameValueBlock);\n+    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n+        int associatedStreamId, int priority, List\u003cString\u003e nameValueBlock,\n+        HeadersMode headersMode) {\n+      SpdyStream stream;\n+      synchronized (SpdyConnection.this) {\n+        // If we\u0027re shutdown, don\u0027t bother with this stream.\n+        if (shutdown) return;\n+\n+        stream \u003d getStream(streamId);\n+\n+        if (stream \u003d\u003d null) {\n+          // The headers claim to be for an existing stream, but we don\u0027t have one.\n+          if (headersMode.failIfStreamAbsent()) {\n+            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n+            return;\n+          }\n+\n+          // If the stream ID is less than the last created ID, assume it\u0027s already closed.\n+          if (streamId \u003c\u003d lastGoodStreamId) return;\n+\n+          // If the stream ID is in the client\u0027s namespace, assume it\u0027s already closed.\n+          if (streamId % 2 \u003d\u003d nextStreamId % 2) return;\n+\n+          // Create a stream.\n+          final SpdyStream newStream \u003d new SpdyStream(streamId, SpdyConnection.this, outFinished,\n+              inFinished, priority, nameValueBlock, settings);\n+          lastGoodStreamId \u003d streamId;\n+          streams.put(streamId, newStream);\n+          executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n+            @Override public void execute() {\n+              try {\n+                handler.receive(newStream);\n+              } catch (IOException e) {\n+                throw new RuntimeException(e);\n+              }\n+            }\n+          });\n+          return;\n+        }\n       }\n+\n+      // The headers claim to be for a new stream, but we already have one.\n+      if (headersMode.failIfStreamPresent()) {\n+        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n+        removeStream(streamId);\n+        return;\n+      }\n+\n+      // Update an existing stream.\n+      stream.receiveHeaders(nameValueBlock, headersMode);\n+      if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "2f31d7122d8806b6c32d2d1e181ca635fb80bba7": {
      "type": "Yparameterchange",
      "commitMessage": "Hide more flags from SPDY APIs.\n\nFlags are not portable between SPDY/3 and HTTP/2.0,\nso hide them in the reader \u0026 writer code.\n\nAlso rename SpdyReader to FrameReader and SpdyWriter to\nFrameWriter. Other classes will be renamed as they become\nindependent of the underlying protocol.\n",
      "commitDate": "2013-08-15, 12:29 a.m.",
      "commitName": "2f31d7122d8806b6c32d2d1e181ca635fb80bba7",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-08-14, 7:25 a.m.",
      "commitNameOld": "39c0d7d56397ab14892db8032464cb8a9f983ff1",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.71,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(int streamId, List\u003cString\u003e nameValueBlock)\n        throws IOException {\n      SpdyStream replyStream \u003d getStream(streamId);\n      if (replyStream !\u003d null) {\n        replyStream.receiveHeaders(nameValueBlock);\n      }\n    }",
      "path": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 499,
      "functionName": "headers",
      "diff": "@@ -1,7 +1,7 @@\n-    @Override public void headers(int flags, int streamId, List\u003cString\u003e nameValueBlock)\n+    @Override public void headers(int streamId, List\u003cString\u003e nameValueBlock)\n         throws IOException {\n       SpdyStream replyStream \u003d getStream(streamId);\n       if (replyStream !\u003d null) {\n         replyStream.receiveHeaders(nameValueBlock);\n       }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[flags-int, streamId-int, nameValueBlock-List\u003cString\u003e]",
        "newValue": "[streamId-int, nameValueBlock-List\u003cString\u003e]"
      }
    },
    "3c0faa9ca18de3be0a178e590086888f4f89612a": {
      "type": "Yfilerename",
      "commitMessage": "Make a home for MockWebServer in OkHttp.\n\nTo build HTTP/2.0 support into OkHttp I\u0027m going to simultaneously\nbuild HTTP/2.0 support into MockWebServer. To make that possible,\nI\u0027m first going to fork MockWebServer and then combine it with\nMockSpdyServer.\n",
      "commitDate": "2013-08-03, 12:50 p.m.",
      "commitName": "3c0faa9ca18de3be0a178e590086888f4f89612a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-07-20, 2:14 p.m.",
      "commitNameOld": "cc4633943800572673c03b32d0b2bc9a08ae184d",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 13.94,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(int flags, int streamId, List\u003cString\u003e nameValueBlock)\n        throws IOException {\n      SpdyStream replyStream \u003d getStream(streamId);\n      if (replyStream !\u003d null) {\n        replyStream.receiveHeaders(nameValueBlock);\n      }\n    }",
      "path": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 493,
      "functionName": "headers",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
        "newPath": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java"
      }
    },
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": {
      "type": "Yfilerename",
      "commitMessage": "Move library into a module. Introduce sample module with simple GitHub client.\n",
      "commitDate": "2013-03-25, 11:04 p.m.",
      "commitName": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2013-03-15, 10:39 a.m.",
      "commitNameOld": "ba2b7432cb9fabfc725b09a9f14878cb128ef208",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 10.52,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    @Override public void headers(int flags, int streamId, List\u003cString\u003e nameValueBlock)\n        throws IOException {\n      SpdyStream replyStream \u003d getStream(streamId);\n      if (replyStream !\u003d null) {\n        replyStream.receiveHeaders(nameValueBlock);\n      }\n    }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 499,
      "functionName": "headers",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
        "newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java"
      }
    },
    "b9580d68e9bc34eef397e9bc7f13091f1e3f1528": {
      "type": "Ybodychange",
      "commitMessage": "Be more careful around IOExceptions.\n\nThis adds a first test where a frame is truncated. That has some\nunpleasant consequences for the other tests because it means the\nMockSpdyPeer is more aggressive about closing the socket when all\nframes have been sent.\n\nIt also reduces the use of exceptions for flow control when handling\nbogus incoming frames. This is a bit worse and a bit better; my\ngoal is to make it easier to differentiate between protocol-level\nproblems (bogus frames) from transport-level problems (closed sockets\nand EOF streams).\n",
      "commitDate": "2013-01-21, 2:42 p.m.",
      "commitName": "b9580d68e9bc34eef397e9bc7f13091f1e3f1528",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-01-18, 3:50 p.m.",
      "commitNameOld": "1bd9fefb5199d1499c8dac6c82c18c82e0678428",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 2.95,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "        @Override public void headers(int flags, int streamId, List\u003cString\u003e nameValueBlock)\n                throws IOException {\n            SpdyStream replyStream \u003d getStream(streamId);\n            if (replyStream !\u003d null) {\n                replyStream.receiveHeaders(nameValueBlock);\n            }\n        }",
      "path": "src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 487,
      "functionName": "headers",
      "diff": "@@ -1,11 +1,7 @@\n         @Override public void headers(int flags, int streamId, List\u003cString\u003e nameValueBlock)\n                 throws IOException {\n             SpdyStream replyStream \u003d getStream(streamId);\n             if (replyStream !\u003d null) {\n-                try {\n-                    replyStream.receiveHeaders(nameValueBlock);\n-                } catch (ProtocolException e) {\n-                    replyStream.closeLater(SpdyStream.RST_PROTOCOL_ERROR);\n-                }\n+                replyStream.receiveHeaders(nameValueBlock);\n             }\n         }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "689f66222bd8984dd69229a4ee9caf8da528ae12": {
      "type": "Yfilerename",
      "commitMessage": "Flatten internal packages and utility classes.\n\nThe previous structure had hierarchy that was useful\nfor libcore but overkill for OkHttp.\n",
      "commitDate": "2013-01-01, 10:50 p.m.",
      "commitName": "689f66222bd8984dd69229a4ee9caf8da528ae12",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-01-01, 10:27 p.m.",
      "commitNameOld": "73516e6ab1d336ffd520e845e14f80cf08657bd0",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "        @Override public void headers(int flags, int streamId, List\u003cString\u003e nameValueBlock)\n                throws IOException {\n            SpdyStream replyStream \u003d getStream(streamId);\n            if (replyStream !\u003d null) {\n                try {\n                    replyStream.receiveHeaders(nameValueBlock);\n                } catch (ProtocolException e) {\n                    replyStream.closeLater(SpdyStream.RST_PROTOCOL_ERROR);\n                }\n            }\n        }",
      "path": "src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
      "functionStartLine": 428,
      "functionName": "headers",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/com/squareup/okhttp/internal/net/spdy/SpdyConnection.java",
        "newPath": "src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java"
      }
    },
    "7a28500a72d6914c6be7d9d8ee47d23f92f35d64": {
      "type": "Yintroduced",
      "commitMessage": "Support the HEADERS frame.\n",
      "commitDate": "2013-01-01, 10:21 p.m.",
      "commitName": "7a28500a72d6914c6be7d9d8ee47d23f92f35d64",
      "commitAuthor": "jwilson",
      "diff": "@@ -0,0 +1,11 @@\n+        @Override public void headers(int flags, int streamId, List\u003cString\u003e nameValueBlock)\n+                throws IOException {\n+            SpdyStream replyStream \u003d getStream(streamId);\n+            if (replyStream !\u003d null) {\n+                try {\n+                    replyStream.receiveHeaders(nameValueBlock);\n+                } catch (ProtocolException e) {\n+                    replyStream.closeLater(SpdyStream.RST_PROTOCOL_ERROR);\n+                }\n+            }\n+        }\n\\ No newline at end of file\n",
      "actualSource": "        @Override public void headers(int flags, int streamId, List\u003cString\u003e nameValueBlock)\n                throws IOException {\n            SpdyStream replyStream \u003d getStream(streamId);\n            if (replyStream !\u003d null) {\n                try {\n                    replyStream.receiveHeaders(nameValueBlock);\n                } catch (ProtocolException e) {\n                    replyStream.closeLater(SpdyStream.RST_PROTOCOL_ERROR);\n                }\n            }\n        }",
      "path": "src/main/java/com/squareup/okhttp/internal/net/spdy/SpdyConnection.java",
      "functionStartLine": 430,
      "functionName": "headers"
    }
  }
}