{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "H:\\Projects\\eclipse\\jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "RepoCommand.java",
  "functionName": "call",
  "functionId": "call",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
  "functionStartLine": 487,
  "functionEndLine": 700,
  "numCommitsSeen": 68,
  "timeTaken": 4809,
  "changeHistory": [
    "6658f367682932c0a77061a5aa37c06e480a0c62",
    "3214171decf596f003c154685638b01faba31ff3",
    "446a7096ef01c0e3bb56736403d91b125b2ee6ba",
    "9bebb1eae78401e1d3289dc3d84006c10d10c0ef",
    "04b8168beb5fb9c7d4e9768cc99a82d0e6176dc2",
    "b6fc8e2f3cb1af6f7cbc624acfac01bec002baf8",
    "fe5437e96b91222e30d9105e7bab490fd68c2d52",
    "f32d65759c9afdcbec28eb3051ed9138b8e03271",
    "27b05c7d719754427a97c141b44bec7de3acb8db",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
    "a9b87de97090b4f7d25ace0525edc1268cfa737f",
    "6ae4ed0f7da996bde2ba5cdc26daff979c9f6866",
    "ddd0fe257bc78dc9646407e7121769d0c03e0d94",
    "0ecb016d7db42ab83584cab3c1554d4d28cc5062",
    "cdd7c23446a0030e5b521d91cbb2d3a9c522ccc2",
    "217b2a7cc5366491be5317d20f3f3c1b6e3475bf",
    "744c370c1be8044d1ccaaf84cd164324961fea1a",
    "d3348e5623a2abf7b2f1356ea077d6eb9bf7760c",
    "0e73d395061d1bfee365acaa2f79c392175d13bf",
    "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386",
    "34dd64f6fe36ace1a90b0b503e2e37d877b7c621",
    "acd7ed52692bb7155333efea6dead712b7156ab9",
    "0b15b48f741f87277e0d1c7d29637430b880dbde",
    "d998bc938a21cb3871b442a3bb54b5807b6e4ed2",
    "056135a1482a9d56ee5055d6bc2df5bea032b5e5",
    "dc4c673902a0847b270faf1771595d7c189a1943",
    "a44a687fedbf1559277b8e6706819aa9be7bce39",
    "0ad8fa7b36dafbea07da15897cc2f2b601772e24"
  ],
  "changeHistoryShort": {
    "6658f367682932c0a77061a5aa37c06e480a0c62": "Ybodychange",
    "3214171decf596f003c154685638b01faba31ff3": "Ybodychange",
    "446a7096ef01c0e3bb56736403d91b125b2ee6ba": "Ybodychange",
    "9bebb1eae78401e1d3289dc3d84006c10d10c0ef": "Ybodychange",
    "04b8168beb5fb9c7d4e9768cc99a82d0e6176dc2": "Ybodychange",
    "b6fc8e2f3cb1af6f7cbc624acfac01bec002baf8": "Ybodychange",
    "fe5437e96b91222e30d9105e7bab490fd68c2d52": "Ybodychange",
    "f32d65759c9afdcbec28eb3051ed9138b8e03271": "Ybodychange",
    "27b05c7d719754427a97c141b44bec7de3acb8db": "Ybodychange",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": "Ybodychange",
    "a9b87de97090b4f7d25ace0525edc1268cfa737f": "Ybodychange",
    "6ae4ed0f7da996bde2ba5cdc26daff979c9f6866": "Ybodychange",
    "ddd0fe257bc78dc9646407e7121769d0c03e0d94": "Ybodychange",
    "0ecb016d7db42ab83584cab3c1554d4d28cc5062": "Ybodychange",
    "cdd7c23446a0030e5b521d91cbb2d3a9c522ccc2": "Ybodychange",
    "217b2a7cc5366491be5317d20f3f3c1b6e3475bf": "Ybodychange",
    "744c370c1be8044d1ccaaf84cd164324961fea1a": "Ybodychange",
    "d3348e5623a2abf7b2f1356ea077d6eb9bf7760c": "Ybodychange",
    "0e73d395061d1bfee365acaa2f79c392175d13bf": "Ybodychange",
    "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386": "Ybodychange",
    "34dd64f6fe36ace1a90b0b503e2e37d877b7c621": "Ybodychange",
    "acd7ed52692bb7155333efea6dead712b7156ab9": "Ybodychange",
    "0b15b48f741f87277e0d1c7d29637430b880dbde": "Ybodychange",
    "d998bc938a21cb3871b442a3bb54b5807b6e4ed2": "Ybodychange",
    "056135a1482a9d56ee5055d6bc2df5bea032b5e5": "Ybodychange",
    "dc4c673902a0847b270faf1771595d7c189a1943": "Ymultichange(Yreturntypechange,Ybodychange)",
    "a44a687fedbf1559277b8e6706819aa9be7bce39": "Ybodychange",
    "0ad8fa7b36dafbea07da15897cc2f2b601772e24": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6658f367682932c0a77061a5aa37c06e480a0c62": {
      "type": "Ybodychange",
      "commitMessage": "Use project names instead of paths for the submodule name\n\nTwo submodules at the same path on different branches need not represent\nthe same repository, and two submodules at different paths can represent\nthe same one.\n\nThe C Git implementation uses the submodule name to internally manage\nthe submodule repositories under .git/modules. When a submodule\nrepresents different repositories in different branches, it makes a\nconflict inside .git/modules.\n\nThe current RepoCommand implementation uses submodule paths as the\nsubmodule names. When the manifest file mounts different repositories to\nthe same path in different branches, this makes a situation described\nabove. To solve this issue, we can use the project name instead of\nthe path as the submodule name.\n\nOn the other hand, since repo v1.12.8~3^2 (repo: Support multiple\nbranches for the same project., 2013-10-11), a manifest file can mount\nthe same project to different paths. If we naively use the project\nname as the submodule name, it makes a conflict in .git/modules, too.\n\nThis patch uses the project name as the submodule name basically, but\nwhen the same project is mounted to different paths, it uses the project\nname and path as the submodule name.\n\nChange-Id: I09dc7d62ba59016fe28852d3139a56ef7ef49b8f\nSigned-off-by: Masaya Suzuki \u003cmasayasuzuki@google.com\u003e\nReported-by: JP Sugarbroad \u003cjpsugar@google.com\u003e\n",
      "commitDate": "2018-07-27, 6:07 p.m.",
      "commitName": "6658f367682932c0a77061a5aa37c06e480a0c62",
      "commitAuthor": "Masaya Suzuki",
      "commitDateOld": "2018-07-20, 3:48 a.m.",
      "commitNameOld": "fb9031c9566308794f888695cafd108f19d835be",
      "commitAuthorOld": "Jonathan Nieder",
      "daysBetweenCommits": 7.6,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\tcheckCallable();\n\t\tif (baseUri \u003d\u003d null) {\n\t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n\t\t}\n\t\tif (inputStream \u003d\u003d null) {\n\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\ttry {\n\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t}\n\t\t}\n\n\t\tList\u003cRepoProject\u003e filteredProjects;\n\t\ttry {\n\t\t\tManifestParser parser \u003d new ManifestParser(includedReader,\n\t\t\t\t\tmanifestPath, branch, baseUri, groupsParam, repo);\n\t\t\tparser.read(inputStream);\n\t\t\tfilteredProjects \u003d parser.getFilteredProjects();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ManifestErrorException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tif (author \u003d\u003d null)\n\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\tif (callback \u003d\u003d null)\n\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\tList\u003cRepoProject\u003e renamedProjects \u003d renameProjects(filteredProjects);\n\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n\t\t\t\tfor (RepoProject proj : renamedProjects) {\n\t\t\t\t\tString name \u003d proj.getName();\n\t\t\t\t\tString path \u003d proj.getPath();\n\t\t\t\t\tString url \u003d proj.getUrl();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(url, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null \u0026\u0026 !ignoreRemoteFailures) {\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(url);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n\t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n\t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n\t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n\t\t\t\t\t\trec.append(path);\n\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\t\trec.append(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t\tattributes.append(rec.toString());\n\t\t\t\t\t}\n\n\t\t\t\t\tURI submodUrl \u003d URI.create(url);\n\t\t\t\t\tif (targetUri !\u003d null) {\n\t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\tsubmodUrl.toString());\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tif (objectId !\u003d null) {\n\t\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\turl, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n\t\t\t\t\t\t\tString link;\n\t\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n\t\t\t\t\t\t\t\tlink \u003d FileUtils.relativizeGitPath(\n\t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf(\u0027/\u0027)),\n\t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlink \u003d proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\t\tlink.getBytes(\n\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n\t\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(linkfile.dest);\n\t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n\t\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\tbuilder.add(dcEntryAttr);\n\t\t\t\t}\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tif (headId !\u003d null \u0026\u0026 rw.parseCommit(headId).getTree().getId().equals(treeId)) {\n\t\t\t\t\t// No change. Do nothing.\n\t\t\t\t\treturn rw.parseCommit(headId);\n\t\t\t\t}\n\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\ttry (Git git \u003d new Git(repo)) {\n\t\t\t\tfor (RepoProject proj : filteredProjects) {\n\t\t\t\t\taddSubmodule(proj.getName(), proj.getUrl(), proj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n\t\t\t\t\t\t\tproj.getLinkFiles(), git);\n\t\t\t\t}\n\t\t\t\treturn git.commit().setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t\t\t.call();\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 487,
      "functionName": "call",
      "diff": "@@ -1,217 +1,214 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (baseUri \u003d\u003d null) {\n \t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n \t\t}\n \t\tif (inputStream \u003d\u003d null) {\n \t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\ttry {\n \t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t}\n \t\t}\n \n \t\tList\u003cRepoProject\u003e filteredProjects;\n \t\ttry {\n \t\t\tManifestParser parser \u003d new ManifestParser(includedReader,\n \t\t\t\t\tmanifestPath, branch, baseUri, groupsParam, repo);\n \t\t\tparser.read(inputStream);\n \t\t\tfilteredProjects \u003d parser.getFilteredProjects();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n-\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n \t\t\tif (author \u003d\u003d null)\n \t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\tif (callback \u003d\u003d null)\n \t\t\t\tcallback \u003d new DefaultRemoteReader();\n-\t\t\tfor (RepoProject proj : filteredProjects) {\n-\t\t\t\taddSubmoduleBare(proj.getUrl(), proj.getPath(),\n-\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n-\t\t\t\t\t\tproj.getLinkFiles(), proj.getGroups(),\n-\t\t\t\t\t\tproj.getRecommendShallow());\n-\t\t\t}\n+\t\t\tList\u003cRepoProject\u003e renamedProjects \u003d renameProjects(filteredProjects);\n+\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n-\t\t\t\tfor (RepoProject proj : bareProjects) {\n+\t\t\t\tfor (RepoProject proj : renamedProjects) {\n+\t\t\t\t\tString name \u003d proj.getName();\n \t\t\t\t\tString path \u003d proj.getPath();\n-\t\t\t\t\tString nameUri \u003d proj.getName();\n+\t\t\t\t\tString url \u003d proj.getUrl();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n+\t\t\t\t\t\tobjectId \u003d callback.sha1(url, proj.getRevision());\n \t\t\t\t\t\tif (objectId \u003d\u003d null \u0026\u0026 !ignoreRemoteFailures) {\n-\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n+\t\t\t\t\t\t\tthrow new RemoteUnavailableException(url);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n-\t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n \t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n \t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n-\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \n-\t\t\t\t\tURI submodUrl \u003d URI.create(nameUri);\n+\t\t\t\t\tURI submodUrl \u003d URI.create(url);\n \t\t\t\t\tif (targetUri !\u003d null) {\n \t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n \t\t\t\t\t}\n-\t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n-\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\tsubmodUrl.toString());\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tif (objectId !\u003d null) {\n \t\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n-\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n+\t\t\t\t\t\t\t\turl, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n \t\t\t\t\t\t\tString link;\n \t\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n \t\t\t\t\t\t\t\tlink \u003d FileUtils.relativizeGitPath(\n \t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n \t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf(\u0027/\u0027)),\n \t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tlink \u003d proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\t\tlink.getBytes(\n \t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(linkfile.dest);\n \t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n \t\t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tif (headId !\u003d null \u0026\u0026 rw.parseCommit(headId).getTree().getId().equals(treeId)) {\n \t\t\t\t\t// No change. Do nothing.\n \t\t\t\t\treturn rw.parseCommit(headId);\n \t\t\t\t}\n \n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\ttry (Git git \u003d new Git(repo)) {\n \t\t\t\tfor (RepoProject proj : filteredProjects) {\n-\t\t\t\t\taddSubmodule(proj.getUrl(), proj.getPath(),\n+\t\t\t\t\taddSubmodule(proj.getName(), proj.getUrl(), proj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getLinkFiles(), git);\n \t\t\t\t}\n \t\t\t\treturn git.commit().setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t\t\t.call();\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3214171decf596f003c154685638b01faba31ff3": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: don\u0027t record new commit if tree did not change\n\nSigned-off-by: Han-Wen Nienhuys \u003chanwen@google.com\u003e\nChange-Id: Ib6509e816684256d723558d5e8f3c37de58a2ff8\n",
      "commitDate": "2018-02-19, 6:24 a.m.",
      "commitName": "3214171decf596f003c154685638b01faba31ff3",
      "commitAuthor": "Han-Wen Nienhuys",
      "commitDateOld": "2018-02-19, 6:24 a.m.",
      "commitNameOld": "446a7096ef01c0e3bb56736403d91b125b2ee6ba",
      "commitAuthorOld": "Han-Wen Nienhuys",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\tcheckCallable();\n\t\tif (baseUri \u003d\u003d null) {\n\t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n\t\t}\n\t\tif (inputStream \u003d\u003d null) {\n\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\ttry {\n\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t}\n\t\t}\n\n\t\tList\u003cRepoProject\u003e filteredProjects;\n\t\ttry {\n\t\t\tManifestParser parser \u003d new ManifestParser(includedReader,\n\t\t\t\t\tmanifestPath, branch, baseUri, groupsParam, repo);\n\t\t\tparser.read(inputStream);\n\t\t\tfilteredProjects \u003d parser.getFilteredProjects();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ManifestErrorException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n\t\t\tif (author \u003d\u003d null)\n\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\tif (callback \u003d\u003d null)\n\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\tfor (RepoProject proj : filteredProjects) {\n\t\t\t\taddSubmoduleBare(proj.getUrl(), proj.getPath(),\n\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n\t\t\t\t\t\tproj.getLinkFiles(), proj.getGroups(),\n\t\t\t\t\t\tproj.getRecommendShallow());\n\t\t\t}\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString path \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null \u0026\u0026 !ignoreRemoteFailures) {\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n\t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n\t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n\t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n\t\t\t\t\t\trec.append(path);\n\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\t\trec.append(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t\tattributes.append(rec.toString());\n\t\t\t\t\t}\n\n\t\t\t\t\tURI submodUrl \u003d URI.create(nameUri);\n\t\t\t\t\tif (targetUri !\u003d null) {\n\t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tif (objectId !\u003d null) {\n\t\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n\t\t\t\t\t\t\tString link;\n\t\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n\t\t\t\t\t\t\t\tlink \u003d FileUtils.relativizeGitPath(\n\t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf(\u0027/\u0027)),\n\t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlink \u003d proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\t\tlink.getBytes(\n\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n\t\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(linkfile.dest);\n\t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n\t\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\tbuilder.add(dcEntryAttr);\n\t\t\t\t}\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tif (headId !\u003d null \u0026\u0026 rw.parseCommit(headId).getTree().getId().equals(treeId)) {\n\t\t\t\t\t// No change. Do nothing.\n\t\t\t\t\treturn rw.parseCommit(headId);\n\t\t\t\t}\n\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\ttry (Git git \u003d new Git(repo)) {\n\t\t\t\tfor (RepoProject proj : filteredProjects) {\n\t\t\t\t\taddSubmodule(proj.getUrl(), proj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n\t\t\t\t\t\t\tproj.getLinkFiles(), git);\n\t\t\t\t}\n\t\t\t\treturn git.commit().setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t\t\t.call();\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 487,
      "functionName": "call",
      "diff": "@@ -1,212 +1,217 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (baseUri \u003d\u003d null) {\n \t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n \t\t}\n \t\tif (inputStream \u003d\u003d null) {\n \t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\ttry {\n \t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t}\n \t\t}\n \n \t\tList\u003cRepoProject\u003e filteredProjects;\n \t\ttry {\n \t\t\tManifestParser parser \u003d new ManifestParser(includedReader,\n \t\t\t\t\tmanifestPath, branch, baseUri, groupsParam, repo);\n \t\t\tparser.read(inputStream);\n \t\t\tfilteredProjects \u003d parser.getFilteredProjects();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n \t\t\tif (author \u003d\u003d null)\n \t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\tif (callback \u003d\u003d null)\n \t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\tfor (RepoProject proj : filteredProjects) {\n \t\t\t\taddSubmoduleBare(proj.getUrl(), proj.getPath(),\n \t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n \t\t\t\t\t\tproj.getLinkFiles(), proj.getGroups(),\n \t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t}\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId \u003d\u003d null \u0026\u0026 !ignoreRemoteFailures) {\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n \t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n \t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \n \t\t\t\t\tURI submodUrl \u003d URI.create(nameUri);\n \t\t\t\t\tif (targetUri !\u003d null) {\n \t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tif (objectId !\u003d null) {\n \t\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n \t\t\t\t\t\t\tString link;\n \t\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n \t\t\t\t\t\t\t\tlink \u003d FileUtils.relativizeGitPath(\n \t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n \t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf(\u0027/\u0027)),\n \t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tlink \u003d proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\t\tlink.getBytes(\n \t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(linkfile.dest);\n \t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n \t\t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n+\t\t\t\tif (headId !\u003d null \u0026\u0026 rw.parseCommit(headId).getTree().getId().equals(treeId)) {\n+\t\t\t\t\t// No change. Do nothing.\n+\t\t\t\t\treturn rw.parseCommit(headId);\n+\t\t\t\t}\n+\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\ttry (Git git \u003d new Git(repo)) {\n \t\t\t\tfor (RepoProject proj : filteredProjects) {\n \t\t\t\t\taddSubmodule(proj.getUrl(), proj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getLinkFiles(), git);\n \t\t\t\t}\n \t\t\t\treturn git.commit().setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t\t\t.call();\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "446a7096ef01c0e3bb56736403d91b125b2ee6ba": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: persist unreadable submodules in .gitmodules\n\nIn cases where a manifest file mixes different remotes, a Gerrit\nserver process may not have access to all remotes, and won\u0027t be able\nto produce a full submodule tree.\n\nPreserving this information in .gitmodules will let downstream clients\nreconstruct the full tree.\n\nSigned-off-by: Han-Wen Nienhuys \u003chanwen@google.com\u003e\nChange-Id: I52f5d3f288e771dca0af2b4dd3f3fa0f940dcf15\n",
      "commitDate": "2018-02-19, 6:24 a.m.",
      "commitName": "446a7096ef01c0e3bb56736403d91b125b2ee6ba",
      "commitAuthor": "Han-Wen Nienhuys",
      "commitDateOld": "2018-02-15, 2:59 a.m.",
      "commitNameOld": "9bebb1eae78401e1d3289dc3d84006c10d10c0ef",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 4.14,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\tcheckCallable();\n\t\tif (baseUri \u003d\u003d null) {\n\t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n\t\t}\n\t\tif (inputStream \u003d\u003d null) {\n\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\ttry {\n\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t}\n\t\t}\n\n\t\tList\u003cRepoProject\u003e filteredProjects;\n\t\ttry {\n\t\t\tManifestParser parser \u003d new ManifestParser(includedReader,\n\t\t\t\t\tmanifestPath, branch, baseUri, groupsParam, repo);\n\t\t\tparser.read(inputStream);\n\t\t\tfilteredProjects \u003d parser.getFilteredProjects();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ManifestErrorException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n\t\t\tif (author \u003d\u003d null)\n\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\tif (callback \u003d\u003d null)\n\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\tfor (RepoProject proj : filteredProjects) {\n\t\t\t\taddSubmoduleBare(proj.getUrl(), proj.getPath(),\n\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n\t\t\t\t\t\tproj.getLinkFiles(), proj.getGroups(),\n\t\t\t\t\t\tproj.getRecommendShallow());\n\t\t\t}\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString path \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null \u0026\u0026 !ignoreRemoteFailures) {\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n\t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n\t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n\t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n\t\t\t\t\t\trec.append(path);\n\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\t\trec.append(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t\tattributes.append(rec.toString());\n\t\t\t\t\t}\n\n\t\t\t\t\tURI submodUrl \u003d URI.create(nameUri);\n\t\t\t\t\tif (targetUri !\u003d null) {\n\t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tif (objectId !\u003d null) {\n\t\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n\t\t\t\t\t\t\tString link;\n\t\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n\t\t\t\t\t\t\t\tlink \u003d FileUtils.relativizeGitPath(\n\t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf(\u0027/\u0027)),\n\t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlink \u003d proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\t\tlink.getBytes(\n\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n\t\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(linkfile.dest);\n\t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n\t\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\tbuilder.add(dcEntryAttr);\n\t\t\t\t}\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\ttry (Git git \u003d new Git(repo)) {\n\t\t\t\tfor (RepoProject proj : filteredProjects) {\n\t\t\t\t\taddSubmodule(proj.getUrl(), proj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n\t\t\t\t\t\t\tproj.getLinkFiles(), git);\n\t\t\t\t}\n\t\t\t\treturn git.commit().setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t\t\t.call();\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 487,
      "functionName": "call",
      "diff": "@@ -1,213 +1,212 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (baseUri \u003d\u003d null) {\n \t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n \t\t}\n \t\tif (inputStream \u003d\u003d null) {\n \t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\ttry {\n \t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t}\n \t\t}\n \n \t\tList\u003cRepoProject\u003e filteredProjects;\n \t\ttry {\n \t\t\tManifestParser parser \u003d new ManifestParser(includedReader,\n \t\t\t\t\tmanifestPath, branch, baseUri, groupsParam, repo);\n \t\t\tparser.read(inputStream);\n \t\t\tfilteredProjects \u003d parser.getFilteredProjects();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n \t\t\tif (author \u003d\u003d null)\n \t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\tif (callback \u003d\u003d null)\n \t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\tfor (RepoProject proj : filteredProjects) {\n \t\t\t\taddSubmoduleBare(proj.getUrl(), proj.getPath(),\n \t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n \t\t\t\t\t\tproj.getLinkFiles(), proj.getGroups(),\n \t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t}\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n-\t\t\t\t\t\tif (objectId \u003d\u003d null) {\n-\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n-\t\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (objectId \u003d\u003d null \u0026\u0026 !ignoreRemoteFailures) {\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n \t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n \t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \n \t\t\t\t\tURI submodUrl \u003d URI.create(nameUri);\n \t\t\t\t\tif (targetUri !\u003d null) {\n \t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n-\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n-\t\t\t\t\tdcEntry.setObjectId(objectId);\n-\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n-\t\t\t\t\tbuilder.add(dcEntry);\n+\t\t\t\t\tif (objectId !\u003d null) {\n+\t\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n+\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n+\t\t\t\t\t\tbuilder.add(dcEntry);\n \n-\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n-\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n+\t\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n+\t\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n-\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n-\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n-\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n-\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n-\t\t\t\t\t\tbuilder.add(dcEntry);\n-\t\t\t\t\t}\n-\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n-\t\t\t\t\t\tString link;\n-\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n-\t\t\t\t\t\t\tlink \u003d FileUtils.relativizeGitPath(\n-\t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n-\t\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf(\u0027/\u0027)),\n-\t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tlink \u003d proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n+\t\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n+\t\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n+\t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n+\t\t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n+\t\t\t\t\t\t\tString link;\n+\t\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n+\t\t\t\t\t\t\t\tlink \u003d FileUtils.relativizeGitPath(\n+\t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n+\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf(\u0027/\u0027)),\n+\t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tlink \u003d proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n+\t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB,\n+\t\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\t\tlink.getBytes(\n-\t\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n-\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(linkfile.dest);\n-\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n-\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n-\t\t\t\t\t\tbuilder.add(dcEntry);\n+\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n+\t\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(linkfile.dest);\n+\t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n+\t\t\t\t\t\t\tbuilder.add(dcEntry);\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\ttry (Git git \u003d new Git(repo)) {\n \t\t\t\tfor (RepoProject proj : filteredProjects) {\n \t\t\t\t\taddSubmodule(proj.getUrl(), proj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getLinkFiles(), git);\n \t\t\t\t}\n \t\t\t\treturn git.commit().setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t\t\t.call();\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9bebb1eae78401e1d3289dc3d84006c10d10c0ef": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: Don\u0027t leave Git open\n\nWhen the command is run on a non-bare repository, an instance of\nGit is created to execute the commit, and is left open when the\ncommand has finished.\n\nRefactor to not use a class scope Git instance, and make sure it\ngets closed before returning.\n\nChange-Id: Ic623ae0fd8b9e264b5dfd434da0de6bb4f910984\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018-02-15, 2:59 a.m.",
      "commitName": "9bebb1eae78401e1d3289dc3d84006c10d10c0ef",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017-12-18, 7:19 a.m.",
      "commitNameOld": "5e2e111280898e47959996a1a1e016e9fcb21179",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 58.82,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\tcheckCallable();\n\t\tif (baseUri \u003d\u003d null) {\n\t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n\t\t}\n\t\tif (inputStream \u003d\u003d null) {\n\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\ttry {\n\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t}\n\t\t}\n\n\t\tList\u003cRepoProject\u003e filteredProjects;\n\t\ttry {\n\t\t\tManifestParser parser \u003d new ManifestParser(includedReader,\n\t\t\t\t\tmanifestPath, branch, baseUri, groupsParam, repo);\n\t\t\tparser.read(inputStream);\n\t\t\tfilteredProjects \u003d parser.getFilteredProjects();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ManifestErrorException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n\t\t\tif (author \u003d\u003d null)\n\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\tif (callback \u003d\u003d null)\n\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\tfor (RepoProject proj : filteredProjects) {\n\t\t\t\taddSubmoduleBare(proj.getUrl(), proj.getPath(),\n\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n\t\t\t\t\t\tproj.getLinkFiles(), proj.getGroups(),\n\t\t\t\t\t\tproj.getRecommendShallow());\n\t\t\t}\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString path \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n\t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n\t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n\t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n\t\t\t\t\t\trec.append(path);\n\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\t\trec.append(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t\tattributes.append(rec.toString());\n\t\t\t\t\t}\n\n\t\t\t\t\tURI submodUrl \u003d URI.create(nameUri);\n\t\t\t\t\tif (targetUri !\u003d null) {\n\t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n\t\t\t\t\t\tString link;\n\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n\t\t\t\t\t\t\tlink \u003d FileUtils.relativizeGitPath(\n\t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n\t\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf(\u0027/\u0027)),\n\t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlink \u003d proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\t\tlink.getBytes(\n\t\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(linkfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\tbuilder.add(dcEntryAttr);\n\t\t\t\t}\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\ttry (Git git \u003d new Git(repo)) {\n\t\t\t\tfor (RepoProject proj : filteredProjects) {\n\t\t\t\t\taddSubmodule(proj.getUrl(), proj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n\t\t\t\t\t\t\tproj.getLinkFiles(), git);\n\t\t\t\t}\n\t\t\t\treturn git.commit().setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t\t\t.call();\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 487,
      "functionName": "call",
      "diff": "@@ -1,214 +1,213 @@\n \tpublic RevCommit call() throws GitAPIException {\n-\t\ttry {\n-\t\t\tcheckCallable();\n-\t\t\tif (baseUri \u003d\u003d null) {\n-\t\t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n-\t\t\t}\n-\t\t\tif (inputStream \u003d\u003d null) {\n-\t\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n-\t\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n-\t\t\t\ttry {\n-\t\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (repo.isBare()) {\n-\t\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n-\t\t\t\tif (author \u003d\u003d null)\n-\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n-\t\t\t\tif (callback \u003d\u003d null)\n-\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n-\t\t\t} else\n-\t\t\t\tgit \u003d new Git(repo);\n-\n-\t\t\tManifestParser parser \u003d new ManifestParser(\n-\t\t\t\t\tincludedReader, manifestPath, branch, baseUri, groupsParam, repo);\n+\t\tcheckCallable();\n+\t\tif (baseUri \u003d\u003d null) {\n+\t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n+\t\t}\n+\t\tif (inputStream \u003d\u003d null) {\n+\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n+\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\ttry {\n-\t\t\t\tparser.read(inputStream);\n-\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n-\t\t\t\t\taddSubmodule(proj.getUrl(),\n-\t\t\t\t\t\t\tproj.getPath(),\n-\t\t\t\t\t\t\tproj.getRevision(),\n-\t\t\t\t\t\t\tproj.getCopyFiles(),\n-\t\t\t\t\t\t\tproj.getLinkFiles(),\n-\t\t\t\t\t\t\tproj.getGroups(),\n-\t\t\t\t\t\t\tproj.getRecommendShallow());\n-\t\t\t\t}\n-\t\t\t} catch (GitAPIException | IOException e) {\n-\t\t\t\tthrow new ManifestErrorException(e);\n+\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t}\n+\t\t}\n+\n+\t\tList\u003cRepoProject\u003e filteredProjects;\n+\t\ttry {\n+\t\t\tManifestParser parser \u003d new ManifestParser(includedReader,\n+\t\t\t\t\tmanifestPath, branch, baseUri, groupsParam, repo);\n+\t\t\tparser.read(inputStream);\n+\t\t\tfilteredProjects \u003d parser.getFilteredProjects();\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new ManifestErrorException(e);\n \t\t} finally {\n \t\t\ttry {\n-\t\t\t\tif (inputStream !\u003d null)\n-\t\t\t\t\tinputStream.close();\n+\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n+\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n+\t\t\tif (author \u003d\u003d null)\n+\t\t\t\tauthor \u003d new PersonIdent(repo);\n+\t\t\tif (callback \u003d\u003d null)\n+\t\t\t\tcallback \u003d new DefaultRemoteReader();\n+\t\t\tfor (RepoProject proj : filteredProjects) {\n+\t\t\t\taddSubmoduleBare(proj.getUrl(), proj.getPath(),\n+\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n+\t\t\t\t\t\tproj.getLinkFiles(), proj.getGroups(),\n+\t\t\t\t\t\tproj.getRecommendShallow());\n+\t\t\t}\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n \t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n \t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \n \t\t\t\t\tURI submodUrl \u003d URI.create(nameUri);\n \t\t\t\t\tif (targetUri !\u003d null) {\n \t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n \t\t\t\t\t\tString link;\n \t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n \t\t\t\t\t\t\tlink \u003d FileUtils.relativizeGitPath(\n \t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n \t\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf(\u0027/\u0027)),\n \t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tlink \u003d proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\t\tlink.getBytes(\n \t\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(linkfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n-\t\t\t} catch (IOException e) {\n+\t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n-\t\t\treturn git\n-\t\t\t\t.commit()\n-\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n-\t\t\t\t.call();\n+\t\t\ttry (Git git \u003d new Git(repo)) {\n+\t\t\t\tfor (RepoProject proj : filteredProjects) {\n+\t\t\t\t\taddSubmodule(proj.getUrl(), proj.getPath(),\n+\t\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n+\t\t\t\t\t\t\tproj.getLinkFiles(), git);\n+\t\t\t\t}\n+\t\t\t\treturn git.commit().setMessage(RepoText.get().repoCommitMessage)\n+\t\t\t\t\t\t.call();\n+\t\t\t} catch (GitAPIException | IOException e) {\n+\t\t\t\tthrow new ManifestErrorException(e);\n+\t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "04b8168beb5fb9c7d4e9768cc99a82d0e6176dc2": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: Skip RemoteReader when encountering a full SHA-1\n\nThere is no point in calling back to the RemoteReader to resolve a\n40-digit hex SHA-1 to itself.  We already skip that call when not\nignoring remote failures; skip it when ignoring remote failures, too.\n\nThis should simplify RemoteReader implementations.\n\nReported-by: Han-Wen Nienhuys \u003chanwen@google.com\u003e\nChange-Id: I7566968ed1f39b1ad73574fa903faf3ee308eb87\n",
      "commitDate": "2017-11-28, 11:17 a.m.",
      "commitName": "04b8168beb5fb9c7d4e9768cc99a82d0e6176dc2",
      "commitAuthor": "Jonathan Nieder",
      "commitDateOld": "2017-08-29, 9:07 p.m.",
      "commitNameOld": "e9fb111182b55cc82c530d82f13176c7a85cd958",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 90.63,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (baseUri \u003d\u003d null) {\n\t\t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n\t\t\t}\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, manifestPath, branch, baseUri, groupsParam, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.getUrl(),\n\t\t\t\t\t\t\tproj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.getCopyFiles(),\n\t\t\t\t\t\t\tproj.getLinkFiles(),\n\t\t\t\t\t\t\tproj.getGroups(),\n\t\t\t\t\t\t\tproj.getRecommendShallow());\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString path \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n\t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n\t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n\t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n\t\t\t\t\t\trec.append(path);\n\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\t\trec.append(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t\tattributes.append(rec.toString());\n\t\t\t\t\t}\n\n\t\t\t\t\tURI submodUrl \u003d URI.create(nameUri);\n\t\t\t\t\tif (targetUri !\u003d null) {\n\t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n\t\t\t\t\t\tString link;\n\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n\t\t\t\t\t\t\tlink \u003d FileUtils.relativizeGitPath(\n\t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n\t\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf(\u0027/\u0027)),\n\t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlink \u003d proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\t\tlink.getBytes(\n\t\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(linkfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\tbuilder.add(dcEntryAttr);\n\t\t\t\t}\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 474,
      "functionName": "call",
      "diff": "@@ -1,215 +1,214 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (baseUri \u003d\u003d null) {\n \t\t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n \t\t\t}\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tManifestParser parser \u003d new ManifestParser(\n \t\t\t\t\tincludedReader, manifestPath, branch, baseUri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getLinkFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tObjectId objectId;\n-\t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n-\t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n+\t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n \t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n \t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \n \t\t\t\t\tURI submodUrl \u003d URI.create(nameUri);\n \t\t\t\t\tif (targetUri !\u003d null) {\n \t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n \t\t\t\t\t\tString link;\n \t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n \t\t\t\t\t\t\tlink \u003d FileUtils.relativizeGitPath(\n \t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n \t\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf(\u0027/\u0027)),\n \t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tlink \u003d proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\t\tlink.getBytes(\n \t\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(linkfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b6fc8e2f3cb1af6f7cbc624acfac01bec002baf8": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: Add linkfile support.\n\nAndroid wants them to work, and we\u0027re only interested in them for bare\nrepos, so add them just for that.\n\nMake sure to use symlinks instead of just using the copyfile\nimplementation. Some scripts look up where they\u0027re actually located in\norder to find related files, so they need the link back to their\nproject.\n\nChange-Id: I929b69b2505f03036f69e25a55daf93842871f30\nSigned-off-by: Dan Willemsen \u003cdwillemsen@google.com\u003e\nSigned-off-by: Stefan Beller \u003csbeller@google.com\u003e\nSigned-off-by: Jeff Gaston \u003cjeffrygaston@google.com\u003e\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017-04-18, 4:33 a.m.",
      "commitName": "b6fc8e2f3cb1af6f7cbc624acfac01bec002baf8",
      "commitAuthor": "Dan Willemsen",
      "commitDateOld": "2017-04-14, 1:49 p.m.",
      "commitNameOld": "3af4afdfbfed7ed97424b91d08bf55c3b23c0b9b",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 3.61,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (baseUri \u003d\u003d null) {\n\t\t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n\t\t\t}\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, manifestPath, branch, baseUri, groupsParam, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.getUrl(),\n\t\t\t\t\t\t\tproj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.getCopyFiles(),\n\t\t\t\t\t\t\tproj.getLinkFiles(),\n\t\t\t\t\t\t\tproj.getGroups(),\n\t\t\t\t\t\t\tproj.getRecommendShallow());\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString path \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n\t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n\t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n\t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n\t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n\t\t\t\t\t\trec.append(path);\n\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\t\trec.append(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t\tattributes.append(rec.toString());\n\t\t\t\t\t}\n\n\t\t\t\t\tURI submodUrl \u003d URI.create(nameUri);\n\t\t\t\t\tif (targetUri !\u003d null) {\n\t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n\t\t\t\t\t\tString link;\n\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n\t\t\t\t\t\t\tlink \u003d FileUtils.relativizeGitPath(\n\t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n\t\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf(\u0027/\u0027)),\n\t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlink \u003d proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\t\tlink.getBytes(\n\t\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(linkfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\tbuilder.add(dcEntryAttr);\n\t\t\t\t}\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 475,
      "functionName": "call",
      "diff": "@@ -1,195 +1,215 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (baseUri \u003d\u003d null) {\n \t\t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n \t\t\t}\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tManifestParser parser \u003d new ManifestParser(\n \t\t\t\t\tincludedReader, manifestPath, branch, baseUri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n+\t\t\t\t\t\t\tproj.getLinkFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n \t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n \t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \n \t\t\t\t\tURI submodUrl \u003d URI.create(nameUri);\n \t\t\t\t\tif (targetUri !\u003d null) {\n \t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n+\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n+\t\t\t\t\t\tString link;\n+\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n+\t\t\t\t\t\t\tlink \u003d FileUtils.relativizeGitPath(\n+\t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n+\t\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf(\u0027/\u0027)),\n+\t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tlink \u003d proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB,\n+\t\t\t\t\t\t\t\tlink.getBytes(\n+\t\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n+\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(linkfile.dest);\n+\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n+\t\t\t\t\t\tbuilder.add(dcEntry);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fe5437e96b91222e30d9105e7bab490fd68c2d52": {
      "type": "Ybodychange",
      "commitMessage": "Fix RepoCommand to allow for relative URLs\n\nThis is necessary for deploying submodules on android.googlesource.com.\n\n* Allow an empty base URL. This is useful if the \u0027fetch\u0027 field is \".\"\n  and all names are relative to some host root.\n\n* The URLs in the resulting superproject are relative to the\n  superproject\u0027s URL. Add RepoCommand#setDestinationURI to\n  set this. If unset, the existing behavior is maintained.\n\n* Add two tests for the Android and Gerrit case, checking the URL\n  format in .gitmodules; the tests use a custom RemoteReader which is\n  representative of the use of this class in Gerrit\u0027s Supermanifest\n  plugin.\n\nChange-Id: Ia75530226120d75aa0017c5410fd65d0563e91b\nSigned-off-by: Han-Wen Nienhuys \u003chanwen@google.com\u003e\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017-04-12, 9:53 p.m.",
      "commitName": "fe5437e96b91222e30d9105e7bab490fd68c2d52",
      "commitAuthor": "Han-Wen Nienhuys",
      "commitDateOld": "2017-03-29, 10:54 a.m.",
      "commitNameOld": "f32d65759c9afdcbec28eb3051ed9138b8e03271",
      "commitAuthorOld": "Han-Wen Nienhuys",
      "daysBetweenCommits": 14.46,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (baseUri \u003d\u003d null) {\n\t\t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n\t\t\t}\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, manifestPath, branch, baseUri, groupsParam, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.getUrl(),\n\t\t\t\t\t\t\tproj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.getCopyFiles(),\n\t\t\t\t\t\t\tproj.getGroups(),\n\t\t\t\t\t\t\tproj.getRecommendShallow());\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString path \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n\t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n\t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n\t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n\t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n\t\t\t\t\t\trec.append(path);\n\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\t\trec.append(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t\tattributes.append(rec.toString());\n\t\t\t\t\t}\n\n\t\t\t\t\tURI submodUrl \u003d URI.create(nameUri);\n\t\t\t\t\tif (targetUri !\u003d null) {\n\t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\tbuilder.add(dcEntryAttr);\n\t\t\t\t}\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 471,
      "functionName": "call",
      "diff": "@@ -1,191 +1,195 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n-\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0) {\n-\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\tJGitText.get().uriNotConfigured);\n+\t\t\tif (baseUri \u003d\u003d null) {\n+\t\t\t\tbaseUri \u003d \"\"; //$NON-NLS-1$\n \t\t\t}\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tManifestParser parser \u003d new ManifestParser(\n-\t\t\t\t\tincludedReader, manifestPath, branch, uri, groupsParam, repo);\n+\t\t\t\t\tincludedReader, manifestPath, branch, baseUri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n \t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n \t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n+\n+\t\t\t\t\tURI submodUrl \u003d URI.create(nameUri);\n+\t\t\t\t\tif (targetUri !\u003d null) {\n+\t\t\t\t\t\tsubmodUrl \u003d relativize(targetUri, submodUrl);\n+\t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n-\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f32d65759c9afdcbec28eb3051ed9138b8e03271": {
      "type": "Ybodychange",
      "commitMessage": "Document the intended use of RepoCommand#setURI()\n\nSigned-off-by: Han-Wen Nienhuys \u003chanwen@google.com\u003e\nChange-Id: I4a59dd8278b7b0026094692127b7f55e89c10bae\n",
      "commitDate": "2017-03-29, 10:54 a.m.",
      "commitName": "f32d65759c9afdcbec28eb3051ed9138b8e03271",
      "commitAuthor": "Han-Wen Nienhuys",
      "commitDateOld": "2017-03-27, 5:36 p.m.",
      "commitNameOld": "27b05c7d719754427a97c141b44bec7de3acb8db",
      "commitAuthorOld": "Han-Wen Nienhuys",
      "daysBetweenCommits": 1.72,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\t}\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, manifestPath, branch, uri, groupsParam, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.getUrl(),\n\t\t\t\t\t\t\tproj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.getCopyFiles(),\n\t\t\t\t\t\t\tproj.getGroups(),\n\t\t\t\t\t\t\tproj.getRecommendShallow());\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString path \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n\t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n\t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n\t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n\t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n\t\t\t\t\t\trec.append(path);\n\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\t\trec.append(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t\tattributes.append(rec.toString());\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\tbuilder.add(dcEntryAttr);\n\t\t\t\t}\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 452,
      "functionName": "call",
      "diff": "@@ -1,190 +1,191 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n-\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n+\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0) {\n \t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n+\t\t\t\t\tJGitText.get().uriNotConfigured);\n+\t\t\t}\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tManifestParser parser \u003d new ManifestParser(\n \t\t\t\t\tincludedReader, manifestPath, branch, uri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n \t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n \t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "27b05c7d719754427a97c141b44bec7de3acb8db": {
      "type": "Ybodychange",
      "commitMessage": "Consistently use \u0027path\u0027 for the path to a subrepo in RepoCommand\n\nSigned-off-by: Han-Wen Nienhuys \u003chanwen@google.com\u003e\nChange-Id: I79ea7eb7b4d319e0100e3121aca5ef82eb8ad92a\n",
      "commitDate": "2017-03-27, 5:36 p.m.",
      "commitName": "27b05c7d719754427a97c141b44bec7de3acb8db",
      "commitAuthor": "Han-Wen Nienhuys",
      "commitDateOld": "2017-02-20, 4:47 p.m.",
      "commitNameOld": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 34.99,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, manifestPath, branch, uri, groupsParam, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.getUrl(),\n\t\t\t\t\t\t\tproj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.getCopyFiles(),\n\t\t\t\t\t\t\tproj.getGroups(),\n\t\t\t\t\t\t\tproj.getRecommendShallow());\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString path \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n\t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n\t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n\t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n\t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n\t\t\t\t\t\trec.append(path);\n\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\t\trec.append(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t\tattributes.append(rec.toString());\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\tbuilder.add(dcEntryAttr);\n\t\t\t\t}\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 448,
      "functionName": "call",
      "diff": "@@ -1,190 +1,190 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream \u003d\u003d null) {\n-\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n+\t\t\t\tif (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n-\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n+\t\t\t\t\tinputStream \u003d new FileInputStream(manifestPath);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tManifestParser parser \u003d new ManifestParser(\n-\t\t\t\t\tincludedReader, path, branch, uri, groupsParam, repo);\n+\t\t\t\t\tincludedReader, manifestPath, branch, uri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n-\t\t\t\t\tString name \u003d proj.getPath();\n+\t\t\t\t\tString path \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n-\t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n \t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n \t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n-\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n-\t\t\t\t\t\trec.append(name);\n+\t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n-\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n-\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n-\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n+\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
      "type": "Ybodychange",
      "commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit\u0027s not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017-02-20, 4:47 p.m.",
      "commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017-02-19, 7:05 p.m.",
      "commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, path, branch, uri, groupsParam, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.getUrl(),\n\t\t\t\t\t\t\tproj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.getCopyFiles(),\n\t\t\t\t\t\t\tproj.getGroups(),\n\t\t\t\t\t\t\tproj.getRecommendShallow());\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n\t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n\t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n\t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n\t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n\t\t\t\t\t\trec.append(name);\n\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\t\trec.append(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t\tattributes.append(rec.toString());\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\tbuilder.add(dcEntryAttr);\n\t\t\t\t}\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 448,
      "functionName": "call",
      "diff": "@@ -1,190 +1,190 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n-\t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n+\t\t\t\tbareProjects \u003d new ArrayList\u003c\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tManifestParser parser \u003d new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n \t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n \t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(name);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a9b87de97090b4f7d25ace0525edc1268cfa737f": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: Avoid group lists shadowing groups strings\n\nReported-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\nChange-Id: I9e9b021d335bda4d58b6bcc30f59b81ac5b37724\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
      "commitDate": "2016-08-08, 9:51 p.m.",
      "commitName": "a9b87de97090b4f7d25ace0525edc1268cfa737f",
      "commitAuthor": "Jonathan Nieder",
      "commitDateOld": "2016-06-01, 4:17 a.m.",
      "commitNameOld": "525baa1213097aa8635d846ce024635b1f33931a",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 68.73,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, path, branch, uri, groupsParam, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.getUrl(),\n\t\t\t\t\t\t\tproj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.getCopyFiles(),\n\t\t\t\t\t\t\tproj.getGroups(),\n\t\t\t\t\t\t\tproj.getRecommendShallow());\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n\t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n\t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n\t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n\t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n\t\t\t\t\t\trec.append(name);\n\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\t\trec.append(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t\tattributes.append(rec.toString());\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\tbuilder.add(dcEntryAttr);\n\t\t\t\t}\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 453,
      "functionName": "call",
      "diff": "@@ -1,190 +1,190 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tManifestParser parser \u003d new ManifestParser(\n-\t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n+\t\t\t\t\tincludedReader, path, branch, uri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n \t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n \t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(name);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6ae4ed0f7da996bde2ba5cdc26daff979c9f6866": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: record manifest shallow recommendation in .gitmodules\n\nGit core learned about the submodule.\u003cname\u003e.shallow option in\n.gitmodules files, which is a recommendation to clone a submodule\nshallow. A repo manifest may record a clone depth recommendation as\nan optional field, which contains more information than a binary\nshallow/nonshallow recommendation, so any attempted conversion may be\nlossy. In practice the clone depth recommendation is either \u00271\u0027 or doesn\u0027t\nexist, which is the binary behavior we have in Git core.\n\nChange-Id: I51aa9cb6d1d9660dae6ab6d21ad7bae9bc5325e6\nSigned-off-by: Stefan Beller \u003csbeller@google.com\u003e\n",
      "commitDate": "2016-05-31, 6:19 p.m.",
      "commitName": "6ae4ed0f7da996bde2ba5cdc26daff979c9f6866",
      "commitAuthor": "Stefan Beller",
      "commitDateOld": "2016-05-31, 6:18 p.m.",
      "commitNameOld": "ddd0fe257bc78dc9646407e7121769d0c03e0d94",
      "commitAuthorOld": "Stefan Beller",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.getUrl(),\n\t\t\t\t\t\t\tproj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.getCopyFiles(),\n\t\t\t\t\t\t\tproj.getGroups(),\n\t\t\t\t\t\t\tproj.getRecommendShallow());\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n\t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n\t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n\t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n\t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n\t\t\t\t\t\trec.append(name);\n\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\t\trec.append(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t\tattributes.append(rec.toString());\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\tbuilder.add(dcEntryAttr);\n\t\t\t\t}\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 454,
      "functionName": "call",
      "diff": "@@ -1,179 +1,190 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tManifestParser parser \u003d new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n-\t\t\t\t\t\t\tproj.getGroups());\n+\t\t\t\t\t\t\tproj.getGroups(),\n+\t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n+\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n+\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n+\t\t\t\t\t\t\t// depth in the \u0027clone-depth\u0027 field, while\n+\t\t\t\t\t\t\t// git core only uses a binary \u0027shallow \u003d true/false\u0027\n+\t\t\t\t\t\t\t// hint, we\u0027ll map any depth to \u0027shallow \u003d true\u0027\n+\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\t\t\ttrue);\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(name);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ddd0fe257bc78dc9646407e7121769d0c03e0d94": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: record manifest groups as submodule labels\n\nGit core learned about attributes in pathspecs:\n\n    pathspec: allow querying for attributes\n\n    The pathspec mechanism is extended via the new\n    \":(attr:eol\u003dinput)pattern/to/match\" syntax to filter paths so that it\n    requires paths to not just match the given pattern but also have the\n    specified attrs attached for them to be chosen.\n\n(177161a5f7, 2016-05-20)\n\nWe intend to use these pathspec attribute patterns for submodule\ngrouping, similar to the grouping in repo. So the RepoCommand which\ntranslates repo manifest files into submodules should propagate this\ninformation along. This requires writing information to the\n.gitattributes file instead of the .gitmodules file. For now we just\noverwrite any existing .gitattributes file and do not care about prior\nattributes set. If this becomes an issue we need to figure out how to\ncorrectly amend the grouping information to an existing .gitattributes\nfile.\n\nChange-Id: I0f55b45786b6b8fc3d5be62d7f6aab9ac00ed60e\nSigned-off-by: Stefan Beller \u003csbeller@google.com\u003e\n",
      "commitDate": "2016-05-31, 6:18 p.m.",
      "commitName": "ddd0fe257bc78dc9646407e7121769d0c03e0d94",
      "commitAuthor": "Stefan Beller",
      "commitDateOld": "2016-03-11, 5:37 p.m.",
      "commitNameOld": "7507d9e2a967e9c978e1fab3ca22deec1b5632c5",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 80.99,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.getUrl(),\n\t\t\t\t\t\t\tproj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.getCopyFiles(),\n\t\t\t\t\t\t\tproj.getGroups());\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n\t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n\t\t\t\t\t\trec.append(name);\n\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n\t\t\t\t\t\t\trec.append(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t\tattributes.append(rec.toString());\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tif (recordSubmoduleLabels) {\n\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\tbuilder.add(dcEntryAttr);\n\t\t\t\t}\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 438,
      "functionName": "call",
      "diff": "@@ -1,156 +1,179 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tManifestParser parser \u003d new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n-\t\t\t\t\t\t\tproj.getCopyFiles());\n+\t\t\t\t\t\t\tproj.getCopyFiles(),\n+\t\t\t\t\t\t\tproj.getGroups());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n+\t\t\t\tStringBuilder attributes \u003d new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\tif (recordSubmoduleLabels) {\n+\t\t\t\t\t\tStringBuilder rec \u003d new StringBuilder();\n+\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n+\t\t\t\t\t\trec.append(name);\n+\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n+\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n+\t\t\t\t\t\t\trec.append(group);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n+\t\t\t\t\t\tattributes.append(rec.toString());\n+\t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n+\t\t\t\tif (recordSubmoduleLabels) {\n+\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n+\t\t\t\t\tfinal DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n+\t\t\t\t\tObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB,\n+\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n+\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n+\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n+\t\t\t\t\tbuilder.add(dcEntryAttr);\n+\t\t\t\t}\n+\n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0ecb016d7db42ab83584cab3c1554d4d28cc5062": {
      "type": "Ybodychange",
      "commitMessage": "Add ignoreRemoteFailures option to RepoCommand\n\nWith ignoreRemoteFailures set to true, we can ignore remote failures\n(e.g. the branch of a project described in the manifest file does not\nexist), skip that project and continue to the next one, instead of fail\nthe whole operation.\n\nChange-Id: I8b3765713599e34f1411f9bbc7f575ec7c2384e0\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2016-03-11, 5:20 p.m.",
      "commitName": "0ecb016d7db42ab83584cab3c1554d4d28cc5062",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2015-11-25, 5:05 p.m.",
      "commitNameOld": "fe98218e0df85012cb9b901c71c44f232f65cb3a",
      "commitAuthorOld": "Jonathan Nieder",
      "daysBetweenCommits": 107.01,
      "commitsBetweenForRepo": 267,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.getUrl(),\n\t\t\t\t\t\t\tproj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.getCopyFiles());\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n\t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (recordRemoteBranch) {\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 420,
      "functionName": "call",
      "diff": "@@ -1,149 +1,156 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tManifestParser parser \u003d new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n-\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n-\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n-\t\t\t\t\t// create gitlink\n-\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n-\t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n+\t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n+\t\t\t\t\t\t\t\u0026\u0026 !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n-\t\t\t\t\t\tif (recordRemoteBranch)\n+\t\t\t\t\t\tif (objectId \u003d\u003d null) {\n+\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n+\t\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tif (objectId \u003d\u003d null)\n-\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n+\n+\t\t\t\t\t// create gitlink\n+\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cdd7c23446a0030e5b521d91cbb2d3a9c522ccc2": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: Add setRecordRemoteBranch option to record upstream branch\n\nOn a server also running Gerrit that is using RepoCommand to\nconvert from an XML manifest to a git submodule superproject\nperiodically, it would be handy to be able to use Gerrit\u0027s\nsubmodule subscription feature[1] to update the superproject\nautomatically between RepoCommand runs as changes are merged\nin each subprojects.\n\nThis requires setting the \u0027branch\u0027 field for each submodule\nso that Gerrit knows what branch to watch.  Add an option to\ndo that.\n\nSetting the branch field also is useful for plain Git users,\nsince it allows them to use \"git submodule update --remote\" to\nmanually update all submodules between RepoCommand runs.\n\n[1] https://gerrit-review.googlesource.com/Documentation/user-submodules.html\n\nChange-Id: I1a10861bcd0df3b3673fc2d481c8129b2bdac5f9\nSigned-off-by: Stefan Beller \u003csbeller@google.com\u003e\n",
      "commitDate": "2015-10-05, 7:01 p.m.",
      "commitName": "cdd7c23446a0030e5b521d91cbb2d3a9c522ccc2",
      "commitAuthor": "Stefan Beller",
      "commitDateOld": "2015-07-10, 2:39 p.m.",
      "commitNameOld": "217b2a7cc5366491be5317d20f3f3c1b6e3475bf",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 87.18,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.getUrl(),\n\t\t\t\t\t\t\tproj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.getCopyFiles());\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t\tif (recordRemoteBranch)\n\t\t\t\t\t\t\t// can be branch or tag\n\t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\t\tproj.getRevision());\n\t\t\t\t\t}\n\t\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 394,
      "functionName": "call",
      "diff": "@@ -1,145 +1,149 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tManifestParser parser \u003d new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n-\t\t\t\t\tif (ObjectId.isId(proj.getRevision()))\n+\t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n-\t\t\t\t\telse {\n+\t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n+\t\t\t\t\t\tif (recordRemoteBranch)\n+\t\t\t\t\t\t\t// can be branch or tag\n+\t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId \u003d\u003d null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "217b2a7cc5366491be5317d20f3f3c1b6e3475bf": {
      "type": "Ybodychange",
      "commitMessage": "Add setTargetBranch in RepoCommand.\n\nThis will allow us to write the super project in a branch other than\nmaster.\n\nChange-Id: I578ed9ecbc6423416239e31ad644531dae9fb5c3\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2015-07-10, 2:39 p.m.",
      "commitName": "217b2a7cc5366491be5317d20f3f3c1b6e3475bf",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2015-05-26, 12:58 p.m.",
      "commitNameOld": "744c370c1be8044d1ccaaf84cd164324961fea1a",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 45.07,
      "commitsBetweenForRepo": 104,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.getUrl(),\n\t\t\t\t\t\t\tproj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.getCopyFiles());\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision()))\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\telse {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t}\n\t\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tMessageFormat.format(\n\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n\t\t\t\t\t\t\t\tru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 369,
      "functionName": "call",
      "diff": "@@ -1,143 +1,145 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tManifestParser parser \u003d new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.getPath();\n \t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision()))\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\telse {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId \u003d\u003d null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n-\t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n+\t\t\t\tObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n-\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+\t\t\t\tRefUpdate ru \u003d repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n-\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n+\t\t\t\t\t\t\t\tMessageFormat.format(\n+\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n+\t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n-\t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n+\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "744c370c1be8044d1ccaaf84cd164324961fea1a": {
      "type": "Ybodychange",
      "commitMessage": "Add getters to RepoProject.\n\nChange-Id: I74ded6c2c3f5985568cd77bd8799b45017fb1d09\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2015-05-26, 12:58 p.m.",
      "commitName": "744c370c1be8044d1ccaaf84cd164324961fea1a",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2015-05-24, 4:27 a.m.",
      "commitNameOld": "1773002a3446c93ab03997b65139fc7d014599b9",
      "commitAuthorOld": "Andrey Loskutov",
      "daysBetweenCommits": 2.36,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.getUrl(),\n\t\t\t\t\t\t\tproj.getPath(),\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.getCopyFiles());\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.getPath();\n\t\t\t\t\tString nameUri \u003d proj.getName();\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.getRevision()))\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n\t\t\t\t\telse {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n\t\t\t\t\t}\n\t\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 350,
      "functionName": "call",
      "diff": "@@ -1,143 +1,143 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tManifestParser parser \u003d new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n-\t\t\t\t\taddSubmodule(proj.url,\n-\t\t\t\t\t\t\tproj.path,\n+\t\t\t\t\taddSubmodule(proj.getUrl(),\n+\t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n-\t\t\t\t\t\t\tproj.copyfiles);\n+\t\t\t\t\t\t\tproj.getCopyFiles());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n-\t\t\t\t\tString name \u003d proj.path;\n-\t\t\t\t\tString nameUri \u003d proj.name;\n+\t\t\t\t\tString name \u003d proj.getPath();\n+\t\t\t\t\tString nameUri \u003d proj.getName();\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n-\t\t\t\t\tif (ObjectId.isId(proj.revision))\n-\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n+\t\t\t\t\tif (ObjectId.isId(proj.getRevision()))\n+\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.getRevision());\n \t\t\t\t\telse {\n-\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.revision);\n+\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId \u003d\u003d null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n-\t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n+\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n-\t\t\t\t\t\t\t\tnameUri, proj.revision, copyfile.src);\n+\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d3348e5623a2abf7b2f1356ea077d6eb9bf7760c": {
      "type": "Ybodychange",
      "commitMessage": "Refactor to expose ManifestParser.\n\nThe repo xml manifest parser used in RepoCommand could also be useful for\nothers, so refactor to make it public.\n\nAlso this breaks backward compatibility slightly.\n\nChange-Id: I5001bd2fe77541109fe32dbe2597a065e6ad585e\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2015-05-22, 2:08 p.m.",
      "commitName": "d3348e5623a2abf7b2f1356ea077d6eb9bf7760c",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2015-05-20, 6:01 p.m.",
      "commitNameOld": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tManifestParser parser \u003d new ManifestParser(\n\t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n\t\t\ttry {\n\t\t\t\tparser.read(inputStream);\n\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n\t\t\t\t\taddSubmodule(proj.url,\n\t\t\t\t\t\t\tproj.path,\n\t\t\t\t\t\t\tproj.getRevision(),\n\t\t\t\t\t\t\tproj.copyfiles);\n\t\t\t\t}\n\t\t\t} catch (GitAPIException | IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tfor (RepoProject proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.path;\n\t\t\t\t\tString nameUri \u003d proj.name;\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.revision))\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n\t\t\t\t\telse {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.revision);\n\t\t\t\t\t}\n\t\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.revision, copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 351,
      "functionName": "call",
      "diff": "@@ -1,137 +1,143 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n-\t\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n+\t\t\t\tbareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n-\t\t\tXmlManifest manifest \u003d new XmlManifest(\n-\t\t\t\t\tthis, includedReader, path, uri, groups);\n+\t\t\tManifestParser parser \u003d new ManifestParser(\n+\t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n-\t\t\t\tmanifest.read(inputStream);\n-\t\t\t} catch (IOException e) {\n+\t\t\t\tparser.read(inputStream);\n+\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n+\t\t\t\t\taddSubmodule(proj.url,\n+\t\t\t\t\t\t\tproj.path,\n+\t\t\t\t\t\t\tproj.getRevision(),\n+\t\t\t\t\t\t\tproj.copyfiles);\n+\t\t\t\t}\n+\t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n-\t\t\t\tfor (Project proj : bareProjects) {\n+\t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.path;\n \t\t\t\t\tString nameUri \u003d proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.revision))\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n \t\t\t\t\telse {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId \u003d\u003d null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.revision, copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e73d395061d1bfee365acaa2f79c392175d13bf": {
      "type": "Ybodychange",
      "commitMessage": "Use AutoClosable to close resources in bundle org.eclipse.jgit\n\n- use try-with-resource where possible\n- replace use of deprecated release() by close()\n\nChange-Id: I0f139c3535679087b7fa09649166bca514750b81\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015-05-20, 6:01 p.m.",
      "commitName": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2015-01-21, 6:42 p.m.",
      "commitNameOld": "9ffe6deced8dd79dd283fff650a8ac19ce3d9a08",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 118.93,
      "commitsBetweenForRepo": 171,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tXmlManifest manifest \u003d new XmlManifest(\n\t\t\t\t\tthis, includedReader, path, uri, groups);\n\t\t\ttry {\n\t\t\t\tmanifest.read(inputStream);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tfor (Project proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.path;\n\t\t\t\t\tString nameUri \u003d proj.name;\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.revision))\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n\t\t\t\t\telse {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.revision);\n\t\t\t\t\t}\n\t\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.revision, copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 699,
      "functionName": "call",
      "diff": "@@ -1,140 +1,137 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tXmlManifest manifest \u003d new XmlManifest(\n \t\t\t\t\tthis, includedReader, path, uri, groups);\n \t\t\ttry {\n \t\t\t\tmanifest.read(inputStream);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n-\t\t\tRevWalk rw \u003d new RevWalk(repo);\n-\t\t\ttry {\n+\t\t\ttry (RevWalk rw \u003d new RevWalk(repo)) {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tfor (Project proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.path;\n \t\t\t\t\tString nameUri \u003d proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.revision))\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n \t\t\t\t\telse {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId \u003d\u003d null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.revision, copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n-\t\t\t} finally {\n-\t\t\t\trw.release();\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386": {
      "type": "Ybodychange",
      "commitMessage": "Rename local variables/parameters to remove warnings about hiding\n\nChange-Id: I73f38492b6a2e7fd6e77005efd0a8a8c65763e74\n",
      "commitDate": "2014-09-04, 5:35 a.m.",
      "commitName": "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2014-09-04, 5:28 a.m.",
      "commitNameOld": "0bc98f17b2b3504b1b180a605e45654ace49ef1a",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tXmlManifest manifest \u003d new XmlManifest(\n\t\t\t\t\tthis, includedReader, path, uri, groups);\n\t\t\ttry {\n\t\t\t\tmanifest.read(inputStream);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\tRevWalk rw \u003d new RevWalk(repo);\n\t\t\ttry {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tfor (Project proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.path;\n\t\t\t\t\tString nameUri \u003d proj.name;\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.revision))\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n\t\t\t\t\telse {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.revision);\n\t\t\t\t\t}\n\t\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\tnameUri, proj.revision, copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t} finally {\n\t\t\t\trw.release();\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 702,
      "functionName": "call",
      "diff": "@@ -1,140 +1,140 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tXmlManifest manifest \u003d new XmlManifest(\n \t\t\t\t\tthis, includedReader, path, uri, groups);\n \t\t\ttry {\n \t\t\t\tmanifest.read(inputStream);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\tRevWalk rw \u003d new RevWalk(repo);\n \t\t\ttry {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tfor (Project proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.path;\n-\t\t\t\t\tString uri \u003d proj.name;\n+\t\t\t\t\tString nameUri \u003d proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n-\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.revision))\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n \t\t\t\t\telse {\n-\t\t\t\t\t\tobjectId \u003d callback.sha1(uri, proj.revision);\n+\t\t\t\t\t\tobjectId \u003d callback.sha1(nameUri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId \u003d\u003d null)\n-\t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n+\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n-\t\t\t\t\t\t\t\turi, proj.revision, copyfile.src);\n+\t\t\t\t\t\t\t\tnameUri, proj.revision, copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t} finally {\n \t\t\t\trw.release();\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34dd64f6fe36ace1a90b0b503e2e37d877b7c621": {
      "type": "Ybodychange",
      "commitMessage": "Add support to \u003cinclude\u003e tag in repo manifest xml.\n\nChange-Id: I32d468f92e24701ea680435bf3417e3850857303\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014-08-13, 4:04 p.m.",
      "commitName": "34dd64f6fe36ace1a90b0b503e2e37d877b7c621",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2014-08-13, 1:36 p.m.",
      "commitNameOld": "38a24bc7990bfa76e5dbd905434341a28e8e543f",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tXmlManifest manifest \u003d new XmlManifest(\n\t\t\t\t\tthis, includedReader, path, uri, groups);\n\t\t\ttry {\n\t\t\t\tmanifest.read(inputStream);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\tRevWalk rw \u003d new RevWalk(repo);\n\t\t\ttry {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tfor (Project proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.path;\n\t\t\t\t\tString uri \u003d proj.name;\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.revision))\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n\t\t\t\t\telse {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(uri, proj.revision);\n\t\t\t\t\t}\n\t\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\turi, proj.revision, copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t} finally {\n\t\t\t\trw.release();\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 677,
      "functionName": "call",
      "diff": "@@ -1,140 +1,140 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream \u003d\u003d null) {\n \t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream \u003d new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n \t\t\t\tif (author \u003d\u003d null)\n \t\t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\t\tif (callback \u003d\u003d null)\n \t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit \u003d new Git(repo);\n \n \t\t\tXmlManifest manifest \u003d new XmlManifest(\n-\t\t\t\t\tthis, inputStream, path, uri, groups);\n+\t\t\t\t\tthis, includedReader, path, uri, groups);\n \t\t\ttry {\n-\t\t\t\tmanifest.read();\n+\t\t\t\tmanifest.read(inputStream);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream !\u003d null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it\u0027s not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\tRevWalk rw \u003d new RevWalk(repo);\n \t\t\ttry {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tfor (Project proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.path;\n \t\t\t\t\tString uri \u003d proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.revision))\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n \t\t\t\t\telse {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(uri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId \u003d\u003d null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\turi, proj.revision, copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t} finally {\n \t\t\t\trw.release();\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "acd7ed52692bb7155333efea6dead712b7156ab9": {
      "type": "Ybodychange",
      "commitMessage": "Added setInputStream to RepoCommand.\n\nSometimes an input stream is more useful than the filename of the xml manifest.\n\nChange-Id: Icb09ac751b3d8d7eb14427ad1aac8cee0c371c5f\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014-06-09, 1:26 p.m.",
      "commitName": "acd7ed52692bb7155333efea6dead712b7156ab9",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2014-06-05, 8:40 p.m.",
      "commitNameOld": "39001eacc1158050d6f1deaea259b4fe4af136dc",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 3.7,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\ttry {\n\t\t\tcheckCallable();\n\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n\t\t\tif (inputStream \u003d\u003d null) {\n\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\ttry {\n\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repo.isBare()) {\n\t\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n\t\t\t\tif (author \u003d\u003d null)\n\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\t\tif (callback \u003d\u003d null)\n\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t\t} else\n\t\t\t\tgit \u003d new Git(repo);\n\n\t\t\tXmlManifest manifest \u003d new XmlManifest(\n\t\t\t\t\tthis, inputStream, path, uri, groups);\n\t\t\ttry {\n\t\t\t\tmanifest.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (inputStream !\u003d null)\n\t\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Just ignore it, it\u0027s not important.\n\t\t\t}\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\tRevWalk rw \u003d new RevWalk(repo);\n\t\t\ttry {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tfor (Project proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.path;\n\t\t\t\t\tString uri \u003d proj.name;\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.revision))\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n\t\t\t\t\telse {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(uri, proj.revision);\n\t\t\t\t\t}\n\t\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\turi, proj.revision, copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t} finally {\n\t\t\t\trw.release();\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 519,
      "functionName": "call",
      "diff": "@@ -1,120 +1,140 @@\n \tpublic RevCommit call() throws GitAPIException {\n-\t\tcheckCallable();\n-\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n-\t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n-\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n-\t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n-\n-\t\tif (repo.isBare()) {\n-\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n-\t\t\tif (author \u003d\u003d null)\n-\t\t\t\tauthor \u003d new PersonIdent(repo);\n-\t\t\tif (callback \u003d\u003d null)\n-\t\t\t\tcallback \u003d new DefaultRemoteReader();\n-\t\t} else\n-\t\t\tgit \u003d new Git(repo);\n-\n-\t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n \t\ttry {\n-\t\t\tmanifest.read();\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new ManifestErrorException(e);\n+\t\t\tcheckCallable();\n+\t\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n+\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n+\t\t\tif (inputStream \u003d\u003d null) {\n+\t\t\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n+\t\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n+\t\t\t\ttry {\n+\t\t\t\t\tinputStream \u003d new FileInputStream(path);\n+\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (repo.isBare()) {\n+\t\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n+\t\t\t\tif (author \u003d\u003d null)\n+\t\t\t\t\tauthor \u003d new PersonIdent(repo);\n+\t\t\t\tif (callback \u003d\u003d null)\n+\t\t\t\t\tcallback \u003d new DefaultRemoteReader();\n+\t\t\t} else\n+\t\t\t\tgit \u003d new Git(repo);\n+\n+\t\t\tXmlManifest manifest \u003d new XmlManifest(\n+\t\t\t\t\tthis, inputStream, path, uri, groups);\n+\t\t\ttry {\n+\t\t\t\tmanifest.read();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new ManifestErrorException(e);\n+\t\t\t}\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tif (inputStream !\u003d null)\n+\t\t\t\t\tinputStream.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\t// Just ignore it, it\u0027s not important.\n+\t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\tRevWalk rw \u003d new RevWalk(repo);\n \t\t\ttry {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tfor (Project proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.path;\n \t\t\t\t\tString uri \u003d proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.revision))\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n \t\t\t\t\telse {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(uri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId \u003d\u003d null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n \t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n \t\t\t\t\t\t\t\turi, proj.revision, copyfile.src);\n \t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t} finally {\n \t\t\t\trw.release();\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0b15b48f741f87277e0d1c7d29637430b880dbde": {
      "type": "Ybodychange",
      "commitMessage": "Handle repo copyfile in bare repositories.\n\nChange-Id: Ie06f0c3d1bc9b2123102efaa5542ec3c232b72cd\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014-05-09, 8:25 p.m.",
      "commitName": "0b15b48f741f87277e0d1c7d29637430b880dbde",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2014-05-09, 8:25 p.m.",
      "commitNameOld": "d998bc938a21cb3871b442a3bb54b5807b6e4ed2",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\tcheckCallable();\n\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n\n\t\tif (repo.isBare()) {\n\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n\t\t\tif (author \u003d\u003d null)\n\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\tif (callback \u003d\u003d null)\n\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t} else\n\t\t\tgit \u003d new Git(repo);\n\n\t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n\t\ttry {\n\t\t\tmanifest.read();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ManifestErrorException(e);\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\tRevWalk rw \u003d new RevWalk(repo);\n\n\t\t\ttry {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tfor (Project proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.path;\n\t\t\t\t\tString uri \u003d proj.name;\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.revision))\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n\t\t\t\t\telse {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(uri, proj.revision);\n\t\t\t\t\t}\n\t\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n\t\t\t\t\t\t\t\turi, proj.revision, copyfile.src);\n\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t} finally {\n\t\t\t\trw.release();\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 498,
      "functionName": "call",
      "diff": "@@ -1,111 +1,121 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n \t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n \n \t\tif (repo.isBare()) {\n \t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n \t\t\tif (author \u003d\u003d null)\n \t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\tif (callback \u003d\u003d null)\n \t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t} else\n \t\t\tgit \u003d new Git(repo);\n \n \t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n \t\ttry {\n \t\t\tmanifest.read();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\tRevWalk rw \u003d new RevWalk(repo);\n \n \t\t\ttry {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tfor (Project proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.path;\n \t\t\t\t\tString uri \u003d proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n-\t\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n+\t\t\t\t\tDirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.revision))\n \t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n \t\t\t\t\telse {\n \t\t\t\t\t\tobjectId \u003d callback.sha1(uri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId \u003d\u003d null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n+\n+\t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n+\t\t\t\t\t\tbyte[] src \u003d callback.readFile(\n+\t\t\t\t\t\t\t\turi, proj.revision, copyfile.src);\n+\t\t\t\t\t\tobjectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n+\t\t\t\t\t\tdcEntry \u003d new DirCacheEntry(copyfile.dest);\n+\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n+\t\t\t\t\t\tbuilder.add(dcEntry);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t} finally {\n \t\t\t\trw.release();\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d998bc938a21cb3871b442a3bb54b5807b6e4ed2": {
      "type": "Ybodychange",
      "commitMessage": "Handle the revision attribute in repo manifest.\n\nChange-Id: I77fe073aeb13c58029551b7d6e1451a9b62dc766\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014-05-09, 8:25 p.m.",
      "commitName": "d998bc938a21cb3871b442a3bb54b5807b6e4ed2",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2014-05-07, 2:03 p.m.",
      "commitNameOld": "056135a1482a9d56ee5055d6bc2df5bea032b5e5",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 2.27,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\tcheckCallable();\n\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n\n\t\tif (repo.isBare()) {\n\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n\t\t\tif (author \u003d\u003d null)\n\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\tif (callback \u003d\u003d null)\n\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t} else\n\t\t\tgit \u003d new Git(repo);\n\n\t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n\t\ttry {\n\t\t\tmanifest.read();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ManifestErrorException(e);\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\tRevWalk rw \u003d new RevWalk(repo);\n\n\t\t\ttry {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tfor (Project proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.path;\n\t\t\t\t\tString uri \u003d proj.name;\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\tif (ObjectId.isId(proj.revision))\n\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n\t\t\t\t\telse {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(uri, proj.revision);\n\t\t\t\t\t}\n\t\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t} finally {\n\t\t\t\trw.release();\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 469,
      "functionName": "call",
      "diff": "@@ -1,115 +1,111 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n \t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n \n \t\tif (repo.isBare()) {\n \t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n \t\t\tif (author \u003d\u003d null)\n \t\t\t\tauthor \u003d new PersonIdent(repo);\n \t\t\tif (callback \u003d\u003d null)\n \t\t\t\tcallback \u003d new DefaultRemoteReader();\n \t\t} else\n \t\t\tgit \u003d new Git(repo);\n \n \t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n \t\ttry {\n \t\t\tmanifest.read();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index \u003d DirCache.newInCore();\n \t\t\tDirCacheBuilder builder \u003d index.builder();\n \t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n \t\t\tRevWalk rw \u003d new RevWalk(repo);\n \n \t\t\ttry {\n \t\t\t\tConfig cfg \u003d new Config();\n \t\t\t\tfor (Project proj : bareProjects) {\n \t\t\t\t\tString name \u003d proj.path;\n \t\t\t\t\tString uri \u003d proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tobjectId \u003d callback.sha1(uri);\n-\t\t\t\t\t} catch (GitAPIException e) {\n-\t\t\t\t\t\t// Something wrong getting the head sha1\n-\t\t\t\t\t\tthrow new RemoteUnavailableException(uri, e);\n-\t\t\t\t\t} catch (IllegalArgumentException e) {\n-\t\t\t\t\t\t// The revision from the manifest is malformed.\n-\t\t\t\t\t\tthrow new ManifestErrorException(e);\n+\t\t\t\t\tif (ObjectId.isId(proj.revision))\n+\t\t\t\t\t\tobjectId \u003d ObjectId.fromString(proj.revision);\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tobjectId \u003d callback.sha1(uri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId \u003d\u003d null)\n-\t\t\t\t\t\tthrow new RemoteUnavailableException(uri, null);\n+\t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t}\n \t\t\t\tString content \u003d cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId !\u003d null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc \u003d ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t} finally {\n \t\t\t\trw.release();\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "056135a1482a9d56ee5055d6bc2df5bea032b5e5": {
      "type": "Ybodychange",
      "commitMessage": "Handle repo submodules for bare repositories.\n\nChange-Id: Id028a7bc9600baf0f3e2316a1f4b99e53ccc746a\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014-05-07, 2:03 p.m.",
      "commitName": "056135a1482a9d56ee5055d6bc2df5bea032b5e5",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2014-04-25, 1:42 p.m.",
      "commitNameOld": "dc4c673902a0847b270faf1771595d7c189a1943",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 12.01,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\tcheckCallable();\n\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n\n\t\tif (repo.isBare()) {\n\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n\t\t\tif (author \u003d\u003d null)\n\t\t\t\tauthor \u003d new PersonIdent(repo);\n\t\t\tif (callback \u003d\u003d null)\n\t\t\t\tcallback \u003d new DefaultRemoteReader();\n\t\t} else\n\t\t\tgit \u003d new Git(repo);\n\n\t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n\t\ttry {\n\t\t\tmanifest.read();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ManifestErrorException(e);\n\t\t}\n\n\t\tif (repo.isBare()) {\n\t\t\tDirCache index \u003d DirCache.newInCore();\n\t\t\tDirCacheBuilder builder \u003d index.builder();\n\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n\t\t\tRevWalk rw \u003d new RevWalk(repo);\n\n\t\t\ttry {\n\t\t\t\tConfig cfg \u003d new Config();\n\t\t\t\tfor (Project proj : bareProjects) {\n\t\t\t\t\tString name \u003d proj.path;\n\t\t\t\t\tString uri \u003d proj.name;\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t// create gitlink\n\t\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n\t\t\t\t\tObjectId objectId;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tobjectId \u003d callback.sha1(uri);\n\t\t\t\t\t} catch (GitAPIException e) {\n\t\t\t\t\t\t// Something wrong getting the head sha1\n\t\t\t\t\t\tthrow new RemoteUnavailableException(uri, e);\n\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t// The revision from the manifest is malformed.\n\t\t\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t\t\t}\n\t\t\t\t\tif (objectId \u003d\u003d null)\n\t\t\t\t\t\tthrow new RemoteUnavailableException(uri, null);\n\t\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n\t\t\t\t\tbuilder.add(dcEntry);\n\t\t\t\t}\n\t\t\t\tString content \u003d cfg.toText();\n\n\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n\t\t\t\tdcEntry.setObjectId(objectId);\n\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n\t\t\t\tbuilder.add(dcEntry);\n\n\t\t\t\tbuilder.finish();\n\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n\n\t\t\t\t// Create a Commit object, populate it and write it\n\t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n\t\t\t\tcommit.setTreeId(treeId);\n\t\t\t\tif (headId !\u003d null)\n\t\t\t\t\tcommit.setParentIds(headId);\n\t\t\t\tcommit.setAuthor(author);\n\t\t\t\tcommit.setCommitter(author);\n\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n\n\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n\t\t\t\tinserter.flush();\n\n\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n\t\t\t\tru.setNewObjectId(commitId);\n\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n\t\t\t\tResult rc \u003d ru.update(rw);\n\n\t\t\t\tswitch (rc) {\n\t\t\t\t\tcase NEW:\n\t\t\t\t\tcase FORCED:\n\t\t\t\t\tcase FAST_FORWARD:\n\t\t\t\t\t\t// Successful. Do nothing.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REJECTED:\n\t\t\t\t\tcase LOCK_FAILURE:\n\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n\t\t\t\t\t\t\t\trc);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n\t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n\t\t\t\t}\n\n\t\t\t\treturn rw.parseCommit(commitId);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ManifestErrorException(e);\n\t\t\t} finally {\n\t\t\t\trw.release();\n\t\t\t}\n\t\t} else {\n\t\t\treturn git\n\t\t\t\t.commit()\n\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t\t.call();\n\t\t}\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 438,
      "functionName": "call",
      "diff": "@@ -1,20 +1,115 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n \t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n \n-\t\tgit \u003d new Git(repo);\n+\t\tif (repo.isBare()) {\n+\t\t\tbareProjects \u003d new ArrayList\u003cProject\u003e();\n+\t\t\tif (author \u003d\u003d null)\n+\t\t\t\tauthor \u003d new PersonIdent(repo);\n+\t\t\tif (callback \u003d\u003d null)\n+\t\t\t\tcallback \u003d new DefaultRemoteReader();\n+\t\t} else\n+\t\t\tgit \u003d new Git(repo);\n+\n \t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n \t\ttry {\n \t\t\tmanifest.read();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t}\n \n-\t\treturn git\n-\t\t\t.commit()\n-\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n-\t\t\t.call();\n+\t\tif (repo.isBare()) {\n+\t\t\tDirCache index \u003d DirCache.newInCore();\n+\t\t\tDirCacheBuilder builder \u003d index.builder();\n+\t\t\tObjectInserter inserter \u003d repo.newObjectInserter();\n+\t\t\tRevWalk rw \u003d new RevWalk(repo);\n+\n+\t\t\ttry {\n+\t\t\t\tConfig cfg \u003d new Config();\n+\t\t\t\tfor (Project proj : bareProjects) {\n+\t\t\t\t\tString name \u003d proj.path;\n+\t\t\t\t\tString uri \u003d proj.name;\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t// create gitlink\n+\t\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n+\t\t\t\t\tObjectId objectId;\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tobjectId \u003d callback.sha1(uri);\n+\t\t\t\t\t} catch (GitAPIException e) {\n+\t\t\t\t\t\t// Something wrong getting the head sha1\n+\t\t\t\t\t\tthrow new RemoteUnavailableException(uri, e);\n+\t\t\t\t\t} catch (IllegalArgumentException e) {\n+\t\t\t\t\t\t// The revision from the manifest is malformed.\n+\t\t\t\t\t\tthrow new ManifestErrorException(e);\n+\t\t\t\t\t}\n+\t\t\t\t\tif (objectId \u003d\u003d null)\n+\t\t\t\t\t\tthrow new RemoteUnavailableException(uri, null);\n+\t\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n+\t\t\t\t\tbuilder.add(dcEntry);\n+\t\t\t\t}\n+\t\t\t\tString content \u003d cfg.toText();\n+\n+\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n+\t\t\t\tfinal DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n+\t\t\t\tObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB,\n+\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n+\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n+\t\t\t\tbuilder.add(dcEntry);\n+\n+\t\t\t\tbuilder.finish();\n+\t\t\t\tObjectId treeId \u003d index.writeTree(inserter);\n+\n+\t\t\t\t// Create a Commit object, populate it and write it\n+\t\t\t\tObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n+\t\t\t\tCommitBuilder commit \u003d new CommitBuilder();\n+\t\t\t\tcommit.setTreeId(treeId);\n+\t\t\t\tif (headId !\u003d null)\n+\t\t\t\t\tcommit.setParentIds(headId);\n+\t\t\t\tcommit.setAuthor(author);\n+\t\t\t\tcommit.setCommitter(author);\n+\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n+\n+\t\t\t\tObjectId commitId \u003d inserter.insert(commit);\n+\t\t\t\tinserter.flush();\n+\n+\t\t\t\tRefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+\t\t\t\tru.setNewObjectId(commitId);\n+\t\t\t\tru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n+\t\t\t\tResult rc \u003d ru.update(rw);\n+\n+\t\t\t\tswitch (rc) {\n+\t\t\t\t\tcase NEW:\n+\t\t\t\t\tcase FORCED:\n+\t\t\t\t\tcase FAST_FORWARD:\n+\t\t\t\t\t\t// Successful. Do nothing.\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase REJECTED:\n+\t\t\t\t\tcase LOCK_FAILURE:\n+\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n+\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n+\t\t\t\t\t\t\t\trc);\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n+\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n+\t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n+\t\t\t\t}\n+\n+\t\t\t\treturn rw.parseCommit(commitId);\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new ManifestErrorException(e);\n+\t\t\t} finally {\n+\t\t\t\trw.release();\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn git\n+\t\t\t\t.commit()\n+\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n+\t\t\t\t.call();\n+\t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dc4c673902a0847b270faf1771595d7c189a1943": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "Commit changes generated during repo command\n\nChange-Id: Ia4df9808294d2069dcc5973bcb69b4499c7dcacd\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e",
      "commitDate": "2014-04-25, 1:42 p.m.",
      "commitName": "dc4c673902a0847b270faf1771595d7c189a1943",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Commit changes generated during repo command\n\nChange-Id: Ia4df9808294d2069dcc5973bcb69b4499c7dcacd\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e",
          "commitDate": "2014-04-25, 1:42 p.m.",
          "commitName": "dc4c673902a0847b270faf1771595d7c189a1943",
          "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
          "commitDateOld": "2014-04-24, 2:03 a.m.",
          "commitNameOld": "51cccc9dae3191567a2972a7ebe692b1629808c1",
          "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
          "daysBetweenCommits": 1.49,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\tcheckCallable();\n\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n\n\t\tgit \u003d new Git(repo);\n\t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n\t\ttry {\n\t\t\tmanifest.read();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ManifestErrorException(e);\n\t\t}\n\n\t\treturn git\n\t\t\t.commit()\n\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t.call();\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
          "functionStartLine": 351,
          "functionName": "call",
          "diff": "@@ -1,16 +1,20 @@\n-\tpublic Void call() throws GitAPIException {\n+\tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n \t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n \n+\t\tgit \u003d new Git(repo);\n \t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n \t\ttry {\n \t\t\tmanifest.read();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t}\n \n-\t\treturn null;\n+\t\treturn git\n+\t\t\t.commit()\n+\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n+\t\t\t.call();\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Void",
            "newValue": "RevCommit"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Commit changes generated during repo command\n\nChange-Id: Ia4df9808294d2069dcc5973bcb69b4499c7dcacd\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e",
          "commitDate": "2014-04-25, 1:42 p.m.",
          "commitName": "dc4c673902a0847b270faf1771595d7c189a1943",
          "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
          "commitDateOld": "2014-04-24, 2:03 a.m.",
          "commitNameOld": "51cccc9dae3191567a2972a7ebe692b1629808c1",
          "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
          "daysBetweenCommits": 1.49,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic RevCommit call() throws GitAPIException {\n\t\tcheckCallable();\n\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n\n\t\tgit \u003d new Git(repo);\n\t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n\t\ttry {\n\t\t\tmanifest.read();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ManifestErrorException(e);\n\t\t}\n\n\t\treturn git\n\t\t\t.commit()\n\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n\t\t\t.call();\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
          "functionStartLine": 351,
          "functionName": "call",
          "diff": "@@ -1,16 +1,20 @@\n-\tpublic Void call() throws GitAPIException {\n+\tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n \t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n \n+\t\tgit \u003d new Git(repo);\n \t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n \t\ttry {\n \t\t\tmanifest.read();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t}\n \n-\t\treturn null;\n+\t\treturn git\n+\t\t\t.commit()\n+\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n+\t\t\t.call();\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "a44a687fedbf1559277b8e6706819aa9be7bce39": {
      "type": "Ybodychange",
      "commitMessage": "Added groups support to repo subcommand.\n\nChange-Id: Id0e7663b6ac4f6938fdcacaf2158107b6285fc25\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014-04-24, 2:03 a.m.",
      "commitName": "a44a687fedbf1559277b8e6706819aa9be7bce39",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2014-04-24, 1:48 a.m.",
      "commitNameOld": "0ad8fa7b36dafbea07da15897cc2f2b601772e24",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Void call() throws GitAPIException {\n\t\tcheckCallable();\n\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n\n\t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n\t\ttry {\n\t\t\tmanifest.read();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ManifestErrorException(e);\n\t\t}\n\n\t\treturn null;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 278,
      "functionName": "call",
      "diff": "@@ -1,16 +1,16 @@\n \tpublic Void call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n \t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n \n-\t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri);\n+\t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n \t\ttry {\n \t\t\tmanifest.read();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t}\n \n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0ad8fa7b36dafbea07da15897cc2f2b601772e24": {
      "type": "Yintroduced",
      "commitMessage": "Implemented first part of the repo sub-command.\n\nCurrently the repo sub-command only \"works\", but the submodules will have .git\ndirectories themselves, and lacks group support.\n\nChange-Id: I88a6ee07109187c6c9bfd92a044775fcfb5befa6\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014-04-24, 1:48 a.m.",
      "commitName": "0ad8fa7b36dafbea07da15897cc2f2b601772e24",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "diff": "@@ -0,0 +1,16 @@\n+\tpublic Void call() throws GitAPIException {\n+\t\tcheckCallable();\n+\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n+\t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n+\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n+\t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n+\n+\t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri);\n+\t\ttry {\n+\t\t\tmanifest.read();\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new ManifestErrorException(e);\n+\t\t}\n+\n+\t\treturn null;\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic Void call() throws GitAPIException {\n\t\tcheckCallable();\n\t\tif (path \u003d\u003d null || path.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n\t\tif (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n\t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n\n\t\tXmlManifest manifest \u003d new XmlManifest(this, path, uri);\n\t\ttry {\n\t\t\tmanifest.read();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ManifestErrorException(e);\n\t\t}\n\n\t\treturn null;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 221,
      "functionName": "call"
    }
  }
}