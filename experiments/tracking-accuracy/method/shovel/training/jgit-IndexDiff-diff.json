{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "H:\\Projects\\eclipse\\jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "IndexDiff.java",
  "functionName": "diff",
  "functionId": "diff___monitor-ProgressMonitor(modifiers-final)__estWorkTreeSize-int__estIndexSize-int__title-String(modifiers-final)",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
  "functionStartLine": 409,
  "functionEndLine": 593,
  "numCommitsSeen": 75,
  "timeTaken": 4526,
  "changeHistory": [
    "5639639b06c004d18415f59a271319da2fb7b930",
    "0c259eaf1db076837768512deb6c251c86e67941",
    "df3469f6ad81dccb314bf2d5021a3cec2b184985",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
    "5d9f595eb87fba31c2253051102116fc7876e6c0",
    "12280c02dbb8e4ac10893fbbd415be757afab4c1",
    "2390531888af6dc9e4fda6cb026271dc068c40ab",
    "0e73d395061d1bfee365acaa2f79c392175d13bf",
    "da595f093e5547a7da583fa0459400e47a2638c6",
    "9597c41ea9db20d769f7b8c54eafa207824e5bd6",
    "abb57e6b5674b7251bd94b7238e5d995ad9c30c5",
    "d8fcc964a85b255aac431c14ac35624f0634620b",
    "5328c8c9164414a63ce7f1323d8194b84b6f1e49",
    "95172dea173425697814e3ba0b4eb823301bf7d0",
    "5404e70dc64201786cd6a21efb41310912860122",
    "1080cc5a0d67012c0ef08d9468fbbc9d90b0c238",
    "53ef3e51145adb4b060110e262d7c064be0d5fc5",
    "6befabcb1584118fb02188f602f7ca34b9a7efc5",
    "298486a7c320629de12f9506e0133686a7382b01",
    "1a867d10b974cab4d43d77f5b392f4f07807ebd8",
    "5e2e3819a690b739eba773415899d20db88a452e",
    "1783749e169c57cef7131e1749a01ee269b89df8",
    "18abb8195a67a0502a71e2420078dd95563e18c6",
    "a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f",
    "d4bbb2e4497335993f4d24f539111dc5d3f8bbcd",
    "e6c39227640536ac1c2e41d8970aeca84b3c6268",
    "48e80698cf7b19422cb7a62a34170cc3c7a3f7a2",
    "ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c",
    "f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b",
    "a02be9725c9f83f0a0280a9a1f00e8d484825885",
    "b4359cb8294de1e80147f00caabad9ebd6b7bce1",
    "2dc2dd8b1b4c98b255b3f2dec655a3f0b197ce07",
    "6f3b089188ef4937ab4e9970b0987b061000831e",
    "ea4ff61ad3de3f5742905c7a92e99cf041d19596",
    "cd1141cd45e8148c2d3fc5553ae19c9fee3fc4a6",
    "9a6a433576c8b1cedb5f3aff9cfecb8217881ddf",
    "3ba1c7c0681642da30fce234b4a4f405852adfdd",
    "203bd6626767015dfb04d421c572b26a34e9cecf",
    "1a6964c8274c50f0253db75f010d78ef0e739343"
  ],
  "changeHistoryShort": {
    "5639639b06c004d18415f59a271319da2fb7b930": "Ybodychange",
    "0c259eaf1db076837768512deb6c251c86e67941": "Ybodychange",
    "df3469f6ad81dccb314bf2d5021a3cec2b184985": "Ybodychange",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": "Ybodychange",
    "5d9f595eb87fba31c2253051102116fc7876e6c0": "Ybodychange",
    "12280c02dbb8e4ac10893fbbd415be757afab4c1": "Ybodychange",
    "2390531888af6dc9e4fda6cb026271dc068c40ab": "Ybodychange",
    "0e73d395061d1bfee365acaa2f79c392175d13bf": "Ybodychange",
    "da595f093e5547a7da583fa0459400e47a2638c6": "Ybodychange",
    "9597c41ea9db20d769f7b8c54eafa207824e5bd6": "Ybodychange",
    "abb57e6b5674b7251bd94b7238e5d995ad9c30c5": "Ybodychange",
    "d8fcc964a85b255aac431c14ac35624f0634620b": "Ybodychange",
    "5328c8c9164414a63ce7f1323d8194b84b6f1e49": "Ybodychange",
    "95172dea173425697814e3ba0b4eb823301bf7d0": "Ybodychange",
    "5404e70dc64201786cd6a21efb41310912860122": "Ybodychange",
    "1080cc5a0d67012c0ef08d9468fbbc9d90b0c238": "Ybodychange",
    "53ef3e51145adb4b060110e262d7c064be0d5fc5": "Ybodychange",
    "6befabcb1584118fb02188f602f7ca34b9a7efc5": "Ybodychange",
    "298486a7c320629de12f9506e0133686a7382b01": "Ybodychange",
    "1a867d10b974cab4d43d77f5b392f4f07807ebd8": "Ybodychange",
    "5e2e3819a690b739eba773415899d20db88a452e": "Ymultichange(Yparameterchange,Ybodychange)",
    "1783749e169c57cef7131e1749a01ee269b89df8": "Ybodychange",
    "18abb8195a67a0502a71e2420078dd95563e18c6": "Ybodychange",
    "a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f": "Ybodychange",
    "d4bbb2e4497335993f4d24f539111dc5d3f8bbcd": "Ybodychange",
    "e6c39227640536ac1c2e41d8970aeca84b3c6268": "Ybodychange",
    "48e80698cf7b19422cb7a62a34170cc3c7a3f7a2": "Ybodychange",
    "ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c": "Ybodychange",
    "f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b": "Ybodychange",
    "a02be9725c9f83f0a0280a9a1f00e8d484825885": "Ybodychange",
    "b4359cb8294de1e80147f00caabad9ebd6b7bce1": "Ybodychange",
    "2dc2dd8b1b4c98b255b3f2dec655a3f0b197ce07": "Ybodychange",
    "6f3b089188ef4937ab4e9970b0987b061000831e": "Ybodychange",
    "ea4ff61ad3de3f5742905c7a92e99cf041d19596": "Ybodychange",
    "cd1141cd45e8148c2d3fc5553ae19c9fee3fc4a6": "Ybodychange",
    "9a6a433576c8b1cedb5f3aff9cfecb8217881ddf": "Ybodychange",
    "3ba1c7c0681642da30fce234b4a4f405852adfdd": "Ybodychange",
    "203bd6626767015dfb04d421c572b26a34e9cecf": "Ybodychange",
    "1a6964c8274c50f0253db75f010d78ef0e739343": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5639639b06c004d18415f59a271319da2fb7b930": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Refactor to open Repository in try-with-resource\n\nChange-Id: I667d685ccedc730e786f1e52323fdeba4b91af3e\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018-03-14, 6:57 p.m.",
      "commitName": "5639639b06c004d18415f59a271319da2fb7b930",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017-12-19, 6:02 p.m.",
      "commitNameOld": "0c259eaf1db076837768512deb6c251c86e67941",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 85.0,
      "commitsBetweenForRepo": 242,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n\t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n\t\t\ttreeWalk.setRecursive(true);\n\t\t\t// add the trees (tree, dirchache, workdir)\n\t\t\tif (tree !\u003d null)\n\t\t\t\ttreeWalk.addTree(tree);\n\t\t\telse\n\t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n\t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n\n\t\t\tif (monitor !\u003d null) {\n\t\t\t\t// Get the maximum size of the work tree and index\n\t\t\t\t// and add some (quite arbitrary)\n\t\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\t\tmonitor.beginTask(title, total);\n\t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t\t}\n\n\t\t\tif (filter !\u003d null)\n\t\t\t\tfilters.add(filter);\n\t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\t\tfilters.add(indexDiffFilter);\n\t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\t\tfileModes.clear();\n\t\t\twhile (treeWalk.next()) {\n\t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\t\tDirCacheIterator.class);\n\t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n\t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| treeIterator\n\t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n\t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n\t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\tif (path !\u003d null) {\n\t\t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n\t\t\t\t\t\trecordFileMode(path, treeWalk.getFileMode(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tthrow new IOException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n\t\t\t\t\t\t\tsmw.getPath()), e);\n\t\t\t\t}\n\t\t\t\ttry (Repository subRepo \u003d smw.getRepository()) {\n\t\t\t\t\tif (subRepo !\u003d null) {\n\t\t\t\t\t\tString subRepoPath \u003d smw.getPath();\n\t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (subHead !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId())) {\n\t\t\t\t\t\t\tmodified.add(subRepoPath);\n\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n\t\t\t\t\t\t} else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n\t\t\t\t\t\t\t\t\t.getPath());\n\t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n\t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n\t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(subRepoPath, smid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmodified.add(subRepoPath);\n\t\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 409,
      "functionName": "diff",
      "diff": "@@ -1,188 +1,185 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n \t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree !\u003d null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n \t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n \n \t\t\tif (monitor !\u003d null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter !\u003d null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator !\u003d null) {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\tif (path !\u003d null) {\n \t\t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n \t\t\t\t\t\trecordFileMode(path, treeWalk.getFileMode(i));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tthrow new IOException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n \t\t\t\t\t\t\tsmw.getPath()), e);\n \t\t\t\t}\n-\t\t\t\tRepository subRepo \u003d smw.getRepository();\n-\t\t\t\tif (subRepo !\u003d null) {\n-\t\t\t\t\tString subRepoPath \u003d smw.getPath();\n-\t\t\t\t\ttry {\n+\t\t\t\ttry (Repository subRepo \u003d smw.getRepository()) {\n+\t\t\t\t\tif (subRepo !\u003d null) {\n+\t\t\t\t\t\tString subRepoPath \u003d smw.getPath();\n \t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId())) {\n \t\t\t\t\t\t\tmodified.add(subRepoPath);\n \t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n \t\t\t\t\t\t} else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n \t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(subRepoPath, smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(subRepoPath);\n \t\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t} finally {\n-\t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0c259eaf1db076837768512deb6c251c86e67941": {
      "type": "Ybodychange",
      "commitMessage": "Replace explicit calls to initCause where possible\n\nWhere the exception being thrown has a constructor that takes a\nThrowable, use that instead of instantiating the exception and then\nexplicitly calling initCause.\n\nChange-Id: I06a0df407ba751a7af8c1c4a46f9e2714f13dbe3\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017-12-19, 6:02 p.m.",
      "commitName": "0c259eaf1db076837768512deb6c251c86e67941",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017-12-19, 7:43 a.m.",
      "commitNameOld": "8a6af368c4129ef35520ec72cc9f55a3f685bfb8",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n\t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n\t\t\ttreeWalk.setRecursive(true);\n\t\t\t// add the trees (tree, dirchache, workdir)\n\t\t\tif (tree !\u003d null)\n\t\t\t\ttreeWalk.addTree(tree);\n\t\t\telse\n\t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n\t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n\n\t\t\tif (monitor !\u003d null) {\n\t\t\t\t// Get the maximum size of the work tree and index\n\t\t\t\t// and add some (quite arbitrary)\n\t\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\t\tmonitor.beginTask(title, total);\n\t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t\t}\n\n\t\t\tif (filter !\u003d null)\n\t\t\t\tfilters.add(filter);\n\t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\t\tfilters.add(indexDiffFilter);\n\t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\t\tfileModes.clear();\n\t\t\twhile (treeWalk.next()) {\n\t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\t\tDirCacheIterator.class);\n\t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n\t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| treeIterator\n\t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n\t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n\t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\tif (path !\u003d null) {\n\t\t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n\t\t\t\t\t\trecordFileMode(path, treeWalk.getFileMode(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tthrow new IOException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n\t\t\t\t\t\t\tsmw.getPath()), e);\n\t\t\t\t}\n\t\t\t\tRepository subRepo \u003d smw.getRepository();\n\t\t\t\tif (subRepo !\u003d null) {\n\t\t\t\t\tString subRepoPath \u003d smw.getPath();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (subHead !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId())) {\n\t\t\t\t\t\t\tmodified.add(subRepoPath);\n\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n\t\t\t\t\t\t} else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n\t\t\t\t\t\t\t\t\t.getPath());\n\t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n\t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n\t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(subRepoPath, smid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmodified.add(subRepoPath);\n\t\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsubRepo.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 409,
      "functionName": "diff",
      "diff": "@@ -1,190 +1,188 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n \t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree !\u003d null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n \t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n \n \t\t\tif (monitor !\u003d null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter !\u003d null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator !\u003d null) {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\tif (path !\u003d null) {\n \t\t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n \t\t\t\t\t\trecordFileMode(path, treeWalk.getFileMode(i));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n-\t\t\t\t\tIOException e1 \u003d new IOException(MessageFormat.format(\n+\t\t\t\t\tthrow new IOException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n-\t\t\t\t\t\t\tsmw.getPath()));\n-\t\t\t\t\te1.initCause(e);\n-\t\t\t\t\tthrow e1;\n+\t\t\t\t\t\t\tsmw.getPath()), e);\n \t\t\t\t}\n \t\t\t\tRepository subRepo \u003d smw.getRepository();\n \t\t\t\tif (subRepo !\u003d null) {\n \t\t\t\t\tString subRepoPath \u003d smw.getPath();\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId())) {\n \t\t\t\t\t\t\tmodified.add(subRepoPath);\n \t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n \t\t\t\t\t\t} else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n \t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(subRepoPath, smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(subRepoPath);\n \t\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "df3469f6ad81dccb314bf2d5021a3cec2b184985": {
      "type": "Ybodychange",
      "commitMessage": "Record submodule paths with untracked changes as FileMode.GITLINK\n\nBug: 520702\nChange-Id: I9bb48af9e8f1f2ce7968a82297c7c16f1237f987\nSigned-off-by: Thomas Wolf \u003cthomas.wolf@paranor.ch\u003e\n",
      "commitDate": "2017-08-14, 8:03 a.m.",
      "commitName": "df3469f6ad81dccb314bf2d5021a3cec2b184985",
      "commitAuthor": "Thomas Wolf",
      "commitDateOld": "2017-02-20, 4:47 p.m.",
      "commitNameOld": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 174.59,
      "commitsBetweenForRepo": 208,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n\t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n\t\t\ttreeWalk.setRecursive(true);\n\t\t\t// add the trees (tree, dirchache, workdir)\n\t\t\tif (tree !\u003d null)\n\t\t\t\ttreeWalk.addTree(tree);\n\t\t\telse\n\t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n\t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n\n\t\t\tif (monitor !\u003d null) {\n\t\t\t\t// Get the maximum size of the work tree and index\n\t\t\t\t// and add some (quite arbitrary)\n\t\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\t\tmonitor.beginTask(title, total);\n\t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t\t}\n\n\t\t\tif (filter !\u003d null)\n\t\t\t\tfilters.add(filter);\n\t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\t\tfilters.add(indexDiffFilter);\n\t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\t\tfileModes.clear();\n\t\t\twhile (treeWalk.next()) {\n\t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\t\tDirCacheIterator.class);\n\t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n\t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| treeIterator\n\t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n\t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n\t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\tif (path !\u003d null) {\n\t\t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n\t\t\t\t\t\trecordFileMode(path, treeWalk.getFileMode(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tIOException e1 \u003d new IOException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n\t\t\t\t\t\t\tsmw.getPath()));\n\t\t\t\t\te1.initCause(e);\n\t\t\t\t\tthrow e1;\n\t\t\t\t}\n\t\t\t\tRepository subRepo \u003d smw.getRepository();\n\t\t\t\tif (subRepo !\u003d null) {\n\t\t\t\t\tString subRepoPath \u003d smw.getPath();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (subHead !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId())) {\n\t\t\t\t\t\t\tmodified.add(subRepoPath);\n\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n\t\t\t\t\t\t} else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n\t\t\t\t\t\t\t\t\t.getPath());\n\t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n\t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n\t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(subRepoPath, smid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmodified.add(subRepoPath);\n\t\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsubRepo.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 404,
      "functionName": "diff",
      "diff": "@@ -1,191 +1,190 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n \t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree !\u003d null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n \t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n \n \t\t\tif (monitor !\u003d null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter !\u003d null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator !\u003d null) {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n-\t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n-\t\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n-\t\t\t\t\tString path \u003d treeWalk.getPathString();\n-\t\t\t\t\tif (path !\u003d null) {\n-\t\t\t\t\t\tif (values \u003d\u003d null)\n-\t\t\t\t\t\t\tvalues \u003d new HashSet\u003c\u003e();\n-\t\t\t\t\t\tvalues.add(path);\n-\t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n+\t\t\t\tString path \u003d treeWalk.getPathString();\n+\t\t\t\tif (path !\u003d null) {\n+\t\t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n+\t\t\t\t\t\trecordFileMode(path, treeWalk.getFileMode(i));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 \u003d new IOException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n \t\t\t\t\t\t\tsmw.getPath()));\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo \u003d smw.getRepository();\n \t\t\t\tif (subRepo !\u003d null) {\n+\t\t\t\t\tString subRepoPath \u003d smw.getPath();\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead !\u003d null\n-\t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId()))\n-\t\t\t\t\t\t\tmodified.add(smw.getPath());\n-\t\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n+\t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId())) {\n+\t\t\t\t\t\t\tmodified.add(subRepoPath);\n+\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n+\t\t\t\t\t\t} else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n \t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n-\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n+\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(subRepoPath, smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n+\t\t\t\t\t\t\t\tmodified.add(subRepoPath);\n+\t\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
      "type": "Ybodychange",
      "commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit\u0027s not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017-02-20, 4:47 p.m.",
      "commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017-02-19, 7:05 p.m.",
      "commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n\t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n\t\t\ttreeWalk.setRecursive(true);\n\t\t\t// add the trees (tree, dirchache, workdir)\n\t\t\tif (tree !\u003d null)\n\t\t\t\ttreeWalk.addTree(tree);\n\t\t\telse\n\t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n\t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n\n\t\t\tif (monitor !\u003d null) {\n\t\t\t\t// Get the maximum size of the work tree and index\n\t\t\t\t// and add some (quite arbitrary)\n\t\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\t\tmonitor.beginTask(title, total);\n\t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t\t}\n\n\t\t\tif (filter !\u003d null)\n\t\t\t\tfilters.add(filter);\n\t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\t\tfilters.add(indexDiffFilter);\n\t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\t\tfileModes.clear();\n\t\t\twhile (treeWalk.next()) {\n\t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\t\tDirCacheIterator.class);\n\t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n\t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| treeIterator\n\t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n\t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n\t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n\t\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\tif (path !\u003d null) {\n\t\t\t\t\t\tif (values \u003d\u003d null)\n\t\t\t\t\t\t\tvalues \u003d new HashSet\u003c\u003e();\n\t\t\t\t\t\tvalues.add(path);\n\t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tIOException e1 \u003d new IOException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n\t\t\t\t\t\t\tsmw.getPath()));\n\t\t\t\t\te1.initCause(e);\n\t\t\t\t\tthrow e1;\n\t\t\t\t}\n\t\t\t\tRepository subRepo \u003d smw.getRepository();\n\t\t\t\tif (subRepo !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (subHead !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId()))\n\t\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n\t\t\t\t\t\t\t\t\t.getPath());\n\t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n\t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n\t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsubRepo.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 404,
      "functionName": "diff",
      "diff": "@@ -1,191 +1,191 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n \t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree !\u003d null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n-\t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n+\t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n \n \t\t\tif (monitor !\u003d null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter !\u003d null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator !\u003d null) {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n \t\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\tif (path !\u003d null) {\n \t\t\t\t\t\tif (values \u003d\u003d null)\n-\t\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n+\t\t\t\t\t\t\tvalues \u003d new HashSet\u003c\u003e();\n \t\t\t\t\t\tvalues.add(path);\n \t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 \u003d new IOException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n \t\t\t\t\t\t\tsmw.getPath()));\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo \u003d smw.getRepository();\n \t\t\t\tif (subRepo !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n \t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5d9f595eb87fba31c2253051102116fc7876e6c0": {
      "type": "Ybodychange",
      "commitMessage": "Add support for clean filters\n\nWhen filters are defined for certain paths in gitattributes make\nsure that clean filters are processed when adding new content to the\nobject database.\n\nChange-Id: Iffd72914cec5b434ba4d0de232e285b7492db868\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2015-11-27, 5:23 p.m.",
      "commitName": "5d9f595eb87fba31c2253051102116fc7876e6c0",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2015-11-17, 6:28 p.m.",
      "commitNameOld": "12280c02dbb8e4ac10893fbbd415be757afab4c1",
      "commitAuthorOld": "Arthur Daussy",
      "daysBetweenCommits": 9.95,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n\t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n\t\t\ttreeWalk.setRecursive(true);\n\t\t\t// add the trees (tree, dirchache, workdir)\n\t\t\tif (tree !\u003d null)\n\t\t\t\ttreeWalk.addTree(tree);\n\t\t\telse\n\t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n\t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\t\tif (monitor !\u003d null) {\n\t\t\t\t// Get the maximum size of the work tree and index\n\t\t\t\t// and add some (quite arbitrary)\n\t\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\t\tmonitor.beginTask(title, total);\n\t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t\t}\n\n\t\t\tif (filter !\u003d null)\n\t\t\t\tfilters.add(filter);\n\t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\t\tfilters.add(indexDiffFilter);\n\t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\t\tfileModes.clear();\n\t\t\twhile (treeWalk.next()) {\n\t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\t\tDirCacheIterator.class);\n\t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n\t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| treeIterator\n\t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n\t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n\t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n\t\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\tif (path !\u003d null) {\n\t\t\t\t\t\tif (values \u003d\u003d null)\n\t\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n\t\t\t\t\t\tvalues.add(path);\n\t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tIOException e1 \u003d new IOException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n\t\t\t\t\t\t\tsmw.getPath()));\n\t\t\t\t\te1.initCause(e);\n\t\t\t\t\tthrow e1;\n\t\t\t\t}\n\t\t\t\tRepository subRepo \u003d smw.getRepository();\n\t\t\t\tif (subRepo !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (subHead !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId()))\n\t\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n\t\t\t\t\t\t\t\t\t.getPath());\n\t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n\t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n\t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsubRepo.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 401,
      "functionName": "diff",
      "diff": "@@ -1,190 +1,191 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n \t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree !\u003d null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n+\t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n \t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\t\tif (monitor !\u003d null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter !\u003d null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator !\u003d null) {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n \t\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\tif (path !\u003d null) {\n \t\t\t\t\t\tif (values \u003d\u003d null)\n \t\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n \t\t\t\t\t\tvalues.add(path);\n \t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 \u003d new IOException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n \t\t\t\t\t\t\tsmw.getPath()));\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo \u003d smw.getRepository();\n \t\t\t\tif (subRepo !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n \t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "12280c02dbb8e4ac10893fbbd415be757afab4c1": {
      "type": "Ybodychange",
      "commitMessage": "Adds the git attributes computation on the treewalk\n\nAdds the getAttributes feature to the tree walk. The computation of\nattributes needs to be done by the TreeWalk since it needs both a\nWorkingTreeIterator and a DirCacheIterator.\n\nBug: 342372\nCQ: 9120\nChange-Id: I5e33257fd8c9895869a128bad3fd1e720409d361\nSigned-off-by: Arthur Daussy \u003carthur.daussy@obeo.fr\u003e\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2015-11-17, 6:28 p.m.",
      "commitName": "12280c02dbb8e4ac10893fbbd415be757afab4c1",
      "commitAuthor": "Arthur Daussy",
      "commitDateOld": "2015-05-26, 4:52 a.m.",
      "commitNameOld": "2390531888af6dc9e4fda6cb026271dc068c40ab",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 175.61,
      "commitsBetweenForRepo": 270,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n\t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n\t\t\ttreeWalk.setRecursive(true);\n\t\t\t// add the trees (tree, dirchache, workdir)\n\t\t\tif (tree !\u003d null)\n\t\t\t\ttreeWalk.addTree(tree);\n\t\t\telse\n\t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\t\tif (monitor !\u003d null) {\n\t\t\t\t// Get the maximum size of the work tree and index\n\t\t\t\t// and add some (quite arbitrary)\n\t\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\t\tmonitor.beginTask(title, total);\n\t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t\t}\n\n\t\t\tif (filter !\u003d null)\n\t\t\t\tfilters.add(filter);\n\t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\t\tfilters.add(indexDiffFilter);\n\t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\t\tfileModes.clear();\n\t\t\twhile (treeWalk.next()) {\n\t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\t\tDirCacheIterator.class);\n\t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n\t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| treeIterator\n\t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n\t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n\t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n\t\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\tif (path !\u003d null) {\n\t\t\t\t\t\tif (values \u003d\u003d null)\n\t\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n\t\t\t\t\t\tvalues.add(path);\n\t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tIOException e1 \u003d new IOException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n\t\t\t\t\t\t\tsmw.getPath()));\n\t\t\t\t\te1.initCause(e);\n\t\t\t\t\tthrow e1;\n\t\t\t\t}\n\t\t\t\tRepository subRepo \u003d smw.getRepository();\n\t\t\t\tif (subRepo !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (subHead !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId()))\n\t\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n\t\t\t\t\t\t\t\t\t.getPath());\n\t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n\t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n\t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsubRepo.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 401,
      "functionName": "diff",
      "diff": "@@ -1,189 +1,190 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n+\t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree !\u003d null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\t\tif (monitor !\u003d null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter !\u003d null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator !\u003d null) {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n \t\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\tif (path !\u003d null) {\n \t\t\t\t\t\tif (values \u003d\u003d null)\n \t\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n \t\t\t\t\t\tvalues.add(path);\n \t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 \u003d new IOException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n \t\t\t\t\t\t\tsmw.getPath()));\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo \u003d smw.getRepository();\n \t\t\t\tif (subRepo !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n \t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2390531888af6dc9e4fda6cb026271dc068c40ab": {
      "type": "Ybodychange",
      "commitMessage": "Externalize translatable texts in org.eclipse.jgit\n\nChange-Id: Ibf4c299f9d203c78cae79e61f88d4bea60ea2795\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015-05-26, 4:52 a.m.",
      "commitName": "2390531888af6dc9e4fda6cb026271dc068c40ab",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2015-05-20, 6:01 p.m.",
      "commitNameOld": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n\t\t\ttreeWalk.setRecursive(true);\n\t\t\t// add the trees (tree, dirchache, workdir)\n\t\t\tif (tree !\u003d null)\n\t\t\t\ttreeWalk.addTree(tree);\n\t\t\telse\n\t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\t\tif (monitor !\u003d null) {\n\t\t\t\t// Get the maximum size of the work tree and index\n\t\t\t\t// and add some (quite arbitrary)\n\t\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\t\tmonitor.beginTask(title, total);\n\t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t\t}\n\n\t\t\tif (filter !\u003d null)\n\t\t\t\tfilters.add(filter);\n\t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\t\tfilters.add(indexDiffFilter);\n\t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\t\tfileModes.clear();\n\t\t\twhile (treeWalk.next()) {\n\t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\t\tDirCacheIterator.class);\n\t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n\t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| treeIterator\n\t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n\t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n\t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n\t\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\tif (path !\u003d null) {\n\t\t\t\t\t\tif (values \u003d\u003d null)\n\t\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n\t\t\t\t\t\tvalues.add(path);\n\t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tIOException e1 \u003d new IOException(MessageFormat.format(\n\t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n\t\t\t\t\t\t\tsmw.getPath()));\n\t\t\t\t\te1.initCause(e);\n\t\t\t\t\tthrow e1;\n\t\t\t\t}\n\t\t\t\tRepository subRepo \u003d smw.getRepository();\n\t\t\t\tif (subRepo !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (subHead !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId()))\n\t\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n\t\t\t\t\t\t\t\t\t.getPath());\n\t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n\t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n\t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsubRepo.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 400,
      "functionName": "diff",
      "diff": "@@ -1,189 +1,189 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree !\u003d null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\t\tif (monitor !\u003d null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter !\u003d null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator !\u003d null) {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n \t\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\tif (path !\u003d null) {\n \t\t\t\t\t\tif (values \u003d\u003d null)\n \t\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n \t\t\t\t\t\tvalues.add(path);\n \t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n-\t\t\t\t\tIOException e1 \u003d new IOException(\n-\t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n-\t\t\t\t\t\t\t\t\t+ smw.getPath());\n+\t\t\t\t\tIOException e1 \u003d new IOException(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n+\t\t\t\t\t\t\tsmw.getPath()));\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo \u003d smw.getRepository();\n \t\t\t\tif (subRepo !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n \t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e73d395061d1bfee365acaa2f79c392175d13bf": {
      "type": "Ybodychange",
      "commitMessage": "Use AutoClosable to close resources in bundle org.eclipse.jgit\n\n- use try-with-resource where possible\n- replace use of deprecated release() by close()\n\nChange-Id: I0f139c3535679087b7fa09649166bca514750b81\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015-05-20, 6:01 p.m.",
      "commitName": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2014-12-12, 8:49 a.m.",
      "commitNameOld": "da595f093e5547a7da583fa0459400e47a2638c6",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 159.34,
      "commitsBetweenForRepo": 215,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n\t\t\ttreeWalk.setRecursive(true);\n\t\t\t// add the trees (tree, dirchache, workdir)\n\t\t\tif (tree !\u003d null)\n\t\t\t\ttreeWalk.addTree(tree);\n\t\t\telse\n\t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\t\tif (monitor !\u003d null) {\n\t\t\t\t// Get the maximum size of the work tree and index\n\t\t\t\t// and add some (quite arbitrary)\n\t\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\t\tmonitor.beginTask(title, total);\n\t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t\t}\n\n\t\t\tif (filter !\u003d null)\n\t\t\t\tfilters.add(filter);\n\t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\t\tfilters.add(indexDiffFilter);\n\t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\t\tfileModes.clear();\n\t\t\twhile (treeWalk.next()) {\n\t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\t\tDirCacheIterator.class);\n\t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n\t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| treeIterator\n\t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n\t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n\t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n\t\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\tif (path !\u003d null) {\n\t\t\t\t\t\tif (values \u003d\u003d null)\n\t\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n\t\t\t\t\t\tvalues.add(path);\n\t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tIOException e1 \u003d new IOException(\n\t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n\t\t\t\t\t\t\t\t\t+ smw.getPath());\n\t\t\t\t\te1.initCause(e);\n\t\t\t\t\tthrow e1;\n\t\t\t\t}\n\t\t\t\tRepository subRepo \u003d smw.getRepository();\n\t\t\t\tif (subRepo !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (subHead !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId()))\n\t\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n\t\t\t\t\t\t\t\t\t.getPath());\n\t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n\t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n\t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsubRepo.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 398,
      "functionName": "diff",
      "diff": "@@ -1,185 +1,189 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n-\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n-\t\ttreeWalk.setRecursive(true);\n-\t\t// add the trees (tree, dirchache, workdir)\n-\t\tif (tree !\u003d null)\n-\t\t\ttreeWalk.addTree(tree);\n-\t\telse\n-\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n-\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n-\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n-\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n+\t\ttry (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n+\t\t\ttreeWalk.setRecursive(true);\n+\t\t\t// add the trees (tree, dirchache, workdir)\n+\t\t\tif (tree !\u003d null)\n+\t\t\t\ttreeWalk.addTree(tree);\n+\t\t\telse\n+\t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n+\t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n+\t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n+\t\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n-\t\tif (monitor !\u003d null) {\n-\t\t\t// Get the maximum size of the work tree and index\n-\t\t\t// and add some (quite arbitrary)\n-\t\t\tif (estIndexSize \u003d\u003d 0)\n-\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n-\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n-\t\t\t\t\testWorkTreeSize * 10 / 9);\n-\t\t\tmonitor.beginTask(title, total);\n-\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n-\t\t}\n-\n-\t\tif (filter !\u003d null)\n-\t\t\tfilters.add(filter);\n-\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n-\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n-\t\tfilters.add(indexDiffFilter);\n-\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n-\t\tfileModes.clear();\n-\t\twhile (treeWalk.next()) {\n-\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n-\t\t\t\t\tAbstractTreeIterator.class);\n-\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n-\t\t\t\t\tDirCacheIterator.class);\n-\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n-\t\t\t\t\tWorkingTreeIterator.class);\n-\n-\t\t\tif (dirCacheIterator !\u003d null) {\n-\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n-\t\t\t\t\t\t.getDirCacheEntry();\n-\t\t\t\tif (dirCacheEntry !\u003d null) {\n-\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n-\t\t\t\t\tif (stage \u003e 0) {\n-\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n-\t\t\t\t\t\taddConflict(path, stage);\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\tif (monitor !\u003d null) {\n+\t\t\t\t// Get the maximum size of the work tree and index\n+\t\t\t\t// and add some (quite arbitrary)\n+\t\t\t\tif (estIndexSize \u003d\u003d 0)\n+\t\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n+\t\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n+\t\t\t\t\t\testWorkTreeSize * 10 / 9);\n+\t\t\t\tmonitor.beginTask(title, total);\n+\t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n-\t\t\tif (treeIterator !\u003d null) {\n+\t\t\tif (filter !\u003d null)\n+\t\t\t\tfilters.add(filter);\n+\t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n+\t\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n+\t\t\tfilters.add(indexDiffFilter);\n+\t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n+\t\t\tfileModes.clear();\n+\t\t\twhile (treeWalk.next()) {\n+\t\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n+\t\t\t\t\t\tAbstractTreeIterator.class);\n+\t\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n+\t\t\t\t\t\tDirCacheIterator.class);\n+\t\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk\n+\t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n+\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n-\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n-\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n-\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n-\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n+\t\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n+\t\t\t\t\t\t\t.getDirCacheEntry();\n+\t\t\t\t\tif (dirCacheEntry !\u003d null) {\n+\t\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n+\t\t\t\t\t\tif (stage \u003e 0) {\n+\t\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n+\t\t\t\t\t\t\taddConflict(path, stage);\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (treeIterator !\u003d null) {\n+\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n+\t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n+\t\t\t\t\t\t\t\t|| treeIterator\n+\t\t\t\t\t\t\t\t\t\t.getEntryRawMode() !\u003d dirCacheIterator\n+\t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n+\t\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n+\t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n+\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n-\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n-\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n+\t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n+\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n+\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n-\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n-\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n-\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n-\t\t\t\t\tif (workingTreeIterator !\u003d null)\n-\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n+\t\t\t\t\tif (dirCacheIterator !\u003d null) {\n+\t\t\t\t\t\t// not in repo, in index \u003d\u003e added\n+\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n+\t\t\t\t\t\tif (workingTreeIterator !\u003d null\n+\t\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n+\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t} else {\n+\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n-\t\t\t\t\t// not in repo, in index \u003d\u003e added\n-\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n-\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n-\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n-\t\t\t\t} else {\n-\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n-\t\t\t\t\tif (workingTreeIterator !\u003d null\n-\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n-\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n+\t\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n+\t\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n+\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (workingTreeIterator.isModified(\n+\t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n+\t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n+\t\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n+\t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n+\t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL\n+\t\t\t\t\t\t\t\t\t\t\t\u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n+\t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n \n-\t\t\tif (dirCacheIterator !\u003d null) {\n-\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n-\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n-\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n-\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n-\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n-\t\t\t\t} else {\n-\t\t\t\t\tif (workingTreeIterator.isModified(\n-\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n-\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n-\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n-\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n-\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n-\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n+\t\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n+\t\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n+\t\t\t\t\tString path \u003d treeWalk.getPathString();\n+\t\t\t\t\tif (path !\u003d null) {\n+\t\t\t\t\t\tif (values \u003d\u003d null)\n+\t\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n+\t\t\t\t\t\tvalues.add(path);\n+\t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\n-\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n-\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n-\t\t\t\tString path \u003d treeWalk.getPathString();\n-\t\t\t\tif (path !\u003d null) {\n-\t\t\t\t\tif (values \u003d\u003d null)\n-\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n-\t\t\t\t\tvalues.add(path);\n-\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n-\t\t\t\t}\n-\t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 \u003d new IOException(\n \t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n \t\t\t\t\t\t\t\t\t+ smw.getPath());\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo \u003d smw.getRepository();\n \t\t\t\tif (subRepo !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead !\u003d null\n \t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n \t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "da595f093e5547a7da583fa0459400e47a2638c6": {
      "type": "Ybodychange",
      "commitMessage": "Fix tests on windows by closing repos\n\nWithout explicitly closing repos we can\u0027t delete the test repositories\non windows.\n\nChange-Id: Id5fa17bd764cbf28703c2f21639d7e969289c2d6\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014-12-12, 8:49 a.m.",
      "commitName": "da595f093e5547a7da583fa0459400e47a2638c6",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2014-11-09, 4:44 p.m.",
      "commitNameOld": "9597c41ea9db20d769f7b8c54eafa207824e5bd6",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 32.67,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\tfilters.add(indexDiffFilter);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\tfileModes.clear();\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\tif (path !\u003d null) {\n\t\t\t\t\tif (values \u003d\u003d null)\n\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n\t\t\t\t\tvalues.add(path);\n\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tIOException e1 \u003d new IOException(\n\t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n\t\t\t\t\t\t\t\t\t+ smw.getPath());\n\t\t\t\t\te1.initCause(e);\n\t\t\t\t\tthrow e1;\n\t\t\t\t}\n\t\t\t\tRepository subRepo \u003d smw.getRepository();\n\t\t\t\tif (subRepo !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (subHead !\u003d null\n\t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId()))\n\t\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n\t\t\t\t\t\t\t\t\t.getPath());\n\t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n\t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n\t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsubRepo.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 398,
      "functionName": "diff",
      "diff": "@@ -1,178 +1,185 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\tif (monitor !\u003d null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\tfileModes.clear();\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n \t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\tif (path !\u003d null) {\n \t\t\t\t\tif (values \u003d\u003d null)\n \t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n \t\t\t\t\tvalues.add(path);\n \t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 \u003d new IOException(\n \t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n \t\t\t\t\t\t\t\t\t+ smw.getPath());\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo \u003d smw.getRepository();\n \t\t\t\tif (subRepo !\u003d null) {\n-\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n-\t\t\t\t\tif (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n-\t\t\t\t\t\tmodified.add(smw.getPath());\n-\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n-\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n-\t\t\t\t\t\tif (smid \u003d\u003d null) {\n-\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo, smw.getObjectId(),\n-\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n-\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (smid.diff()) {\n-\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n-\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n-\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n-\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n-\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n-\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n-\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n-\t\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n+\t\t\t\t\t\tif (subHead !\u003d null\n+\t\t\t\t\t\t\t\t\u0026\u0026 !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\t\tmodified.add(smw.getPath());\n+\t\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n+\t\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw\n+\t\t\t\t\t\t\t\t\t.getPath());\n+\t\t\t\t\t\t\tif (smid \u003d\u003d null) {\n+\t\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo,\n+\t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n+\t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n+\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (smid.diff()) {\n+\t\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n+\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n+\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n+\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n+\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n+\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n+\t\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n+\t\t\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t} finally {\n+\t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9597c41ea9db20d769f7b8c54eafa207824e5bd6": {
      "type": "Ybodychange",
      "commitMessage": "Fix possible NPE in IndexDiff when not all submodules are cloned\n\nThe latest changes to IndexDiff just assumed that all configured\nsubmodules are allways cloned. If a configured submodule did not exist\nan exception was thrown. This is fixed by this commit.\n\nBug: 450567\nChange-Id: Iabe3b196d998c19483082e5720038ebddaeb1890\n",
      "commitDate": "2014-11-09, 4:44 p.m.",
      "commitName": "9597c41ea9db20d769f7b8c54eafa207824e5bd6",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2014-11-06, 3:48 a.m.",
      "commitNameOld": "abb57e6b5674b7251bd94b7238e5d995ad9c30c5",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 3.54,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\tfilters.add(indexDiffFilter);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\tfileModes.clear();\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\tif (path !\u003d null) {\n\t\t\t\t\tif (values \u003d\u003d null)\n\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n\t\t\t\t\tvalues.add(path);\n\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tIOException e1 \u003d new IOException(\n\t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n\t\t\t\t\t\t\t\t\t+ smw.getPath());\n\t\t\t\t\te1.initCause(e);\n\t\t\t\t\tthrow e1;\n\t\t\t\t}\n\t\t\t\tRepository subRepo \u003d smw.getRepository();\n\t\t\t\tif (subRepo !\u003d null) {\n\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n\t\t\t\t\tif (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n\t\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo, smw.getObjectId(),\n\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 398,
      "functionName": "diff",
      "diff": "@@ -1,176 +1,178 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\tif (monitor !\u003d null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\tfileModes.clear();\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n \t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\tif (path !\u003d null) {\n \t\t\t\t\tif (values \u003d\u003d null)\n \t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n \t\t\t\t\tvalues.add(path);\n \t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 \u003d new IOException(\n \t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n \t\t\t\t\t\t\t\t\t+ smw.getPath());\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo \u003d smw.getRepository();\n-\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n-\t\t\t\tif (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n-\t\t\t\t\tmodified.add(smw.getPath());\n-\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n-\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n-\t\t\t\t\tif (smid \u003d\u003d null) {\n-\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo, smw.getObjectId(),\n-\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n-\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n-\t\t\t\t\t}\n-\t\t\t\t\tif (smid.diff()) {\n-\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n-\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n-\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n-\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n-\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n-\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n-\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n-\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t}\n+\t\t\t\tif (subRepo !\u003d null) {\n+\t\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n+\t\t\t\t\tif (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\tmodified.add(smw.getPath());\n+\t\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n+\t\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n+\t\t\t\t\t\tif (smid \u003d\u003d null) {\n+\t\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo, smw.getObjectId(),\n+\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n+\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (smid.diff()) {\n+\t\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n+\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n+\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n+\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n+\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n+\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n+\t\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n+\t\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tmodified.add(smw.getPath());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "abb57e6b5674b7251bd94b7238e5d995ad9c30c5": {
      "type": "Ybodychange",
      "commitMessage": "Do not swallow exception if IndexDiff hits invalid ignore param\n\nChange-Id: I8a595e1f01a0731118d3c537be420222f7fec744\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014-11-06, 3:48 a.m.",
      "commitName": "abb57e6b5674b7251bd94b7238e5d995ad9c30c5",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2014-11-06, 3:46 a.m.",
      "commitNameOld": "d8fcc964a85b255aac431c14ac35624f0634620b",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\tfilters.add(indexDiffFilter);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\tfileModes.clear();\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\tif (path !\u003d null) {\n\t\t\t\t\tif (values \u003d\u003d null)\n\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n\t\t\t\t\tvalues.add(path);\n\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tIOException e1 \u003d new IOException(\n\t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n\t\t\t\t\t\t\t\t\t+ smw.getPath());\n\t\t\t\t\te1.initCause(e);\n\t\t\t\t\tthrow e1;\n\t\t\t\t}\n\t\t\t\tRepository subRepo \u003d smw.getRepository();\n\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n\t\t\t\tif (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo, smw.getObjectId(),\n\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n\t\t\t\t\t}\n\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 398,
      "functionName": "diff",
      "diff": "@@ -1,174 +1,176 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\tif (monitor !\u003d null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\tfileModes.clear();\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n \t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\tif (path !\u003d null) {\n \t\t\t\t\tif (values \u003d\u003d null)\n \t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n \t\t\t\t\tvalues.add(path);\n \t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n-\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\tIOException e1 \u003d new IOException(\n \t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n \t\t\t\t\t\t\t\t\t+ smw.getPath());\n+\t\t\t\t\te1.initCause(e);\n+\t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo \u003d smw.getRepository();\n \t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\tif (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n \t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n \t\t\t\t\tif (smid \u003d\u003d null) {\n \t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo, smw.getObjectId(),\n \t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t}\n \t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d8fcc964a85b255aac431c14ac35624f0634620b": {
      "type": "Ybodychange",
      "commitMessage": "Fix non-externalized string warnings in IndexDiff\n\nChange-Id: Ia803182114f0e8b418428e03601f9afc6542ed28\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014-11-06, 3:46 a.m.",
      "commitName": "d8fcc964a85b255aac431c14ac35624f0634620b",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2014-11-06, 3:40 a.m.",
      "commitNameOld": "5328c8c9164414a63ce7f1323d8194b84b6f1e49",
      "commitAuthorOld": "Axel Richard",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\tfilters.add(indexDiffFilter);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\tfileModes.clear();\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\tif (path !\u003d null) {\n\t\t\t\t\tif (values \u003d\u003d null)\n\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n\t\t\t\t\tvalues.add(path);\n\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tthrow new IOException(\n\t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n\t\t\t\t\t\t\t\t\t+ smw.getPath());\n\t\t\t\t}\n\t\t\t\tRepository subRepo \u003d smw.getRepository();\n\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n\t\t\t\tif (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo, smw.getObjectId(),\n\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n\t\t\t\t\t}\n\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 398,
      "functionName": "diff",
      "diff": "@@ -1,174 +1,174 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\tif (monitor !\u003d null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\tfileModes.clear();\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n \t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\tif (path !\u003d null) {\n \t\t\t\t\tif (values \u003d\u003d null)\n \t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n \t\t\t\t\tvalues.add(path);\n \t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tthrow new IOException(\n \t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n \t\t\t\t\t\t\t\t\t+ smw.getPath());\n \t\t\t\t}\n \t\t\t\tRepository subRepo \u003d smw.getRepository();\n-\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n+\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\tif (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n \t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n \t\t\t\t\tif (smid \u003d\u003d null) {\n \t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo, smw.getObjectId(),\n \t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t}\n \t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5328c8c9164414a63ce7f1323d8194b84b6f1e49": {
      "type": "Ybodychange",
      "commitMessage": "Add new method IndexDiff#getPathsWithIndexMode\n\nGet the list of paths that have the given file mode.\n\nThis helps EGit to efficiently determine which modified files are\nsymlinks and should be shown with a symlink icon in the staging view.\n\nBug: 429302\nChange-Id: Id15f0c6f265667f5b8b57cc2d9f97de568371919\nSigned-off-by: Axel Richard \u003caxel.richard@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014-11-06, 3:40 a.m.",
      "commitName": "5328c8c9164414a63ce7f1323d8194b84b6f1e49",
      "commitAuthor": "Axel Richard",
      "commitDateOld": "2014-11-03, 11:08 a.m.",
      "commitNameOld": "c017ac4c85cab7449a49b681843b9bc33e54d2b6",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\tfilters.add(indexDiffFilter);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\tfileModes.clear();\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\tif (path !\u003d null) {\n\t\t\t\t\tif (values \u003d\u003d null)\n\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n\t\t\t\t\tvalues.add(path);\n\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tthrow new IOException(\n\t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n\t\t\t\t\t\t\t\t\t+ smw.getPath());\n\t\t\t\t}\n\t\t\t\tRepository subRepo \u003d smw.getRepository();\n\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n\t\t\t\tif (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo, smw.getObjectId(),\n\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n\t\t\t\t\t}\n\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 398,
      "functionName": "diff",
      "diff": "@@ -1,161 +1,174 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\tif (monitor !\u003d null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n+\t\tfileModes.clear();\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tfor (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n+\t\t\t\tSet\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n+\t\t\t\tString path \u003d treeWalk.getPathString();\n+\t\t\t\tif (path !\u003d null) {\n+\t\t\t\t\tif (values \u003d\u003d null)\n+\t\t\t\t\t\tvalues \u003d new HashSet\u003cString\u003e();\n+\t\t\t\t\tvalues.add(path);\n+\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tthrow new IOException(\n \t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n \t\t\t\t\t\t\t\t\t+ smw.getPath());\n \t\t\t\t}\n \t\t\t\tRepository subRepo \u003d smw.getRepository();\n \t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n \t\t\t\tif (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n \t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n \t\t\t\t\tif (smid \u003d\u003d null) {\n \t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo, smw.getObjectId(),\n \t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t}\n \t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "95172dea173425697814e3ba0b4eb823301bf7d0": {
      "type": "Ybodychange",
      "commitMessage": "Support for Submodule configuration submodule.\u003cname\u003e.ignore\n\nFor each submodule native git allows to configure which modifications to\nsubmodules should be ignored by the status command. It is possible to\nignore \"none\", \"all\", \"dirty\", \"untracked\" [1]. This configuration is\nnow supported by IndexDiff. The StatusCommand offers the possibility to\nspecify this mode.\n\n[1] http://git-scm.com/docs/gitmodules\n\nChange-Id: Ifd81d574a680f9b4152945ba70f8ec4af4f452c9\n",
      "commitDate": "2014-11-03, 4:32 a.m.",
      "commitName": "95172dea173425697814e3ba0b4eb823301bf7d0",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2014-02-02, 7:16 a.m.",
      "commitNameOld": "5404e70dc64201786cd6a21efb41310912860122",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 273.89,
      "commitsBetweenForRepo": 346,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\tfilters.add(indexDiffFilter);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n\t\t\twhile (smw.next()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ConfigInvalidException e) {\n\t\t\t\t\tthrow new IOException(\n\t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n\t\t\t\t\t\t\t\t\t+ smw.getPath());\n\t\t\t\t}\n\t\t\t\tRepository subRepo \u003d smw.getRepository();\n\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n\t\t\t\tif (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n\t\t\t\t\tif (smid \u003d\u003d null) {\n\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo, smw.getObjectId(),\n\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n\t\t\t\t\t}\n\t\t\t\t\tif (smid.diff()) {\n\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified.add(smw.getPath());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 392,
      "functionName": "diff",
      "diff": "@@ -1,108 +1,161 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\tif (monitor !\u003d null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n-\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n+\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n+\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n-\t\t\t\t\tremoved.add(treeWalk.getPathString());\n+\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n+\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n-\t\t\t\t\tadded.add(treeWalk.getPathString());\n+\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n-\t\t\t\t\tmissing.add(treeWalk.getPathString());\n+\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t|| ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n-\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n+\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n+\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n+\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n+\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n+\t\t\tSubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n+\t\t\twhile (smw.next()) {\n+\t\t\t\ttry {\n+\t\t\t\t\tif (localIgnoreSubmoduleMode \u003d\u003d null)\n+\t\t\t\t\t\tlocalIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n+\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n+\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t} catch (ConfigInvalidException e) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n+\t\t\t\t\t\t\t\t\t+ smw.getPath());\n+\t\t\t\t}\n+\t\t\t\tRepository subRepo \u003d smw.getRepository();\n+\t\t\t\tObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n+\t\t\t\tif (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n+\t\t\t\t\tmodified.add(smw.getPath());\n+\t\t\t\telse if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n+\t\t\t\t\tIndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n+\t\t\t\t\tif (smid \u003d\u003d null) {\n+\t\t\t\t\t\tsmid \u003d new IndexDiff(subRepo, smw.getObjectId(),\n+\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n+\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n+\t\t\t\t\t}\n+\t\t\t\t\tif (smid.diff()) {\n+\t\t\t\t\t\tif (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED\n+\t\t\t\t\t\t\t\t\u0026\u0026 smid.getAdded().isEmpty()\n+\t\t\t\t\t\t\t\t\u0026\u0026 smid.getChanged().isEmpty()\n+\t\t\t\t\t\t\t\t\u0026\u0026 smid.getConflicting().isEmpty()\n+\t\t\t\t\t\t\t\t\u0026\u0026 smid.getMissing().isEmpty()\n+\t\t\t\t\t\t\t\t\u0026\u0026 smid.getModified().isEmpty()\n+\t\t\t\t\t\t\t\t\u0026\u0026 smid.getRemoved().isEmpty()) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5404e70dc64201786cd6a21efb41310912860122": {
      "type": "Ybodychange",
      "commitMessage": "Fix for core.autocrlf\u003dinput resulting in modified file\n\nThis version does not attempt to unsmudge, unlike the first attempt\nin Idafad150553df14827eccfde2e3b95760e16a8b6.\n\nBug: 372834\nChange-Id: I9300e735cb16d6208e1df963abb1ff69f688155d\nAlso-by: Robin Stocker \u003crobin@nibor.org\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\n",
      "commitDate": "2014-02-02, 7:16 a.m.",
      "commitName": "5404e70dc64201786cd6a21efb41310912860122",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013-04-19, 11:05 a.m.",
      "commitNameOld": "1080cc5a0d67012c0ef08d9468fbbc9d90b0c238",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 288.88,
      "commitsBetweenForRepo": 282,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\tfilters.add(indexDiffFilter);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 356,
      "functionName": "diff",
      "diff": "@@ -1,107 +1,108 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\tif (monitor !\u003d null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry !\u003d null) {\n \t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n \t\t\t\t\tif (stage \u003e 0) {\n \t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n-\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n+\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n+\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1080cc5a0d67012c0ef08d9468fbbc9d90b0c238": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Provide stage state for conflicting entries\n\nAdds a new method getConflictingStageStates() which returns a\nMap\u003cString, StageState\u003e (path to stage state). StageState is an enum for\nall possible stage combinations (BOTH_DELETED, ADDED_BY_US, ...).\n\nThis can be used to implement the conflict text for unmerged paths in\noutput of \"git status\" or in EGit for decorations/hints.\n\nBug: 403697\nChange-Id: Ib461640a43111b7df4a0debe92ff69b82171329c\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2013-04-19, 11:05 a.m.",
      "commitName": "1080cc5a0d67012c0ef08d9468fbbc9d90b0c238",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2012-12-27, 10:57 a.m.",
      "commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 112.96,
      "commitsBetweenForRepo": 201,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\tfilters.add(indexDiffFilter);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\tif (dirCacheEntry !\u003d null) {\n\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n\t\t\t\t\tif (stage \u003e 0) {\n\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n\t\t\t\t\t\taddConflict(path, stage);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 356,
      "functionName": "diff",
      "diff": "@@ -1,103 +1,107 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\tif (monitor !\u003d null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n-\t\t\t\tif (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n-\t\t\t\t\tconflicts.add(treeWalk.getPathString());\n-\t\t\t\t\tcontinue;\n+\t\t\t\tif (dirCacheEntry !\u003d null) {\n+\t\t\t\t\tint stage \u003d dirCacheEntry.getStage();\n+\t\t\t\t\tif (stage \u003e 0) {\n+\t\t\t\t\t\tString path \u003d treeWalk.getPathString();\n+\t\t\t\t\t\taddConflict(path, stage);\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53ef3e51145adb4b060110e262d7c064be0d5fc5": {
      "type": "Ybodychange",
      "commitMessage": "Add detection of untracked folders to IndexDiffFilter\n\nDecorators need to know whether folders in the working tree contain only\nuntracked files. This change enhances IndexDiffFilter to report such\nfolders. This works only together with treewalks which operate in\ndefault traversal mode. For treewalks which process entries in\npostorder mode (files are walked before their parent folder is walked)\nthis detection doesn\u0027t work.\n\nBug: 359264\nChange-Id: I9298d1e3ccac0aec8bbd4e8ac867bc06a5c89c9f\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2011-11-10, 2:15 p.m.",
      "commitName": "53ef3e51145adb4b060110e262d7c064be0d5fc5",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2011-10-05, 7:56 a.m.",
      "commitNameOld": "6befabcb1584118fb02188f602f7ca34b9a7efc5",
      "commitAuthorOld": "Jens Baumgart",
      "daysBetweenCommits": 36.3,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\tfilters.add(indexDiffFilter);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\tif (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n\t\t\t\t\tconflicts.add(treeWalk.getPathString());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 254,
      "functionName": "diff",
      "diff": "@@ -1,103 +1,103 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\tif (monitor !\u003d null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n-\t\tIndexDiffFilter indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n+\t\tindexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n \t\t\t\t\tconflicts.add(treeWalk.getPathString());\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6befabcb1584118fb02188f602f7ca34b9a7efc5": {
      "type": "Ybodychange",
      "commitMessage": "Extend IndexDiff to calculate ignored files and folders\n\nIndexDiff was extended to calculate ignored files and folders.\nThe calculation only considers files that are NOT in the index.\nThis functionality is required by the new EGit decorator implementation.\n\nBug: 359264\nChange-Id: I8f09d6a4d61b64aeea80fd22bf3a2963c2bca347\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\n",
      "commitDate": "2011-10-05, 7:56 a.m.",
      "commitName": "6befabcb1584118fb02188f602f7ca34b9a7efc5",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2011-08-16, 4:22 p.m.",
      "commitNameOld": "ac909ec89d7a6f59e2d02dcc900a4f80576b12a4",
      "commitAuthorOld": "Kevin Sawicki",
      "daysBetweenCommits": 49.65,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tIndexDiffFilter indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n\t\tfilters.add(indexDiffFilter);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\tif (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n\t\t\t\t\tconflicts.add(treeWalk.getPathString());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 251,
      "functionName": "diff",
      "diff": "@@ -1,101 +1,103 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\tif (monitor !\u003d null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n-\t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n+\t\tIndexDiffFilter indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n+\t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n \t\t\t\t\tconflicts.add(treeWalk.getPathString());\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n+\t\tignored \u003d indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "298486a7c320629de12f9506e0133686a7382b01": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: conflicting files aren\u0027t properly shown\n\nBefore this change any files in the conflicting set would\nalso be listed in the the other IndexDiff Sets which is\nconfusing.  With this change a conflicting file will not\nbe included in any of the other sets.\n\nChange-Id: Ife9f2652685220bcfddc1f9820423acdcd5acfdc\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011-05-05, 2:48 p.m.",
      "commitName": "298486a7c320629de12f9506e0133686a7382b01",
      "commitAuthor": "Bernard Leach",
      "commitDateOld": "2011-04-19, 6:11 p.m.",
      "commitNameOld": "1a867d10b974cab4d43d77f5b392f4f07807ebd8",
      "commitAuthorOld": "Bernard Leach",
      "daysBetweenCommits": 15.86,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\tif (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n\t\t\t\t\tconflicts.add(treeWalk.getPathString());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 249,
      "functionName": "diff",
      "diff": "@@ -1,98 +1,101 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\tif (monitor !\u003d null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n+\t\t\tif (dirCacheIterator !\u003d null) {\n+\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n+\t\t\t\t\t\t.getDirCacheEntry();\n+\t\t\t\tif (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n+\t\t\t\t\tconflicts.add(treeWalk.getPathString());\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n-\n-\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n-\t\t\t\t\t\t.getDirCacheEntry();\n-\t\t\t\tif (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n-\t\t\t\t\tconflicts.add(treeWalk.getPathString());\n-\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a867d10b974cab4d43d77f5b392f4f07807ebd8": {
      "type": "Ybodychange",
      "commitMessage": "Added support to IndexDiff to return information on conflicts\n\nChange-Id: I43c13eb72a44f80135c93525fce0c0280b0e64a2\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011-04-19, 6:11 p.m.",
      "commitName": "1a867d10b974cab4d43d77f5b392f4f07807ebd8",
      "commitAuthor": "Bernard Leach",
      "commitDateOld": "2011-03-08, 6:05 p.m.",
      "commitNameOld": "c7e9f013b716b6c25bffd8f4f83b738c1a1f1cd8",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 41.96,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n\t\t\t\t\t\t.getDirCacheEntry();\n\t\t\t\tif (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n\t\t\t\t\tconflicts.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 249,
      "functionName": "diff",
      "diff": "@@ -1,92 +1,98 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \n \t\tif (monitor !\u003d null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize \u003d\u003d 0)\n \t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n \t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n+\n+\t\t\t\tfinal DirCacheEntry dirCacheEntry \u003d dirCacheIterator\n+\t\t\t\t\t\t.getDirCacheEntry();\n+\t\t\t\tif (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n+\t\t\t\t\tconflicts.add(treeWalk.getPathString());\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor !\u003d null)\n \t\t\tmonitor.endTask();\n \n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5e2e3819a690b739eba773415899d20db88a452e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Add progress reporting to IndexDiff\n\nChange-Id: I4f05bdb0c58b039bd379341a6093f06a2cdfec6e\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2011-01-20, 7:28 p.m.",
      "commitName": "5e2e3819a690b739eba773415899d20db88a452e",
      "commitAuthor": "Robin Rosenberg",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Add progress reporting to IndexDiff\n\nChange-Id: I4f05bdb0c58b039bd379341a6093f06a2cdfec6e\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
          "commitDate": "2011-01-20, 7:28 p.m.",
          "commitName": "5e2e3819a690b739eba773415899d20db88a452e",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2010-12-09, 12:51 p.m.",
          "commitNameOld": "1783749e169c57cef7131e1749a01ee269b89df8",
          "commitAuthorOld": "Christian Halstrick",
          "daysBetweenCommits": 42.28,
          "commitsBetweenForRepo": 65,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
          "functionStartLine": 245,
          "functionName": "diff",
          "diff": "@@ -1,74 +1,92 @@\n-\tpublic boolean diff() throws IOException {\n+\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n+\t\t\tint estIndexSize, final String title)\n+\t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n+\n+\t\tif (monitor !\u003d null) {\n+\t\t\t// Get the maximum size of the work tree and index\n+\t\t\t// and add some (quite arbitrary)\n+\t\t\tif (estIndexSize \u003d\u003d 0)\n+\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n+\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n+\t\t\t\t\testWorkTreeSize * 10 / 9);\n+\t\t\tmonitor.beginTask(title, total);\n+\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n+\t\t}\n+\n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\t// consume the remaining work\n+\t\tif (monitor !\u003d null)\n+\t\t\tmonitor.endTask();\n+\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[monitor-ProgressMonitor(modifiers-final), estWorkTreeSize-int, estIndexSize-int, title-String(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Add progress reporting to IndexDiff\n\nChange-Id: I4f05bdb0c58b039bd379341a6093f06a2cdfec6e\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
          "commitDate": "2011-01-20, 7:28 p.m.",
          "commitName": "5e2e3819a690b739eba773415899d20db88a452e",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2010-12-09, 12:51 p.m.",
          "commitNameOld": "1783749e169c57cef7131e1749a01ee269b89df8",
          "commitAuthorOld": "Christian Halstrick",
          "daysBetweenCommits": 42.28,
          "commitsBetweenForRepo": 65,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n\t\t\tint estIndexSize, final String title)\n\t\t\tthrows IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\n\t\tif (monitor !\u003d null) {\n\t\t\t// Get the maximum size of the work tree and index\n\t\t\t// and add some (quite arbitrary)\n\t\t\tif (estIndexSize \u003d\u003d 0)\n\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n\t\t\t\t\testWorkTreeSize * 10 / 9);\n\t\t\tmonitor.beginTask(title, total);\n\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n\t\t}\n\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// consume the remaining work\n\t\tif (monitor !\u003d null)\n\t\t\tmonitor.endTask();\n\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
          "functionStartLine": 245,
          "functionName": "diff",
          "diff": "@@ -1,74 +1,92 @@\n-\tpublic boolean diff() throws IOException {\n+\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n+\t\t\tint estIndexSize, final String title)\n+\t\t\tthrows IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n+\n+\t\tif (monitor !\u003d null) {\n+\t\t\t// Get the maximum size of the work tree and index\n+\t\t\t// and add some (quite arbitrary)\n+\t\t\tif (estIndexSize \u003d\u003d 0)\n+\t\t\t\testIndexSize \u003d dirCache.getEntryCount();\n+\t\t\tint total \u003d Math.max(estIndexSize * 10 / 9,\n+\t\t\t\t\testWorkTreeSize * 10 / 9);\n+\t\t\tmonitor.beginTask(title, total);\n+\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n+\t\t}\n+\n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\t// consume the remaining work\n+\t\tif (monitor !\u003d null)\n+\t\t\tmonitor.endTask();\n+\n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "1783749e169c57cef7131e1749a01ee269b89df8": {
      "type": "Ybodychange",
      "commitMessage": "Add a performance optimized variant of the ANY_DIFF filter\n\nIf a treewalk walks also over index and the workingtree then the\nIndexDiffFilter filter can be used which works much faster then\nthe semantically equivalent ANY_DIFF filter. This is because this\nfilter can better avoid computing SHA-1 ids over the content of\nworking-tree files which is very costly.\n\nThis fix will significantly improve the performance of e.g.\nEGit\u0027s commit dialog.\n\nChange-Id: I2a51816f4ed9df2900c6307a54cd09f50004266f\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Philipp Thun \u003cphilipp.thun@sap.com\u003e\n",
      "commitDate": "2010-12-09, 12:51 p.m.",
      "commitName": "1783749e169c57cef7131e1749a01ee269b89df8",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2010-12-08, 1:03 p.m.",
      "commitNameOld": "18abb8195a67a0502a71e2420078dd95563e18c6",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.99,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 170,
      "functionName": "diff",
      "diff": "@@ -1,75 +1,74 @@\n \tpublic boolean diff() throws IOException {\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n-\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n-\t\tfilters.add(TreeFilter.ANY_DIFF);\n+\t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n \t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n \t\t\t\t\u0026\u0026 untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "18abb8195a67a0502a71e2420078dd95563e18c6": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Remove unnecessary changesExist flag\n\nInstead of setting a boolean when a difference record is found, return\nfalse from diff() only if all of the collections are empty.  When all\nof them are empty, no difference was found.\n\nChange-Id: I555fef37adb764ce253481751071c53ad12cf416\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-12-08, 1:03 p.m.",
      "commitName": "18abb8195a67a0502a71e2420078dd95563e18c6",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-12-08, 1:03 p.m.",
      "commitNameOld": "a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(TreeFilter.ANY_DIFF);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n\t\t\t\t\u0026\u0026 untracked.isEmpty())\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 170,
      "functionName": "diff",
      "diff": "@@ -1,76 +1,75 @@\n \tpublic boolean diff() throws IOException {\n-\t\tboolean changesExist \u003d false;\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n-\t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n-\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n-\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n-\t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n-\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n-\t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\treturn changesExist;\n+\n+\t\tif (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty()\n+\t\t\t\t\u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty()\n+\t\t\t\t\u0026\u0026 untracked.isEmpty())\n+\t\t\treturn false;\n+\t\telse\n+\t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Use isModified() when comparing index-worktree\n\nThe isModified() is more efficient because it can skip over files that\nare stat clean, without needing to scan them.\n\nThis is useful to efficently work on paths that were already staged\nand thus differ between HEAD and the index, but not between the index\nand the working tree.\n\nChange-Id: I4418202e612f0571974e0898050d987c6c280966\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-12-08, 1:03 p.m.",
      "commitName": "a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-12-08, 1:03 p.m.",
      "commitNameOld": "d4bbb2e4497335993f4d24f539111dc5d3f8bbcd",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(TreeFilter.ANY_DIFF);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (workingTreeIterator.isModified(\n\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 170,
      "functionName": "diff",
      "diff": "@@ -1,75 +1,76 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist \u003d false;\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n-\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n+\t\t\t\t\tif (workingTreeIterator.isModified(\n+\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d4bbb2e4497335993f4d24f539111dc5d3f8bbcd": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Clean up tree-index compare for staged files\n\nWhen comparing the ObjectIds for two tree entries its faster\nto use the raw buffer compares over allocating ObjectIds and\nthen performing equals on their contents.\n\nHowever, this also needs to consider the raw modes.  It is possible\nfor a path to change modes but not ObjectId (e.g. making a file\nexecutable), and in this case its still a staged change to report back\nto the caller.\n\nChange-Id: I1a267254c04b3273a97f63c71d1e6718cd9d2fa8\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-12-08, 1:03 p.m.",
      "commitName": "d4bbb2e4497335993f4d24f539111dc5d3f8bbcd",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-12-08, 1:03 p.m.",
      "commitNameOld": "e6c39227640536ac1c2e41d8970aeca84b3c6268",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(TreeFilter.ANY_DIFF);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 170,
      "functionName": "diff",
      "diff": "@@ -1,74 +1,75 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist \u003d false;\n \t\tdirCache \u003d repository.readDirCache();\n \n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n-\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n-\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n+\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n+\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n+\t\t\t\t\t\t\t!\u003d dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e6c39227640536ac1c2e41d8970aeca84b3c6268": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Fix getAssumeUnchanged()\n\nIf the caller really needs the list of files that are flagged as\nassume-unchanged (aka assume-valid in the DirCache), we should give\nthem the complete list and not just those that we wrongly identified\nas being modified during diff().\n\nThis change is necessary because diff() is slightly broken and is\ndiscovering differences on files that it shouldn\u0027t have considered.\n\nChange-Id: Ibe464c1a0e51c19dc287a4bc5348b7b07f4d840b\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-12-08, 1:03 p.m.",
      "commitName": "e6c39227640536ac1c2e41d8970aeca84b3c6268",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-12-08, 1:03 p.m.",
      "commitNameOld": "72f87adce69da858164c70c40d9e0ae778aa5257",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tdirCache \u003d repository.readDirCache();\n\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(TreeFilter.ANY_DIFF);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 170,
      "functionName": "diff",
      "diff": "@@ -1,78 +1,74 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist \u003d false;\n-\t\tDirCache dirCache \u003d repository.readDirCache();\n+\t\tdirCache \u003d repository.readDirCache();\n+\n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n-\t\t\tif (dirCacheIterator !\u003d null) {\n-\t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n-\t\t\t\t\tassumeUnchanged.add(treeWalk.getPathString());\n-\t\t\t}\n-\n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "48e80698cf7b19422cb7a62a34170cc3c7a3f7a2": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Remove always true not-subtree check\n\nThe TreeWalk is configured to be recursive, which means subtrees are\nnever presented to the application.  Therefore the working tree file\nmode can never be a subtree/subdirectory at this point in the code.\n\nChange-Id: Ie842ddc147957d09205c0d2ce87b25c566862fd9\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-12-08, 1:03 p.m.",
      "commitName": "48e80698cf7b19422cb7a62a34170cc3c7a3f7a2",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-12-08, 1:03 p.m.",
      "commitNameOld": "ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tDirCache dirCache \u003d repository.readDirCache();\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(TreeFilter.ANY_DIFF);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n\t\t\t\t\tassumeUnchanged.add(treeWalk.getPathString());\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 168,
      "functionName": "diff",
      "diff": "@@ -1,81 +1,78 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist \u003d false;\n \t\tDirCache dirCache \u003d repository.readDirCache();\n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n-\t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n \t\t\t\t\tassumeUnchanged.add(treeWalk.getPathString());\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n-\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n-\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n-\t\t\t\t\t\tchangesExist \u003d true;\n-\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n-\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n-\t\t\t\t\t}\n+\t\t\t\t\tremoved.add(treeWalk.getPathString());\n+\t\t\t\t\tchangesExist \u003d true;\n+\t\t\t\t\tif (workingTreeIterator !\u003d null)\n+\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Always use TreeWalk.getPathString()\n\nInstead of asking the individual iterators for their path string, use\nthe TreeWalk\u0027s generic getPathString() method.  Its just as fast\nbecause it uses the path of the current matching iterator.\n\nChange-Id: I9b827fbbafce1c78f09d5527cdc64fbe9022a16e\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-12-08, 1:03 p.m.",
      "commitName": "ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-12-08, 1:03 p.m.",
      "commitNameOld": "f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tDirCache dirCache \u003d repository.readDirCache();\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(TreeFilter.ANY_DIFF);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n\t\t\t\t\tassumeUnchanged.add(treeWalk.getPathString());\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(treeWalk.getPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 168,
      "functionName": "diff",
      "diff": "@@ -1,82 +1,81 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist \u003d false;\n \t\tDirCache dirCache \u003d repository.readDirCache();\n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n-\t\t\t\t\tassumeUnchanged.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\tassumeUnchanged.add(treeWalk.getPathString());\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n-\t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n-\t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n+\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n-\t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n-\t\t\t\t\t\t\t\t\t.getEntryPathString());\n+\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n-\t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n-\t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n+\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n-\t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n-\t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Simplify allocation of filter list\n\nWe add either 3 or 4 filters.  If we are adding only 3 filters,\nallocating the array for 4 isn\u0027t a huge waste of memory, but it\ndoes simplify our code.\n\nChange-Id: I7df29b414f6d5cfcf533edb1405083e6fcec32cf\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-12-08, 1:03 p.m.",
      "commitName": "f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-12-07, 7:49 p.m.",
      "commitNameOld": "a02be9725c9f83f0a0280a9a1f00e8d484825885",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.72,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tDirCache dirCache \u003d repository.readDirCache();\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(TreeFilter.ANY_DIFF);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n\t\t\t\t\tassumeUnchanged.add(dirCacheIterator.getEntryPathString());\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n\t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n\t\t\t\t\t\t\t\t\t.getEntryPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 168,
      "functionName": "diff",
      "diff": "@@ -1,83 +1,82 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist \u003d false;\n \t\tDirCache dirCache \u003d repository.readDirCache();\n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n-\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(\n-\t\t\t\tfilter \u003d\u003d null ? 3 : 4);\n+\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n \t\t\t\t\tassumeUnchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n \t\t\t\t\t\t\t\t\t.getEntryPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a02be9725c9f83f0a0280a9a1f00e8d484825885": {
      "type": "Ybodychange",
      "commitMessage": "Remove empty iterator from TreeWalk\n\nIts confusing that a new TreeWalk() needs to have reset() invoked\non it before addTree().  This is a historical accident caused by\nhow TreeWalk was abused within ObjectWalk.\n\nDrop the initial empty tree from the TreeWalk and thus remove a\nnumber of pointless reset() operations from unit tests and some of\nthe internal JGit code.\n\nExisting application code which is still calling reset() will simply\nbe incurring a few unnecessary field assignments, but they should\nconsider cleaning up their code in the future.\n\nChange-Id: I434e94ffa43491019e7dff52ca420a4d2245f48b\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-12-07, 7:49 p.m.",
      "commitName": "a02be9725c9f83f0a0280a9a1f00e8d484825885",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010-11-30, 1:51 p.m.",
      "commitNameOld": "b4359cb8294de1e80147f00caabad9ebd6b7bce1",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 7.25,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tDirCache dirCache \u003d repository.readDirCache();\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(\n\t\t\t\tfilter \u003d\u003d null ? 3 : 4);\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(TreeFilter.ANY_DIFF);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n\t\t\t\t\tassumeUnchanged.add(dirCacheIterator.getEntryPathString());\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n\t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n\t\t\t\t\t\t\t\t\t.getEntryPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 168,
      "functionName": "diff",
      "diff": "@@ -1,84 +1,83 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist \u003d false;\n \t\tDirCache dirCache \u003d repository.readDirCache();\n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n-\t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(\n \t\t\t\tfilter \u003d\u003d null ? 3 : 4);\n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n \t\t\t\t\tassumeUnchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t}\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n \t\t\t\t\t\t\t\t\t.getEntryPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b4359cb8294de1e80147f00caabad9ebd6b7bce1": {
      "type": "Ybodychange",
      "commitMessage": "Include list of assume unchanged files in IndexDiff\n\nThe IndexDiff had not collected the info if the flag\n\"assume-unchanged\" is set. This information is useful for clients\nwhich may want to decide if specific actions are allowed on a file.\n\nBug: 326213\nChange-Id: I14bb7b03247d6c0b429a9d8d3f6b10f21d8ddeb1\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\n",
      "commitDate": "2010-11-30, 1:51 p.m.",
      "commitName": "b4359cb8294de1e80147f00caabad9ebd6b7bce1",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2010-11-30, 5:05 a.m.",
      "commitNameOld": "7bf0f5070e977d716fbce9309266bb7c26be0a74",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 0.37,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tDirCache dirCache \u003d repository.readDirCache();\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.reset();\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(\n\t\t\t\tfilter \u003d\u003d null ? 3 : 4);\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(TreeFilter.ANY_DIFF);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n\t\t\t\t\tassumeUnchanged.add(dirCacheIterator.getEntryPathString());\n\t\t\t}\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n\t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n\t\t\t\t\t\t\t\t\t.getEntryPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 168,
      "functionName": "diff",
      "diff": "@@ -1,79 +1,84 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist \u003d false;\n \t\tDirCache dirCache \u003d repository.readDirCache();\n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(\n \t\t\t\tfilter \u003d\u003d null ? 3 : 4);\n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n \n+\t\t\tif (dirCacheIterator !\u003d null) {\n+\t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n+\t\t\t\t\tassumeUnchanged.add(dirCacheIterator.getEntryPathString());\n+\t\t\t}\n+\n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n \t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n \t\t\t\t\t\t\t\t\t.getEntryPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2dc2dd8b1b4c98b255b3f2dec655a3f0b197ce07": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: support state [removed, untracked]\n\nIndexDiff was extended to detect files which are both removed from the\nindex and untracked.  Before this change these files were only added\nto the removed collection.\n\nChange-Id: I971d8261d2e8932039fce462b59c12e143f79f90\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-11-08, 6:32 p.m.",
      "commitName": "2dc2dd8b1b4c98b255b3f2dec655a3f0b197ce07",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2010-10-25, 7:00 a.m.",
      "commitNameOld": "6f3b089188ef4937ab4e9970b0987b061000831e",
      "commitAuthorOld": "Jens Baumgart",
      "daysBetweenCommits": 14.52,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tDirCache dirCache \u003d repository.readDirCache();\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.reset();\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(\n\t\t\t\tfilter \u003d\u003d null ? 3 : 4);\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(TreeFilter.ANY_DIFF);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n\t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n\t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n\t\t\t\t\t\t\t\t\t.getEntryPathString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 163,
      "functionName": "diff",
      "diff": "@@ -1,76 +1,79 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist \u003d false;\n \t\tDirCache dirCache \u003d repository.readDirCache();\n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(\n \t\t\t\tfilter \u003d\u003d null ? 3 : 4);\n \t\tif (filter !\u003d null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n+\t\t\t\t\t\tif (workingTreeIterator !\u003d null)\n+\t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n+\t\t\t\t\t\t\t\t\t.getEntryPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f3b089188ef4937ab4e9970b0987b061000831e": {
      "type": "Ybodychange",
      "commitMessage": "Allow setting a filter in IndexDiff\n\nIndexDiff now allows to set an additional filter. This can be used\ne.g. for restricting the tree walk to a given set of files.\n\nChange-Id: I642de17e74b997fa0c5878c90631f6640ed70bdd\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\n",
      "commitDate": "2010-10-25, 7:00 a.m.",
      "commitName": "6f3b089188ef4937ab4e9970b0987b061000831e",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2010-09-01, 6:19 p.m.",
      "commitNameOld": "ea4ff61ad3de3f5742905c7a92e99cf041d19596",
      "commitAuthorOld": "Marc Strapetz",
      "daysBetweenCommits": 53.53,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tDirCache dirCache \u003d repository.readDirCache();\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.reset();\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(\n\t\t\t\tfilter \u003d\u003d null ? 3 : 4);\n\t\tif (filter !\u003d null)\n\t\t\tfilters.add(filter);\n\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n\t\tfilters.add(TreeFilter.ANY_DIFF);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n\t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 163,
      "functionName": "diff",
      "diff": "@@ -1,72 +1,76 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist \u003d false;\n \t\tDirCache dirCache \u003d repository.readDirCache();\n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n-\t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n-\t\ttreeWalk.setFilter(AndTreeFilter.create(new TreeFilter[] {\n-\t\t\t\tnew NotIgnoredFilter(WORKDIR), new SkipWorkTreeFilter(INDEX),\n-\t\t\t\tTreeFilter.ANY_DIFF }));\n+\t\tCollection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(\n+\t\t\t\tfilter \u003d\u003d null ? 3 : 4);\n+\t\tif (filter !\u003d null)\n+\t\t\tfilters.add(filter);\n+\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n+\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n+\t\tfilters.add(TreeFilter.ANY_DIFF);\n+\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ea4ff61ad3de3f5742905c7a92e99cf041d19596": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff honors Index entries\u0027 \"skipWorkTree\" flag.\n\nChange-Id: I428d11412130b64fc46d7052011f5dff3d653802\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-09-01, 6:19 p.m.",
      "commitName": "ea4ff61ad3de3f5742905c7a92e99cf041d19596",
      "commitAuthor": "Marc Strapetz",
      "commitDateOld": "2010-08-12, 12:43 p.m.",
      "commitNameOld": "cd1141cd45e8148c2d3fc5553ae19c9fee3fc4a6",
      "commitAuthorOld": "Jens Baumgart",
      "daysBetweenCommits": 20.23,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tDirCache dirCache \u003d repository.readDirCache();\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.reset();\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(new TreeFilter[] {\n\t\t\t\tnew NotIgnoredFilter(WORKDIR), new SkipWorkTreeFilter(INDEX),\n\t\t\t\tTreeFilter.ANY_DIFF }));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n\t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 150,
      "functionName": "diff",
      "diff": "@@ -1,71 +1,72 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist \u003d false;\n \t\tDirCache dirCache \u003d repository.readDirCache();\n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n-\t\ttreeWalk.setFilter(AndTreeFilter.create(TreeFilter.ANY_DIFF,\n-\t\t\t\tnew NotIgnoredFilter(WORKDIR)));\n+\t\ttreeWalk.setFilter(AndTreeFilter.create(new TreeFilter[] {\n+\t\t\t\tnew NotIgnoredFilter(WORKDIR), new SkipWorkTreeFilter(INDEX),\n+\t\t\t\tTreeFilter.ANY_DIFF }));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cd1141cd45e8148c2d3fc5553ae19c9fee3fc4a6": {
      "type": "Ybodychange",
      "commitMessage": "Improve IndexDiff performance\n\nExclude ignored files from IndexDiff tree walk.\nThis makes EGit commit much faster.\n\nChange-Id: I398499510c22c37667b7612db32eac3b31d325f0\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2010-08-12, 12:43 p.m.",
      "commitName": "cd1141cd45e8148c2d3fc5553ae19c9fee3fc4a6",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2010-08-09, 5:14 a.m.",
      "commitNameOld": "9a6a433576c8b1cedb5f3aff9cfecb8217881ddf",
      "commitAuthorOld": "Jens Baumgart",
      "daysBetweenCommits": 3.31,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tDirCache dirCache \u003d repository.readDirCache();\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.reset();\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n\t\ttreeWalk.setFilter(AndTreeFilter.create(TreeFilter.ANY_DIFF,\n\t\t\t\tnew NotIgnoredFilter(WORKDIR)));\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n\t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 149,
      "functionName": "diff",
      "diff": "@@ -1,69 +1,71 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist \u003d false;\n \t\tDirCache dirCache \u003d repository.readDirCache();\n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree !\u003d null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n+\t\ttreeWalk.setFilter(AndTreeFilter.create(TreeFilter.ANY_DIFF,\n+\t\t\t\tnew NotIgnoredFilter(WORKDIR)));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9a6a433576c8b1cedb5f3aff9cfecb8217881ddf": {
      "type": "Ybodychange",
      "commitMessage": "Fix NPE on commit in empty Repository\n\nNPE occured when committing in an empty repository.\n\nBug: 321858\nChange-Id: Ibddb056c32c14c1444785501c43b95fdf64884b1\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\n",
      "commitDate": "2010-08-09, 5:14 a.m.",
      "commitName": "9a6a433576c8b1cedb5f3aff9cfecb8217881ddf",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2010-08-04, 11:03 a.m.",
      "commitNameOld": "3ba1c7c0681642da30fce234b4a4f405852adfdd",
      "commitAuthorOld": "Jens Baumgart",
      "daysBetweenCommits": 4.76,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tDirCache dirCache \u003d repository.readDirCache();\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.reset();\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\tif (tree !\u003d null)\n\t\t\ttreeWalk.addTree(tree);\n\t\telse\n\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n\t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 147,
      "functionName": "diff",
      "diff": "@@ -1,66 +1,69 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist \u003d false;\n \t\tDirCache dirCache \u003d repository.readDirCache();\n \t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n \t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n-\t\ttreeWalk.addTree(tree);\n+\t\tif (tree !\u003d null)\n+\t\t\ttreeWalk.addTree(tree);\n+\t\telse\n+\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n \n \t\t\tif (treeIterator !\u003d null) {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index \u003d\u003e removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\t\t// not in repo, in index \u003d\u003e added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n \t\t\t\t\tif (workingTreeIterator !\u003d null\n \t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator !\u003d null) {\n \t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n \t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3ba1c7c0681642da30fce234b4a4f405852adfdd": {
      "type": "Ybodychange",
      "commitMessage": "Add gitignore support to IndexDiff and use TreeWalk\n\nIndexDiff was re-implemented and now uses TreeWalk instead\nof GitIndex. Additionally, gitignore support and retrieval of\nuntracked files was added.\n\nChange-Id: Ie6a8e04833c61d44c668c906b161202b200bb509\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2010-08-04, 11:03 a.m.",
      "commitName": "3ba1c7c0681642da30fce234b4a4f405852adfdd",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2010-07-22, 5:56 p.m.",
      "commitNameOld": "fa9b225e06f16ca7fd7ffca5689f4af0942a73e1",
      "commitAuthorOld": "",
      "daysBetweenCommits": 12.71,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tboolean changesExist \u003d false;\n\t\tDirCache dirCache \u003d repository.readDirCache();\n\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n\t\ttreeWalk.reset();\n\t\ttreeWalk.setRecursive(true);\n\t\t// add the trees (tree, dirchache, workdir)\n\t\ttreeWalk.addTree(tree);\n\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n\t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n\t\twhile (treeWalk.next()) {\n\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n\t\t\t\t\tAbstractTreeIterator.class);\n\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n\t\t\t\t\tDirCacheIterator.class);\n\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n\t\t\t\t\tWorkingTreeIterator.class);\n\t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n\n\t\t\tif (treeIterator !\u003d null) {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n\t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n\t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\t\t// not in repo, in index \u003d\u003e added\n\t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n\t\t\t\t\tif (workingTreeIterator !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n\t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dirCacheIterator !\u003d null) {\n\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n\t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n\t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n\t\t\t\t\t\tchangesExist \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changesExist;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 138,
      "functionName": "diff",
      "diff": "@@ -1,34 +1,66 @@\n \tpublic boolean diff() throws IOException {\n-\t\tfinal File root \u003d index.getRepository().getWorkTree();\n-\t\tnew IndexTreeWalker(index, tree, root, new AbstractIndexTreeVisitor() {\n-\t\t\tpublic void visitEntry(TreeEntry treeEntry, Entry indexEntry, File file) {\n-\t\t\t\tif (treeEntry \u003d\u003d null) {\n-\t\t\t\t\tadded.add(indexEntry.getName());\n-\t\t\t\t\tanyChanges \u003d true;\n-\t\t\t\t} else if (indexEntry \u003d\u003d null) {\n-\t\t\t\t\tif (!(treeEntry instanceof Tree))\n-\t\t\t\t\t\tremoved.add(treeEntry.getFullName());\n-\t\t\t\t\tanyChanges \u003d true;\n+\t\tboolean changesExist \u003d false;\n+\t\tDirCache dirCache \u003d repository.readDirCache();\n+\t\tTreeWalk treeWalk \u003d new TreeWalk(repository);\n+\t\ttreeWalk.reset();\n+\t\ttreeWalk.setRecursive(true);\n+\t\t// add the trees (tree, dirchache, workdir)\n+\t\ttreeWalk.addTree(tree);\n+\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n+\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n+\t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n+\t\twhile (treeWalk.next()) {\n+\t\t\tAbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE,\n+\t\t\t\t\tAbstractTreeIterator.class);\n+\t\t\tDirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX,\n+\t\t\t\t\tDirCacheIterator.class);\n+\t\t\tWorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR,\n+\t\t\t\t\tWorkingTreeIterator.class);\n+\t\t\tFileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n+\n+\t\t\tif (treeIterator !\u003d null) {\n+\t\t\t\tif (dirCacheIterator !\u003d null) {\n+\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n+\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n+\t\t\t\t\t\t// in repo, in index, content diff \u003d\u003e changed\n+\t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\t\tchangesExist \u003d true;\n+\t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tif (!treeEntry.getId().equals(indexEntry.getObjectId())) {\n-\t\t\t\t\t\tchanged.add(indexEntry.getName());\n-\t\t\t\t\t\tanyChanges \u003d true;\n+\t\t\t\t\t// in repo, not in index \u003d\u003e removed\n+\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n+\t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n+\t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n-\n-\t\t\t\tif (indexEntry !\u003d null) {\n-\t\t\t\t\tif (!file.exists()) {\n-\t\t\t\t\t\tmissing.add(indexEntry.getName());\n-\t\t\t\t\t\tanyChanges \u003d true;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif (indexEntry.isModified(root, true)) {\n-\t\t\t\t\t\t\tmodified.add(indexEntry.getName());\n-\t\t\t\t\t\t\tanyChanges \u003d true;\n-\t\t\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (dirCacheIterator !\u003d null) {\n+\t\t\t\t\t// not in repo, in index \u003d\u003e added\n+\t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\tchangesExist \u003d true;\n+\t\t\t\t} else {\n+\t\t\t\t\t// not in repo, not in index \u003d\u003e untracked\n+\t\t\t\t\tif (workingTreeIterator !\u003d null\n+\t\t\t\t\t\t\t\u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n+\t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n+\t\t\t\t\t\tchangesExist \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t}).walk();\n \n-\t\treturn anyChanges;\n+\t\t\tif (dirCacheIterator !\u003d null) {\n+\t\t\t\tif (workingTreeIterator \u003d\u003d null) {\n+\t\t\t\t\t// in index, not in workdir \u003d\u003e missing\n+\t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\tchangesExist \u003d true;\n+\t\t\t\t} else {\n+\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n+\t\t\t\t\t\t// in index, in workdir, content differs \u003d\u003e modified\n+\t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\t\tchangesExist \u003d true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "203bd6626767015dfb04d421c572b26a34e9cecf": {
      "type": "Ybodychange",
      "commitMessage": "Rename Repository getWorkDir to getWorkTree\n\nThis better matches with the name used in the environment\n(GIT_WORK_TREE), in the configuration file (core.worktree),\nand in our builder object.\n\nSince we are already breaking a good chunk of other code\nrelated to repository access, and this fairly easy to fix\nin an application\u0027s code base, I\u0027m not going to offer the\nwrapper getWorkDir() method.\n\nChange-Id: Ib698ba4bbc213c48114f342378cecfe377e37bb7\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010-06-25, 9:03 p.m.",
      "commitName": "203bd6626767015dfb04d421c572b26a34e9cecf",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2009-10-31, 5:48 p.m.",
      "commitNameOld": "4d91645e890527efbe04ffaee12b4aa3637733c4",
      "commitAuthorOld": "Alex Blewitt",
      "daysBetweenCommits": 237.14,
      "commitsBetweenForRepo": 269,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tfinal File root \u003d index.getRepository().getWorkTree();\n\t\tnew IndexTreeWalker(index, tree, root, new AbstractIndexTreeVisitor() {\n\t\t\tpublic void visitEntry(TreeEntry treeEntry, Entry indexEntry, File file) {\n\t\t\t\tif (treeEntry \u003d\u003d null) {\n\t\t\t\t\tadded.add(indexEntry.getName());\n\t\t\t\t\tanyChanges \u003d true;\n\t\t\t\t} else if (indexEntry \u003d\u003d null) {\n\t\t\t\t\tif (!(treeEntry instanceof Tree))\n\t\t\t\t\t\tremoved.add(treeEntry.getFullName());\n\t\t\t\t\tanyChanges \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!treeEntry.getId().equals(indexEntry.getObjectId())) {\n\t\t\t\t\t\tchanged.add(indexEntry.getName());\n\t\t\t\t\t\tanyChanges \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (indexEntry !\u003d null) {\n\t\t\t\t\tif (!file.exists()) {\n\t\t\t\t\t\tmissing.add(indexEntry.getName());\n\t\t\t\t\t\tanyChanges \u003d true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (indexEntry.isModified(root, true)) {\n\t\t\t\t\t\t\tmodified.add(indexEntry.getName());\n\t\t\t\t\t\t\tanyChanges \u003d true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}).walk();\n\n\t\treturn anyChanges;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 91,
      "functionName": "diff",
      "diff": "@@ -1,34 +1,34 @@\n \tpublic boolean diff() throws IOException {\n-\t\tfinal File root \u003d index.getRepository().getWorkDir();\n+\t\tfinal File root \u003d index.getRepository().getWorkTree();\n \t\tnew IndexTreeWalker(index, tree, root, new AbstractIndexTreeVisitor() {\n \t\t\tpublic void visitEntry(TreeEntry treeEntry, Entry indexEntry, File file) {\n \t\t\t\tif (treeEntry \u003d\u003d null) {\n \t\t\t\t\tadded.add(indexEntry.getName());\n \t\t\t\t\tanyChanges \u003d true;\n \t\t\t\t} else if (indexEntry \u003d\u003d null) {\n \t\t\t\t\tif (!(treeEntry instanceof Tree))\n \t\t\t\t\t\tremoved.add(treeEntry.getFullName());\n \t\t\t\t\tanyChanges \u003d true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!treeEntry.getId().equals(indexEntry.getObjectId())) {\n \t\t\t\t\t\tchanged.add(indexEntry.getName());\n \t\t\t\t\t\tanyChanges \u003d true;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (indexEntry !\u003d null) {\n \t\t\t\t\tif (!file.exists()) {\n \t\t\t\t\t\tmissing.add(indexEntry.getName());\n \t\t\t\t\t\tanyChanges \u003d true;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (indexEntry.isModified(root, true)) {\n \t\t\t\t\t\t\tmodified.add(indexEntry.getName());\n \t\t\t\t\t\t\tanyChanges \u003d true;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}).walk();\n \n \t\treturn anyChanges;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a6964c8274c50f0253db75f010d78ef0e739343": {
      "type": "Yintroduced",
      "commitMessage": "Initial JGit contribution to eclipse.org\n\nPer CQ 3448 this is the initial contribution of the JGit project\nto eclipse.org.  It is derived from the historical JGit repository\nat commit 3a2dd9921c8a08740a9e02c421469e5b1a9e47cb.\n\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2009-09-29, 7:47 p.m.",
      "commitName": "1a6964c8274c50f0253db75f010d78ef0e739343",
      "commitAuthor": "Git Development Community",
      "diff": "@@ -0,0 +1,34 @@\n+\tpublic boolean diff() throws IOException {\n+\t\tfinal File root \u003d index.getRepository().getWorkDir();\n+\t\tnew IndexTreeWalker(index, tree, root, new AbstractIndexTreeVisitor() {\n+\t\t\tpublic void visitEntry(TreeEntry treeEntry, Entry indexEntry, File file) {\n+\t\t\t\tif (treeEntry \u003d\u003d null) {\n+\t\t\t\t\tadded.add(indexEntry.getName());\n+\t\t\t\t\tanyChanges \u003d true;\n+\t\t\t\t} else if (indexEntry \u003d\u003d null) {\n+\t\t\t\t\tif (!(treeEntry instanceof Tree))\n+\t\t\t\t\t\tremoved.add(treeEntry.getFullName());\n+\t\t\t\t\tanyChanges \u003d true;\n+\t\t\t\t} else {\n+\t\t\t\t\tif (!treeEntry.getId().equals(indexEntry.getObjectId())) {\n+\t\t\t\t\t\tchanged.add(indexEntry.getName());\n+\t\t\t\t\t\tanyChanges \u003d true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\tif (indexEntry !\u003d null) {\n+\t\t\t\t\tif (!file.exists()) {\n+\t\t\t\t\t\tmissing.add(indexEntry.getName());\n+\t\t\t\t\t\tanyChanges \u003d true;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (indexEntry.isModified(root, true)) {\n+\t\t\t\t\t\t\tmodified.add(indexEntry.getName());\n+\t\t\t\t\t\t\tanyChanges \u003d true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}).walk();\n+\t\t\n+\t\treturn anyChanges;\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic boolean diff() throws IOException {\n\t\tfinal File root \u003d index.getRepository().getWorkDir();\n\t\tnew IndexTreeWalker(index, tree, root, new AbstractIndexTreeVisitor() {\n\t\t\tpublic void visitEntry(TreeEntry treeEntry, Entry indexEntry, File file) {\n\t\t\t\tif (treeEntry \u003d\u003d null) {\n\t\t\t\t\tadded.add(indexEntry.getName());\n\t\t\t\t\tanyChanges \u003d true;\n\t\t\t\t} else if (indexEntry \u003d\u003d null) {\n\t\t\t\t\tif (!(treeEntry instanceof Tree))\n\t\t\t\t\t\tremoved.add(treeEntry.getFullName());\n\t\t\t\t\tanyChanges \u003d true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!treeEntry.getId().equals(indexEntry.getObjectId())) {\n\t\t\t\t\t\tchanged.add(indexEntry.getName());\n\t\t\t\t\t\tanyChanges \u003d true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (indexEntry !\u003d null) {\n\t\t\t\t\tif (!file.exists()) {\n\t\t\t\t\t\tmissing.add(indexEntry.getName());\n\t\t\t\t\t\tanyChanges \u003d true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (indexEntry.isModified(root, true)) {\n\t\t\t\t\t\t\tmodified.add(indexEntry.getName());\n\t\t\t\t\t\t\tanyChanges \u003d true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}).walk();\n\t\t\n\t\treturn anyChanges;\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 91,
      "functionName": "diff"
    }
  }
}