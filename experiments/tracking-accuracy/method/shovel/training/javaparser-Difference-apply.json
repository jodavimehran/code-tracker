{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "H:\\Projects\\javaparser\\javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "Difference.java",
  "functionName": "apply",
  "functionId": "apply",
  "sourceFilePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
  "functionStartLine": 115,
  "functionEndLine": 144,
  "numCommitsSeen": 180,
  "timeTaken": 5683,
  "changeHistory": [
    "2d3f5e219af9d1ba916f1dc21a6169a41a254632",
    "996b78486d0db86dece4457a7faa9b314dc3b847",
    "0a54807d59a9f39be0d222ae45697413d6765516",
    "b7bd15d12e107c85e29912960f7b4e48aac4dc38",
    "c35fbac21da07f996f017169288b748764488c20",
    "a25f53f8871fd178b6791d1194d7358b55d1ba37",
    "29a9b8bcb552dc691cc57c85b8eb017092c960ad",
    "04f28d4024daa5798f3c627170bfe2a96bce8e55",
    "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
    "40f6fef078275d3ca43f02918200a2d6076fef9d",
    "7f177dcaadbccb2076a2a41aa1000696a9a8a10e",
    "2ae6f779cc175b3cd82d915419f378e53ff4b056",
    "de5c17c37f15a1c134f518ed2754974cc4b9aa15",
    "fb8daf1673c35798aeb7cca8033dd9c9b2e5c4fc",
    "5123e075b8411953473b23c82e64d8d23edb9181",
    "478b82aa16242a7324a16ffc9df8811309228234",
    "3a31705ba43ab2968ab2f113272b2462c91027bb",
    "6149218487aac50fad2256c8723639671747d7bb",
    "516947a3d4eda478d20dcbb4216d6c52cf11d169",
    "6a1ee724c337694ee28b2a09af41c236b880ba66",
    "c3f372b0c7c8ca4bed1261e7f1d3f17ed01b4889",
    "7d55cf4c1cac9c2f8a3a917cfadfaf921e11e2b2",
    "a3359354bf46a3459c2262ba520c95ba4bf02a58",
    "cbf3d3d09837a5648602ac7ececc3322144e68f0",
    "74dc0e58a9a6aa10a2c41bf121af592df43c30fe",
    "7c051d8316c3c9270f191bae4a5323b92f283420",
    "f8d5e2fda0aedca5f9a9cb726f7787286bbfd05e",
    "5689cad203e3ff4f51af7bc2b73f13ab03c91ca1",
    "1a6665bb95b0e46cafdb19202274e6d6725ea464",
    "1555adc99a08f09e7f7ec40db7bd2535062e55af",
    "10508ce2a362ca01c7f29c39c7f98469233fce04",
    "ad402162f98243c84e4f7c9693012633347a4829",
    "a31908d22bc52d1bf24e00d3bc1bc709224156fd",
    "488ccb1191c3b71644bdc9176712394220b9252b",
    "87b56cb1f18252c95d88b979a449f06d55def290",
    "b29a465257afcf2cc720c9423c2ddedd1edd31a3",
    "9192b9d17903947058b755b987d1c57a05821e58",
    "b1cd1afb0aaa19f370a169350318496ca7e541bb",
    "adb78b277512189cc5f8ecb076d9bf8106f9e1e0",
    "0be8bb2b4275456c18bee064c5de2ccb12a33080",
    "bd0af28e7b81048d9bda153b908c727304ca8a04",
    "15cb49e74025eb4011187f31735aa4772993fb5d",
    "4b87b2b6b407077eb064ac949baaa2fbd0487986",
    "a55cd517deae99d6bb32717af632cd9dc9f01928",
    "7121d100d536b7b3df76c22ad3acc4c507be7bfe",
    "152592f7c8110f04ea6ca6e6c6d57360fd40ee16",
    "e71e376b9542dd7fea6e973301d8d426f340d65b",
    "ed7f4a6532043b5ac8c8da55923fbd91f72ec574",
    "548fb9c5a72776ec009c5f2f92b1a4c480a05030",
    "f21322dd131f30bfcd809d2748a2366df7dc27d3",
    "882790065271126fc4b17a71bebb078b60ffe00c",
    "572ea89397e9b3b35dc616d48176ab0d296612dd",
    "48ac9477b3997592001fa0f44f98eb7481f7b9ea",
    "5d76ede0db52033984e3d7908105c6f2f4380725",
    "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f",
    "b2625a83a00b165c95bb7eddc9a1a4b65b4750aa",
    "f0f313058c4389cd48052112e3fb906c060be30f",
    "6c2c1abbfcee5a8874d805a58f08d7d21c20482c",
    "566e84eb47ec36af0964ae8a3584460737917d73",
    "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16",
    "ecefb777275fd26b37f10709f97810a3e6a69bb2",
    "01e9c90792e879eca937a12b6bb30b31e51aee53",
    "f4ce6ce924ffbd03518c64cea9b830d04f75b849",
    "6f102302a83146e02d13ff476f39fc8a86710e38",
    "cc13f68e3655ea43b56dd13ee55a81f3a2d37fee",
    "c73ae5d79b62de91209477538b45ab5216fb108e"
  ],
  "changeHistoryShort": {
    "2d3f5e219af9d1ba916f1dc21a6169a41a254632": "Ybodychange",
    "996b78486d0db86dece4457a7faa9b314dc3b847": "Ybodychange",
    "0a54807d59a9f39be0d222ae45697413d6765516": "Ybodychange",
    "b7bd15d12e107c85e29912960f7b4e48aac4dc38": "Ybodychange",
    "c35fbac21da07f996f017169288b748764488c20": "Ybodychange",
    "a25f53f8871fd178b6791d1194d7358b55d1ba37": "Ybodychange",
    "29a9b8bcb552dc691cc57c85b8eb017092c960ad": "Ybodychange",
    "04f28d4024daa5798f3c627170bfe2a96bce8e55": "Ybodychange",
    "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c": "Ymultichange(Yparameterchange,Ybodychange)",
    "40f6fef078275d3ca43f02918200a2d6076fef9d": "Ybodychange",
    "7f177dcaadbccb2076a2a41aa1000696a9a8a10e": "Ybodychange",
    "2ae6f779cc175b3cd82d915419f378e53ff4b056": "Ybodychange",
    "de5c17c37f15a1c134f518ed2754974cc4b9aa15": "Ybodychange",
    "fb8daf1673c35798aeb7cca8033dd9c9b2e5c4fc": "Ybodychange",
    "5123e075b8411953473b23c82e64d8d23edb9181": "Ybodychange",
    "478b82aa16242a7324a16ffc9df8811309228234": "Ybodychange",
    "3a31705ba43ab2968ab2f113272b2462c91027bb": "Ybodychange",
    "6149218487aac50fad2256c8723639671747d7bb": "Ybodychange",
    "516947a3d4eda478d20dcbb4216d6c52cf11d169": "Ybodychange",
    "6a1ee724c337694ee28b2a09af41c236b880ba66": "Ybodychange",
    "c3f372b0c7c8ca4bed1261e7f1d3f17ed01b4889": "Ybodychange",
    "7d55cf4c1cac9c2f8a3a917cfadfaf921e11e2b2": "Ybodychange",
    "a3359354bf46a3459c2262ba520c95ba4bf02a58": "Ybodychange",
    "cbf3d3d09837a5648602ac7ececc3322144e68f0": "Ybodychange",
    "74dc0e58a9a6aa10a2c41bf121af592df43c30fe": "Ybodychange",
    "7c051d8316c3c9270f191bae4a5323b92f283420": "Ybodychange",
    "f8d5e2fda0aedca5f9a9cb726f7787286bbfd05e": "Ybodychange",
    "5689cad203e3ff4f51af7bc2b73f13ab03c91ca1": "Ybodychange",
    "1a6665bb95b0e46cafdb19202274e6d6725ea464": "Ybodychange",
    "1555adc99a08f09e7f7ec40db7bd2535062e55af": "Ybodychange",
    "10508ce2a362ca01c7f29c39c7f98469233fce04": "Ybodychange",
    "ad402162f98243c84e4f7c9693012633347a4829": "Ybodychange",
    "a31908d22bc52d1bf24e00d3bc1bc709224156fd": "Ybodychange",
    "488ccb1191c3b71644bdc9176712394220b9252b": "Ybodychange",
    "87b56cb1f18252c95d88b979a449f06d55def290": "Ybodychange",
    "b29a465257afcf2cc720c9423c2ddedd1edd31a3": "Ybodychange",
    "9192b9d17903947058b755b987d1c57a05821e58": "Ybodychange",
    "b1cd1afb0aaa19f370a169350318496ca7e541bb": "Ybodychange",
    "adb78b277512189cc5f8ecb076d9bf8106f9e1e0": "Ybodychange",
    "0be8bb2b4275456c18bee064c5de2ccb12a33080": "Ybodychange",
    "bd0af28e7b81048d9bda153b908c727304ca8a04": "Ybodychange",
    "15cb49e74025eb4011187f31735aa4772993fb5d": "Ymultichange(Ymodifierchange,Ybodychange)",
    "4b87b2b6b407077eb064ac949baaa2fbd0487986": "Ybodychange",
    "a55cd517deae99d6bb32717af632cd9dc9f01928": "Ybodychange",
    "7121d100d536b7b3df76c22ad3acc4c507be7bfe": "Ybodychange",
    "152592f7c8110f04ea6ca6e6c6d57360fd40ee16": "Ybodychange",
    "e71e376b9542dd7fea6e973301d8d426f340d65b": "Ybodychange",
    "ed7f4a6532043b5ac8c8da55923fbd91f72ec574": "Ybodychange",
    "548fb9c5a72776ec009c5f2f92b1a4c480a05030": "Ybodychange",
    "f21322dd131f30bfcd809d2748a2366df7dc27d3": "Ybodychange",
    "882790065271126fc4b17a71bebb078b60ffe00c": "Ybodychange",
    "572ea89397e9b3b35dc616d48176ab0d296612dd": "Ybodychange",
    "48ac9477b3997592001fa0f44f98eb7481f7b9ea": "Ybodychange",
    "5d76ede0db52033984e3d7908105c6f2f4380725": "Ymultichange(Yparameterchange,Ybodychange)",
    "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f": "Ybodychange",
    "b2625a83a00b165c95bb7eddc9a1a4b65b4750aa": "Ybodychange",
    "f0f313058c4389cd48052112e3fb906c060be30f": "Ybodychange",
    "6c2c1abbfcee5a8874d805a58f08d7d21c20482c": "Ybodychange",
    "566e84eb47ec36af0964ae8a3584460737917d73": "Ybodychange",
    "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16": "Ymultichange(Ymovefromfile,Ybodychange)",
    "ecefb777275fd26b37f10709f97810a3e6a69bb2": "Ybodychange",
    "01e9c90792e879eca937a12b6bb30b31e51aee53": "Ybodychange",
    "f4ce6ce924ffbd03518c64cea9b830d04f75b849": "Ybodychange",
    "6f102302a83146e02d13ff476f39fc8a86710e38": "Ybodychange",
    "cc13f68e3655ea43b56dd13ee55a81f3a2d37fee": "Ybodychange",
    "c73ae5d79b62de91209477538b45ab5216fb108e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2d3f5e219af9d1ba916f1dc21a6169a41a254632": {
      "type": "Ybodychange",
      "commitMessage": "built RemovedGroup into Difference class to be able to handle indentations better for removed elements\n",
      "commitDate": "2018-06-07, 4:54 p.m.",
      "commitName": "2d3f5e219af9d1ba916f1dc21a6169a41a254632",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-06-07, 4:54 p.m.",
      "commitNameOld": "996b78486d0db86dece4457a7faa9b314dc3b847",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply() {\n        extractReshuffledDiffElements(diffElements);\n        Map\u003cRemoved, RemovedGroup\u003e removedGroups \u003d combineRemovedElementsToRemovedGroups();\n\n        do {\n            boolean isLeftOverDiffElement \u003d applyLeftOverDiffElements();\n            boolean isLeftOverOriginalElement \u003d applyLeftOverOriginalElements();\n\n            if (!isLeftOverDiffElement \u0026\u0026 !isLeftOverOriginalElement){\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof Added) {\n                    applyAddedDiffElement((Added) diffElement);\n                } else {\n                    TextElement originalElement \u003d originalElements.get(originalIndex);\n                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof Kept) {\n                        applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else if (diffElement instanceof Removed) {\n                        Removed removed \u003d (Removed) diffElement;\n                        applyRemovedDiffElement(removedGroups.get(removed), removed, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 123,
      "functionName": "apply",
      "diff": "@@ -1,54 +1,30 @@\n     void apply() {\n         extractReshuffledDiffElements(diffElements);\n+        Map\u003cRemoved, RemovedGroup\u003e removedGroups \u003d combineRemovedElementsToRemovedGroups();\n \n         do {\n-            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n-                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n-                if (diffElement instanceof Kept) {\n-                    Kept kept \u003d (Kept) diffElement;\n+            boolean isLeftOverDiffElement \u003d applyLeftOverDiffElements();\n+            boolean isLeftOverOriginalElement \u003d applyLeftOverOriginalElements();\n \n-                    if (kept.isWhiteSpaceOrComment() || kept.isIndent() || kept.isUnindent()) {\n-                        diffIndex++;\n-                    } else {\n-                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n-                                + nodeText + \". Difference: \" + this);\n-                    }\n-                } else if (diffElement instanceof Added) {\n-                    Added addedElement \u003d (Added) diffElement;\n-\n-                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n-                    originalIndex++;\n-                    diffIndex++;\n-                } else {\n-                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n-                }\n-            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n-                TextElement originalElement \u003d originalElements.get(originalIndex);\n-\n-                if (originalElement.isWhiteSpaceOrComment()) {\n-                    originalIndex++;\n-                } else {\n-                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n-                            + this + \" \" + originalElement);\n-                }\n-            } else {\n+            if (!isLeftOverDiffElement \u0026\u0026 !isLeftOverOriginalElement){\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n                     applyAddedDiffElement((Added) diffElement);\n                 } else {\n                     TextElement originalElement \u003d originalElements.get(originalIndex);\n                     boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n                         applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else if (diffElement instanceof Removed) {\n-                        applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n+                        Removed removed \u003d (Removed) diffElement;\n+                        applyRemovedDiffElement(removedGroups.get(removed), removed, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "996b78486d0db86dece4457a7faa9b314dc3b847": {
      "type": "Ybodychange",
      "commitMessage": "moved extraction of reshuffled diffElements out of the loop with the rest\n",
      "commitDate": "2018-06-07, 4:54 p.m.",
      "commitName": "996b78486d0db86dece4457a7faa9b314dc3b847",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-05-29, 2:28 a.m.",
      "commitNameOld": "0a54807d59a9f39be0d222ae45697413d6765516",
      "commitAuthorOld": "Jooyung Han",
      "daysBetweenCommits": 9.6,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply() {\n        extractReshuffledDiffElements(diffElements);\n\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n\n                    if (kept.isWhiteSpaceOrComment() || kept.isIndent() || kept.isUnindent()) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof Added) {\n                    Added addedElement \u003d (Added) diffElement;\n\n                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n\n                if (originalElement.isWhiteSpaceOrComment()) {\n                    originalIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + originalElement);\n                }\n            } else {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof Added) {\n                    applyAddedDiffElement((Added) diffElement);\n                } else {\n                    TextElement originalElement \u003d originalElements.get(originalIndex);\n                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof Kept) {\n                        applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else if (diffElement instanceof Removed) {\n                        applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 123,
      "functionName": "apply",
      "diff": "@@ -1,54 +1,54 @@\n     void apply() {\n+        extractReshuffledDiffElements(diffElements);\n+\n         do {\n             if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept \u003d (Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment() || kept.isIndent() || kept.isUnindent()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n                     Added addedElement \u003d (Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n                     applyAddedDiffElement((Added) diffElement);\n                 } else {\n                     TextElement originalElement \u003d originalElements.get(originalIndex);\n                     boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n                         applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else if (diffElement instanceof Removed) {\n                         applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n-                    } else if (diffElement instanceof Reshuffled) {\n-                        applyReshuffledDiffElement((Reshuffled) diffElement);\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a54807d59a9f39be0d222ae45697413d6765516": {
      "type": "Ybodychange",
      "commitMessage": "Fix Difference.apply() with redundant Unindent\n\nRedundant unindent may be discarded just like other whitespaces\n",
      "commitDate": "2018-05-29, 2:28 a.m.",
      "commitName": "0a54807d59a9f39be0d222ae45697413d6765516",
      "commitAuthor": "Jooyung Han",
      "commitDateOld": "2018-05-19, 12:42 p.m.",
      "commitNameOld": "8718d4a587fe7951b4767c6bcc52d7979d9b8795",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 9.57,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply() {\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n\n                    if (kept.isWhiteSpaceOrComment() || kept.isIndent() || kept.isUnindent()) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof Added) {\n                    Added addedElement \u003d (Added) diffElement;\n\n                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n\n                if (originalElement.isWhiteSpaceOrComment()) {\n                    originalIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + originalElement);\n                }\n            } else {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof Added) {\n                    applyAddedDiffElement((Added) diffElement);\n                } else {\n                    TextElement originalElement \u003d originalElements.get(originalIndex);\n                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof Kept) {\n                        applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else if (diffElement instanceof Removed) {\n                        applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else if (diffElement instanceof Reshuffled) {\n                        applyReshuffledDiffElement((Reshuffled) diffElement);\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 123,
      "functionName": "apply",
      "diff": "@@ -1,54 +1,54 @@\n     void apply() {\n         do {\n             if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept \u003d (Kept) diffElement;\n \n-                    if (kept.isWhiteSpaceOrComment()) {\n+                    if (kept.isWhiteSpaceOrComment() || kept.isIndent() || kept.isUnindent()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n                     Added addedElement \u003d (Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n                     applyAddedDiffElement((Added) diffElement);\n                 } else {\n                     TextElement originalElement \u003d originalElements.get(originalIndex);\n                     boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n                         applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else if (diffElement instanceof Removed) {\n                         applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else if (diffElement instanceof Reshuffled) {\n                         applyReshuffledDiffElement((Reshuffled) diffElement);\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b7bd15d12e107c85e29912960f7b4e48aac4dc38": {
      "type": "Ybodychange",
      "commitMessage": "Reduced cognitive complexity by extracting some methods\n",
      "commitDate": "2018-05-18, 9:34 p.m.",
      "commitName": "b7bd15d12e107c85e29912960f7b4e48aac4dc38",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-05-18, 9:23 p.m.",
      "commitNameOld": "c35fbac21da07f996f017169288b748764488c20",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply() {\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n\n                    if (kept.isWhiteSpaceOrComment()) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof Added) {\n                    Added addedElement \u003d (Added) diffElement;\n\n                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n\n                if (originalElement.isWhiteSpaceOrComment()) {\n                    originalIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + originalElement);\n                }\n            } else {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof Added) {\n                    applyAddedDiffElement((Added) diffElement);\n                } else {\n                    TextElement originalElement \u003d originalElements.get(originalIndex);\n                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof Kept) {\n                        applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else if (diffElement instanceof Removed) {\n                        applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else if (diffElement instanceof Reshuffled) {\n                        applyReshuffledDiffElement((Reshuffled) diffElement);\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 124,
      "functionName": "apply",
      "diff": "@@ -1,294 +1,54 @@\n     void apply() {\n         do {\n             if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept \u003d (Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n                     Added addedElement \u003d (Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n-                    Added addedElement \u003d (Added) diffElement;\n-\n-                    if (addedElement.isIndent()) {\n-                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n-                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n-                        }\n-                        addedIndentation \u003d true;\n-                        diffIndex++;\n-                        continue;\n-                    }\n-                    if (addedElement.isUnindent()) {\n-                        for (int i \u003d 0; i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++){\n-                            indentation.remove(indentation.size() - 1);\n-                        }\n-                        addedIndentation \u003d false;\n-                        diffIndex++;\n-                        continue;\n-                    }\n-\n-                    TextElement addedTextElement \u003d addedElement.toTextElement();\n-                    boolean used \u003d false;\n-                    if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n-                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n-                            nodeText.addElement(originalIndex++, e);\n-                        }\n-                    } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n-                        if (addedTextElement.isNewline()) {\n-                            used \u003d true;\n-                        }\n-                        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n-                        // This remove the space in \"{ }\" when adding a new line\n-                        while (originalElements.get(originalIndex).isSpaceOrTab()) {\n-                            originalElements.remove(originalIndex);\n-                        }\n-                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n-                            nodeText.addElement(originalIndex++, e);\n-                        }\n-                        // Indentation is painful...\n-                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n-                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n-                        // not there, so when adding new elements we force it. However if the indentation has been\n-                        // inserted by us in this transformation we do not want to insert it again\n-                        if (!addedIndentation) {\n-                            for (TextElement e : indentationBlock()) {\n-                                nodeText.addElement(originalIndex++, e);\n-                            }\n-                        }\n-                    }\n-\n-                    if (!used) {\n-                        nodeText.addElement(originalIndex, addedTextElement);\n-                        originalIndex++;\n-                    }\n-\n-                    if (addedTextElement.isNewline()) {\n-                        boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n-                        originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n-                    }\n-\n-                    diffIndex++;\n+                    applyAddedDiffElement((Added) diffElement);\n                 } else {\n                     TextElement originalElement \u003d originalElements.get(originalIndex);\n                     boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n-                        Kept kept \u003d (Kept)diffElement;\n-\n-                        if (originalElement.isComment()) {\n-                            originalIndex++;\n-                        } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n-                            diffIndex++;\n-                            originalIndex++;\n-                        } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n-                            if (originalElement.isWhiteSpaceOrComment()) {\n-                                originalIndex++;\n-                            } else {\n-                                if (kept.isPrimitiveType()) {\n-                                    originalIndex++;\n-                                    diffIndex++;\n-                                } else {\n-                                    throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n-                                }\n-                            }\n-                        } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n-                            TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n-\n-                            if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n-                                originalIndex++;\n-                                diffIndex++;\n-                            } else if (kept.isWhiteSpaceOrComment()) {\n-                                diffIndex++;\n-                            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n-                                originalIndex++;\n-                            } else {\n-                                throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n-                            }\n-                        } else if (kept.isWhiteSpace()) {\n-                            diffIndex++;\n-                        } else if (kept.isIndent()) {\n-                            diffIndex++;\n-                        } else if (kept.isUnindent()) {\n-                            // Nothing to do, beside considering indentation\n-                            diffIndex++;\n-                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n-                                nodeText.removeElement(--originalIndex);\n-                            }\n-                        } else {\n-                            throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n-                        }\n+                        applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else if (diffElement instanceof Removed) {\n-                        Removed removed \u003d (Removed)diffElement;\n-\n-                        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n-                            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n-                            if (originalElementChild.isComment()) {\n-                                // We expected to remove a proper node but we found a comment in between.\n-                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n-                                Comment comment \u003d (Comment)originalElementChild.getChild();\n-                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n-                                    nodeText.removeElement(originalIndex);\n-                                } else {\n-                                    originalIndex++;\n-                                }\n-                            } else {\n-                                nodeText.removeElement(originalIndex);\n-                                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n-                                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n-                                } else {\n-                                    if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n-                                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n-                                    }\n-                                    // If in front we have one space and before also we had space let\u0027s drop one space\n-                                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n-                                        if (originalElements.get(originalIndex).isWhiteSpace()\n-                                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n-                                            // However we do not want to do that when we are about to adding or removing elements\n-                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n-                                                originalElements.remove(originalIndex--);\n-                                            }\n-                                        }\n-                                    }\n-                                }\n-                                diffIndex++;\n-                            }\n-                        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n-                                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n-                            nodeText.removeElement(originalIndex);\n-                            diffIndex++;\n-                        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n-                            originalIndex++;\n-                        } else if (removed.isPrimitiveType()) {\n-                            if (isPrimitiveType(originalElement)) {\n-                                nodeText.removeElement(originalIndex);\n-                                diffIndex++;\n-                            } else {\n-                                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n-                            }\n-                        } else if (removed.isWhiteSpace()) {\n-                            diffIndex++;\n-                        } else if (originalElement.isWhiteSpace()) {\n-                            originalIndex++;\n-                        } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n-                        }\n+                        applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else if (diffElement instanceof Reshuffled) {\n-                        // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n-                        Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n-                        CsmMix elementsFromPreviousOrder \u003d reshuffled.getPreviousOrder();\n-                        CsmMix elementsFromNextOrder \u003d reshuffled.getNextOrder();\n-\n-                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n-                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n-\n-                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n-                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n-\n-                        Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n-                        for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n-                            int value \u003d nodeTextIndexOfPreviousElements.get(i);\n-                            if (value !\u003d -1) {\n-                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n-                            }\n-                        }\n-                        int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n-\n-                        // Elements to be added at the end\n-                        List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n-                        List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n-\n-                        Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n-                        for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n-                            // If it has a mapping, then it is kept\n-                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n-                                // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n-                                // element that has a mapping\n-                                int originalCsmIndex \u003d -1;\n-                                for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n-                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n-                                        originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n-                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n-                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n-                                        }\n-                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n-                                    }\n-                                }\n-                                // it does not preceed anything, so it goes at the end\n-                                if (originalCsmIndex \u003d\u003d -1) {\n-                                    elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n-                                }\n-                            }\n-                        }\n-\n-                        // We go over the original node text elements, in the order they appear in the NodeText.\n-                        // Considering an original node text element (ONE)\n-                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n-                        //   we find the correspond OCE (Original CSM Element)\n-                        // * we first add new elements that are marked to be added before OCE\n-                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n-                        //   otherwise we add a removed element\n-\n-                        diffElements.remove(diffIndex);\n-\n-                        int diffElIterator \u003d diffIndex;\n-                        if (lastNodeTextIndex !\u003d -1) {\n-                            for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n-\n-                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n-                                    int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n-                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n-                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n-                                        }\n-                                    }\n-\n-                                    CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n-                                    boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n-                                    if (toBeKept) {\n-                                        diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n-                                    } else {\n-                                        diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n-                                    }\n-                                }\n-                                // else we have a simple node text element, without associated csm element, just keep ignore it\n-                            }\n-                        }\n-\n-                        // Finally we look for the remaining new elements that were not yet added and\n-                        // add all of them\n-                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n-                        }\n+                        applyReshuffledDiffElement((Reshuffled) diffElement);\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c35fbac21da07f996f017169288b748764488c20": {
      "type": "Ybodychange",
      "commitMessage": "Changed local indentaton variables to fields\n",
      "commitDate": "2018-05-18, 9:23 p.m.",
      "commitName": "c35fbac21da07f996f017169288b748764488c20",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-05-18, 9:15 p.m.",
      "commitNameOld": "a25f53f8871fd178b6791d1194d7358b55d1ba37",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply() {\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n\n                    if (kept.isWhiteSpaceOrComment()) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof Added) {\n                    Added addedElement \u003d (Added) diffElement;\n\n                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n\n                if (originalElement.isWhiteSpaceOrComment()) {\n                    originalIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + originalElement);\n                }\n            } else {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof Added) {\n                    Added addedElement \u003d (Added) diffElement;\n\n                    if (addedElement.isIndent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement.isUnindent()) {\n                        for (int i \u003d 0; i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n\n                    TextElement addedTextElement \u003d addedElement.toTextElement();\n                    boolean used \u003d false;\n                    if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (addedTextElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                            originalElements.remove(originalIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(originalIndex++, e);\n                            }\n                        }\n                    }\n\n                    if (!used) {\n                        nodeText.addElement(originalIndex, addedTextElement);\n                        originalIndex++;\n                    }\n\n                    if (addedTextElement.isNewline()) {\n                        boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                        originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n\n                    diffIndex++;\n                } else {\n                    TextElement originalElement \u003d originalElements.get(originalIndex);\n                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof Kept) {\n                        Kept kept \u003d (Kept)diffElement;\n\n                        if (originalElement.isComment()) {\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                            diffIndex++;\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                            if (originalElement.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                if (kept.isPrimitiveType()) {\n                                    originalIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                                }\n                            }\n                        } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                            TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n\n                            if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else if (kept.isWhiteSpaceOrComment()) {\n                                diffIndex++;\n                            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n                            }\n                        } else if (kept.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (kept.isIndent()) {\n                            diffIndex++;\n                        } else if (kept.isUnindent()) {\n                            // Nothing to do, beside considering indentation\n                            diffIndex++;\n                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                nodeText.removeElement(--originalIndex);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof Removed) {\n                        Removed removed \u003d (Removed)diffElement;\n\n                        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                            if (originalElementChild.isComment()) {\n                                // We expected to remove a proper node but we found a comment in between.\n                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                Comment comment \u003d (Comment)originalElementChild.getChild();\n                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                    nodeText.removeElement(originalIndex);\n                                } else {\n                                    originalIndex++;\n                                }\n                            } else {\n                                nodeText.removeElement(originalIndex);\n                                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                } else {\n                                    if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n                                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                    }\n                                    // If in front we have one space and before also we had space let\u0027s drop one space\n                                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                        if (originalElements.get(originalIndex).isWhiteSpace()\n                                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                            // However we do not want to do that when we are about to adding or removing elements\n                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                                originalElements.remove(originalIndex--);\n                                            }\n                                        }\n                                    }\n                                }\n                                diffIndex++;\n                            }\n                        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else if (removed.isPrimitiveType()) {\n                            if (isPrimitiveType(originalElement)) {\n                                nodeText.removeElement(originalIndex);\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                            }\n                        } else if (removed.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (originalElement.isWhiteSpace()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof Reshuffled) {\n                        // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                        Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n                        CsmMix elementsFromPreviousOrder \u003d reshuffled.getPreviousOrder();\n                        CsmMix elementsFromNextOrder \u003d reshuffled.getNextOrder();\n\n                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n\n                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n\n                        Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                        for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                            int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                            if (value !\u003d -1) {\n                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n                            }\n                        }\n                        int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                        // Elements to be added at the end\n                        List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                        List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n\n                        Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                        for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                            // If it has a mapping, then it is kept\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                // element that has a mapping\n                                int originalCsmIndex \u003d -1;\n                                for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                        originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                        }\n                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                    }\n                                }\n                                // it does not preceed anything, so it goes at the end\n                                if (originalCsmIndex \u003d\u003d -1) {\n                                    elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                }\n                            }\n                        }\n\n                        // We go over the original node text elements, in the order they appear in the NodeText.\n                        // Considering an original node text element (ONE)\n                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                        //   we find the correspond OCE (Original CSM Element)\n                        // * we first add new elements that are marked to be added before OCE\n                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                        //   otherwise we add a removed element\n\n                        diffElements.remove(diffIndex);\n\n                        int diffElIterator \u003d diffIndex;\n                        if (lastNodeTextIndex !\u003d -1) {\n                            for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                    int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                        }\n                                    }\n\n                                    CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                    boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                    if (toBeKept) {\n                                        diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                    } else {\n                                        diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                    }\n                                }\n                                // else we have a simple node text element, without associated csm element, just keep ignore it\n                            }\n                        }\n\n                        // Finally we look for the remaining new elements that were not yet added and\n                        // add all of them\n                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 124,
      "functionName": "apply",
      "diff": "@@ -1,297 +1,294 @@\n     void apply() {\n-        boolean addedIndentation \u003d false;\n-        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n-\n         do {\n             if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept \u003d (Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n                     Added addedElement \u003d (Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n                     Added addedElement \u003d (Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n-                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n+                        for (int i \u003d 0; i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement \u003d addedElement.toTextElement();\n                     boolean used \u003d false;\n                     if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement \u003d originalElements.get(originalIndex);\n                     boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n                         Kept kept \u003d (Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                             TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof Removed) {\n                         Removed removed \u003d (Removed)diffElement;\n \n                         if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                             ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment \u003d (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n                                     if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n                                         originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let\u0027s drop one space\n                                     if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                 \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof Reshuffled) {\n                         // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder \u003d reshuffled.getPreviousOrder();\n                         CsmMix elementsFromNextOrder \u003d reshuffled.getNextOrder();\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                         for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                             int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                             if (value !\u003d -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                         List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n \n                         Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                         for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex \u003d -1;\n                                 for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex \u003d\u003d -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator \u003d diffIndex;\n                         if (lastNodeTextIndex !\u003d -1) {\n                             for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a25f53f8871fd178b6791d1194d7358b55d1ba37": {
      "type": "Ybodychange",
      "commitMessage": "Moved DifferenceElement classes to their own files\n",
      "commitDate": "2018-05-18, 9:15 p.m.",
      "commitName": "a25f53f8871fd178b6791d1194d7358b55d1ba37",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-05-18, 8:49 p.m.",
      "commitNameOld": "29a9b8bcb552dc691cc57c85b8eb017092c960ad",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply() {\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n\n                    if (kept.isWhiteSpaceOrComment()) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof Added) {\n                    Added addedElement \u003d (Added) diffElement;\n\n                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n\n                if (originalElement.isWhiteSpaceOrComment()) {\n                    originalIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + originalElement);\n                }\n            } else {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof Added) {\n                    Added addedElement \u003d (Added) diffElement;\n\n                    if (addedElement.isIndent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement.isUnindent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n\n                    TextElement addedTextElement \u003d addedElement.toTextElement();\n                    boolean used \u003d false;\n                    if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (addedTextElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                            originalElements.remove(originalIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(originalIndex++, e);\n                            }\n                        }\n                    }\n\n                    if (!used) {\n                        nodeText.addElement(originalIndex, addedTextElement);\n                        originalIndex++;\n                    }\n\n                    if (addedTextElement.isNewline()) {\n                        boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                        originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n\n                    diffIndex++;\n                } else {\n                    TextElement originalElement \u003d originalElements.get(originalIndex);\n                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof Kept) {\n                        Kept kept \u003d (Kept)diffElement;\n\n                        if (originalElement.isComment()) {\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                            diffIndex++;\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                            if (originalElement.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                if (kept.isPrimitiveType()) {\n                                    originalIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                                }\n                            }\n                        } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                            TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n\n                            if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else if (kept.isWhiteSpaceOrComment()) {\n                                diffIndex++;\n                            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n                            }\n                        } else if (kept.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (kept.isIndent()) {\n                            diffIndex++;\n                        } else if (kept.isUnindent()) {\n                            // Nothing to do, beside considering indentation\n                            diffIndex++;\n                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                nodeText.removeElement(--originalIndex);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof Removed) {\n                        Removed removed \u003d (Removed)diffElement;\n\n                        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                            if (originalElementChild.isComment()) {\n                                // We expected to remove a proper node but we found a comment in between.\n                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                Comment comment \u003d (Comment)originalElementChild.getChild();\n                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                    nodeText.removeElement(originalIndex);\n                                } else {\n                                    originalIndex++;\n                                }\n                            } else {\n                                nodeText.removeElement(originalIndex);\n                                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                } else {\n                                    if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n                                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                    }\n                                    // If in front we have one space and before also we had space let\u0027s drop one space\n                                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                        if (originalElements.get(originalIndex).isWhiteSpace()\n                                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                            // However we do not want to do that when we are about to adding or removing elements\n                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                                originalElements.remove(originalIndex--);\n                                            }\n                                        }\n                                    }\n                                }\n                                diffIndex++;\n                            }\n                        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else if (removed.isPrimitiveType()) {\n                            if (isPrimitiveType(originalElement)) {\n                                nodeText.removeElement(originalIndex);\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                            }\n                        } else if (removed.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (originalElement.isWhiteSpace()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof Reshuffled) {\n                        // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                        Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n                        CsmMix elementsFromPreviousOrder \u003d reshuffled.getPreviousOrder();\n                        CsmMix elementsFromNextOrder \u003d reshuffled.getNextOrder();\n\n                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n\n                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n\n                        Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                        for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                            int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                            if (value !\u003d -1) {\n                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n                            }\n                        }\n                        int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                        // Elements to be added at the end\n                        List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                        List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n\n                        Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                        for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                            // If it has a mapping, then it is kept\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                // element that has a mapping\n                                int originalCsmIndex \u003d -1;\n                                for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                        originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                        }\n                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                    }\n                                }\n                                // it does not preceed anything, so it goes at the end\n                                if (originalCsmIndex \u003d\u003d -1) {\n                                    elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                }\n                            }\n                        }\n\n                        // We go over the original node text elements, in the order they appear in the NodeText.\n                        // Considering an original node text element (ONE)\n                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                        //   we find the correspond OCE (Original CSM Element)\n                        // * we first add new elements that are marked to be added before OCE\n                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                        //   otherwise we add a removed element\n\n                        diffElements.remove(diffIndex);\n\n                        int diffElIterator \u003d diffIndex;\n                        if (lastNodeTextIndex !\u003d -1) {\n                            for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                    int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                        }\n                                    }\n\n                                    CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                    boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                    if (toBeKept) {\n                                        diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                    } else {\n                                        diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                    }\n                                }\n                                // else we have a simple node text element, without associated csm element, just keep ignore it\n                            }\n                        }\n\n                        // Finally we look for the remaining new elements that were not yet added and\n                        // add all of them\n                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 121,
      "functionName": "apply",
      "diff": "@@ -1,297 +1,297 @@\n     void apply() {\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n \n         do {\n             if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n-                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n-                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n-                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n+                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n+                if (diffElement instanceof Kept) {\n+                    Kept kept \u003d (Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n-                } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n-                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n+                } else if (diffElement instanceof Added) {\n+                    Added addedElement \u003d (Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n-                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n+                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n \n-                if (diffElement instanceof DifferenceElementCalculator.Added) {\n-                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n+                if (diffElement instanceof Added) {\n+                    Added addedElement \u003d (Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement \u003d addedElement.toTextElement();\n                     boolean used \u003d false;\n                     if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement \u003d originalElements.get(originalIndex);\n                     boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n \n-                    if (diffElement instanceof DifferenceElementCalculator.Kept) {\n-                        DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept)diffElement;\n+                    if (diffElement instanceof Kept) {\n+                        Kept kept \u003d (Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n-                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n+                                    throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                             TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n+                                throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n-                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n+                            throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                         }\n-                    } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n-                        DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed)diffElement;\n+                    } else if (diffElement instanceof Removed) {\n+                        Removed removed \u003d (Removed)diffElement;\n \n                         if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                             ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment \u003d (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n-                                    if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n+                                    if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n                                         originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let\u0027s drop one space\n                                     if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n-                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n+                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                 \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n+                                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n+                            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                         }\n-                    } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n+                    } else if (diffElement instanceof Reshuffled) {\n                         // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n-                        DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled)diffElement;\n-                        CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n-                        CsmMix elementsFromNextOrder \u003d reshuffled.element;\n+                        Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n+                        CsmMix elementsFromPreviousOrder \u003d reshuffled.getPreviousOrder();\n+                        CsmMix elementsFromNextOrder \u003d reshuffled.getNextOrder();\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                         for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                             int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                             if (value !\u003d -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                         List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n \n                         Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                         for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex \u003d -1;\n                                 for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex \u003d\u003d -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator \u003d diffIndex;\n                         if (lastNodeTextIndex !\u003d -1) {\n                             for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n+                                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n-                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n+                                        diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                     } else {\n-                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n+                                        diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n+                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "29a9b8bcb552dc691cc57c85b8eb017092c960ad": {
      "type": "Ybodychange",
      "commitMessage": "Changed some local variables to instance variables\n",
      "commitDate": "2018-05-18, 8:49 p.m.",
      "commitName": "29a9b8bcb552dc691cc57c85b8eb017092c960ad",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-05-18, 8:42 p.m.",
      "commitNameOld": "04f28d4024daa5798f3c627170bfe2a96bce8e55",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply() {\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n\n                    if (kept.isWhiteSpaceOrComment()) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n\n                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n\n                if (originalElement.isWhiteSpaceOrComment()) {\n                    originalIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + originalElement);\n                }\n            } else {\n                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof DifferenceElementCalculator.Added) {\n                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n\n                    if (addedElement.isIndent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement.isUnindent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n\n                    TextElement addedTextElement \u003d addedElement.toTextElement();\n                    boolean used \u003d false;\n                    if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (addedTextElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                            originalElements.remove(originalIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(originalIndex++, e);\n                            }\n                        }\n                    }\n\n                    if (!used) {\n                        nodeText.addElement(originalIndex, addedTextElement);\n                        originalIndex++;\n                    }\n\n                    if (addedTextElement.isNewline()) {\n                        boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                        originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n\n                    diffIndex++;\n                } else {\n                    TextElement originalElement \u003d originalElements.get(originalIndex);\n                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                        DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept)diffElement;\n\n                        if (originalElement.isComment()) {\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                            diffIndex++;\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                            if (originalElement.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                if (kept.isPrimitiveType()) {\n                                    originalIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                }\n                            }\n                        } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                            TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n\n                            if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else if (kept.isWhiteSpaceOrComment()) {\n                                diffIndex++;\n                            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                            }\n                        } else if (kept.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (kept.isIndent()) {\n                            diffIndex++;\n                        } else if (kept.isUnindent()) {\n                            // Nothing to do, beside considering indentation\n                            diffIndex++;\n                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                nodeText.removeElement(--originalIndex);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                        DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed)diffElement;\n\n                        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                            if (originalElementChild.isComment()) {\n                                // We expected to remove a proper node but we found a comment in between.\n                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                Comment comment \u003d (Comment)originalElementChild.getChild();\n                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                    nodeText.removeElement(originalIndex);\n                                } else {\n                                    originalIndex++;\n                                }\n                            } else {\n                                nodeText.removeElement(originalIndex);\n                                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                } else {\n                                    if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                    }\n                                    // If in front we have one space and before also we had space let\u0027s drop one space\n                                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                        if (originalElements.get(originalIndex).isWhiteSpace()\n                                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                            // However we do not want to do that when we are about to adding or removing elements\n                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                originalElements.remove(originalIndex--);\n                                            }\n                                        }\n                                    }\n                                }\n                                diffIndex++;\n                            }\n                        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else if (removed.isPrimitiveType()) {\n                            if (isPrimitiveType(originalElement)) {\n                                nodeText.removeElement(originalIndex);\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                            }\n                        } else if (removed.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (originalElement.isWhiteSpace()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                        // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                        DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled)diffElement;\n                        CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                        CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n\n                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n\n                        Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                        for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                            int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                            if (value !\u003d -1) {\n                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n                            }\n                        }\n                        int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                        // Elements to be added at the end\n                        List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                        List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n\n                        Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                        for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                            // If it has a mapping, then it is kept\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                // element that has a mapping\n                                int originalCsmIndex \u003d -1;\n                                for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                        originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                        }\n                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                    }\n                                }\n                                // it does not preceed anything, so it goes at the end\n                                if (originalCsmIndex \u003d\u003d -1) {\n                                    elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                }\n                            }\n                        }\n\n                        // We go over the original node text elements, in the order they appear in the NodeText.\n                        // Considering an original node text element (ONE)\n                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                        //   we find the correspond OCE (Original CSM Element)\n                        // * we first add new elements that are marked to be added before OCE\n                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                        //   otherwise we add a removed element\n\n                        diffElements.remove(diffIndex);\n\n                        int diffElIterator \u003d diffIndex;\n                        if (lastNodeTextIndex !\u003d -1) {\n                            for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                    int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                        }\n                                    }\n\n                                    CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                    boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                    if (toBeKept) {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                    } else {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                    }\n                                }\n                                // else we have a simple node text element, without associated csm element, just keep ignore it\n                            }\n                        }\n\n                        // Finally we look for the remaining new elements that were not yet added and\n                        // add all of them\n                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 120,
      "functionName": "apply",
      "diff": "@@ -1,304 +1,297 @@\n     void apply() {\n-        if (nodeText \u003d\u003d null) {\n-            throw new NullPointerException();\n-        }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n \n-        List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n-        int originalIndex \u003d 0;\n-\n-        int diffIndex \u003d 0;\n         do {\n             if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                 DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                 if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                     DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n \n                 if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement \u003d addedElement.toTextElement();\n                     boolean used \u003d false;\n                     if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement \u003d originalElements.get(originalIndex);\n                     boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                         DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                             TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                         DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed)diffElement;\n \n                         if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                             ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment \u003d (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n                                     if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                         originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let\u0027s drop one space\n                                     if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                 \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                         // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                         for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                             int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                             if (value !\u003d -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                         List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n \n                         Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                         for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex \u003d -1;\n                                 for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex \u003d\u003d -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator \u003d diffIndex;\n                         if (lastNodeTextIndex !\u003d -1) {\n                             for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "04f28d4024daa5798f3c627170bfe2a96bce8e55": {
      "type": "Ybodychange",
      "commitMessage": "Removed getElements method\n",
      "commitDate": "2018-05-18, 8:42 p.m.",
      "commitName": "04f28d4024daa5798f3c627170bfe2a96bce8e55",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-05-18, 8:36 p.m.",
      "commitNameOld": "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply() {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n\n        List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n        int originalIndex \u003d 0;\n\n        int diffIndex \u003d 0;\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n\n                    if (kept.isWhiteSpaceOrComment()) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n\n                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n\n                if (originalElement.isWhiteSpaceOrComment()) {\n                    originalIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + originalElement);\n                }\n            } else {\n                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof DifferenceElementCalculator.Added) {\n                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n\n                    if (addedElement.isIndent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement.isUnindent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n\n                    TextElement addedTextElement \u003d addedElement.toTextElement();\n                    boolean used \u003d false;\n                    if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (addedTextElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                            originalElements.remove(originalIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(originalIndex++, e);\n                            }\n                        }\n                    }\n\n                    if (!used) {\n                        nodeText.addElement(originalIndex, addedTextElement);\n                        originalIndex++;\n                    }\n\n                    if (addedTextElement.isNewline()) {\n                        boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                        originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n\n                    diffIndex++;\n                } else {\n                    TextElement originalElement \u003d originalElements.get(originalIndex);\n                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                        DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept)diffElement;\n\n                        if (originalElement.isComment()) {\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                            diffIndex++;\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                            if (originalElement.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                if (kept.isPrimitiveType()) {\n                                    originalIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                }\n                            }\n                        } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                            TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n\n                            if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else if (kept.isWhiteSpaceOrComment()) {\n                                diffIndex++;\n                            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                            }\n                        } else if (kept.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (kept.isIndent()) {\n                            diffIndex++;\n                        } else if (kept.isUnindent()) {\n                            // Nothing to do, beside considering indentation\n                            diffIndex++;\n                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                nodeText.removeElement(--originalIndex);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                        DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed)diffElement;\n\n                        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                            if (originalElementChild.isComment()) {\n                                // We expected to remove a proper node but we found a comment in between.\n                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                Comment comment \u003d (Comment)originalElementChild.getChild();\n                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                    nodeText.removeElement(originalIndex);\n                                } else {\n                                    originalIndex++;\n                                }\n                            } else {\n                                nodeText.removeElement(originalIndex);\n                                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                } else {\n                                    if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                    }\n                                    // If in front we have one space and before also we had space let\u0027s drop one space\n                                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                        if (originalElements.get(originalIndex).isWhiteSpace()\n                                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                            // However we do not want to do that when we are about to adding or removing elements\n                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                originalElements.remove(originalIndex--);\n                                            }\n                                        }\n                                    }\n                                }\n                                diffIndex++;\n                            }\n                        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else if (removed.isPrimitiveType()) {\n                            if (isPrimitiveType(originalElement)) {\n                                nodeText.removeElement(originalIndex);\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                            }\n                        } else if (removed.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (originalElement.isWhiteSpace()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                        // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                        DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled)diffElement;\n                        CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                        CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n\n                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n\n                        Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                        for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                            int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                            if (value !\u003d -1) {\n                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n                            }\n                        }\n                        int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                        // Elements to be added at the end\n                        List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                        List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n\n                        Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                        for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                            // If it has a mapping, then it is kept\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                // element that has a mapping\n                                int originalCsmIndex \u003d -1;\n                                for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                        originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                        }\n                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                    }\n                                }\n                                // it does not preceed anything, so it goes at the end\n                                if (originalCsmIndex \u003d\u003d -1) {\n                                    elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                }\n                            }\n                        }\n\n                        // We go over the original node text elements, in the order they appear in the NodeText.\n                        // Considering an original node text element (ONE)\n                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                        //   we find the correspond OCE (Original CSM Element)\n                        // * we first add new elements that are marked to be added before OCE\n                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                        //   otherwise we add a removed element\n\n                        diffElements.remove(diffIndex);\n\n                        int diffElIterator \u003d diffIndex;\n                        if (lastNodeTextIndex !\u003d -1) {\n                            for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                    int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                        }\n                                    }\n\n                                    CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                    boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                    if (toBeKept) {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                    } else {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                    }\n                                }\n                                // else we have a simple node text element, without associated csm element, just keep ignore it\n                            }\n                        }\n\n                        // Finally we look for the remaining new elements that were not yet added and\n                        // add all of them\n                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 109,
      "functionName": "apply",
      "diff": "@@ -1,305 +1,304 @@\n     void apply() {\n-        if (this.nodeText \u003d\u003d null) {\n+        if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n-        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(this.node);\n+        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n \n         List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n         int originalIndex \u003d 0;\n \n-        List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n         int diffIndex \u003d 0;\n         do {\n             if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                 DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                 if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                     DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n \n                 if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement \u003d addedElement.toTextElement();\n                     boolean used \u003d false;\n                     if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement \u003d originalElements.get(originalIndex);\n                     boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                         DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                             TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                         DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed)diffElement;\n \n                         if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                             ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment \u003d (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n-                                    if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n+                                    if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                         originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let\u0027s drop one space\n                                     if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                 \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                         // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                         for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                             int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                             if (value !\u003d -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                         List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n \n                         Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                         for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex \u003d -1;\n                                 for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex \u003d\u003d -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator \u003d diffIndex;\n                         if (lastNodeTextIndex !\u003d -1) {\n                             for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Moved method parameters from Difference.apply to its constructor as instance variables\n",
      "commitDate": "2018-05-18, 8:36 p.m.",
      "commitName": "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
      "commitAuthor": "Thomas Leu",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Moved method parameters from Difference.apply to its constructor as instance variables\n",
          "commitDate": "2018-05-18, 8:36 p.m.",
          "commitName": "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
          "commitAuthor": "Thomas Leu",
          "commitDateOld": "2018-05-18, 7:51 p.m.",
          "commitNameOld": "40f6fef078275d3ca43f02918200a2d6076fef9d",
          "commitAuthorOld": "Thomas Leu",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    void apply() {\n        if (this.nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(this.node);\n\n        List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n        int originalIndex \u003d 0;\n\n        List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n        int diffIndex \u003d 0;\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n\n                    if (kept.isWhiteSpaceOrComment()) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n\n                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n\n                if (originalElement.isWhiteSpaceOrComment()) {\n                    originalIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + originalElement);\n                }\n            } else {\n                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof DifferenceElementCalculator.Added) {\n                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n\n                    if (addedElement.isIndent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement.isUnindent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n\n                    TextElement addedTextElement \u003d addedElement.toTextElement();\n                    boolean used \u003d false;\n                    if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (addedTextElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                            originalElements.remove(originalIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(originalIndex++, e);\n                            }\n                        }\n                    }\n\n                    if (!used) {\n                        nodeText.addElement(originalIndex, addedTextElement);\n                        originalIndex++;\n                    }\n\n                    if (addedTextElement.isNewline()) {\n                        boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                        originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n\n                    diffIndex++;\n                } else {\n                    TextElement originalElement \u003d originalElements.get(originalIndex);\n                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                        DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept)diffElement;\n\n                        if (originalElement.isComment()) {\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                            diffIndex++;\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                            if (originalElement.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                if (kept.isPrimitiveType()) {\n                                    originalIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                }\n                            }\n                        } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                            TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n\n                            if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else if (kept.isWhiteSpaceOrComment()) {\n                                diffIndex++;\n                            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                            }\n                        } else if (kept.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (kept.isIndent()) {\n                            diffIndex++;\n                        } else if (kept.isUnindent()) {\n                            // Nothing to do, beside considering indentation\n                            diffIndex++;\n                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                nodeText.removeElement(--originalIndex);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                        DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed)diffElement;\n\n                        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                            if (originalElementChild.isComment()) {\n                                // We expected to remove a proper node but we found a comment in between.\n                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                Comment comment \u003d (Comment)originalElementChild.getChild();\n                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                    nodeText.removeElement(originalIndex);\n                                } else {\n                                    originalIndex++;\n                                }\n                            } else {\n                                nodeText.removeElement(originalIndex);\n                                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                } else {\n                                    if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                    }\n                                    // If in front we have one space and before also we had space let\u0027s drop one space\n                                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                        if (originalElements.get(originalIndex).isWhiteSpace()\n                                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                            // However we do not want to do that when we are about to adding or removing elements\n                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                originalElements.remove(originalIndex--);\n                                            }\n                                        }\n                                    }\n                                }\n                                diffIndex++;\n                            }\n                        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else if (removed.isPrimitiveType()) {\n                            if (isPrimitiveType(originalElement)) {\n                                nodeText.removeElement(originalIndex);\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                            }\n                        } else if (removed.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (originalElement.isWhiteSpace()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                        // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                        DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled)diffElement;\n                        CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                        CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n\n                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n\n                        Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                        for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                            int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                            if (value !\u003d -1) {\n                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n                            }\n                        }\n                        int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                        // Elements to be added at the end\n                        List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                        List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n\n                        Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                        for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                            // If it has a mapping, then it is kept\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                // element that has a mapping\n                                int originalCsmIndex \u003d -1;\n                                for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                        originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                        }\n                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                    }\n                                }\n                                // it does not preceed anything, so it goes at the end\n                                if (originalCsmIndex \u003d\u003d -1) {\n                                    elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                }\n                            }\n                        }\n\n                        // We go over the original node text elements, in the order they appear in the NodeText.\n                        // Considering an original node text element (ONE)\n                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                        //   we find the correspond OCE (Original CSM Element)\n                        // * we first add new elements that are marked to be added before OCE\n                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                        //   otherwise we add a removed element\n\n                        diffElements.remove(diffIndex);\n\n                        int diffElIterator \u003d diffIndex;\n                        if (lastNodeTextIndex !\u003d -1) {\n                            for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                    int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                        }\n                                    }\n\n                                    CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                    boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                    if (toBeKept) {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                    } else {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                    }\n                                }\n                                // else we have a simple node text element, without associated csm element, just keep ignore it\n                            }\n                        }\n\n                        // Finally we look for the remaining new elements that were not yet added and\n                        // add all of them\n                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n    }",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 109,
          "functionName": "apply",
          "diff": "@@ -1,305 +1,305 @@\n-    void apply(NodeText nodeText, Node node) {\n-        if (nodeText \u003d\u003d null) {\n+    void apply() {\n+        if (this.nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n-        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n+        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(this.node);\n \n         List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n         int originalIndex \u003d 0;\n \n         List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n         int diffIndex \u003d 0;\n         do {\n             if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                 DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                 if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                     DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n \n                 if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement \u003d addedElement.toTextElement();\n                     boolean used \u003d false;\n                     if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement \u003d originalElements.get(originalIndex);\n                     boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                         DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                             TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                         DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed)diffElement;\n \n                         if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                             ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment \u003d (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n                                     if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                         originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let\u0027s drop one space\n                                     if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                 \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                         // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                         for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                             int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                             if (value !\u003d -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                         List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n \n                         Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                         for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex \u003d -1;\n                                 for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex \u003d\u003d -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator \u003d diffIndex;\n                         if (lastNodeTextIndex !\u003d -1) {\n                             for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[nodeText-NodeText, node-Node]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Moved method parameters from Difference.apply to its constructor as instance variables\n",
          "commitDate": "2018-05-18, 8:36 p.m.",
          "commitName": "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
          "commitAuthor": "Thomas Leu",
          "commitDateOld": "2018-05-18, 7:51 p.m.",
          "commitNameOld": "40f6fef078275d3ca43f02918200a2d6076fef9d",
          "commitAuthorOld": "Thomas Leu",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    void apply() {\n        if (this.nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(this.node);\n\n        List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n        int originalIndex \u003d 0;\n\n        List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n        int diffIndex \u003d 0;\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n\n                    if (kept.isWhiteSpaceOrComment()) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n\n                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n\n                if (originalElement.isWhiteSpaceOrComment()) {\n                    originalIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + originalElement);\n                }\n            } else {\n                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof DifferenceElementCalculator.Added) {\n                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n\n                    if (addedElement.isIndent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement.isUnindent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n\n                    TextElement addedTextElement \u003d addedElement.toTextElement();\n                    boolean used \u003d false;\n                    if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (addedTextElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                            originalElements.remove(originalIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(originalIndex++, e);\n                            }\n                        }\n                    }\n\n                    if (!used) {\n                        nodeText.addElement(originalIndex, addedTextElement);\n                        originalIndex++;\n                    }\n\n                    if (addedTextElement.isNewline()) {\n                        boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                        originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n\n                    diffIndex++;\n                } else {\n                    TextElement originalElement \u003d originalElements.get(originalIndex);\n                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                        DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept)diffElement;\n\n                        if (originalElement.isComment()) {\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                            diffIndex++;\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                            if (originalElement.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                if (kept.isPrimitiveType()) {\n                                    originalIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                }\n                            }\n                        } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                            TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n\n                            if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else if (kept.isWhiteSpaceOrComment()) {\n                                diffIndex++;\n                            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                            }\n                        } else if (kept.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (kept.isIndent()) {\n                            diffIndex++;\n                        } else if (kept.isUnindent()) {\n                            // Nothing to do, beside considering indentation\n                            diffIndex++;\n                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                nodeText.removeElement(--originalIndex);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                        DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed)diffElement;\n\n                        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                            if (originalElementChild.isComment()) {\n                                // We expected to remove a proper node but we found a comment in between.\n                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                Comment comment \u003d (Comment)originalElementChild.getChild();\n                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                    nodeText.removeElement(originalIndex);\n                                } else {\n                                    originalIndex++;\n                                }\n                            } else {\n                                nodeText.removeElement(originalIndex);\n                                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                } else {\n                                    if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                    }\n                                    // If in front we have one space and before also we had space let\u0027s drop one space\n                                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                        if (originalElements.get(originalIndex).isWhiteSpace()\n                                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                            // However we do not want to do that when we are about to adding or removing elements\n                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                originalElements.remove(originalIndex--);\n                                            }\n                                        }\n                                    }\n                                }\n                                diffIndex++;\n                            }\n                        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else if (removed.isPrimitiveType()) {\n                            if (isPrimitiveType(originalElement)) {\n                                nodeText.removeElement(originalIndex);\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                            }\n                        } else if (removed.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (originalElement.isWhiteSpace()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                        // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                        DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled)diffElement;\n                        CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                        CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n\n                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n\n                        Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                        for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                            int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                            if (value !\u003d -1) {\n                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n                            }\n                        }\n                        int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                        // Elements to be added at the end\n                        List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                        List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n\n                        Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                        for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                            // If it has a mapping, then it is kept\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                // element that has a mapping\n                                int originalCsmIndex \u003d -1;\n                                for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                        originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                        }\n                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                    }\n                                }\n                                // it does not preceed anything, so it goes at the end\n                                if (originalCsmIndex \u003d\u003d -1) {\n                                    elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                }\n                            }\n                        }\n\n                        // We go over the original node text elements, in the order they appear in the NodeText.\n                        // Considering an original node text element (ONE)\n                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                        //   we find the correspond OCE (Original CSM Element)\n                        // * we first add new elements that are marked to be added before OCE\n                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                        //   otherwise we add a removed element\n\n                        diffElements.remove(diffIndex);\n\n                        int diffElIterator \u003d diffIndex;\n                        if (lastNodeTextIndex !\u003d -1) {\n                            for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                    int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                        }\n                                    }\n\n                                    CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                    boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                    if (toBeKept) {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                    } else {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                    }\n                                }\n                                // else we have a simple node text element, without associated csm element, just keep ignore it\n                            }\n                        }\n\n                        // Finally we look for the remaining new elements that were not yet added and\n                        // add all of them\n                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n    }",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 109,
          "functionName": "apply",
          "diff": "@@ -1,305 +1,305 @@\n-    void apply(NodeText nodeText, Node node) {\n-        if (nodeText \u003d\u003d null) {\n+    void apply() {\n+        if (this.nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n-        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n+        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(this.node);\n \n         List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n         int originalIndex \u003d 0;\n \n         List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n         int diffIndex \u003d 0;\n         do {\n             if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                 DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                 if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                     DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n \n                 if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement \u003d addedElement.toTextElement();\n                     boolean used \u003d false;\n                     if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement \u003d originalElements.get(originalIndex);\n                     boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                         DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                             TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                         DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed)diffElement;\n \n                         if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                             ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment \u003d (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n                                     if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                         originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let\u0027s drop one space\n                                     if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                 \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                         // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                         for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                             int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                             if (value !\u003d -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                         List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n \n                         Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                         for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex \u003d -1;\n                                 for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex \u003d\u003d -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator \u003d diffIndex;\n                         if (lastNodeTextIndex !\u003d -1) {\n                             for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "40f6fef078275d3ca43f02918200a2d6076fef9d": {
      "type": "Ybodychange",
      "commitMessage": "Moved DifferenceElement classes and static methods to new class DifferenceElementCalculator\n",
      "commitDate": "2018-05-18, 7:51 p.m.",
      "commitName": "40f6fef078275d3ca43f02918200a2d6076fef9d",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-05-18, 7:26 p.m.",
      "commitNameOld": "c4bbfa7060e136038d49a7ecfc35ec960153ac06",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n\n        List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n        int originalIndex \u003d 0;\n\n        List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n        int diffIndex \u003d 0;\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n\n                    if (kept.isWhiteSpaceOrComment()) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n\n                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n\n                if (originalElement.isWhiteSpaceOrComment()) {\n                    originalIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + originalElement);\n                }\n            } else {\n                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof DifferenceElementCalculator.Added) {\n                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n\n                    if (addedElement.isIndent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement.isUnindent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n\n                    TextElement addedTextElement \u003d addedElement.toTextElement();\n                    boolean used \u003d false;\n                    if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (addedTextElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                            originalElements.remove(originalIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(originalIndex++, e);\n                            }\n                        }\n                    }\n\n                    if (!used) {\n                        nodeText.addElement(originalIndex, addedTextElement);\n                        originalIndex++;\n                    }\n\n                    if (addedTextElement.isNewline()) {\n                        boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                        originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n\n                    diffIndex++;\n                } else {\n                    TextElement originalElement \u003d originalElements.get(originalIndex);\n                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                        DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept)diffElement;\n\n                        if (originalElement.isComment()) {\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                            diffIndex++;\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                            if (originalElement.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                if (kept.isPrimitiveType()) {\n                                    originalIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                }\n                            }\n                        } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                            TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n\n                            if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else if (kept.isWhiteSpaceOrComment()) {\n                                diffIndex++;\n                            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                            }\n                        } else if (kept.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (kept.isIndent()) {\n                            diffIndex++;\n                        } else if (kept.isUnindent()) {\n                            // Nothing to do, beside considering indentation\n                            diffIndex++;\n                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                nodeText.removeElement(--originalIndex);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                        DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed)diffElement;\n\n                        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                            if (originalElementChild.isComment()) {\n                                // We expected to remove a proper node but we found a comment in between.\n                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                Comment comment \u003d (Comment)originalElementChild.getChild();\n                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                    nodeText.removeElement(originalIndex);\n                                } else {\n                                    originalIndex++;\n                                }\n                            } else {\n                                nodeText.removeElement(originalIndex);\n                                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                } else {\n                                    if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                    }\n                                    // If in front we have one space and before also we had space let\u0027s drop one space\n                                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                        if (originalElements.get(originalIndex).isWhiteSpace()\n                                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                            // However we do not want to do that when we are about to adding or removing elements\n                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                originalElements.remove(originalIndex--);\n                                            }\n                                        }\n                                    }\n                                }\n                                diffIndex++;\n                            }\n                        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else if (removed.isPrimitiveType()) {\n                            if (isPrimitiveType(originalElement)) {\n                                nodeText.removeElement(originalIndex);\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                            }\n                        } else if (removed.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (originalElement.isWhiteSpace()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                        // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                        DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled)diffElement;\n                        CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                        CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n\n                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n\n                        Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                        for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                            int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                            if (value !\u003d -1) {\n                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n                            }\n                        }\n                        int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                        // Elements to be added at the end\n                        List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                        List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n\n                        Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                        for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                            // If it has a mapping, then it is kept\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                // element that has a mapping\n                                int originalCsmIndex \u003d -1;\n                                for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                        originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                        }\n                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                    }\n                                }\n                                // it does not preceed anything, so it goes at the end\n                                if (originalCsmIndex \u003d\u003d -1) {\n                                    elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                }\n                            }\n                        }\n\n                        // We go over the original node text elements, in the order they appear in the NodeText.\n                        // Considering an original node text element (ONE)\n                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                        //   we find the correspond OCE (Original CSM Element)\n                        // * we first add new elements that are marked to be added before OCE\n                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                        //   otherwise we add a removed element\n\n                        diffElements.remove(diffIndex);\n\n                        int diffElIterator \u003d diffIndex;\n                        if (lastNodeTextIndex !\u003d -1) {\n                            for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                    int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                        }\n                                    }\n\n                                    CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                    boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                    if (toBeKept) {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                    } else {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                    }\n                                }\n                                // else we have a simple node text element, without associated csm element, just keep ignore it\n                            }\n                        }\n\n                        // Finally we look for the remaining new elements that were not yet added and\n                        // add all of them\n                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 105,
      "functionName": "apply",
      "diff": "@@ -1,305 +1,305 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n \n         List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n         int originalIndex \u003d 0;\n \n-        List\u003cDifferenceElement\u003e diffElements \u003d getElements();\n+        List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n         int diffIndex \u003d 0;\n         do {\n             if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n-                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n-                if (diffElement instanceof Kept) {\n-                    Kept kept \u003d (Kept) diffElement;\n+                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n+                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n+                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n-                } else if (diffElement instanceof Added) {\n-                    Added addedElement \u003d (Added) diffElement;\n+                } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n+                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n-                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n+                DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n \n-                if (diffElement instanceof Added) {\n-                    Added addedElement \u003d (Added) diffElement;\n+                if (diffElement instanceof DifferenceElementCalculator.Added) {\n+                    DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement \u003d addedElement.toTextElement();\n                     boolean used \u003d false;\n                     if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement \u003d originalElements.get(originalIndex);\n                     boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n \n-                    if (diffElement instanceof Kept) {\n-                        Kept kept \u003d (Kept)diffElement;\n+                    if (diffElement instanceof DifferenceElementCalculator.Kept) {\n+                        DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                             TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n-                    } else if (diffElement instanceof Removed) {\n-                        Removed removed \u003d (Removed)diffElement;\n+                    } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n+                        DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed)diffElement;\n \n                         if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                             ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment \u003d (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n-                                    if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n+                                    if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                         originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let\u0027s drop one space\n                                     if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n-                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n+                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                 \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n-                    } else if (diffElement instanceof Reshuffled) {\n+                    } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                         // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n-                        Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n+                        DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                         for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                             int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                             if (value !\u003d -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                         List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n \n                         Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                         for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex \u003d -1;\n                                 for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex \u003d\u003d -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator \u003d diffIndex;\n                         if (lastNodeTextIndex !\u003d -1) {\n                             for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n+                                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n-                                        diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n+                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                     } else {\n-                                        diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n+                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n+                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7f177dcaadbccb2076a2a41aa1000696a9a8a10e": {
      "type": "Ybodychange",
      "commitMessage": "Extracted some methods and renamed some variables\n",
      "commitDate": "2018-05-18, 5:48 p.m.",
      "commitName": "7f177dcaadbccb2076a2a41aa1000696a9a8a10e",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-05-18, 4:05 p.m.",
      "commitNameOld": "2ae6f779cc175b3cd82d915419f378e53ff4b056",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n\n        List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n        int originalIndex \u003d 0;\n\n        List\u003cDifferenceElement\u003e diffElements \u003d getElements();\n        int diffIndex \u003d 0;\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n\n                    if (kept.isWhiteSpaceOrComment()) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof Added) {\n                    Added addedElement \u003d (Added) diffElement;\n\n                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n\n                if (originalElement.isWhiteSpaceOrComment()) {\n                    originalIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + originalElement);\n                }\n            } else {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof Added) {\n                    Added addedElement \u003d (Added) diffElement;\n\n                    if (addedElement.isIndent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement.isUnindent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n\n                    TextElement addedTextElement \u003d addedElement.toTextElement();\n                    boolean used \u003d false;\n                    if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (addedTextElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                            originalElements.remove(originalIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(originalIndex++, e);\n                            }\n                        }\n                    }\n\n                    if (!used) {\n                        nodeText.addElement(originalIndex, addedTextElement);\n                        originalIndex++;\n                    }\n\n                    if (addedTextElement.isNewline()) {\n                        boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                        originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n\n                    diffIndex++;\n                } else {\n                    TextElement originalElement \u003d originalElements.get(originalIndex);\n                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof Kept) {\n                        Kept kept \u003d (Kept)diffElement;\n\n                        if (originalElement.isComment()) {\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                            diffIndex++;\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                            if (originalElement.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                if (kept.isPrimitiveType()) {\n                                    originalIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                }\n                            }\n                        } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                            TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n\n                            if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else if (kept.isWhiteSpaceOrComment()) {\n                                diffIndex++;\n                            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                            }\n                        } else if (kept.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (kept.isIndent()) {\n                            diffIndex++;\n                        } else if (kept.isUnindent()) {\n                            // Nothing to do, beside considering indentation\n                            diffIndex++;\n                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                nodeText.removeElement(--originalIndex);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof Removed) {\n                        Removed removed \u003d (Removed)diffElement;\n\n                        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n                            if (originalElementChild.isComment()) {\n                                // We expected to remove a proper node but we found a comment in between.\n                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                Comment comment \u003d (Comment)originalElementChild.getChild();\n                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                    nodeText.removeElement(originalIndex);\n                                } else {\n                                    originalIndex++;\n                                }\n                            } else {\n                                nodeText.removeElement(originalIndex);\n                                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                } else {\n                                    if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                    }\n                                    // If in front we have one space and before also we had space let\u0027s drop one space\n                                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                        if (originalElements.get(originalIndex).isWhiteSpace()\n                                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                            // However we do not want to do that when we are about to adding or removing elements\n                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                                originalElements.remove(originalIndex--);\n                                            }\n                                        }\n                                    }\n                                }\n                                diffIndex++;\n                            }\n                        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else if (removed.isPrimitiveType()) {\n                            if (isPrimitiveType(originalElement)) {\n                                nodeText.removeElement(originalIndex);\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                            }\n                        } else if (removed.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (originalElement.isWhiteSpace()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof Reshuffled) {\n                        // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                        Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n                        CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                        CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n\n                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n\n                        Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                        for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                            int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                            if (value !\u003d -1) {\n                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n                            }\n                        }\n                        int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                        // Elements to be added at the end\n                        List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                        List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n\n                        Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                        for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                            // If it has a mapping, then it is kept\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                // element that has a mapping\n                                int originalCsmIndex \u003d -1;\n                                for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                        originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                        }\n                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                    }\n                                }\n                                // it does not preceed anything, so it goes at the end\n                                if (originalCsmIndex \u003d\u003d -1) {\n                                    elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                }\n                            }\n                        }\n\n                        // We go over the original node text elements, in the order they appear in the NodeText.\n                        // Considering an original node text element (ONE)\n                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                        //   we find the correspond OCE (Original CSM Element)\n                        // * we first add new elements that are marked to be added before OCE\n                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                        //   otherwise we add a removed element\n\n                        diffElements.remove(diffIndex);\n\n                        int diffElIterator \u003d diffIndex;\n                        if (lastNodeTextIndex !\u003d -1) {\n                            for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                    int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                        }\n                                    }\n\n                                    CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                    boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                    if (toBeKept) {\n                                        diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                    } else {\n                                        diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                    }\n                                }\n                                // else we have a simple node text element, without associated csm element, just keep ignore it\n                            }\n                        }\n\n                        // Finally we look for the remaining new elements that were not yet added and\n                        // add all of them\n                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 570,
      "functionName": "apply",
      "diff": "@@ -1,313 +1,305 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n \n         List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n         int originalIndex \u003d 0;\n \n-        List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n+        List\u003cDifferenceElement\u003e diffElements \u003d getElements();\n         int diffIndex \u003d 0;\n         do {\n             if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept \u003d (Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n                     Added addedElement \u003d (Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n+\n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n                     Added addedElement \u003d (Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n-                    TextElement textElement \u003d addedElement.toTextElement();\n+\n+                    TextElement addedTextElement \u003d addedElement.toTextElement();\n                     boolean used \u003d false;\n                     if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n-                        if (textElement.isNewline()) {\n+                        if (addedTextElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n+\n                     if (!used) {\n-                        nodeText.addElement(originalIndex, textElement);\n+                        nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n-                    if (textElement.isNewline()) {\n-                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size()\n-                                \u0026\u0026 diffElements.get(diffIndex + 1).isAdded()\n-                                \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n+\n+                    if (addedTextElement.isNewline()) {\n+                        boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n+\n                     diffIndex++;\n                 } else {\n                     TextElement originalElement \u003d originalElements.get(originalIndex);\n                     boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n                         Kept kept \u003d (Kept)diffElement;\n+\n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n-                            CsmToken csmToken \u003d (CsmToken) kept.element;\n-                            TokenTextElement nodeTextToken \u003d (TokenTextElement) originalElement;\n-                            if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n+                            TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n+\n+                            if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n-                            } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n+                            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n+                                throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                             }\n-                        } else if (kept.isToken() \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n+                        } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n-                            // Nothing to do\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof Removed) {\n                         Removed removed \u003d (Removed)diffElement;\n+\n                         if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n-                            ChildTextElement actualChild \u003d (ChildTextElement)originalElement;\n-                            if (actualChild.isComment()) {\n-                                CsmChild csmChild \u003d (CsmChild)removed.element;\n+                            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n+                            if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n-                                Comment comment \u003d (Comment)actualChild.getChild();\n-                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n+                                Comment comment \u003d (Comment)originalElementChild.getChild();\n+                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n                                     if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                         originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let\u0027s drop one space\n                                     if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n-                                \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind()) {\n+                                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof Reshuffled) {\n-\n                         // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n-                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n-\n-                        for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n-                            boolean found \u003d false;\n-                            CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n-                            for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n-                                CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n-                                if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n-                                        \u0026\u0026 matching(ne, pe)) {\n-                                    found \u003d true;\n-                                    correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n-                                }\n-                            }\n-                        }\n+                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                         for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                             int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                             if (value !\u003d -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n+                        List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n+\n                         Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n-                        for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n+                        for (int ni \u003d 0; ni\u003c nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex \u003d -1;\n-                                for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n+                                for (int nj \u003d ni + 1; nj\u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex\u003d\u003d-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                         }\n-                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n+                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex \u003d\u003d -1) {\n-                                    elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n+                                    elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n-                        this.getElements().remove(diffIndex);\n+                        diffElements.remove(diffIndex);\n+\n                         int diffElIterator \u003d diffIndex;\n                         if (lastNodeTextIndex !\u003d -1) {\n                             for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ae6f779cc175b3cd82d915419f378e53ff4b056": {
      "type": "Ybodychange",
      "commitMessage": "Renamed given to original\n",
      "commitDate": "2018-05-18, 4:05 p.m.",
      "commitName": "2ae6f779cc175b3cd82d915419f378e53ff4b056",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-05-17, 6:47 p.m.",
      "commitNameOld": "de5c17c37f15a1c134f518ed2754974cc4b9aa15",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.89,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n\n        List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n        int originalIndex \u003d 0;\n\n        List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n        int diffIndex \u003d 0;\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n\n                    if (kept.isWhiteSpaceOrComment()) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof Added) {\n                    Added addedElement \u003d (Added) diffElement;\n\n                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                if (originalElement.isWhiteSpaceOrComment()) {\n                    originalIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + originalElement);\n                }\n            } else {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof Added) {\n                    Added addedElement \u003d (Added) diffElement;\n\n                    if (addedElement.isIndent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement.isUnindent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d addedElement.toTextElement();\n                    boolean used \u003d false;\n                    if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                            originalElements.remove(originalIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(originalIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(originalIndex, textElement);\n                        originalIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size()\n                                \u0026\u0026 diffElements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else {\n                    TextElement originalElement \u003d originalElements.get(originalIndex);\n                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof Kept) {\n                        Kept kept \u003d (Kept)diffElement;\n                        if (originalElement.isComment()) {\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                            diffIndex++;\n                            originalIndex++;\n                        } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                            if (originalElement.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                if (kept.isPrimitiveType()) {\n                                    originalIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                }\n                            }\n                        } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                            CsmToken csmToken \u003d (CsmToken) kept.element;\n                            TokenTextElement nodeTextToken \u003d (TokenTextElement) originalElement;\n                            if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else if (kept.isWhiteSpaceOrComment()) {\n                                diffIndex++;\n                            } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                                originalIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                            }\n                        } else if (kept.isToken() \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (kept.isIndent()) {\n                            // Nothing to do\n                            diffIndex++;\n                        } else if (kept.isUnindent()) {\n                            // Nothing to do, beside considering indentation\n                            diffIndex++;\n                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                nodeText.removeElement(--originalIndex);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof Removed) {\n                        Removed removed \u003d (Removed)diffElement;\n                        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                            ChildTextElement actualChild \u003d (ChildTextElement)originalElement;\n                            if (actualChild.isComment()) {\n                                CsmChild csmChild \u003d (CsmChild)removed.element;\n                                // We expected to remove a proper node but we found a comment in between.\n                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                Comment comment \u003d (Comment)actualChild.getChild();\n                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                                    nodeText.removeElement(originalIndex);\n                                } else {\n                                    originalIndex++;\n                                }\n                            } else {\n                                nodeText.removeElement(originalIndex);\n                                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                } else {\n                                    if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                    }\n                                    // If in front we have one space and before also we had space let\u0027s drop one space\n                                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                        if (originalElements.get(originalIndex).isWhiteSpace()\n                                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                            // However we do not want to do that when we are about to adding or removing elements\n                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                                originalElements.remove(originalIndex--);\n                                            }\n                                        }\n                                    }\n                                }\n                                diffIndex++;\n                            }\n                        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                                \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind()) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else if (removed.isPrimitiveType()) {\n                            if (isPrimitiveType(originalElement)) {\n                                nodeText.removeElement(originalIndex);\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                            }\n                        } else if (removed.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (originalElement.isWhiteSpace()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (diffElement instanceof Reshuffled) {\n\n                        // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                        Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n                        CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                        CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n\n                        for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                            boolean found \u003d false;\n                            CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                            for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                                CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                                if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                        \u0026\u0026 matching(ne, pe)) {\n                                    found \u003d true;\n                                    correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                                }\n                            }\n                        }\n\n                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n\n                        Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                        for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                            int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                            if (value !\u003d -1) {\n                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n                            }\n                        }\n                        int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                        // Elements to be added at the end\n                        List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                        Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                        for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                            // If it has a mapping, then it is kept\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                // element that has a mapping\n                                int originalCsmIndex \u003d -1;\n                                for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                        originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                        }\n                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                    }\n                                }\n                                // it does not preceed anything, so it goes at the end\n                                if (originalCsmIndex \u003d\u003d -1) {\n                                    elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                        }\n\n                        // We go over the original node text elements, in the order they appear in the NodeText.\n                        // Considering an original node text element (ONE)\n                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                        //   we find the correspond OCE (Original CSM Element)\n                        // * we first add new elements that are marked to be added before OCE\n                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                        //   otherwise we add a removed element\n\n                        this.getElements().remove(diffIndex);\n                        int diffElIterator \u003d diffIndex;\n                        if (lastNodeTextIndex !\u003d -1) {\n                            for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                    int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                        }\n                                    }\n\n                                    CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                    boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                    if (toBeKept) {\n                                        diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                    } else {\n                                        diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                    }\n                                }\n                                // else we have a simple node text element, without associated csm element, just keep ignore it\n                            }\n                        }\n\n                        // Finally we look for the remaining new elements that were not yet added and\n                        // add all of them\n                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 534,
      "functionName": "apply",
      "diff": "@@ -1,313 +1,313 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n \n-        List\u003cTextElement\u003e givenElements \u003d nodeText.getElements();\n-        int givenIndex \u003d 0;\n+        List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n+        int originalIndex \u003d 0;\n \n         List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n         int diffIndex \u003d 0;\n         do {\n-            if (diffIndex \u003c diffElements.size() \u0026\u0026 givenIndex \u003e\u003d givenElements.size()) {\n+            if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept \u003d (Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n                     Added addedElement \u003d (Added) diffElement;\n \n-                    nodeText.addElement(givenIndex, addedElement.toTextElement());\n-                    givenIndex++;\n+                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n+                    originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n-            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 givenIndex \u003c givenElements.size()) {\n-                TextElement givenElement \u003d givenElements.get(givenIndex);\n-                if (givenElement.isWhiteSpaceOrComment()) {\n-                    givenIndex++;\n+            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n+                TextElement originalElement \u003d originalElements.get(originalIndex);\n+                if (originalElement.isWhiteSpaceOrComment()) {\n+                    originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n-                            + this + \" \" + givenElement);\n+                            + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n                     Added addedElement \u003d (Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d addedElement.toTextElement();\n                     boolean used \u003d false;\n-                    if (givenIndex \u003e 0 \u0026\u0026 givenElements.get(givenIndex - 1).isNewline()) {\n-                        for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n-                            nodeText.addElement(givenIndex++, e);\n+                    if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n+                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n+                            nodeText.addElement(originalIndex++, e);\n                         }\n-                    } else if (isAfterLBrace(nodeText, givenIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n+                    } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n-                        nodeText.addElement(givenIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n+                        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n-                        while (givenElements.get(givenIndex).isSpaceOrTab()) {\n-                            givenElements.remove(givenIndex);\n+                        while (originalElements.get(originalIndex).isSpaceOrTab()) {\n+                            originalElements.remove(originalIndex);\n                         }\n-                        for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n-                            nodeText.addElement(givenIndex++, e);\n+                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n+                            nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n-                                nodeText.addElement(givenIndex++, e);\n+                                nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n-                        nodeText.addElement(givenIndex, textElement);\n-                        givenIndex++;\n+                        nodeText.addElement(originalIndex, textElement);\n+                        originalIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size()\n                                 \u0026\u0026 diffElements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n-                        givenIndex \u003d adjustIndentation(indentation, nodeText, givenIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n+                        originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else {\n-                    TextElement givenElement \u003d givenElements.get(givenIndex);\n-                    boolean givenElementIsChild \u003d givenElement instanceof ChildTextElement;\n-                    boolean givenElementIsToken \u003d givenElement instanceof TokenTextElement;\n+                    TextElement originalElement \u003d originalElements.get(originalIndex);\n+                    boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n+                    boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n                         Kept kept \u003d (Kept)diffElement;\n-                        if (givenElement.isComment()) {\n-                            givenIndex++;\n-                        } else if (kept.isChild() \u0026\u0026 givenElementIsChild) {\n+                        if (originalElement.isComment()) {\n+                            originalIndex++;\n+                        } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                             diffIndex++;\n-                            givenIndex++;\n-                        } else if (kept.isChild() \u0026\u0026 givenElementIsToken) {\n-                            if (givenElement.isWhiteSpaceOrComment()) {\n-                                givenIndex++;\n+                            originalIndex++;\n+                        } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n+                            if (originalElement.isWhiteSpaceOrComment()) {\n+                                originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n-                                    givenIndex++;\n+                                    originalIndex++;\n                                     diffIndex++;\n                                 } else {\n-                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n+                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n-                        } else if (kept.isToken() \u0026\u0026 givenElementIsToken) {\n+                        } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                             CsmToken csmToken \u003d (CsmToken) kept.element;\n-                            TokenTextElement nodeTextToken \u003d (TokenTextElement) givenElement;\n+                            TokenTextElement nodeTextToken \u003d (TokenTextElement) originalElement;\n                             if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n-                                givenIndex++;\n+                                originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n-                                givenIndex++;\n+                                originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                             }\n                         } else if (kept.isToken() \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             // Nothing to do\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n-                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 givenIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n-                                nodeText.removeElement(--givenIndex);\n+                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n+                                nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n-                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n+                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof Removed) {\n                         Removed removed \u003d (Removed)diffElement;\n-                        if (removed.isChild() \u0026\u0026 givenElementIsChild) {\n-                            ChildTextElement actualChild \u003d (ChildTextElement)givenElement;\n+                        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n+                            ChildTextElement actualChild \u003d (ChildTextElement)originalElement;\n                             if (actualChild.isComment()) {\n                                 CsmChild csmChild \u003d (CsmChild)removed.element;\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment \u003d (Comment)actualChild.getChild();\n                                 if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n-                                    nodeText.removeElement(givenIndex);\n+                                    nodeText.removeElement(originalIndex);\n                                 } else {\n-                                    givenIndex++;\n+                                    originalIndex++;\n                                 }\n                             } else {\n-                                nodeText.removeElement(givenIndex);\n-                                if (givenIndex \u003c givenElements.size() \u0026\u0026 givenElements.get(givenIndex).isNewline()) {\n-                                    givenIndex \u003d considerCleaningTheLine(nodeText, givenIndex);\n+                                nodeText.removeElement(originalIndex);\n+                                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n+                                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n                                     if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n-                                        givenIndex \u003d considerEnforcingIndentation(nodeText, givenIndex);\n+                                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let\u0027s drop one space\n-                                    if (givenElements.size() \u003e givenIndex \u0026\u0026 givenIndex \u003e 0) {\n-                                        if (givenElements.get(givenIndex).isWhiteSpace()\n-                                                \u0026\u0026 givenElements.get(givenIndex - 1).isWhiteSpace()) {\n+                                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n+                                        if (originalElements.get(originalIndex).isWhiteSpace()\n+                                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n-                                                givenElements.remove(givenIndex--);\n+                                                originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n-                        } else if (removed.isToken() \u0026\u0026 givenElementIsToken\n-                                \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)givenElement).getTokenKind()) {\n-                            nodeText.removeElement(givenIndex);\n+                        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n+                                \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind()) {\n+                            nodeText.removeElement(originalIndex);\n                             diffIndex++;\n-                        } else if (givenElementIsToken \u0026\u0026 givenElement.isWhiteSpaceOrComment()) {\n-                            givenIndex++;\n+                        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n+                            originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n-                            if (isPrimitiveType(givenElement)) {\n-                                nodeText.removeElement(givenIndex);\n+                            if (isPrimitiveType(originalElement)) {\n+                                nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n+                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n-                        } else if (givenElement.isWhiteSpace()) {\n-                            givenIndex++;\n+                        } else if (originalElement.isWhiteSpace()) {\n+                            originalIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n+                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof Reshuffled) {\n \n                         // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n \n                         for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                             boolean found \u003d false;\n                             CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                             for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                                 CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                                 if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                         \u0026\u0026 matching(ne, pe)) {\n                                     found \u003d true;\n                                     correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                                 }\n                             }\n                         }\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n-                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, givenIndex, node);\n+                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                         for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                             int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                             if (value !\u003d -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                         Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                         for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex \u003d -1;\n                                 for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex \u003d\u003d -1) {\n                                     elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         this.getElements().remove(diffIndex);\n                         int diffElIterator \u003d diffIndex;\n                         if (lastNodeTextIndex !\u003d -1) {\n-                            for (int ntIndex \u003d givenIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n+                            for (int ntIndex \u003d originalIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new Added(elementToAdd));\n                         }\n                     } else {\n-                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n+                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n-        } while (diffIndex \u003c diffElements.size() || givenIndex \u003c givenElements.size());\n+        } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "de5c17c37f15a1c134f518ed2754974cc4b9aa15": {
      "type": "Ybodychange",
      "commitMessage": "Moved some logic to DifferenceElement objects and some renamings etc.\n",
      "commitDate": "2018-05-17, 6:47 p.m.",
      "commitName": "de5c17c37f15a1c134f518ed2754974cc4b9aa15",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-05-17, 5:24 p.m.",
      "commitNameOld": "fb8daf1673c35798aeb7cca8033dd9c9b2e5c4fc",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n\n        List\u003cTextElement\u003e givenElements \u003d nodeText.getElements();\n        int givenIndex \u003d 0;\n\n        List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n        int diffIndex \u003d 0;\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 givenIndex \u003e\u003d givenElements.size()) {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n\n                    if (kept.isWhiteSpaceOrComment()) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof Added) {\n                    Added addedElement \u003d (Added) diffElement;\n\n                    nodeText.addElement(givenIndex, addedElement.toTextElement());\n                    givenIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 givenIndex \u003c givenElements.size()) {\n                TextElement givenElement \u003d givenElements.get(givenIndex);\n                if (givenElement.isWhiteSpaceOrComment()) {\n                    givenIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + givenElement);\n                }\n            } else {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n\n                if (diffElement instanceof Added) {\n                    Added addedElement \u003d (Added) diffElement;\n\n                    if (addedElement.isIndent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement.isUnindent()) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d addedElement.toTextElement();\n                    boolean used \u003d false;\n                    if (givenIndex \u003e 0 \u0026\u0026 givenElements.get(givenIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                            nodeText.addElement(givenIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, givenIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(givenIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (givenElements.get(givenIndex).isSpaceOrTab()) {\n                            givenElements.remove(givenIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                            nodeText.addElement(givenIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(givenIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(givenIndex, textElement);\n                        givenIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size()\n                                \u0026\u0026 diffElements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        givenIndex \u003d adjustIndentation(indentation, nodeText, givenIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else {\n                    TextElement givenElement \u003d givenElements.get(givenIndex);\n                    boolean givenElementIsChild \u003d givenElement instanceof ChildTextElement;\n                    boolean givenElementIsToken \u003d givenElement instanceof TokenTextElement;\n\n                    if (diffElement instanceof Kept) {\n                        Kept kept \u003d (Kept)diffElement;\n                        if (givenElement.isComment()) {\n                            givenIndex++;\n                        } else if (kept.isChild() \u0026\u0026 givenElementIsChild) {\n                            diffIndex++;\n                            givenIndex++;\n                        } else if (kept.isChild() \u0026\u0026 givenElementIsToken) {\n                            if (givenElement.isWhiteSpaceOrComment()) {\n                                givenIndex++;\n                            } else {\n                                if (kept.isPrimitiveType()) {\n                                    givenIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                                }\n                            }\n                        } else if (kept.isToken() \u0026\u0026 givenElementIsToken) {\n                            CsmToken csmToken \u003d (CsmToken) kept.element;\n                            TokenTextElement nodeTextToken \u003d (TokenTextElement) givenElement;\n                            if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                                givenIndex++;\n                                diffIndex++;\n                            } else if (kept.isWhiteSpaceOrComment()) {\n                                diffIndex++;\n                            } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                                givenIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                            }\n                        } else if (kept.isToken() \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (kept.isIndent()) {\n                            // Nothing to do\n                            diffIndex++;\n                        } else if (kept.isUnindent()) {\n                            // Nothing to do, beside considering indentation\n                            diffIndex++;\n                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 givenIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n                                nodeText.removeElement(--givenIndex);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                        }\n                    } else if (diffElement instanceof Removed) {\n                        Removed removed \u003d (Removed)diffElement;\n                        if (removed.isChild() \u0026\u0026 givenElementIsChild) {\n                            ChildTextElement actualChild \u003d (ChildTextElement)givenElement;\n                            if (actualChild.isComment()) {\n                                CsmChild csmChild \u003d (CsmChild)removed.element;\n                                // We expected to remove a proper node but we found a comment in between.\n                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                Comment comment \u003d (Comment)actualChild.getChild();\n                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                                    nodeText.removeElement(givenIndex);\n                                } else {\n                                    givenIndex++;\n                                }\n                            } else {\n                                nodeText.removeElement(givenIndex);\n                                if (givenIndex \u003c givenElements.size() \u0026\u0026 givenElements.get(givenIndex).isNewline()) {\n                                    givenIndex \u003d considerCleaningTheLine(nodeText, givenIndex);\n                                } else {\n                                    if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                        givenIndex \u003d considerEnforcingIndentation(nodeText, givenIndex);\n                                    }\n                                    // If in front we have one space and before also we had space let\u0027s drop one space\n                                    if (givenElements.size() \u003e givenIndex \u0026\u0026 givenIndex \u003e 0) {\n                                        if (givenElements.get(givenIndex).isWhiteSpace()\n                                                \u0026\u0026 givenElements.get(givenIndex - 1).isWhiteSpace()) {\n                                            // However we do not want to do that when we are about to adding or removing elements\n                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                                givenElements.remove(givenIndex--);\n                                            }\n                                        }\n                                    }\n                                }\n                                diffIndex++;\n                            }\n                        } else if (removed.isToken() \u0026\u0026 givenElementIsToken\n                                \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)givenElement).getTokenKind()) {\n                            nodeText.removeElement(givenIndex);\n                            diffIndex++;\n                        } else if (givenElementIsToken \u0026\u0026 givenElement.isWhiteSpaceOrComment()) {\n                            givenIndex++;\n                        } else if (removed.isPrimitiveType()) {\n                            if (isPrimitiveType(givenElement)) {\n                                nodeText.removeElement(givenIndex);\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                            }\n                        } else if (removed.isWhiteSpace()) {\n                            diffIndex++;\n                        } else if (givenElement.isWhiteSpace()) {\n                            givenIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                        }\n                    } else if (diffElement instanceof Reshuffled) {\n\n                        // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                        Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n                        CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                        CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n\n                        for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                            boolean found \u003d false;\n                            CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                            for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                                CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                                if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                        \u0026\u0026 matching(ne, pe)) {\n                                    found \u003d true;\n                                    correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                                }\n                            }\n                        }\n\n                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, givenIndex, node);\n\n                        Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                        for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                            int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                            if (value !\u003d -1) {\n                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n                            }\n                        }\n                        int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                        // Elements to be added at the end\n                        List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                        Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                        for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                            // If it has a mapping, then it is kept\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                                // element that has a mapping\n                                int originalCsmIndex \u003d -1;\n                                for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                        originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                        }\n                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                    }\n                                }\n                                // it does not preceed anything, so it goes at the end\n                                if (originalCsmIndex \u003d\u003d -1) {\n                                    elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                        }\n\n                        // We go over the original node text elements, in the order they appear in the NodeText.\n                        // Considering an original node text element (ONE)\n                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                        //   we find the correspond OCE (Original CSM Element)\n                        // * we first add new elements that are marked to be added before OCE\n                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                        //   otherwise we add a removed element\n\n                        this.getElements().remove(diffIndex);\n                        int diffElIterator \u003d diffIndex;\n                        if (lastNodeTextIndex !\u003d -1) {\n                            for (int ntIndex \u003d givenIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                    int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                        }\n                                    }\n\n                                    CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                    boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                    if (toBeKept) {\n                                        diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                    } else {\n                                        diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                    }\n                                }\n                                // else we have a simple node text element, without associated csm element, just keep ignore it\n                            }\n                        }\n\n                        // Finally we look for the remaining new elements that were not yet added and\n                        // add all of them\n                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n                    }\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || givenIndex \u003c givenElements.size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 534,
      "functionName": "apply",
      "diff": "@@ -1,317 +1,313 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n \n         List\u003cTextElement\u003e givenElements \u003d nodeText.getElements();\n         int givenIndex \u003d 0;\n \n         List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n         int diffIndex \u003d 0;\n         do {\n             if (diffIndex \u003c diffElements.size() \u0026\u0026 givenIndex \u003e\u003d givenElements.size()) {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept \u003d (Kept) diffElement;\n-                    if (kept.element instanceof CsmToken) {\n-                        CsmToken csmToken \u003d (CsmToken) kept.element;\n-                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n-                            diffIndex++;\n-                        } else {\n-                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n-                                    + nodeText + \". Difference: \" + this);\n-                        }\n+\n+                    if (kept.isWhiteSpaceOrComment()) {\n+                        diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n-                    nodeText.addElement(givenIndex, toTextElement(((Added) diffElement).element));\n+                    Added addedElement \u003d (Added) diffElement;\n+\n+                    nodeText.addElement(givenIndex, addedElement.toTextElement());\n                     givenIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 givenIndex \u003c givenElements.size()) {\n                 TextElement givenElement \u003d givenElements.get(givenIndex);\n                 if (givenElement.isWhiteSpaceOrComment()) {\n                     givenIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + givenElement);\n                 }\n             } else {\n                 DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n-                TextElement givenElement \u003d givenElements.get(givenIndex);\n+\n                 if (diffElement instanceof Added) {\n-                    CsmElement addedElement \u003d ((Added) diffElement).element;\n-                    if (addedElement instanceof CsmIndent) {\n+                    Added addedElement \u003d (Added) diffElement;\n+\n+                    if (addedElement.isIndent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n-                    if (addedElement instanceof CsmUnindent) {\n+                    if (addedElement.isUnindent()) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n-                    TextElement textElement \u003d toTextElement(addedElement);\n+                    TextElement textElement \u003d addedElement.toTextElement();\n                     boolean used \u003d false;\n                     if (givenIndex \u003e 0 \u0026\u0026 givenElements.get(givenIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                             nodeText.addElement(givenIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, givenIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(givenIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (givenElements.get(givenIndex).isSpaceOrTab()) {\n                             givenElements.remove(givenIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                             nodeText.addElement(givenIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(givenIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(givenIndex, textElement);\n                         givenIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size()\n                                 \u0026\u0026 diffElements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         givenIndex \u003d adjustIndentation(indentation, nodeText, givenIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n-                } else if (diffElement instanceof Kept) {\n-                    Kept kept \u003d (Kept)diffElement;\n-                    if (givenElement.isComment()) {\n-                        givenIndex++;\n-                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 givenElement instanceof ChildTextElement) {\n-                        diffIndex++;\n-                        givenIndex++;\n-                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 givenElement instanceof TokenTextElement) {\n-                        if (givenElement.isWhiteSpaceOrComment()) {\n+                } else {\n+                    TextElement givenElement \u003d givenElements.get(givenIndex);\n+                    boolean givenElementIsChild \u003d givenElement instanceof ChildTextElement;\n+                    boolean givenElementIsToken \u003d givenElement instanceof TokenTextElement;\n+\n+                    if (diffElement instanceof Kept) {\n+                        Kept kept \u003d (Kept)diffElement;\n+                        if (givenElement.isComment()) {\n                             givenIndex++;\n-                        } else {\n-                            if (kept.element instanceof CsmChild) {\n-                                CsmChild keptChild \u003d (CsmChild)kept.element;\n-                                if (keptChild.getChild() instanceof PrimitiveType) {\n+                        } else if (kept.isChild() \u0026\u0026 givenElementIsChild) {\n+                            diffIndex++;\n+                            givenIndex++;\n+                        } else if (kept.isChild() \u0026\u0026 givenElementIsToken) {\n+                            if (givenElement.isWhiteSpaceOrComment()) {\n+                                givenIndex++;\n+                            } else {\n+                                if (kept.isPrimitiveType()) {\n                                     givenIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                                 }\n-                            } else {\n-                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                             }\n-                        }\n-                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 givenElement instanceof TokenTextElement) {\n-                        CsmToken csmToken \u003d (CsmToken) kept.element;\n-                        TokenTextElement nodeTextToken \u003d (TokenTextElement) givenElement;\n-                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n-                            givenIndex++;\n-                            diffIndex++;\n-                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n-                            diffIndex++;\n-                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n-                            givenIndex++;\n-                        } else {\n-                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n-                        }\n-                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n-                        diffIndex++;\n-                    } else if (kept.element instanceof CsmIndent) {\n-                        // Nothing to do\n-                        diffIndex++;\n-                    } else if (kept.element instanceof CsmUnindent) {\n-                        // Nothing to do, beside considering indentation\n-                        diffIndex++;\n-                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 givenIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n-                            nodeText.removeElement(--givenIndex);\n-                        }\n-                    } else {\n-                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n-                    }\n-                } else if (diffElement instanceof Removed) {\n-                    Removed removed \u003d (Removed)diffElement;\n-                    if ((removed.element instanceof CsmChild) \u0026\u0026 givenElement instanceof ChildTextElement) {\n-                        ChildTextElement actualChild \u003d (ChildTextElement)givenElement;\n-                        if (actualChild.isComment()) {\n-                            CsmChild csmChild \u003d (CsmChild)removed.element;\n-                            // We expected to remove a proper node but we found a comment in between.\n-                            // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n-                            Comment comment \u003d (Comment)actualChild.getChild();\n-                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n-                                nodeText.removeElement(givenIndex);\n-                            } else {\n+                        } else if (kept.isToken() \u0026\u0026 givenElementIsToken) {\n+                            CsmToken csmToken \u003d (CsmToken) kept.element;\n+                            TokenTextElement nodeTextToken \u003d (TokenTextElement) givenElement;\n+                            if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                                 givenIndex++;\n+                                diffIndex++;\n+                            } else if (kept.isWhiteSpaceOrComment()) {\n+                                diffIndex++;\n+                            } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n+                                givenIndex++;\n+                            } else {\n+                                throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n+                            }\n+                        } else if (kept.isToken() \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n+                            diffIndex++;\n+                        } else if (kept.isIndent()) {\n+                            // Nothing to do\n+                            diffIndex++;\n+                        } else if (kept.isUnindent()) {\n+                            // Nothing to do, beside considering indentation\n+                            diffIndex++;\n+                            for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 givenIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n+                                nodeText.removeElement(--givenIndex);\n                             }\n                         } else {\n-                            nodeText.removeElement(givenIndex);\n-                            if (givenIndex \u003c givenElements.size() \u0026\u0026 givenElements.get(givenIndex).isNewline()) {\n-                                givenIndex \u003d considerCleaningTheLine(nodeText, givenIndex);\n-                            } else {\n-                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n-                                    givenIndex \u003d considerEnforcingIndentation(nodeText, givenIndex);\n+                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n+                        }\n+                    } else if (diffElement instanceof Removed) {\n+                        Removed removed \u003d (Removed)diffElement;\n+                        if (removed.isChild() \u0026\u0026 givenElementIsChild) {\n+                            ChildTextElement actualChild \u003d (ChildTextElement)givenElement;\n+                            if (actualChild.isComment()) {\n+                                CsmChild csmChild \u003d (CsmChild)removed.element;\n+                                // We expected to remove a proper node but we found a comment in between.\n+                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n+                                Comment comment \u003d (Comment)actualChild.getChild();\n+                                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n+                                    nodeText.removeElement(givenIndex);\n+                                } else {\n+                                    givenIndex++;\n                                 }\n-                                // If in front we have one space and before also we had space let\u0027s drop one space\n-                                if (givenElements.size() \u003e givenIndex \u0026\u0026 givenIndex \u003e 0) {\n-                                    if (givenElements.get(givenIndex).isWhiteSpace()\n-                                            \u0026\u0026 givenElements.get(givenIndex - 1).isWhiteSpace()) {\n-                                        // However we do not want to do that when we are about to adding or removing elements\n-                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n-                                            givenElements.remove(givenIndex--);\n+                            } else {\n+                                nodeText.removeElement(givenIndex);\n+                                if (givenIndex \u003c givenElements.size() \u0026\u0026 givenElements.get(givenIndex).isNewline()) {\n+                                    givenIndex \u003d considerCleaningTheLine(nodeText, givenIndex);\n+                                } else {\n+                                    if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n+                                        givenIndex \u003d considerEnforcingIndentation(nodeText, givenIndex);\n+                                    }\n+                                    // If in front we have one space and before also we had space let\u0027s drop one space\n+                                    if (givenElements.size() \u003e givenIndex \u0026\u0026 givenIndex \u003e 0) {\n+                                        if (givenElements.get(givenIndex).isWhiteSpace()\n+                                                \u0026\u0026 givenElements.get(givenIndex - 1).isWhiteSpace()) {\n+                                            // However we do not want to do that when we are about to adding or removing elements\n+                                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n+                                                givenElements.remove(givenIndex--);\n+                                            }\n                                         }\n                                     }\n                                 }\n+                                diffIndex++;\n                             }\n-                            diffIndex++;\n-                        }\n-                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 givenElement instanceof TokenTextElement\n-                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)givenElement).getTokenKind()) {\n-                        nodeText.removeElement(givenIndex);\n-                        diffIndex++;\n-                    } else if (givenElement instanceof TokenTextElement\n-                            \u0026\u0026 givenElement.isWhiteSpaceOrComment()) {\n-                        givenIndex++;\n-                    } else if (removed.element instanceof CsmChild\n-                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n-                        if (isPrimitiveType(givenElement)) {\n+                        } else if (removed.isToken() \u0026\u0026 givenElementIsToken\n+                                \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)givenElement).getTokenKind()) {\n                             nodeText.removeElement(givenIndex);\n                             diffIndex++;\n+                        } else if (givenElementIsToken \u0026\u0026 givenElement.isWhiteSpaceOrComment()) {\n+                            givenIndex++;\n+                        } else if (removed.isPrimitiveType()) {\n+                            if (isPrimitiveType(givenElement)) {\n+                                nodeText.removeElement(givenIndex);\n+                                diffIndex++;\n+                            } else {\n+                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n+                            }\n+                        } else if (removed.isWhiteSpace()) {\n+                            diffIndex++;\n+                        } else if (givenElement.isWhiteSpace()) {\n+                            givenIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                         }\n-                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n-                        diffIndex++;\n-                    } else if (givenElement.isWhiteSpace()) {\n-                        givenIndex++;\n+                    } else if (diffElement instanceof Reshuffled) {\n+\n+                        // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n+                        Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n+                        CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n+                        CsmMix elementsFromNextOrder \u003d reshuffled.element;\n+\n+                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n+                        Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n+\n+                        for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n+                            boolean found \u003d false;\n+                            CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n+                            for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n+                                CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n+                                if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n+                                        \u0026\u0026 matching(ne, pe)) {\n+                                    found \u003d true;\n+                                    correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n+                                }\n+                            }\n+                        }\n+\n+                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n+                        List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, givenIndex, node);\n+\n+                        Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n+                        for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n+                            int value \u003d nodeTextIndexOfPreviousElements.get(i);\n+                            if (value !\u003d -1) {\n+                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n+                            }\n+                        }\n+                        int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n+\n+                        // Elements to be added at the end\n+                        List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n+                        Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n+                        for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n+                            // If it has a mapping, then it is kept\n+                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n+                                // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n+                                // element that has a mapping\n+                                int originalCsmIndex \u003d -1;\n+                                for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n+                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n+                                        originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n+                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n+                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n+                                        }\n+                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n+                                    }\n+                                }\n+                                // it does not preceed anything, so it goes at the end\n+                                if (originalCsmIndex \u003d\u003d -1) {\n+                                    elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n+                                }\n+                            }\n+                        }\n+\n+                        // We go over the original node text elements, in the order they appear in the NodeText.\n+                        // Considering an original node text element (ONE)\n+                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n+                        //   we find the correspond OCE (Original CSM Element)\n+                        // * we first add new elements that are marked to be added before OCE\n+                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n+                        //   otherwise we add a removed element\n+\n+                        this.getElements().remove(diffIndex);\n+                        int diffElIterator \u003d diffIndex;\n+                        if (lastNodeTextIndex !\u003d -1) {\n+                            for (int ntIndex \u003d givenIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n+\n+                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n+                                    int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n+                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n+                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n+                                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n+                                        }\n+                                    }\n+\n+                                    CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n+                                    boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n+                                    if (toBeKept) {\n+                                        diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n+                                    } else {\n+                                        diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n+                                    }\n+                                }\n+                                // else we have a simple node text element, without associated csm element, just keep ignore it\n+                            }\n+                        }\n+\n+                        // Finally we look for the remaining new elements that were not yet added and\n+                        // add all of them\n+                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n+                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n+                        }\n                     } else {\n-                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n+                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n                     }\n-                } else if (diffElement instanceof Reshuffled) {\n-\n-                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n-                    Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n-                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n-                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n-\n-                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n-                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n-\n-                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n-                        boolean found \u003d false;\n-                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n-                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n-                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n-                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n-                                    \u0026\u0026 matching(ne, pe)) {\n-                                found \u003d true;\n-                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n-                            }\n-                        }\n-                    }\n-\n-                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n-                    final int startNodeTextIndex \u003d givenIndex;\n-                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, startNodeTextIndex, node);\n-\n-                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n-                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n-                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n-                        if (value !\u003d -1) {\n-                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n-                        }\n-                    }\n-                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n-\n-                    // Elements to be added at the end\n-                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n-                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n-                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n-                        // If it has a mapping, then it is kept\n-                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n-                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n-                            // element that has a mapping\n-                            int originalCsmIndex \u003d -1;\n-                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n-                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n-                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n-                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n-                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n-                                    }\n-                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n-                                }\n-                            }\n-                            // it does not preceed anything, so it goes at the end\n-                            if (originalCsmIndex \u003d\u003d -1) {\n-                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n-                            }\n-                        }\n-                    }\n-\n-                    // We go over the original node text elements, in the order they appear in the NodeText.\n-                    // Considering an original node text element (ONE)\n-                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n-                    //   we find the correspond OCE (Original CSM Element)\n-                    // * we first add new elements that are marked to be added before OCE\n-                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n-                    //   otherwise we add a removed element\n-\n-                    this.getElements().remove(diffIndex);\n-                    int diffElIterator \u003d diffIndex;\n-                    if (lastNodeTextIndex !\u003d -1) {\n-                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n-\n-                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n-                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n-                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n-                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n-                                    }\n-                                }\n-\n-                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n-                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n-                                if (toBeKept) {\n-                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n-                                } else {\n-                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n-                                }\n-                            }\n-                            // else we have a simple node text element, without associated csm element, just keep ignore it\n-                        }\n-                    }\n-\n-                    // Finally we look for the remaining new elements that were not yet added and\n-                    // add all of them\n-                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n-                    }\n-                } else {\n-                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n                 }\n             }\n         } while (diffIndex \u003c diffElements.size() || givenIndex \u003c givenElements.size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb8daf1673c35798aeb7cca8033dd9c9b2e5c4fc": {
      "type": "Ybodychange",
      "commitMessage": "Renamings\n",
      "commitDate": "2018-05-17, 5:24 p.m.",
      "commitName": "fb8daf1673c35798aeb7cca8033dd9c9b2e5c4fc",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-05-11, 12:03 p.m.",
      "commitNameOld": "ae539a6fa91b4a3695df754a8f9e33180f9c466e",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 6.22,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n\n        List\u003cTextElement\u003e givenElements \u003d nodeText.getElements();\n        int givenIndex \u003d 0;\n\n        List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n        int diffIndex \u003d 0;\n        do {\n            if (diffIndex \u003c diffElements.size() \u0026\u0026 givenIndex \u003e\u003d givenElements.size()) {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffElement instanceof Added) {\n                    nodeText.addElement(givenIndex, toTextElement(((Added) diffElement).element));\n                    givenIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 givenIndex \u003c givenElements.size()) {\n                TextElement givenElement \u003d givenElements.get(givenIndex);\n                if (givenElement.isWhiteSpaceOrComment()) {\n                    givenIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + givenElement);\n                }\n            } else {\n                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n                TextElement givenElement \u003d givenElements.get(givenIndex);\n                if (diffElement instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffElement).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(addedElement);\n                    boolean used \u003d false;\n                    if (givenIndex \u003e 0 \u0026\u0026 givenElements.get(givenIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                            nodeText.addElement(givenIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, givenIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(givenIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (givenElements.get(givenIndex).isSpaceOrTab()) {\n                            givenElements.remove(givenIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                            nodeText.addElement(givenIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(givenIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(givenIndex, textElement);\n                        givenIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size()\n                                \u0026\u0026 diffElements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        givenIndex \u003d adjustIndentation(indentation, nodeText, givenIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept)diffElement;\n                    if (givenElement.isComment()) {\n                        givenIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 givenElement instanceof ChildTextElement) {\n                        diffIndex++;\n                        givenIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 givenElement instanceof TokenTextElement) {\n                        if (givenElement.isWhiteSpaceOrComment()) {\n                            givenIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    givenIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 givenElement instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) givenElement;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            givenIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            givenIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do, beside considering indentation\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 givenIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--givenIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                    }\n                } else if (diffElement instanceof Removed) {\n                    Removed removed \u003d (Removed)diffElement;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 givenElement instanceof ChildTextElement) {\n                        ChildTextElement actualChild \u003d (ChildTextElement)givenElement;\n                        if (actualChild.isComment()) {\n                            CsmChild csmChild \u003d (CsmChild)removed.element;\n                            // We expected to remove a proper node but we found a comment in between.\n                            // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                            Comment comment \u003d (Comment)actualChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                                nodeText.removeElement(givenIndex);\n                            } else {\n                                givenIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(givenIndex);\n                            if (givenIndex \u003c givenElements.size() \u0026\u0026 givenElements.get(givenIndex).isNewline()) {\n                                givenIndex \u003d considerCleaningTheLine(nodeText, givenIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                    givenIndex \u003d considerEnforcingIndentation(nodeText, givenIndex);\n                                }\n                                // If in front we have one space and before also we had space let\u0027s drop one space\n                                if (givenElements.size() \u003e givenIndex \u0026\u0026 givenIndex \u003e 0) {\n                                    if (givenElements.get(givenIndex).isWhiteSpace()\n                                            \u0026\u0026 givenElements.get(givenIndex - 1).isWhiteSpace()) {\n                                        // However we do not want to do that when we are about to adding or removing elements\n                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                            givenElements.remove(givenIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 givenElement instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)givenElement).getTokenKind()) {\n                        nodeText.removeElement(givenIndex);\n                        diffIndex++;\n                    } else if (givenElement instanceof TokenTextElement\n                            \u0026\u0026 givenElement.isWhiteSpaceOrComment()) {\n                        givenIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(givenElement)) {\n                            nodeText.removeElement(givenIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (givenElement.isWhiteSpace()) {\n                        givenIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                    }\n                } else if (diffElement instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d givenIndex;\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, startNodeTextIndex, node);\n\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            }\n                            // else we have a simple node text element, without associated csm element, just keep ignore it\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n                }\n            }\n        } while (diffIndex \u003c diffElements.size() || givenIndex \u003c givenElements.size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 482,
      "functionName": "apply",
      "diff": "@@ -1,313 +1,317 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n+\n+        List\u003cTextElement\u003e givenElements \u003d nodeText.getElements();\n+        int givenIndex \u003d 0;\n+\n+        List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n         int diffIndex \u003d 0;\n-        int nodeTextIndex \u003d 0;\n         do {\n-            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n-                DifferenceElement diffEl \u003d elements.get(diffIndex);\n-                if (diffEl instanceof Kept) {\n-                    Kept kept \u003d (Kept) diffEl;\n+            if (diffIndex \u003c diffElements.size() \u0026\u0026 givenIndex \u003e\u003d givenElements.size()) {\n+                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n+                if (diffElement instanceof Kept) {\n+                    Kept kept \u003d (Kept) diffElement;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n-                } else if (diffEl instanceof Added) {\n-                    nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n-                    nodeTextIndex++;\n+                } else if (diffElement instanceof Added) {\n+                    nodeText.addElement(givenIndex, toTextElement(((Added) diffElement).element));\n+                    givenIndex++;\n                     diffIndex++;\n                 } else {\n-                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n-            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n-                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n-                if (nodeTextEl.isWhiteSpaceOrComment()) {\n-                    nodeTextIndex++;\n+            } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 givenIndex \u003c givenElements.size()) {\n+                TextElement givenElement \u003d givenElements.get(givenIndex);\n+                if (givenElement.isWhiteSpaceOrComment()) {\n+                    givenIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n-                            + this + \" \" + nodeTextEl);\n+                            + this + \" \" + givenElement);\n                 }\n             } else {\n-                DifferenceElement diffEl \u003d elements.get(diffIndex);\n-                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n-                if (diffEl instanceof Added) {\n-                    CsmElement addedElement \u003d ((Added) diffEl).element;\n+                DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n+                TextElement givenElement \u003d givenElements.get(givenIndex);\n+                if (diffElement instanceof Added) {\n+                    CsmElement addedElement \u003d ((Added) diffElement).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(addedElement);\n                     boolean used \u003d false;\n-                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n-                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n-                            nodeText.addElement(nodeTextIndex++, e);\n+                    if (givenIndex \u003e 0 \u0026\u0026 givenElements.get(givenIndex - 1).isNewline()) {\n+                        for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n+                            nodeText.addElement(givenIndex++, e);\n                         }\n-                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n+                    } else if (isAfterLBrace(nodeText, givenIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n-                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n+                        nodeText.addElement(givenIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n-                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n-                            nodeText.getElements().remove(nodeTextIndex);\n+                        while (givenElements.get(givenIndex).isSpaceOrTab()) {\n+                            givenElements.remove(givenIndex);\n                         }\n-                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n-                            nodeText.addElement(nodeTextIndex++, e);\n+                        for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n+                            nodeText.addElement(givenIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n-                                nodeText.addElement(nodeTextIndex++, e);\n+                                nodeText.addElement(givenIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n-                        nodeText.addElement(nodeTextIndex, textElement);\n-                        nodeTextIndex++;\n+                        nodeText.addElement(givenIndex, textElement);\n+                        givenIndex++;\n                     }\n                     if (textElement.isNewline()) {\n-                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n-                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n-                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n-                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n+                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size()\n+                                \u0026\u0026 diffElements.get(diffIndex + 1).isAdded()\n+                                \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n+                        givenIndex \u003d adjustIndentation(indentation, nodeText, givenIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n-                } else if (diffEl instanceof Kept) {\n-                    Kept kept \u003d (Kept)diffEl;\n-                    if (nodeTextEl.isComment()) {\n-                        nodeTextIndex++;\n-                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                } else if (diffElement instanceof Kept) {\n+                    Kept kept \u003d (Kept)diffElement;\n+                    if (givenElement.isComment()) {\n+                        givenIndex++;\n+                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 givenElement instanceof ChildTextElement) {\n                         diffIndex++;\n-                        nodeTextIndex++;\n-                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n-                        if (nodeTextEl.isWhiteSpaceOrComment()) {\n-                            nodeTextIndex++;\n+                        givenIndex++;\n+                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 givenElement instanceof TokenTextElement) {\n+                        if (givenElement.isWhiteSpaceOrComment()) {\n+                            givenIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n-                                    nodeTextIndex++;\n+                                    givenIndex++;\n                                     diffIndex++;\n                                 } else {\n-                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                                 }\n                             } else {\n-                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                             }\n                         }\n-                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 givenElement instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n-                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n+                        TokenTextElement nodeTextToken \u003d (TokenTextElement) givenElement;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n-                            nodeTextIndex++;\n+                            givenIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n-                            nodeTextIndex++;\n+                            givenIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n-                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n-                            nodeText.removeElement(--nodeTextIndex);\n+                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 givenIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n+                            nodeText.removeElement(--givenIndex);\n                         }\n                     } else {\n-                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                     }\n-                } else if (diffEl instanceof Removed) {\n-                    Removed removed \u003d (Removed)diffEl;\n-                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n-                        ChildTextElement actualChild \u003d (ChildTextElement)nodeTextEl;\n+                } else if (diffElement instanceof Removed) {\n+                    Removed removed \u003d (Removed)diffElement;\n+                    if ((removed.element instanceof CsmChild) \u0026\u0026 givenElement instanceof ChildTextElement) {\n+                        ChildTextElement actualChild \u003d (ChildTextElement)givenElement;\n                         if (actualChild.isComment()) {\n                             CsmChild csmChild \u003d (CsmChild)removed.element;\n                             // We expected to remove a proper node but we found a comment in between.\n                             // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                             Comment comment \u003d (Comment)actualChild.getChild();\n                             if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n-                                nodeText.removeElement(nodeTextIndex);\n+                                nodeText.removeElement(givenIndex);\n                             } else {\n-                                nodeTextIndex++;\n+                                givenIndex++;\n                             }\n                         } else {\n-                            nodeText.removeElement(nodeTextIndex);\n-                            if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n-                                nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n+                            nodeText.removeElement(givenIndex);\n+                            if (givenIndex \u003c givenElements.size() \u0026\u0026 givenElements.get(givenIndex).isNewline()) {\n+                                givenIndex \u003d considerCleaningTheLine(nodeText, givenIndex);\n                             } else {\n                                 if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n-                                    nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n+                                    givenIndex \u003d considerEnforcingIndentation(nodeText, givenIndex);\n                                 }\n                                 // If in front we have one space and before also we had space let\u0027s drop one space\n-                                if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n-                                    if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n-                                            \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n+                                if (givenElements.size() \u003e givenIndex \u0026\u0026 givenIndex \u003e 0) {\n+                                    if (givenElements.get(givenIndex).isWhiteSpace()\n+                                            \u0026\u0026 givenElements.get(givenIndex - 1).isWhiteSpace()) {\n                                         // However we do not want to do that when we are about to adding or removing elements\n-                                        if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n-                                            nodeText.getElements().remove(nodeTextIndex--);\n+                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n+                                            givenElements.remove(givenIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n-                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n-                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n-                        nodeText.removeElement(nodeTextIndex);\n+                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 givenElement instanceof TokenTextElement\n+                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)givenElement).getTokenKind()) {\n+                        nodeText.removeElement(givenIndex);\n                         diffIndex++;\n-                    } else if (nodeTextEl instanceof TokenTextElement\n-                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n-                        nodeTextIndex++;\n+                    } else if (givenElement instanceof TokenTextElement\n+                            \u0026\u0026 givenElement.isWhiteSpaceOrComment()) {\n+                        givenIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n-                        if (isPrimitiveType(nodeTextEl)) {\n-                            nodeText.removeElement(nodeTextIndex);\n+                        if (isPrimitiveType(givenElement)) {\n+                            nodeText.removeElement(givenIndex);\n                             diffIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n-                    } else if (nodeTextEl.isWhiteSpace()) {\n-                        nodeTextIndex++;\n+                    } else if (givenElement.isWhiteSpace()) {\n+                        givenIndex++;\n                     } else {\n-                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                     }\n-                } else if (diffEl instanceof Reshuffled) {\n+                } else if (diffElement instanceof Reshuffled) {\n \n                     // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n-                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n+                    Reshuffled reshuffled \u003d (Reshuffled)diffElement;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n \n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                     \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n-                    final int startNodeTextIndex \u003d nodeTextIndex;\n+                    final int startNodeTextIndex \u003d givenIndex;\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, startNodeTextIndex, node);\n \n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex \u003d -1;\n                             for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                        elements.add(diffElIterator++, new Added(elementToAdd));\n+                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n-                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n+                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n-                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n+                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                             // else we have a simple node text element, without associated csm element, just keep ignore it\n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                        elements.add(diffElIterator++, new Added(elementToAdd));\n+                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n-                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n+                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n                 }\n             }\n-        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n+        } while (diffIndex \u003c diffElements.size() || givenIndex \u003c givenElements.size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5123e075b8411953473b23c82e64d8d23edb9181": {
      "type": "Ybodychange",
      "commitMessage": "Fixed issue 1461 - wrong identation when adding new annotation\n",
      "commitDate": "2018-05-10, 9:47 p.m.",
      "commitName": "5123e075b8411953473b23c82e64d8d23edb9181",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-03-11, 1:38 p.m.",
      "commitNameOld": "98e6c2f915a109d3157bed8cc2b775b430894535",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 60.34,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if (nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (nodeTextEl.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do, beside considering indentation\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        ChildTextElement actualChild \u003d (ChildTextElement)nodeTextEl;\n                        if (actualChild.isComment()) {\n                            CsmChild csmChild \u003d (CsmChild)removed.element;\n                            // We expected to remove a proper node but we found a comment in between.\n                            // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                            Comment comment \u003d (Comment)actualChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(nodeTextIndex);\n                            if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                                nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                    nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                                }\n                                // If in front we have one space and before also we had space let\u0027s drop one space\n                                if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                    if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                            \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                        // However we do not want to do that when we are about to adding or removing elements\n                                        if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                            nodeText.getElements().remove(nodeTextIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d nodeTextIndex;\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, startNodeTextIndex, node);\n\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        elements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            }\n                            // else we have a simple node text element, without associated csm element, just keep ignore it\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        elements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 482,
      "functionName": "apply",
      "diff": "@@ -1,314 +1,313 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if (nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         ChildTextElement actualChild \u003d (ChildTextElement)nodeTextEl;\n                         if (actualChild.isComment()) {\n                             CsmChild csmChild \u003d (CsmChild)removed.element;\n                             // We expected to remove a proper node but we found a comment in between.\n                             // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                             Comment comment \u003d (Comment)actualChild.getChild();\n                             if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             nodeText.removeElement(nodeTextIndex);\n                             if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                                 nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                             } else {\n                                 if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                     nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                                 }\n                                 // If in front we have one space and before also we had space let\u0027s drop one space\n                                 if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                     if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                             \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                         // However we do not want to do that when we are about to adding or removing elements\n                                         if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                             nodeText.getElements().remove(nodeTextIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n+\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                     \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex \u003d nodeTextIndex;\n-                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n-                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n-                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n-                            .collect(Collectors.toList());\n+                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, startNodeTextIndex, node);\n+\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex \u003d -1;\n                             for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                             // else we have a simple node text element, without associated csm element, just keep ignore it\n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "478b82aa16242a7324a16ffc9df8811309228234": {
      "type": "Ybodychange",
      "commitMessage": "improve how comments are handled by LexicalPreservingPrinter #1297\n",
      "commitDate": "2018-01-13, 8:14 a.m.",
      "commitName": "478b82aa16242a7324a16ffc9df8811309228234",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-11-13, 2:21 p.m.",
      "commitNameOld": "3a31705ba43ab2968ab2f113272b2462c91027bb",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 60.75,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if (nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (nodeTextEl.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do, beside considering indentation\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        ChildTextElement actualChild \u003d (ChildTextElement)nodeTextEl;\n                        if (actualChild.isComment()) {\n                            CsmChild csmChild \u003d (CsmChild)removed.element;\n                            // We expected to remove a proper node but we found a comment in between.\n                            // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                            Comment comment \u003d (Comment)actualChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(nodeTextIndex);\n                            if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                                nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                    nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                                }\n                                // If in front we have one space and before also we had space let\u0027s drop one space\n                                if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                    if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                            \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                        // However we do not want to do that when we are about to adding or removing elements\n                                        if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                            nodeText.getElements().remove(nodeTextIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d nodeTextIndex;\n                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                            .collect(Collectors.toList());\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        elements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            }\n                            // else we have a simple node text element, without associated csm element, just keep ignore it\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        elements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 483,
      "functionName": "apply",
      "diff": "@@ -1,314 +1,314 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n-                    if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n+                    if (nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         ChildTextElement actualChild \u003d (ChildTextElement)nodeTextEl;\n                         if (actualChild.isComment()) {\n                             CsmChild csmChild \u003d (CsmChild)removed.element;\n                             // We expected to remove a proper node but we found a comment in between.\n                             // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                             Comment comment \u003d (Comment)actualChild.getChild();\n                             if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             nodeText.removeElement(nodeTextIndex);\n                             if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                                 nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                             } else {\n                                 if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                     nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                                 }\n                                 // If in front we have one space and before also we had space let\u0027s drop one space\n                                 if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                     if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                             \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                         // However we do not want to do that when we are about to adding or removing elements\n                                         if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                             nodeText.getElements().remove(nodeTextIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                     \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex \u003d nodeTextIndex;\n                     final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                             .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex \u003d -1;\n                             for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                             // else we have a simple node text element, without associated csm element, just keep ignore it\n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3a31705ba43ab2968ab2f113272b2462c91027bb": {
      "type": "Ybodychange",
      "commitMessage": "delete comments associated to nodes to be deleted #1244\n",
      "commitDate": "2017-11-13, 2:21 p.m.",
      "commitName": "3a31705ba43ab2968ab2f113272b2462c91027bb",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-09-20, 11:39 a.m.",
      "commitNameOld": "6149218487aac50fad2256c8723639671747d7bb",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 54.15,
      "commitsBetweenForRepo": 156,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (nodeTextEl.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do, beside considering indentation\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        ChildTextElement actualChild \u003d (ChildTextElement)nodeTextEl;\n                        if (actualChild.isComment()) {\n                            CsmChild csmChild \u003d (CsmChild)removed.element;\n                            // We expected to remove a proper node but we found a comment in between.\n                            // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                            Comment comment \u003d (Comment)actualChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(nodeTextIndex);\n                            if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                                nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                    nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                                }\n                                // If in front we have one space and before also we had space let\u0027s drop one space\n                                if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                    if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                            \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                        // However we do not want to do that when we are about to adding or removing elements\n                                        if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                            nodeText.getElements().remove(nodeTextIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d nodeTextIndex;\n                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                            .collect(Collectors.toList());\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        elements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            }\n                            // else we have a simple node text element, without associated csm element, just keep ignore it\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        elements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 483,
      "functionName": "apply",
      "diff": "@@ -1,301 +1,314 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n-                        nodeText.removeElement(nodeTextIndex);\n-                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n-                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n-                        } else {\n-                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n-                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n+                        ChildTextElement actualChild \u003d (ChildTextElement)nodeTextEl;\n+                        if (actualChild.isComment()) {\n+                            CsmChild csmChild \u003d (CsmChild)removed.element;\n+                            // We expected to remove a proper node but we found a comment in between.\n+                            // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n+                            Comment comment \u003d (Comment)actualChild.getChild();\n+                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n+                                nodeText.removeElement(nodeTextIndex);\n+                            } else {\n+                                nodeTextIndex++;\n                             }\n-                            // If in front we have one space and before also we had space let\u0027s drop one space\n-                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n-                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n-                                        \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n-                                    // However we do not want to do that when we are about to adding or removing elements\n-                                    if ((diffIndex + 1 )\u003d\u003d this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n-                                        nodeText.getElements().remove(nodeTextIndex--);\n+                        } else {\n+                            nodeText.removeElement(nodeTextIndex);\n+                            if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n+                                nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n+                            } else {\n+                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n+                                    nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n+                                }\n+                                // If in front we have one space and before also we had space let\u0027s drop one space\n+                                if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n+                                    if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n+                                            \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n+                                        // However we do not want to do that when we are about to adding or removing elements\n+                                        if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n+                                            nodeText.getElements().remove(nodeTextIndex--);\n+                                        }\n                                     }\n                                 }\n                             }\n+                            diffIndex++;\n                         }\n-                        diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                     \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex \u003d nodeTextIndex;\n                     final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                             .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex \u003d -1;\n                             for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                             // else we have a simple node text element, without associated csm element, just keep ignore it\n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6149218487aac50fad2256c8723639671747d7bb": {
      "type": "Ybodychange",
      "commitMessage": "Remove dependency on LPP for finding nodetext\n",
      "commitDate": "2017-09-20, 11:39 a.m.",
      "commitName": "6149218487aac50fad2256c8723639671747d7bb",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2017-08-12, 6:08 p.m.",
      "commitNameOld": "23226e3befe168df74edef0272ab2a562810074b",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 38.73,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (nodeTextEl.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do, beside considering indentation\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                            // If in front we have one space and before also we had space let\u0027s drop one space\n                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                        \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                    // However we do not want to do that when we are about to adding or removing elements\n                                    if ((diffIndex + 1 )\u003d\u003d this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                        nodeText.getElements().remove(nodeTextIndex--);\n                                    }\n                                }\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d nodeTextIndex;\n                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                            .collect(Collectors.toList());\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        elements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            }\n                            // else we have a simple node text element, without associated csm element, just keep ignore it\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        elements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 482,
      "functionName": "apply",
      "diff": "@@ -1,301 +1,301 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n-        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n+        List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n-                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n-                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n+                    TextElement textElement \u003d toTextElement(addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let\u0027s drop one space\n                             if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     // However we do not want to do that when we are about to adding or removing elements\n                                     if ((diffIndex + 1 )\u003d\u003d this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                     \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex \u003d nodeTextIndex;\n                     final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                             .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex \u003d -1;\n                             for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                             // else we have a simple node text element, without associated csm element, just keep ignore it\n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "516947a3d4eda478d20dcbb4216d6c52cf11d169": {
      "type": "Ybodychange",
      "commitMessage": "cleanup following IDEA suggestions #1001\n",
      "commitDate": "2017-07-19, 11:34 a.m.",
      "commitName": "516947a3d4eda478d20dcbb4216d6c52cf11d169",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-07-19, 11:19 a.m.",
      "commitNameOld": "b83b81211f26f9259b032b188bb2482aa390df0d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (nodeTextEl.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do, beside considering indentation\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                            // If in front we have one space and before also we had space let\u0027s drop one space\n                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                        \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                    // However we do not want to do that when we are about to adding or removing elements\n                                    if ((diffIndex + 1 )\u003d\u003d this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                        nodeText.getElements().remove(nodeTextIndex--);\n                                    }\n                                }\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d nodeTextIndex;\n                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                            .collect(Collectors.toList());\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        elements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            }\n                            // else we have a simple node text element, without associated csm element, just keep ignore it\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        elements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 485,
      "functionName": "apply",
      "diff": "@@ -1,303 +1,301 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let\u0027s drop one space\n                             if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     // However we do not want to do that when we are about to adding or removing elements\n                                     if ((diffIndex + 1 )\u003d\u003d this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n-                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n+                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                     \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex \u003d nodeTextIndex;\n                     final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                             .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex \u003d -1;\n                             for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n-                            } else {\n-                                // simple node text element, without associated csm element, just keep ignore it\n                             }\n-\n+                            // else we have a simple node text element, without associated csm element, just keep ignore it\n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a1ee724c337694ee28b2a09af41c236b880ba66": {
      "type": "Ybodychange",
      "commitMessage": "Take TokenType into consideration\n",
      "commitDate": "2017-07-18, 3:42 p.m.",
      "commitName": "6a1ee724c337694ee28b2a09af41c236b880ba66",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2017-07-12, 12:46 p.m.",
      "commitNameOld": "c3f372b0c7c8ca4bed1261e7f1d3f17ed01b4889",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 6.12,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (nodeTextEl.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do, beside considering indentation\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                            // If in front we have one space and before also we had space let\u0027s drop one space\n                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                        \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                    // However we do not want to do that when we are about to adding or removing elements\n                                    if ((diffIndex + 1 )\u003d\u003d this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                        nodeText.getElements().remove(nodeTextIndex--);\n                                    }\n                                }\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d nodeTextIndex;\n                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                            .collect(Collectors.toList());\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        elements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            } else {\n                                // simple node text element, without associated csm element, just keep ignore it\n                            }\n\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        elements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 485,
      "functionName": "apply",
      "diff": "@@ -1,303 +1,303 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n-                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n+                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let\u0027s drop one space\n                             if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     // However we do not want to do that when we are about to adding or removing elements\n                                     if ((diffIndex + 1 )\u003d\u003d this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex \u003d nodeTextIndex;\n                     final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                             .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex \u003d -1;\n                             for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c3f372b0c7c8ca4bed1261e7f1d3f17ed01b4889": {
      "type": "Ybodychange",
      "commitMessage": "A lot more intellij inspection results\n",
      "commitDate": "2017-07-12, 12:46 p.m.",
      "commitName": "c3f372b0c7c8ca4bed1261e7f1d3f17ed01b4889",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2017-05-21, 7:34 a.m.",
      "commitNameOld": "7d55cf4c1cac9c2f8a3a917cfadfaf921e11e2b2",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 52.22,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (nodeTextEl.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do, beside considering indentation\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                            // If in front we have one space and before also we had space let\u0027s drop one space\n                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                        \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                    // However we do not want to do that when we are about to adding or removing elements\n                                    if ((diffIndex + 1 )\u003d\u003d this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                        nodeText.getElements().remove(nodeTextIndex--);\n                                    }\n                                }\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d nodeTextIndex;\n                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                            .collect(Collectors.toList());\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        elements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            } else {\n                                // simple node text element, without associated csm element, just keep ignore it\n                            }\n\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        elements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 485,
      "functionName": "apply",
      "diff": "@@ -1,303 +1,303 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n-                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n+                        if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let\u0027s drop one space\n                             if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     // However we do not want to do that when we are about to adding or removing elements\n                                     if ((diffIndex + 1 )\u003d\u003d this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex \u003d nodeTextIndex;\n                     final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                             .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex \u003d -1;\n                             for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7d55cf4c1cac9c2f8a3a917cfadfaf921e11e2b2": {
      "type": "Ybodychange",
      "commitMessage": "cleaning up PR 932\n",
      "commitDate": "2017-05-21, 7:34 a.m.",
      "commitName": "7d55cf4c1cac9c2f8a3a917cfadfaf921e11e2b2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-05-21, 7:26 a.m.",
      "commitNameOld": "a3359354bf46a3459c2262ba520c95ba4bf02a58",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do, beside considering indentation\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                            // If in front we have one space and before also we had space let\u0027s drop one space\n                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                        \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                    // However we do not want to do that when we are about to adding or removing elements\n                                    if ((diffIndex + 1 )\u003d\u003d this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                        nodeText.getElements().remove(nodeTextIndex--);\n                                    }\n                                }\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d nodeTextIndex;\n                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                            .collect(Collectors.toList());\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        elements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            } else {\n                                // simple node text element, without associated csm element, just keep ignore it\n                            }\n\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        elements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 485,
      "functionName": "apply",
      "diff": "@@ -1,313 +1,303 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n-                        // Nothing to do\n+                        // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let\u0027s drop one space\n                             if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     // However we do not want to do that when we are about to adding or removing elements\n                                     if ((diffIndex + 1 )\u003d\u003d this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex \u003d nodeTextIndex;\n                     final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                             .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex \u003d -1;\n                             for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n-\n-                    // Check if the last thing we added is a space\n-                    //if (diffElIterator \u003e startIndex\n-                    //        \u0026\u0026 elements.get(diffElIterator - 1).isAdded()\n-                    //        \u0026\u0026 elements.get(diffElIterator - 1).getElement() instanceof TokenTextElement\n-                    //        \u0026\u0026 ((TokenTextElement)elements.get(diffElIterator - 1).getElement()).isWhiteSpace()) {\n-                    //\n-                    //}\n-                    int v\u003d 0;\n-\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a3359354bf46a3459c2262ba520c95ba4bf02a58": {
      "type": "Ybodychange",
      "commitMessage": "correct space merging to work only when there is a kept\n",
      "commitDate": "2017-05-21, 7:26 a.m.",
      "commitName": "a3359354bf46a3459c2262ba520c95ba4bf02a58",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-05-21, 7:26 a.m.",
      "commitNameOld": "1a0ffde702735e1e1deda6d092e92eee2305bd14",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                            // If in front we have one space and before also we had space let\u0027s drop one space\n                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                        \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                    // However we do not want to do that when we are about to adding or removing elements\n                                    if ((diffIndex + 1 )\u003d\u003d this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                        nodeText.getElements().remove(nodeTextIndex--);\n                                    }\n                                }\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d nodeTextIndex;\n                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                            .collect(Collectors.toList());\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        elements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            } else {\n                                // simple node text element, without associated csm element, just keep ignore it\n                            }\n\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        elements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n\n                    // Check if the last thing we added is a space\n                    //if (diffElIterator \u003e startIndex\n                    //        \u0026\u0026 elements.get(diffElIterator - 1).isAdded()\n                    //        \u0026\u0026 elements.get(diffElIterator - 1).getElement() instanceof TokenTextElement\n                    //        \u0026\u0026 ((TokenTextElement)elements.get(diffElIterator - 1).getElement()).isWhiteSpace()) {\n                    //\n                    //}\n                    int v\u003d 0;\n\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 481,
      "functionName": "apply",
      "diff": "@@ -1,313 +1,313 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let\u0027s drop one space\n                             if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n-                                    // However we do not want to do that when we are doing a replacement\n-                                    if ((diffIndex + 1 )\u003d\u003d this.elements.size() || !(elements.get(diffIndex +1 ) instanceof Added)) {\n+                                    // However we do not want to do that when we are about to adding or removing elements\n+                                    if ((diffIndex + 1 )\u003d\u003d this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex \u003d nodeTextIndex;\n                     final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                             .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex \u003d -1;\n                             for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n \n                     // Check if the last thing we added is a space\n                     //if (diffElIterator \u003e startIndex\n                     //        \u0026\u0026 elements.get(diffElIterator - 1).isAdded()\n                     //        \u0026\u0026 elements.get(diffElIterator - 1).getElement() instanceof TokenTextElement\n                     //        \u0026\u0026 ((TokenTextElement)elements.get(diffElIterator - 1).getElement()).isWhiteSpace()) {\n                     //\n                     //}\n                     int v\u003d 0;\n \n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cbf3d3d09837a5648602ac7ececc3322144e68f0": {
      "type": "Ybodychange",
      "commitMessage": "fix CsmMix.prettyPrint\n",
      "commitDate": "2017-05-21, 7:26 a.m.",
      "commitName": "cbf3d3d09837a5648602ac7ececc3322144e68f0",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-05-21, 7:26 a.m.",
      "commitNameOld": "74dc0e58a9a6aa10a2c41bf121af592df43c30fe",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                            // If in front we have one space and before also we had space let\u0027s drop one space\n                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                        \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                    // However we do not want to do that when we are doing a replacement\n                                    if ((diffIndex + 1 )\u003d\u003d this.elements.size() || !(elements.get(diffIndex +1 ) instanceof Added)) {\n                                        nodeText.getElements().remove(nodeTextIndex--);\n                                    }\n                                }\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d nodeTextIndex;\n                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                            .collect(Collectors.toList());\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        elements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            } else {\n                                // simple node text element, without associated csm element, just keep ignore it\n                            }\n\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        elements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n\n                    // Check if the last thing we added is a space\n                    //if (diffElIterator \u003e startIndex\n                    //        \u0026\u0026 elements.get(diffElIterator - 1).isAdded()\n                    //        \u0026\u0026 elements.get(diffElIterator - 1).getElement() instanceof TokenTextElement\n                    //        \u0026\u0026 ((TokenTextElement)elements.get(diffElIterator - 1).getElement()).isWhiteSpace()) {\n                    //\n                    //}\n                    int v\u003d 0;\n\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 535,
      "functionName": "apply",
      "diff": "@@ -1,304 +1,313 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let\u0027s drop one space\n                             if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     // However we do not want to do that when we are doing a replacement\n                                     if ((diffIndex + 1 )\u003d\u003d this.elements.size() || !(elements.get(diffIndex +1 ) instanceof Added)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex \u003d nodeTextIndex;\n                     final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                             .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex \u003d -1;\n                             for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n \n+                    // Check if the last thing we added is a space\n+                    //if (diffElIterator \u003e startIndex\n+                    //        \u0026\u0026 elements.get(diffElIterator - 1).isAdded()\n+                    //        \u0026\u0026 elements.get(diffElIterator - 1).getElement() instanceof TokenTextElement\n+                    //        \u0026\u0026 ((TokenTextElement)elements.get(diffElIterator - 1).getElement()).isWhiteSpace()) {\n+                    //\n+                    //}\n+                    int v\u003d 0;\n+\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "74dc0e58a9a6aa10a2c41bf121af592df43c30fe": {
      "type": "Ybodychange",
      "commitMessage": "working on whitespace reconciliation\n",
      "commitDate": "2017-05-21, 7:26 a.m.",
      "commitName": "74dc0e58a9a6aa10a2c41bf121af592df43c30fe",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-05-21, 7:26 a.m.",
      "commitNameOld": "e9796ac7c5a26db2e4a8b37b781b1c5933b8c1fd",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                            // If in front we have one space and before also we had space let\u0027s drop one space\n                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                        \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                    // However we do not want to do that when we are doing a replacement\n                                    if ((diffIndex + 1 )\u003d\u003d this.elements.size() || !(elements.get(diffIndex +1 ) instanceof Added)) {\n                                        nodeText.getElements().remove(nodeTextIndex--);\n                                    }\n                                }\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d nodeTextIndex;\n                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                            .collect(Collectors.toList());\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        elements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            } else {\n                                // simple node text element, without associated csm element, just keep ignore it\n                            }\n\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        elements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 535,
      "functionName": "apply",
      "diff": "@@ -1,294 +1,304 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n+                            // If in front we have one space and before also we had space let\u0027s drop one space\n+                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n+                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n+                                        \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n+                                    // However we do not want to do that when we are doing a replacement\n+                                    if ((diffIndex + 1 )\u003d\u003d this.elements.size() || !(elements.get(diffIndex +1 ) instanceof Added)) {\n+                                        nodeText.getElements().remove(nodeTextIndex--);\n+                                    }\n+                                }\n+                            }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex \u003d nodeTextIndex;\n                     final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                             .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex \u003d -1;\n                             for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n \n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c051d8316c3c9270f191bae4a5323b92f283420": {
      "type": "Ybodychange",
      "commitMessage": "removing dead code #866\n",
      "commitDate": "2017-05-21, 7:26 a.m.",
      "commitName": "7c051d8316c3c9270f191bae4a5323b92f283420",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-05-21, 7:26 a.m.",
      "commitNameOld": "f8d5e2fda0aedca5f9a9cb726f7787286bbfd05e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d nodeTextIndex;\n                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                            .collect(Collectors.toList());\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        elements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            } else {\n                                // simple node text element, without associated csm element, just keep ignore it\n                            }\n\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        elements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 535,
      "functionName": "apply",
      "diff": "@@ -1,314 +1,293 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex \u003d nodeTextIndex;\n                     final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                             .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex \u003d -1;\n                             for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n-\n-\n-                    //Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenNodeTextIndex \u003d new HashMap\u003c\u003e();\n-                    //List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n-                    //Set\u003cInteger\u003e nodeTextElementsToKeep \u003d new HashSet\u003c\u003e();\n-\n-                    // Let\u0027s figure out which ones of the existing tokens are going to be removed\n-\n-                    // Now I should translate all of this to a sequence of additions and deletions\n-                    // and then just add these differences to the diff to be treated normally\n-\n-//                    // Now let\u0027s understand how the new elements are positioned w.r.t. to the kept elements\n-//                    if (nodeTextIndexOfPreviousElements.isEmpty()) {\n-//                        // They are all just following the sequence in the new mix\n-//                        for (CsmElement csmElement : reshuffled.getElement().getElements()) {\n-//                            nodeText.addElement(nodeTextIndex++, toTextElement());\n-//                        }\n-//                    } else {\n-//                        throw new UnsupportedOperationException();\n-//                    }\n-\n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f8d5e2fda0aedca5f9a9cb726f7787286bbfd05e": {
      "type": "Ybodychange",
      "commitMessage": "new approach based on rewriting Difference based on NodeText on encountering a CsmMix #866\n",
      "commitDate": "2017-05-21, 7:26 a.m.",
      "commitName": "f8d5e2fda0aedca5f9a9cb726f7787286bbfd05e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-05-21, 7:26 a.m.",
      "commitNameOld": "9e91a1d76dbfb28f2bc7c32028fe459b073ee861",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof CsmChild) {\n                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmChild\n                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Reshuffled) {\n\n                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n\n                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                    \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n\n                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n                    final int startNodeTextIndex \u003d nodeTextIndex;\n                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                            .collect(Collectors.toList());\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n\n                    // Elements to be added at the end\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n                        // If it has a mapping, then it is kept\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n                            // element that has a mapping\n                            int originalCsmIndex \u003d -1;\n                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            // it does not preceed anything, so it goes at the end\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n\n\n\n                    //Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenNodeTextIndex \u003d new HashMap\u003c\u003e();\n                    //List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    //Set\u003cInteger\u003e nodeTextElementsToKeep \u003d new HashSet\u003c\u003e();\n\n                    // Let\u0027s figure out which ones of the existing tokens are going to be removed\n\n                    // Now I should translate all of this to a sequence of additions and deletions\n                    // and then just add these differences to the diff to be treated normally\n\n//                    // Now let\u0027s understand how the new elements are positioned w.r.t. to the kept elements\n//                    if (nodeTextIndexOfPreviousElements.isEmpty()) {\n//                        // They are all just following the sequence in the new mix\n//                        for (CsmElement csmElement : reshuffled.getElement().getElements()) {\n//                            nodeText.addElement(nodeTextIndex++, toTextElement());\n//                        }\n//                    } else {\n//                        throw new UnsupportedOperationException();\n//                    }\n\n                    // We go over the original node text elements, in the order they appear in the NodeText.\n                    // Considering an original node text element (ONE)\n                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                    //   we find the correspond OCE (Original CSM Element)\n                    // * we first add new elements that are marked to be added before OCE\n                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                    //   otherwise we add a removed element\n\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        elements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            } else {\n                                // simple node text element, without associated csm element, just keep ignore it\n                            }\n\n                        }\n                    }\n\n                    // Finally we look for the remaining new elements that were not yet added and\n                    // add all of them\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        elements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 535,
      "functionName": "apply",
      "diff": "@@ -1,191 +1,314 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n-                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n+                    if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n-                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n-                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                    } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n-                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n-                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n+                            if (kept.element instanceof CsmChild) {\n+                                CsmChild keptChild \u003d (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n-                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                    if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n-                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n-                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n+                    } else if (removed.element instanceof CsmChild\n+                            \u0026\u0026 ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n+                } else if (diffEl instanceof Reshuffled) {\n+\n+                    // First, let\u0027s see how many tokens we need to attribute to the previous version of the of the CsmMix\n+                    Reshuffled reshuffled \u003d (Reshuffled)diffEl;\n+                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n+                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n+\n+                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n+                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n+                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n+                        boolean found \u003d false;\n+                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n+                        for (int pi\u003d0;pi\u003celementsFromPreviousOrder.getElements().size() \u0026\u0026 !found;pi++) {\n+                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n+                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n+                                    \u0026\u0026 matching(ne, pe)) {\n+                                found \u003d true;\n+                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n+                            }\n+                        }\n+                    }\n+\n+                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n+                    final int startNodeTextIndex \u003d nodeTextIndex;\n+                    final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n+                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream()\n+                            .map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n+                            .collect(Collectors.toList());\n+                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n+                    for (int i\u003d0;i\u003cnodeTextIndexOfPreviousElements.size();i++) {\n+                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n+                        if (value !\u003d -1) {\n+                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n+                        }\n+                    }\n+                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n+\n+                    // Elements to be added at the end\n+                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n+                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n+                    for (int ni\u003d0;ni\u003celementsFromNextOrder.getElements().size();ni++) {\n+                        // If it has a mapping, then it is kept\n+                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n+                            // Ok, it is something new. Where to put it? Let\u0027s see what is the first following\n+                            // element that has a mapping\n+                            int originalCsmIndex \u003d -1;\n+                            for (int nj\u003dni + 1;nj\u003celementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex\u003d\u003d-1;nj++) {\n+                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n+                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n+                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n+                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n+                                    }\n+                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n+                                }\n+                            }\n+                            // it does not preceed anything, so it goes at the end\n+                            if (originalCsmIndex \u003d\u003d -1) {\n+                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n+                            }\n+                        }\n+                    }\n+\n+\n+\n+                    //Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenNodeTextIndex \u003d new HashMap\u003c\u003e();\n+                    //List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n+                    //Set\u003cInteger\u003e nodeTextElementsToKeep \u003d new HashSet\u003c\u003e();\n+\n+                    // Let\u0027s figure out which ones of the existing tokens are going to be removed\n+\n+                    // Now I should translate all of this to a sequence of additions and deletions\n+                    // and then just add these differences to the diff to be treated normally\n+\n+//                    // Now let\u0027s understand how the new elements are positioned w.r.t. to the kept elements\n+//                    if (nodeTextIndexOfPreviousElements.isEmpty()) {\n+//                        // They are all just following the sequence in the new mix\n+//                        for (CsmElement csmElement : reshuffled.getElement().getElements()) {\n+//                            nodeText.addElement(nodeTextIndex++, toTextElement());\n+//                        }\n+//                    } else {\n+//                        throw new UnsupportedOperationException();\n+//                    }\n+\n+                    // We go over the original node text elements, in the order they appear in the NodeText.\n+                    // Considering an original node text element (ONE)\n+                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n+                    //   we find the correspond OCE (Original CSM Element)\n+                    // * we first add new elements that are marked to be added before OCE\n+                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n+                    //   otherwise we add a removed element\n+\n+                    this.getElements().remove(diffIndex);\n+                    int diffElIterator \u003d diffIndex;\n+                    if (lastNodeTextIndex !\u003d -1) {\n+                        for (int ntIndex \u003d startNodeTextIndex; ntIndex\u003c\u003dlastNodeTextIndex; ntIndex++) {\n+\n+                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n+                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n+                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n+                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n+                                        elements.add(diffElIterator++, new Added(elementToAdd));\n+                                    }\n+                                }\n+\n+                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n+                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n+                                if (toBeKept) {\n+                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n+                                } else {\n+                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n+                                }\n+                            } else {\n+                                // simple node text element, without associated csm element, just keep ignore it\n+                            }\n+\n+                        }\n+                    }\n+\n+                    // Finally we look for the remaining new elements that were not yet added and\n+                    // add all of them\n+                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n+                        elements.add(diffElIterator++, new Added(elementToAdd));\n+                    }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5689cad203e3ff4f51af7bc2b73f13ab03c91ca1": {
      "type": "Ybodychange",
      "commitMessage": "reconsider how CsmUnindent is handled in Difference.apply\n",
      "commitDate": "2017-05-21, 7:26 a.m.",
      "commitName": "5689cad203e3ff4f51af7bc2b73f13ab03c91ca1",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-05-21, 7:26 a.m.",
      "commitNameOld": "1a6665bb95b0e46cafdb19202274e6d6725ea464",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do\n                        diffIndex++;\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex\u003e\u003d1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex-1).isSpaceOrTab();i++) {\n                            nodeText.removeElement(--nodeTextIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 430,
      "functionName": "apply",
      "diff": "@@ -1,188 +1,191 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do\n                         diffIndex++;\n+                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex\u003e\u003d1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex-1).isSpaceOrTab();i++) {\n+                            nodeText.removeElement(--nodeTextIndex);\n+                        }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a6665bb95b0e46cafdb19202274e6d6725ea464": {
      "type": "Ybodychange",
      "commitMessage": "cleaning Difference\n",
      "commitDate": "2017-05-21, 7:26 a.m.",
      "commitName": "1a6665bb95b0e46cafdb19202274e6d6725ea464",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-05-21, 7:26 a.m.",
      "commitNameOld": "c624f15225df9442948dc1bb1c655e0114806ebb",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // Nothing to do\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 430,
      "functionName": "apply",
      "diff": "@@ -1,188 +1,188 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n-                        // FIXME\n+                        // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n-                        // FIXME\n+                        // Nothing to do\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1555adc99a08f09e7f7ec40db7bd2535062e55af": {
      "type": "Ybodychange",
      "commitMessage": "progressing on unindent reconciliation\n",
      "commitDate": "2017-05-21, 7:26 a.m.",
      "commitName": "1555adc99a08f09e7f7ec40db7bd2535062e55af",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-05-21, 7:26 a.m.",
      "commitNameOld": "10508ce2a362ca01c7f29c39c7f98469233fce04",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // FIXME\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // FIXME\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 447,
      "functionName": "apply",
      "diff": "@@ -1,188 +1,188 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                 \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                 \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n-                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent \u0026\u0026 !addedIndentation);\n+                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* \u0026\u0026 !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // FIXME\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // FIXME\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "10508ce2a362ca01c7f29c39c7f98469233fce04": {
      "type": "Ybodychange",
      "commitMessage": "reconciliating unindent with existing indentation\n",
      "commitDate": "2017-05-21, 7:26 a.m.",
      "commitName": "10508ce2a362ca01c7f29c39c7f98469233fce04",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-05-21, 7:26 a.m.",
      "commitNameOld": "ad402162f98243c84e4f7c9693012633347a4829",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent \u0026\u0026 !addedIndentation);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // FIXME\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // FIXME\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 447,
      "functionName": "apply",
      "diff": "@@ -1,185 +1,188 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation \u003d true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n-                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n+                        boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size()\n+                                \u0026\u0026 elements.get(diffIndex + 1).isAdded()\n+                                \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n+                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent \u0026\u0026 !addedIndentation);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // FIXME\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // FIXME\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n-                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n+                            \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad402162f98243c84e4f7c9693012633347a4829": {
      "type": "Ybodychange",
      "commitMessage": "explaining why sometimes we force indentation\n",
      "commitDate": "2017-05-21, 7:26 a.m.",
      "commitName": "ad402162f98243c84e4f7c9693012633347a4829",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-05-21, 7:26 a.m.",
      "commitNameOld": "a31908d22bc52d1bf24e00d3bc1bc709224156fd",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        boolean addedIndentation \u003d false;\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                        }\n                        addedIndentation \u003d true;\n                        diffIndex++;\n                        continue;\n                    }\n                    if (addedElement instanceof CsmUnindent) {\n                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n                            indentation.remove(indentation.size() - 1);\n                        }\n                        addedIndentation \u003d false;\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        // This remove the space in \"{ }\" when adding a new line\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        // Indentation is painful...\n                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                        // not there, so when adding new elements we force it. However if the indentation has been\n                        // inserted by us in this transformation we do not want to insert it again\n                        if (!addedIndentation) {\n                            for (TextElement e : indentationBlock()) {\n                                nodeText.addElement(nodeTextIndex++, e);\n                            }\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // FIXME\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // FIXME\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 447,
      "functionName": "apply",
      "diff": "@@ -1,164 +1,185 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n+        boolean addedIndentation \u003d false;\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n-                    if (addedElement instanceof CsmIndent || addedElement instanceof CsmUnindent) {\n+                    if (addedElement instanceof CsmIndent) {\n+                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE;i++){\n+                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n+                        }\n+                        addedIndentation \u003d true;\n+                        diffIndex++;\n+                        continue;\n+                    }\n+                    if (addedElement instanceof CsmUnindent) {\n+                        for (int i\u003d0;i\u003cSTANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty();i++){\n+                            indentation.remove(indentation.size() - 1);\n+                        }\n+                        addedIndentation \u003d false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n+                        // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n-                        for (TextElement e : indentationBlock()) {\n-                            nodeText.addElement(nodeTextIndex++, e);\n+                        // Indentation is painful...\n+                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n+                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n+                        // not there, so when adding new elements we force it. However if the indentation has been\n+                        // inserted by us in this transformation we do not want to insert it again\n+                        if (!addedIndentation) {\n+                            for (TextElement e : indentationBlock()) {\n+                                nodeText.addElement(nodeTextIndex++, e);\n+                            }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // FIXME\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // FIXME\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a31908d22bc52d1bf24e00d3bc1bc709224156fd": {
      "type": "Ybodychange",
      "commitMessage": "initial handling of indent/unindent in Difference\n",
      "commitDate": "2017-05-21, 7:26 a.m.",
      "commitName": "a31908d22bc52d1bf24e00d3bc1bc709224156fd",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-05-21, 7:26 a.m.",
      "commitNameOld": "488ccb1191c3b71644bdc9176712394220b9252b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent || addedElement instanceof CsmUnindent) {\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmIndent) {\n                        // FIXME\n                        diffIndex++;\n                    } else if (kept.element instanceof CsmUnindent) {\n                        // FIXME\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 446,
      "functionName": "apply",
      "diff": "@@ -1,158 +1,164 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement \u003d ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent || addedElement instanceof CsmUnindent) {\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n+                    } else if (kept.element instanceof CsmIndent) {\n+                        // FIXME\n+                        diffIndex++;\n+                    } else if (kept.element instanceof CsmUnindent) {\n+                        // FIXME\n+                        diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "488ccb1191c3b71644bdc9176712394220b9252b": {
      "type": "Ybodychange",
      "commitMessage": "propagating CsmIndent and CsmUnindent\n",
      "commitDate": "2017-05-21, 7:26 a.m.",
      "commitName": "488ccb1191c3b71644bdc9176712394220b9252b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-05-21, 7:26 a.m.",
      "commitNameOld": "87b56cb1f18252c95d88b979a449f06d55def290",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    CsmElement addedElement \u003d ((Added) diffEl).element;\n                    if (addedElement instanceof CsmIndent || addedElement instanceof CsmUnindent) {\n                        diffIndex++;\n                        continue;\n                    }\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 408,
      "functionName": "apply",
      "diff": "@@ -1,153 +1,158 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n-                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n+                    CsmElement addedElement \u003d ((Added) diffEl).element;\n+                    if (addedElement instanceof CsmIndent || addedElement instanceof CsmUnindent) {\n+                        diffIndex++;\n+                        continue;\n+                    }\n+                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "87b56cb1f18252c95d88b979a449f06d55def290": {
      "type": "Ybodychange",
      "commitMessage": "working on propagating the indentation to NodeText generated\n",
      "commitDate": "2017-05-21, 7:26 a.m.",
      "commitName": "87b56cb1f18252c95d88b979a449f06d55def290",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-03-06, 11:35 a.m.",
      "commitNameOld": "b29a465257afcf2cc720c9423c2ddedd1edd31a3",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 75.79,
      "commitsBetweenForRepo": 214,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 375,
      "functionName": "apply",
      "diff": "@@ -1,153 +1,153 @@\n     void apply(NodeText nodeText, Node node) {\n-        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n+        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b29a465257afcf2cc720c9423c2ddedd1edd31a3": {
      "type": "Ybodychange",
      "commitMessage": "Move TokenConstants around\n",
      "commitDate": "2017-03-06, 11:35 a.m.",
      "commitName": "b29a465257afcf2cc720c9423c2ddedd1edd31a3",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2017-03-06, 11:15 a.m.",
      "commitNameOld": "9192b9d17903947058b755b987d1c57a05821e58",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 375,
      "functionName": "apply",
      "diff": "@@ -1,153 +1,153 @@\n     void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n-                        if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n-                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenConstants.eolToken()));\n+                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n-                        } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9192b9d17903947058b755b987d1c57a05821e58": {
      "type": "Ybodychange",
      "commitMessage": "* explicitly match \\r\\n in the grammar\n* centralize token handling\n",
      "commitDate": "2017-03-06, 11:15 a.m.",
      "commitName": "9192b9d17903947058b755b987d1c57a05821e58",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2017-03-06, 10:40 a.m.",
      "commitNameOld": "b1cd1afb0aaa19f370a169350318496ca7e541bb",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isNewline()) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenConstants.eolToken()));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 375,
      "functionName": "apply",
      "diff": "@@ -1,153 +1,153 @@\n     void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n-                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(CARRIAGE_RETURN_TOKEN)) {\n+                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n-                        if (textElement.isToken(CARRIAGE_RETURN_TOKEN)) {\n+                        if (textElement.isNewline()) {\n                             used \u003d true;\n                         }\n-                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(CARRIAGE_RETURN_TOKEN));\n+                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenConstants.eolToken()));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n-                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.CARRIAGE_RETURN_TOKEN)) {\n+                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b1cd1afb0aaa19f370a169350318496ca7e541bb": {
      "type": "Ybodychange",
      "commitMessage": "Some attempts at getting \\r\\n recognized.\n",
      "commitDate": "2017-03-06, 10:40 a.m.",
      "commitName": "b1cd1afb0aaa19f370a169350318496ca7e541bb",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2017-03-05, 5:02 a.m.",
      "commitNameOld": "adb78b277512189cc5f8ecb076d9bf8106f9e1e0",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.23,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(CARRIAGE_RETURN_TOKEN)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isToken(CARRIAGE_RETURN_TOKEN)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(CARRIAGE_RETURN_TOKEN));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.CARRIAGE_RETURN_TOKEN)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 377,
      "functionName": "apply",
      "diff": "@@ -1,153 +1,153 @@\n     void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n-                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n+                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(CARRIAGE_RETURN_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n-                        if (textElement.isToken(NEWLINE_TOKEN)) {\n+                        if (textElement.isToken(CARRIAGE_RETURN_TOKEN)) {\n                             used \u003d true;\n                         }\n-                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n+                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(CARRIAGE_RETURN_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n-                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n+                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.CARRIAGE_RETURN_TOKEN)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "adb78b277512189cc5f8ecb076d9bf8106f9e1e0": {
      "type": "Ybodychange",
      "commitMessage": "issue823: distinguish between spaces and comments\n",
      "commitDate": "2017-03-05, 5:02 a.m.",
      "commitName": "adb78b277512189cc5f8ecb076d9bf8106f9e1e0",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-03-05, 4:50 a.m.",
      "commitNameOld": "0be8bb2b4275456c18bee064c5de2ccb12a33080",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isToken(NEWLINE_TOKEN)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 378,
      "functionName": "apply",
      "diff": "@@ -1,151 +1,153 @@\n     void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isToken(NEWLINE_TOKEN)) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n-                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n+                        nodeTextIndex++;\n+                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0be8bb2b4275456c18bee064c5de2ccb12a33080": {
      "type": "Ybodychange",
      "commitMessage": "issue823: add TextElement.isWhiteSpaceOrComment\n",
      "commitDate": "2017-03-05, 4:50 a.m.",
      "commitName": "0be8bb2b4275456c18bee064c5de2ccb12a33080",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-27, 2:50 p.m.",
      "commitNameOld": "de2adb51f6f0465024755f034fe27de56c651ffd",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 5.58,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isToken(NEWLINE_TOKEN)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 378,
      "functionName": "apply",
      "diff": "@@ -1,151 +1,151 @@\n     void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n-                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n+                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isToken(NEWLINE_TOKEN)) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bd0af28e7b81048d9bda153b908c727304ca8a04": {
      "type": "Ybodychange",
      "commitMessage": "issue124: remove Tokens\n",
      "commitDate": "2017-02-23, 12:57 p.m.",
      "commitName": "bd0af28e7b81048d9bda153b908c727304ca8a04",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 12:39 p.m.",
      "commitNameOld": "15cb49e74025eb4011187f31735aa4772993fb5d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isToken(NEWLINE_TOKEN)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (nodeTextEl.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 377,
      "functionName": "apply",
      "diff": "@@ -1,148 +1,151 @@\n     void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isToken(NEWLINE_TOKEN)) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n-                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n+                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n-                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n-                        diffIndex++;\n-                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n+                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n+                            \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n+                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n+                        diffIndex++;\n+                    } else if (nodeTextEl.isWhiteSpace()) {\n+                        nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "15cb49e74025eb4011187f31735aa4772993fb5d": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "issue124: final cleanup\n",
      "commitDate": "2017-02-23, 12:39 p.m.",
      "commitName": "15cb49e74025eb4011187f31735aa4772993fb5d",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "issue124: final cleanup\n",
          "commitDate": "2017-02-23, 12:39 p.m.",
          "commitName": "15cb49e74025eb4011187f31735aa4772993fb5d",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-02-23, 11:20 a.m.",
          "commitNameOld": "4b87b2b6b407077eb064ac949baaa2fbd0487986",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "    void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isToken(NEWLINE_TOKEN)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 377,
          "functionName": "apply",
          "diff": "@@ -1,145 +1,148 @@\n-    public void apply(NodeText nodeText, Node node) {\n+    void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n-                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                        if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n-                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n+                                    + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n-                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n+                                + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n-                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n+                            + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isToken(NEWLINE_TOKEN)) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n-                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                        } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue124: final cleanup\n",
          "commitDate": "2017-02-23, 12:39 p.m.",
          "commitName": "15cb49e74025eb4011187f31735aa4772993fb5d",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-02-23, 11:20 a.m.",
          "commitNameOld": "4b87b2b6b407077eb064ac949baaa2fbd0487986",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "    void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                    + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                            + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isToken(NEWLINE_TOKEN)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 377,
          "functionName": "apply",
          "diff": "@@ -1,145 +1,148 @@\n-    public void apply(NodeText nodeText, Node node) {\n+    void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n-                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                        if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n-                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n+                                    + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n-                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n+                                + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n-                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n+                            + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isToken(NEWLINE_TOKEN)) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n-                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                        } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "4b87b2b6b407077eb064ac949baaa2fbd0487986": {
      "type": "Ybodychange",
      "commitMessage": "issue124: more cleanup\n",
      "commitDate": "2017-02-23, 11:20 a.m.",
      "commitName": "4b87b2b6b407077eb064ac949baaa2fbd0487986",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:20 a.m.",
      "commitNameOld": "a55cd517deae99d6bb32717af632cd9dc9f01928",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isToken(NEWLINE_TOKEN)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 352,
      "functionName": "apply",
      "diff": "@@ -1,145 +1,145 @@\n     public void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n-                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n-                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n+                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n-                        if (textElement.isToken(3)) {\n+                        if (textElement.isToken(NEWLINE_TOKEN)) {\n                             used \u003d true;\n                         }\n-                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n+                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n+                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a55cd517deae99d6bb32717af632cd9dc9f01928": {
      "type": "Ybodychange",
      "commitMessage": "issue124: clean up\n",
      "commitDate": "2017-02-23, 11:20 a.m.",
      "commitName": "a55cd517deae99d6bb32717af632cd9dc9f01928",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "7121d100d536b7b3df76c22ad3acc4c507be7bfe",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isToken(3)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 373,
      "functionName": "apply",
      "diff": "@@ -1,160 +1,145 @@\n     public void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n-        boolean comingFromRemoved \u003d false;\n-        boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n-                    comingFromRemoved \u003d false;\n-                    comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n-                        //nodeTextIndex \u003d removeWhiteSpaceAfterBrace(nodeText, nodeTextIndex);\n                         if (textElement.isToken(3)) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n-                    comingFromRemoved \u003d false;\n-                    comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n-                            //if (comingFromRemoved) {\n-                                //nodeText.removeElement(nodeTextIndex);\n-                            //} else {\n-                                nodeTextIndex++;\n-                            //}\n+                            nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n-                    comingFromRemoved \u003d false;\n-                    comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n-                    comingFromRemoved \u003d true;\n-                    comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7121d100d536b7b3df76c22ad3acc4c507be7bfe": {
      "type": "Ybodychange",
      "commitMessage": "issue124: adjusting indentation of following line\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "7121d100d536b7b3df76c22ad3acc4c507be7bfe",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "152592f7c8110f04ea6ca6e6c6d57360fd40ee16",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        //nodeTextIndex \u003d removeWhiteSpaceAfterBrace(nodeText, nodeTextIndex);\n                        if (textElement.isToken(3)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    if (textElement.isNewline()) {\n                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            //if (comingFromRemoved) {\n                                //nodeText.removeElement(nodeTextIndex);\n                            //} else {\n                                nodeTextIndex++;\n                            //}\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 373,
      "functionName": "apply",
      "diff": "@@ -1,157 +1,160 @@\n     public void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         //nodeTextIndex \u003d removeWhiteSpaceAfterBrace(nodeText, nodeTextIndex);\n                         if (textElement.isToken(3)) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n+                    if (textElement.isNewline()) {\n+                        nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n+                    }\n                     diffIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             //if (comingFromRemoved) {\n                                 //nodeText.removeElement(nodeTextIndex);\n                             //} else {\n                                 nodeTextIndex++;\n                             //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "152592f7c8110f04ea6ca6e6c6d57360fd40ee16": {
      "type": "Ybodychange",
      "commitMessage": "issue124: fix findIndentation\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "152592f7c8110f04ea6ca6e6c6d57360fd40ee16",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "e71e376b9542dd7fea6e973301d8d426f340d65b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        //nodeTextIndex \u003d removeWhiteSpaceAfterBrace(nodeText, nodeTextIndex);\n                        if (textElement.isToken(3)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                            nodeText.getElements().remove(nodeTextIndex);\n                        }\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    diffIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            //if (comingFromRemoved) {\n                                //nodeText.removeElement(nodeTextIndex);\n                            //} else {\n                                nodeTextIndex++;\n                            //}\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 373,
      "functionName": "apply",
      "diff": "@@ -1,153 +1,157 @@\n     public void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n+                        //nodeTextIndex \u003d removeWhiteSpaceAfterBrace(nodeText, nodeTextIndex);\n                         if (textElement.isToken(3)) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n+                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n+                            nodeText.getElements().remove(nodeTextIndex);\n+                        }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     diffIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             //if (comingFromRemoved) {\n                                 //nodeText.removeElement(nodeTextIndex);\n                             //} else {\n                                 nodeTextIndex++;\n                             //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e71e376b9542dd7fea6e973301d8d426f340d65b": {
      "type": "Ybodychange",
      "commitMessage": "issue124: specific support for replacement\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "e71e376b9542dd7fea6e973301d8d426f340d65b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "ed7f4a6532043b5ac8c8da55923fbd91f72ec574",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                        if (textElement.isToken(3)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    diffIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            //if (comingFromRemoved) {\n                                //nodeText.removeElement(nodeTextIndex);\n                            //} else {\n                                nodeTextIndex++;\n                            //}\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 373,
      "functionName": "apply",
      "diff": "@@ -1,153 +1,153 @@\n     public void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n-                    } else if (isAfterLBrace(nodeText, nodeTextIndex)) {\n+                    } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                         if (textElement.isToken(3)) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     diffIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             //if (comingFromRemoved) {\n                                 //nodeText.removeElement(nodeTextIndex);\n                             //} else {\n                                 nodeTextIndex++;\n                             //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ed7f4a6532043b5ac8c8da55923fbd91f72ec574": {
      "type": "Ybodychange",
      "commitMessage": "issue124: special handling for replacement\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "ed7f4a6532043b5ac8c8da55923fbd91f72ec574",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "548fb9c5a72776ec009c5f2f92b1a4c480a05030",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex)) {\n                        if (textElement.isToken(3)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    diffIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            //if (comingFromRemoved) {\n                                //nodeText.removeElement(nodeTextIndex);\n                            //} else {\n                                nodeTextIndex++;\n                            //}\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 372,
      "functionName": "apply",
      "diff": "@@ -1,149 +1,153 @@\n     public void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex)) {\n                         if (textElement.isToken(3)) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     diffIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             //if (comingFromRemoved) {\n                                 //nodeText.removeElement(nodeTextIndex);\n                             //} else {\n                                 nodeTextIndex++;\n                             //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n+                        } else {\n+                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n+                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n+                            }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "548fb9c5a72776ec009c5f2f92b1a4c480a05030": {
      "type": "Ybodychange",
      "commitMessage": "issue124: correct isAfterLBrace\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "548fb9c5a72776ec009c5f2f92b1a4c480a05030",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "f21322dd131f30bfcd809d2748a2366df7dc27d3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (isAfterLBrace(nodeText, nodeTextIndex)) {\n                        if (textElement.isToken(3)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    diffIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            //if (comingFromRemoved) {\n                                //nodeText.removeElement(nodeTextIndex);\n                            //} else {\n                                nodeTextIndex++;\n                            //}\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 344,
      "functionName": "apply",
      "diff": "@@ -1,149 +1,149 @@\n     public void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n-                    } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n+                    } else if (isAfterLBrace(nodeText, nodeTextIndex)) {\n                         if (textElement.isToken(3)) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     diffIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             //if (comingFromRemoved) {\n                                 //nodeText.removeElement(nodeTextIndex);\n                             //} else {\n                                 nodeTextIndex++;\n                             //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f21322dd131f30bfcd809d2748a2366df7dc27d3": {
      "type": "Ybodychange",
      "commitMessage": "issue124: minor bug\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "f21322dd131f30bfcd809d2748a2366df7dc27d3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "882790065271126fc4b17a71bebb078b60ffe00c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                        if (textElement.isToken(3)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    diffIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            //if (comingFromRemoved) {\n                                //nodeText.removeElement(nodeTextIndex);\n                            //} else {\n                                nodeTextIndex++;\n                            //}\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 334,
      "functionName": "apply",
      "diff": "@@ -1,149 +1,149 @@\n     public void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                         if (textElement.isToken(3)) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     diffIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             //if (comingFromRemoved) {\n                                 //nodeText.removeElement(nodeTextIndex);\n                             //} else {\n                                 nodeTextIndex++;\n                             //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n-                        if (nodeTextIndex \u003e nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n+                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "882790065271126fc4b17a71bebb078b60ffe00c": {
      "type": "Ybodychange",
      "commitMessage": "issue124: removing empty lines\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "882790065271126fc4b17a71bebb078b60ffe00c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "572ea89397e9b3b35dc616d48176ab0d296612dd",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                        if (textElement.isToken(3)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    diffIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                            //if (comingFromRemoved) {\n                                //nodeText.removeElement(nodeTextIndex);\n                            //} else {\n                                nodeTextIndex++;\n                            //}\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003e nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        }\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 334,
      "functionName": "apply",
      "diff": "@@ -1,146 +1,149 @@\n     public void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n-                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                         if (textElement.isToken(3)) {\n                             used \u003d true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     diffIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n-                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n-                            if (comingFromRemoved) {\n-                                nodeText.removeElement(nodeTextIndex);\n-                            } else {\n+                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n+                            //if (comingFromRemoved) {\n+                                //nodeText.removeElement(nodeTextIndex);\n+                            //} else {\n                                 nodeTextIndex++;\n-                            }\n+                            //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n-                        } else if (nodeTextToken.isWhiteSpace()) {\n+                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n+                        if (nodeTextIndex \u003e nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n+                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n+                        }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n-                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "572ea89397e9b3b35dc616d48176ab0d296612dd": {
      "type": "Ybodychange",
      "commitMessage": "issue124: more newlines processing\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "572ea89397e9b3b35dc616d48176ab0d296612dd",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "48ac9477b3997592001fa0f44f98eb7481f7b9ea",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    boolean used \u003d false;\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                        if (textElement.isToken(3)) {\n                            used \u003d true;\n                        }\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    if (!used) {\n                        nodeText.addElement(nodeTextIndex, textElement);\n                        nodeTextIndex++;\n                    }\n                    diffIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                            if (comingFromRemoved) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpace()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 326,
      "functionName": "apply",
      "diff": "@@ -1,140 +1,146 @@\n     public void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n+                    boolean used \u003d false;\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n+                        if (textElement.isToken(3)) {\n+                            used \u003d true;\n+                        }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n-                    nodeText.addElement(nodeTextIndex, textElement);\n-                    nodeTextIndex++;\n+                    if (!used) {\n+                        nodeText.addElement(nodeTextIndex, textElement);\n+                        nodeTextIndex++;\n+                    }\n                     diffIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "48ac9477b3997592001fa0f44f98eb7481f7b9ea": {
      "type": "Ybodychange",
      "commitMessage": "issue124: improvements in processing indentation\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "48ac9477b3997592001fa0f44f98eb7481f7b9ea",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "5d76ede0db52033984e3d7908105c6f2f4380725",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                    diffIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                            if (comingFromRemoved) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpace()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 326,
      "functionName": "apply",
      "diff": "@@ -1,132 +1,140 @@\n     public void apply(NodeText nodeText, Node node) {\n         List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n+                    } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n+                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n+                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n+                            nodeText.addElement(nodeTextIndex++, e);\n+                        }\n+                        for (TextElement e : indentationBlock()) {\n+                            nodeText.addElement(nodeTextIndex++, e);\n+                        }\n                     }\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                     diffIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5d76ede0db52033984e3d7908105c6f2f4380725": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "issue124: consider indentation\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "5d76ede0db52033984e3d7908105c6f2f4380725",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "issue124: consider indentation\n",
          "commitDate": "2017-02-23, 11:19 a.m.",
          "commitName": "5d76ede0db52033984e3d7908105c6f2f4380725",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-02-23, 11:19 a.m.",
          "commitNameOld": "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "    public void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                    diffIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                            if (comingFromRemoved) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpace()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 317,
          "functionName": "apply",
          "diff": "@@ -1,125 +1,132 @@\n-    public void apply(NodeText nodeText) {\n+    public void apply(NodeText nodeText, Node node) {\n+        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n-                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n-                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n-                    diffIndex++;\n+                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n+                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n+                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n+                            nodeText.addElement(nodeTextIndex++, e);\n+                        }\n+                    }\n+                    nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n+                    diffIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n-                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[nodeText-NodeText]",
            "newValue": "[nodeText-NodeText, node-Node]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue124: consider indentation\n",
          "commitDate": "2017-02-23, 11:19 a.m.",
          "commitName": "5d76ede0db52033984e3d7908105c6f2f4380725",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-02-23, 11:19 a.m.",
          "commitNameOld": "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "    public void apply(NodeText nodeText, Node node) {\n        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                    diffIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                            if (comingFromRemoved) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpace()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 317,
          "functionName": "apply",
          "diff": "@@ -1,125 +1,132 @@\n-    public void apply(NodeText nodeText) {\n+    public void apply(NodeText nodeText, Node node) {\n+        List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n-                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n-                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n-                    diffIndex++;\n+                    TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n+                    if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n+                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n+                            nodeText.addElement(nodeTextIndex++, e);\n+                        }\n+                    }\n+                    nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n+                    diffIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n-                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f": {
      "type": "Ybodychange",
      "commitMessage": "issue124: now changing the type of variable causes also the maxCommonType of the enclosing declaration to change\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "b2625a83a00b165c95bb7eddc9a1a4b65b4750aa",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    diffIndex++;\n                    nodeTextIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                            if (comingFromRemoved) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpace()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                        if (isPrimitiveType(nodeTextEl)) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 295,
      "functionName": "apply",
      "diff": "@@ -1,118 +1,125 @@\n     public void apply(NodeText nodeText) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     diffIndex++;\n                     nodeTextIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n+                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n+                        if (isPrimitiveType(nodeTextEl)) {\n+                            nodeText.removeElement(nodeTextIndex);\n+                            diffIndex++;\n+                        } else {\n+                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                        }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b2625a83a00b165c95bb7eddc9a1a4b65b4750aa": {
      "type": "Ybodychange",
      "commitMessage": "issue124: added tollerance for Diff expecting to keep whitespace\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "b2625a83a00b165c95bb7eddc9a1a4b65b4750aa",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "a616b929f4a243fd5ed9097d399e7c6bbe79dfc1",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    diffIndex++;\n                    nodeTextIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                            if (comingFromRemoved) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpace()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 294,
      "functionName": "apply",
      "diff": "@@ -1,116 +1,118 @@\n     public void apply(NodeText nodeText) {\n         if (nodeText \u003d\u003d null) {\n             throw new NullPointerException();\n         }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     diffIndex++;\n                     nodeTextIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n+                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n+                        diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0f313058c4389cd48052112e3fb906c060be30f": {
      "type": "Ybodychange",
      "commitMessage": "issue124: improving how JavadocComment is handled\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "f0f313058c4389cd48052112e3fb906c060be30f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "b062cd703845b9a2d65e423e912d4e245f185ed4",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText) {\n        if (nodeText \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    diffIndex++;\n                    nodeTextIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                            if (comingFromRemoved) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpace()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 295,
      "functionName": "apply",
      "diff": "@@ -1,111 +1,116 @@\n     public void apply(NodeText nodeText) {\n+        if (nodeText \u003d\u003d null) {\n+            throw new NullPointerException();\n+        }\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     diffIndex++;\n                     nodeTextIndex++;\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                     comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n+                    } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken)removed.element).isWhiteSpace()) {\n+                        diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                     comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6c2c1abbfcee5a8874d805a58f08d7d21c20482c": {
      "type": "Ybodychange",
      "commitMessage": "issue124: difference now considering added whitespace\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "6c2c1abbfcee5a8874d805a58f08d7d21c20482c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "566e84eb47ec36af0964ae8a3584460737917d73",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText) {\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        boolean comingFromAdded \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    diffIndex++;\n                    nodeTextIndex++;\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d true;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                            if (comingFromRemoved) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpace()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                    comingFromAdded \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                    comingFromAdded \u003d false;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 295,
      "functionName": "apply",
      "diff": "@@ -1,106 +1,111 @@\n     public void apply(NodeText nodeText) {\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n+        boolean comingFromAdded \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n+                    comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     diffIndex++;\n                     nodeTextIndex++;\n                     comingFromRemoved \u003d false;\n+                    comingFromAdded \u003d true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n+                    comingFromAdded \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n+                    comingFromAdded \u003d false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "566e84eb47ec36af0964ae8a3584460737917d73": {
      "type": "Ybodychange",
      "commitMessage": "issue124: added annotationDeclarationExampleWithModifierAdded\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "566e84eb47ec36af0964ae8a3584460737917d73",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "74000e047aaabc467031830b1d958b281cf28df9",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void apply(NodeText nodeText) {\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    diffIndex++;\n                    nodeTextIndex++;\n                    comingFromRemoved \u003d false;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                            if (comingFromRemoved) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpace()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if (nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 285,
      "functionName": "apply",
      "diff": "@@ -1,103 +1,106 @@\n     public void apply(NodeText nodeText) {\n         int diffIndex \u003d 0;\n         int nodeTextIndex \u003d 0;\n         boolean comingFromRemoved \u003d false;\n         do {\n             if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved \u003d false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl \u003d elements.get(diffIndex);\n                 TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     diffIndex++;\n                     nodeTextIndex++;\n                     comingFromRemoved \u003d false;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept \u003d (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed \u003d (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                             \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n+                    } else if (nodeTextEl instanceof TokenTextElement\n+                            \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                        nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved \u003d true;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "issue124: extract Difference\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "issue124: extract Difference\n",
          "commitDate": "2017-02-23, 11:19 a.m.",
          "commitName": "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-02-23, 11:19 a.m.",
          "commitNameOld": "ecefb777275fd26b37f10709f97810a3e6a69bb2",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public void apply(NodeText nodeText) {\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    diffIndex++;\n                    nodeTextIndex++;\n                    comingFromRemoved \u003d false;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                            if (comingFromRemoved) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpace()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 233,
          "functionName": "apply",
          "diff": "@@ -1,103 +1,103 @@\n-        public void apply(NodeText nodeText) {\n-            int diffIndex \u003d 0;\n-            int nodeTextIndex \u003d 0;\n-            boolean comingFromRemoved \u003d false;\n-            do {\n-                if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n-                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n-                    if (diffEl instanceof Kept) {\n-                        Kept kept \u003d (Kept) diffEl;\n-                        if (kept.element instanceof CsmToken) {\n-                            CsmToken csmToken \u003d (CsmToken) kept.element;\n-                            if (isWhitespace(csmToken.getTokenType())) {\n-                                diffIndex++;\n-                            } else {\n-                                throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n-                            }\n+    public void apply(NodeText nodeText) {\n+        int diffIndex \u003d 0;\n+        int nodeTextIndex \u003d 0;\n+        boolean comingFromRemoved \u003d false;\n+        do {\n+            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n+                DifferenceElement diffEl \u003d elements.get(diffIndex);\n+                if (diffEl instanceof Kept) {\n+                    Kept kept \u003d (Kept) diffEl;\n+                    if (kept.element instanceof CsmToken) {\n+                        CsmToken csmToken \u003d (CsmToken) kept.element;\n+                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                            diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n-                        comingFromRemoved \u003d false;\n-                    } else if (diffEl instanceof Added) {\n-                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n-                        nodeTextIndex++;\n-                        diffIndex++;\n                     } else {\n-                        throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n-                } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n-                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n-                    if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n-                        nodeTextIndex++;\n-                    } else {\n-                        throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n-                    }\n+                    comingFromRemoved \u003d false;\n+                } else if (diffEl instanceof Added) {\n+                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    nodeTextIndex++;\n+                    diffIndex++;\n                 } else {\n-                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n-                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n-                    if (diffEl instanceof Added) {\n-                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+                }\n+            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n+                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n+                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                    nodeTextIndex++;\n+                } else {\n+                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                }\n+            } else {\n+                DifferenceElement diffEl \u003d elements.get(diffIndex);\n+                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n+                if (diffEl instanceof Added) {\n+                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    diffIndex++;\n+                    nodeTextIndex++;\n+                    comingFromRemoved \u003d false;\n+                } else if (diffEl instanceof Kept) {\n+                    Kept kept \u003d (Kept)diffEl;\n+                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n-                        comingFromRemoved \u003d false;\n-                    } else if (diffEl instanceof Kept) {\n-                        Kept kept \u003d (Kept)diffEl;\n-                        if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n-                            diffIndex++;\n-                            nodeTextIndex++;\n-                        } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n-                            if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n-                                if (comingFromRemoved) {\n-                                    nodeText.removeElement(nodeTextIndex);\n-                                } else {\n-                                    nodeTextIndex++;\n-                                }\n+                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n+                            if (comingFromRemoved) {\n+                                nodeText.removeElement(nodeTextIndex);\n                             } else {\n-                                if (kept.element instanceof CsmChild) {\n-                                    CsmChild keptChild \u003d (CsmChild)kept.element;\n-                                    if (keptChild.child instanceof PrimitiveType) {\n-                                        nodeTextIndex++;\n-                                        diffIndex++;\n-                                    } else {\n-                                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n-                                    }\n+                                nodeTextIndex++;\n+                            }\n+                        } else {\n+                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n+                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n+                                if (keptChild.getChild() instanceof PrimitiveType) {\n+                                    nodeTextIndex++;\n+                                    diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n-                            }\n-                        } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n-                            CsmToken csmToken \u003d (CsmToken) kept.element;\n-                            TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n-                            if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n-                                nodeTextIndex++;\n-                                diffIndex++;\n-                            } else if (isWhitespace(csmToken.getTokenType())) {\n-                                diffIndex++;\n-                            } else if (nodeTextToken.isWhiteSpace()) {\n-                                nodeTextIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n+                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n-                        } else {\n-                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n-                        comingFromRemoved \u003d false;\n-                    } else if (diffEl instanceof Removed) {\n-                        Removed removed \u003d (Removed)diffEl;\n-                        if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n-                            nodeText.removeElement(nodeTextIndex);\n+                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                        CsmToken csmToken \u003d (CsmToken) kept.element;\n+                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n+                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n+                            nodeTextIndex++;\n                             diffIndex++;\n-                        } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n-                                \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n-                            nodeText.removeElement(nodeTextIndex);\n+                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n+                        } else if (nodeTextToken.isWhiteSpace()) {\n+                            nodeTextIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n-                        comingFromRemoved \u003d true;\n                     } else {\n-                        throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n+                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n+                    comingFromRemoved \u003d false;\n+                } else if (diffEl instanceof Removed) {\n+                    Removed removed \u003d (Removed)diffEl;\n+                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                        nodeText.removeElement(nodeTextIndex);\n+                        diffIndex++;\n+                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n+                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n+                        nodeText.removeElement(nodeTextIndex);\n+                        diffIndex++;\n+                    } else {\n+                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                    }\n+                    comingFromRemoved \u003d true;\n+                } else {\n+                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n-            } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n-        }\n\\ No newline at end of file\n+            }\n+        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n+    }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
            "newPath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
            "oldMethodName": "apply",
            "newMethodName": "apply"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue124: extract Difference\n",
          "commitDate": "2017-02-23, 11:19 a.m.",
          "commitName": "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-02-23, 11:19 a.m.",
          "commitNameOld": "ecefb777275fd26b37f10709f97810a3e6a69bb2",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public void apply(NodeText nodeText) {\n        int diffIndex \u003d 0;\n        int nodeTextIndex \u003d 0;\n        boolean comingFromRemoved \u003d false;\n        do {\n            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept) diffEl;\n                    if (kept.element instanceof CsmToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                    comingFromRemoved \u003d false;\n                } else if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    nodeTextIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                }\n            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                }\n            } else {\n                DifferenceElement diffEl \u003d elements.get(diffIndex);\n                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                if (diffEl instanceof Added) {\n                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                    diffIndex++;\n                    nodeTextIndex++;\n                    comingFromRemoved \u003d false;\n                } else if (diffEl instanceof Kept) {\n                    Kept kept \u003d (Kept)diffEl;\n                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                            if (comingFromRemoved) {\n                                nodeText.removeElement(nodeTextIndex);\n                            } else {\n                                nodeTextIndex++;\n                            }\n                        } else {\n                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                if (keptChild.getChild() instanceof PrimitiveType) {\n                                    nodeTextIndex++;\n                                    diffIndex++;\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        }\n                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            nodeTextIndex++;\n                            diffIndex++;\n                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpace()) {\n                            nodeTextIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d false;\n                } else if (diffEl instanceof Removed) {\n                    Removed removed \u003d (Removed)diffEl;\n                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                    comingFromRemoved \u003d true;\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                }\n            }\n        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n    }",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 233,
          "functionName": "apply",
          "diff": "@@ -1,103 +1,103 @@\n-        public void apply(NodeText nodeText) {\n-            int diffIndex \u003d 0;\n-            int nodeTextIndex \u003d 0;\n-            boolean comingFromRemoved \u003d false;\n-            do {\n-                if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n-                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n-                    if (diffEl instanceof Kept) {\n-                        Kept kept \u003d (Kept) diffEl;\n-                        if (kept.element instanceof CsmToken) {\n-                            CsmToken csmToken \u003d (CsmToken) kept.element;\n-                            if (isWhitespace(csmToken.getTokenType())) {\n-                                diffIndex++;\n-                            } else {\n-                                throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n-                            }\n+    public void apply(NodeText nodeText) {\n+        int diffIndex \u003d 0;\n+        int nodeTextIndex \u003d 0;\n+        boolean comingFromRemoved \u003d false;\n+        do {\n+            if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n+                DifferenceElement diffEl \u003d elements.get(diffIndex);\n+                if (diffEl instanceof Kept) {\n+                    Kept kept \u003d (Kept) diffEl;\n+                    if (kept.element instanceof CsmToken) {\n+                        CsmToken csmToken \u003d (CsmToken) kept.element;\n+                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                            diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n-                        comingFromRemoved \u003d false;\n-                    } else if (diffEl instanceof Added) {\n-                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n-                        nodeTextIndex++;\n-                        diffIndex++;\n                     } else {\n-                        throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n-                } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n-                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n-                    if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n-                        nodeTextIndex++;\n-                    } else {\n-                        throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n-                    }\n+                    comingFromRemoved \u003d false;\n+                } else if (diffEl instanceof Added) {\n+                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    nodeTextIndex++;\n+                    diffIndex++;\n                 } else {\n-                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n-                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n-                    if (diffEl instanceof Added) {\n-                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+                }\n+            } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n+                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n+                if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                    nodeTextIndex++;\n+                } else {\n+                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                }\n+            } else {\n+                DifferenceElement diffEl \u003d elements.get(diffIndex);\n+                TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n+                if (diffEl instanceof Added) {\n+                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    diffIndex++;\n+                    nodeTextIndex++;\n+                    comingFromRemoved \u003d false;\n+                } else if (diffEl instanceof Kept) {\n+                    Kept kept \u003d (Kept)diffEl;\n+                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n-                        comingFromRemoved \u003d false;\n-                    } else if (diffEl instanceof Kept) {\n-                        Kept kept \u003d (Kept)diffEl;\n-                        if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n-                            diffIndex++;\n-                            nodeTextIndex++;\n-                        } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n-                            if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n-                                if (comingFromRemoved) {\n-                                    nodeText.removeElement(nodeTextIndex);\n-                                } else {\n-                                    nodeTextIndex++;\n-                                }\n+                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n+                            if (comingFromRemoved) {\n+                                nodeText.removeElement(nodeTextIndex);\n                             } else {\n-                                if (kept.element instanceof CsmChild) {\n-                                    CsmChild keptChild \u003d (CsmChild)kept.element;\n-                                    if (keptChild.child instanceof PrimitiveType) {\n-                                        nodeTextIndex++;\n-                                        diffIndex++;\n-                                    } else {\n-                                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n-                                    }\n+                                nodeTextIndex++;\n+                            }\n+                        } else {\n+                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n+                                LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild)kept.element;\n+                                if (keptChild.getChild() instanceof PrimitiveType) {\n+                                    nodeTextIndex++;\n+                                    diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n-                            }\n-                        } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n-                            CsmToken csmToken \u003d (CsmToken) kept.element;\n-                            TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n-                            if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n-                                nodeTextIndex++;\n-                                diffIndex++;\n-                            } else if (isWhitespace(csmToken.getTokenType())) {\n-                                diffIndex++;\n-                            } else if (nodeTextToken.isWhiteSpace()) {\n-                                nodeTextIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n+                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n-                        } else {\n-                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n-                        comingFromRemoved \u003d false;\n-                    } else if (diffEl instanceof Removed) {\n-                        Removed removed \u003d (Removed)diffEl;\n-                        if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n-                            nodeText.removeElement(nodeTextIndex);\n+                    } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                        CsmToken csmToken \u003d (CsmToken) kept.element;\n+                        TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n+                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n+                            nodeTextIndex++;\n                             diffIndex++;\n-                        } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n-                                \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n-                            nodeText.removeElement(nodeTextIndex);\n+                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n+                        } else if (nodeTextToken.isWhiteSpace()) {\n+                            nodeTextIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n-                        comingFromRemoved \u003d true;\n                     } else {\n-                        throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n+                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n+                    comingFromRemoved \u003d false;\n+                } else if (diffEl instanceof Removed) {\n+                    Removed removed \u003d (Removed)diffEl;\n+                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                        nodeText.removeElement(nodeTextIndex);\n+                        diffIndex++;\n+                    } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n+                            \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n+                        nodeText.removeElement(nodeTextIndex);\n+                        diffIndex++;\n+                    } else {\n+                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                    }\n+                    comingFromRemoved \u003d true;\n+                } else {\n+                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n-            } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n-        }\n\\ No newline at end of file\n+            }\n+        } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n+    }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ecefb777275fd26b37f10709f97810a3e6a69bb2": {
      "type": "Ybodychange",
      "commitMessage": "issue124: addressing a few more cases\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "ecefb777275fd26b37f10709f97810a3e6a69bb2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "670f643e671ee92ed35db80bb96e28fc5250866d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "        public void apply(NodeText nodeText) {\n            int diffIndex \u003d 0;\n            int nodeTextIndex \u003d 0;\n            boolean comingFromRemoved \u003d false;\n            do {\n                if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n                    if (diffEl instanceof Kept) {\n                        Kept kept \u003d (Kept) diffEl;\n                        if (kept.element instanceof CsmToken) {\n                            CsmToken csmToken \u003d (CsmToken) kept.element;\n                            if (isWhitespace(csmToken.getTokenType())) {\n                                diffIndex++;\n                            } else {\n                                throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                            }\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                        comingFromRemoved \u003d false;\n                    } else if (diffEl instanceof Added) {\n                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                    }\n                } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                    if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                    }\n                } else {\n                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                    if (diffEl instanceof Added) {\n                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                        diffIndex++;\n                        nodeTextIndex++;\n                        comingFromRemoved \u003d false;\n                    } else if (diffEl instanceof Kept) {\n                        Kept kept \u003d (Kept)diffEl;\n                        if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                            diffIndex++;\n                            nodeTextIndex++;\n                        } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                            if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                                if (comingFromRemoved) {\n                                    nodeText.removeElement(nodeTextIndex);\n                                } else {\n                                    nodeTextIndex++;\n                                }\n                            } else {\n                                if (kept.element instanceof CsmChild) {\n                                    CsmChild keptChild \u003d (CsmChild)kept.element;\n                                    if (keptChild.child instanceof PrimitiveType) {\n                                        nodeTextIndex++;\n                                        diffIndex++;\n                                    } else {\n                                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                    }\n                                } else {\n                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                }\n                            }\n                        } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                            CsmToken csmToken \u003d (CsmToken) kept.element;\n                            TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                            if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else if (isWhitespace(csmToken.getTokenType())) {\n                                diffIndex++;\n                            } else if (nodeTextToken.isWhiteSpace()) {\n                                nodeTextIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                        comingFromRemoved \u003d false;\n                    } else if (diffEl instanceof Removed) {\n                        Removed removed \u003d (Removed)diffEl;\n                        if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                                \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                        comingFromRemoved \u003d true;\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                    }\n                }\n            } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n        }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
      "functionStartLine": 498,
      "functionName": "apply",
      "diff": "@@ -1,93 +1,103 @@\n         public void apply(NodeText nodeText) {\n             int diffIndex \u003d 0;\n             int nodeTextIndex \u003d 0;\n             boolean comingFromRemoved \u003d false;\n             do {\n                 if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                     DifferenceElement diffEl \u003d elements.get(diffIndex);\n                     if (diffEl instanceof Kept) {\n                         Kept kept \u003d (Kept) diffEl;\n                         if (kept.element instanceof CsmToken) {\n                             CsmToken csmToken \u003d (CsmToken) kept.element;\n                             if (isWhitespace(csmToken.getTokenType())) {\n                                 diffIndex++;\n                             } else {\n                                 throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                             }\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                         comingFromRemoved \u003d false;\n                     } else if (diffEl instanceof Added) {\n                         nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                     }\n                 } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                     TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                     if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                     }\n                 } else {\n                     DifferenceElement diffEl \u003d elements.get(diffIndex);\n                     TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                     if (diffEl instanceof Added) {\n                         nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                         diffIndex++;\n                         nodeTextIndex++;\n                         comingFromRemoved \u003d false;\n                     } else if (diffEl instanceof Kept) {\n                         Kept kept \u003d (Kept)diffEl;\n                         if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                             diffIndex++;\n                             nodeTextIndex++;\n                         } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                             if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                                 if (comingFromRemoved) {\n                                     nodeText.removeElement(nodeTextIndex);\n                                 } else {\n                                     nodeTextIndex++;\n                                 }\n                             } else {\n-                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                                if (kept.element instanceof CsmChild) {\n+                                    CsmChild keptChild \u003d (CsmChild)kept.element;\n+                                    if (keptChild.child instanceof PrimitiveType) {\n+                                        nodeTextIndex++;\n+                                        diffIndex++;\n+                                    } else {\n+                                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                                    }\n+                                } else {\n+                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                                }\n                             }\n                         } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                             CsmToken csmToken \u003d (CsmToken) kept.element;\n                             TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                             if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else if (isWhitespace(csmToken.getTokenType())) {\n                                 diffIndex++;\n                             } else if (nodeTextToken.isWhiteSpace()) {\n                                 nodeTextIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                         comingFromRemoved \u003d false;\n                     } else if (diffEl instanceof Removed) {\n                         Removed removed \u003d (Removed)diffEl;\n                         if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                                 \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                         comingFromRemoved \u003d true;\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                     }\n                 }\n             } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n         }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "01e9c90792e879eca937a12b6bb30b31e51aee53": {
      "type": "Ybodychange",
      "commitMessage": "issue124: expanding the cases covered\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "01e9c90792e879eca937a12b6bb30b31e51aee53",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "f4ce6ce924ffbd03518c64cea9b830d04f75b849",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "        public void apply(NodeText nodeText) {\n            int diffIndex \u003d 0;\n            int nodeTextIndex \u003d 0;\n            boolean comingFromRemoved \u003d false;\n            do {\n                if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n                    if (diffEl instanceof Kept) {\n                        Kept kept \u003d (Kept) diffEl;\n                        if (kept.element instanceof CsmToken) {\n                            CsmToken csmToken \u003d (CsmToken) kept.element;\n                            if (isWhitespace(csmToken.getTokenType())) {\n                                diffIndex++;\n                            } else {\n                                throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                            }\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                        comingFromRemoved \u003d false;\n                    } else if (diffEl instanceof Added) {\n                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                    }\n                } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                    if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                    }\n                } else {\n                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                    if (diffEl instanceof Added) {\n                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                        diffIndex++;\n                        nodeTextIndex++;\n                        comingFromRemoved \u003d false;\n                    } else if (diffEl instanceof Kept) {\n                        Kept kept \u003d (Kept)diffEl;\n                        if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                            diffIndex++;\n                            nodeTextIndex++;\n                        } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                            if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                                if (comingFromRemoved) {\n                                    nodeText.removeElement(nodeTextIndex);\n                                } else {\n                                    nodeTextIndex++;\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                            CsmToken csmToken \u003d (CsmToken) kept.element;\n                            TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                            if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else if (isWhitespace(csmToken.getTokenType())) {\n                                diffIndex++;\n                            } else if (nodeTextToken.isWhiteSpace()) {\n                                nodeTextIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                        comingFromRemoved \u003d false;\n                    } else if (diffEl instanceof Removed) {\n                        Removed removed \u003d (Removed)diffEl;\n                        if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n                                \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                        comingFromRemoved \u003d true;\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                    }\n                }\n            } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n        }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
      "functionStartLine": 429,
      "functionName": "apply",
      "diff": "@@ -1,81 +1,93 @@\n         public void apply(NodeText nodeText) {\n             int diffIndex \u003d 0;\n             int nodeTextIndex \u003d 0;\n             boolean comingFromRemoved \u003d false;\n             do {\n                 if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                     DifferenceElement diffEl \u003d elements.get(diffIndex);\n                     if (diffEl instanceof Kept) {\n-                        Kept kept \u003d (Kept)diffEl;\n+                        Kept kept \u003d (Kept) diffEl;\n                         if (kept.element instanceof CsmToken) {\n-                            CsmToken csmToken \u003d (CsmToken)kept.element;\n+                            CsmToken csmToken \u003d (CsmToken) kept.element;\n                             if (isWhitespace(csmToken.getTokenType())) {\n                                 diffIndex++;\n                             } else {\n                                 throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                             }\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                         comingFromRemoved \u003d false;\n+                    } else if (diffEl instanceof Added) {\n+                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                        nodeTextIndex++;\n+                        diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                     }\n                 } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                     TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                     if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                     }\n                 } else {\n                     DifferenceElement diffEl \u003d elements.get(diffIndex);\n                     TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                     if (diffEl instanceof Added) {\n                         nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                         diffIndex++;\n                         nodeTextIndex++;\n                         comingFromRemoved \u003d false;\n                     } else if (diffEl instanceof Kept) {\n                         Kept kept \u003d (Kept)diffEl;\n                         if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                             diffIndex++;\n                             nodeTextIndex++;\n                         } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                             if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                                 if (comingFromRemoved) {\n                                     nodeText.removeElement(nodeTextIndex);\n                                 } else {\n                                     nodeTextIndex++;\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n-                            CsmToken csmToken \u003d (CsmToken)kept.element;\n-                            TokenTextElement nodeTextToken \u003d (TokenTextElement)nodeTextEl;\n+                            CsmToken csmToken \u003d (CsmToken) kept.element;\n+                            TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                             if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n+                            } else if (isWhitespace(csmToken.getTokenType())) {\n+                                diffIndex++;\n+                            } else if (nodeTextToken.isWhiteSpace()) {\n+                                nodeTextIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException();\n+                                throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                         comingFromRemoved \u003d false;\n                     } else if (diffEl instanceof Removed) {\n                         Removed removed \u003d (Removed)diffEl;\n                         if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n+                        } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement\n+                                \u0026\u0026 ((CsmToken)removed.element).getTokenType() \u003d\u003d ((TokenTextElement)nodeTextEl).getTokenKind()) {\n+                            nodeText.removeElement(nodeTextIndex);\n+                            diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                         comingFromRemoved \u003d true;\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                     }\n                 }\n             } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n         }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4ce6ce924ffbd03518c64cea9b830d04f75b849": {
      "type": "Ybodychange",
      "commitMessage": "issue124: array creation level support using CSM\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "f4ce6ce924ffbd03518c64cea9b830d04f75b849",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "6f102302a83146e02d13ff476f39fc8a86710e38",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "        public void apply(NodeText nodeText) {\n            int diffIndex \u003d 0;\n            int nodeTextIndex \u003d 0;\n            boolean comingFromRemoved \u003d false;\n            do {\n                if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n                    if (diffEl instanceof Kept) {\n                        Kept kept \u003d (Kept)diffEl;\n                        if (kept.element instanceof CsmToken) {\n                            CsmToken csmToken \u003d (CsmToken)kept.element;\n                            if (isWhitespace(csmToken.getTokenType())) {\n                                diffIndex++;\n                            } else {\n                                throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                            }\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                        comingFromRemoved \u003d false;\n                    } else {\n                        throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                    }\n                } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                    if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                    }\n                } else {\n                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                    if (diffEl instanceof Added) {\n                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                        diffIndex++;\n                        nodeTextIndex++;\n                        comingFromRemoved \u003d false;\n                    } else if (diffEl instanceof Kept) {\n                        Kept kept \u003d (Kept)diffEl;\n                        if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                            diffIndex++;\n                            nodeTextIndex++;\n                        } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                            if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                                if (comingFromRemoved) {\n                                    nodeText.removeElement(nodeTextIndex);\n                                } else {\n                                    nodeTextIndex++;\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                            CsmToken csmToken \u003d (CsmToken)kept.element;\n                            TokenTextElement nodeTextToken \u003d (TokenTextElement)nodeTextEl;\n                            if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                        comingFromRemoved \u003d false;\n                    } else if (diffEl instanceof Removed) {\n                        Removed removed \u003d (Removed)diffEl;\n                        if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                        comingFromRemoved \u003d true;\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                    }\n                }\n            } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n        }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
      "functionStartLine": 332,
      "functionName": "apply",
      "diff": "@@ -1,68 +1,81 @@\n         public void apply(NodeText nodeText) {\n             int diffIndex \u003d 0;\n             int nodeTextIndex \u003d 0;\n             boolean comingFromRemoved \u003d false;\n             do {\n                 if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                     DifferenceElement diffEl \u003d elements.get(diffIndex);\n                     if (diffEl instanceof Kept) {\n                         Kept kept \u003d (Kept)diffEl;\n                         if (kept.element instanceof CsmToken) {\n                             CsmToken csmToken \u003d (CsmToken)kept.element;\n                             if (isWhitespace(csmToken.getTokenType())) {\n                                 diffIndex++;\n                             } else {\n                                 throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                             }\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                         comingFromRemoved \u003d false;\n                     } else {\n                         throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                     }\n                 } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n-                    nodeTextIndex++;\n-                    throw new UnsupportedOperationException(\"B\");\n+                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n+                    if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                        nodeTextIndex++;\n+                    } else {\n+                        throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                    }\n                 } else {\n                     DifferenceElement diffEl \u003d elements.get(diffIndex);\n                     TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                     if (diffEl instanceof Added) {\n                         nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                         diffIndex++;\n                         nodeTextIndex++;\n                         comingFromRemoved \u003d false;\n                     } else if (diffEl instanceof Kept) {\n                         Kept kept \u003d (Kept)diffEl;\n                         if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                             diffIndex++;\n                             nodeTextIndex++;\n                         } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n-                            if (((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                            if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                                 if (comingFromRemoved) {\n                                     nodeText.removeElement(nodeTextIndex);\n                                 } else {\n                                     nodeTextIndex++;\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n+                        } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                            CsmToken csmToken \u003d (CsmToken)kept.element;\n+                            TokenTextElement nodeTextToken \u003d (TokenTextElement)nodeTextEl;\n+                            if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n+                                nodeTextIndex++;\n+                                diffIndex++;\n+                            } else {\n+                                throw new UnsupportedOperationException();\n+                            }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                         comingFromRemoved \u003d false;\n                     } else if (diffEl instanceof Removed) {\n                         Removed removed \u003d (Removed)diffEl;\n                         if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                         comingFromRemoved \u003d true;\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                     }\n                 }\n             } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n         }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f102302a83146e02d13ff476f39fc8a86710e38": {
      "type": "Ybodychange",
      "commitMessage": "issue124: lexical preservation based on CSM implemented for CompilationUnit\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "6f102302a83146e02d13ff476f39fc8a86710e38",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "cc13f68e3655ea43b56dd13ee55a81f3a2d37fee",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "        public void apply(NodeText nodeText) {\n            int diffIndex \u003d 0;\n            int nodeTextIndex \u003d 0;\n            boolean comingFromRemoved \u003d false;\n            do {\n                if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n                    if (diffEl instanceof Kept) {\n                        Kept kept \u003d (Kept)diffEl;\n                        if (kept.element instanceof CsmToken) {\n                            CsmToken csmToken \u003d (CsmToken)kept.element;\n                            if (isWhitespace(csmToken.getTokenType())) {\n                                diffIndex++;\n                            } else {\n                                throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                            }\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                        comingFromRemoved \u003d false;\n                    } else {\n                        throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                    }\n                } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                    nodeTextIndex++;\n                    throw new UnsupportedOperationException(\"B\");\n                } else {\n                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                    if (diffEl instanceof Added) {\n                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                        diffIndex++;\n                        nodeTextIndex++;\n                        comingFromRemoved \u003d false;\n                    } else if (diffEl instanceof Kept) {\n                        Kept kept \u003d (Kept)diffEl;\n                        if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                            diffIndex++;\n                            nodeTextIndex++;\n                        } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                            if (((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                                if (comingFromRemoved) {\n                                    nodeText.removeElement(nodeTextIndex);\n                                } else {\n                                    nodeTextIndex++;\n                                }\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                        comingFromRemoved \u003d false;\n                    } else if (diffEl instanceof Removed) {\n                        Removed removed \u003d (Removed)diffEl;\n                        if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                        comingFromRemoved \u003d true;\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                    }\n                }\n            } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n        }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
      "functionStartLine": 332,
      "functionName": "apply",
      "diff": "@@ -1,59 +1,68 @@\n         public void apply(NodeText nodeText) {\n             int diffIndex \u003d 0;\n             int nodeTextIndex \u003d 0;\n+            boolean comingFromRemoved \u003d false;\n             do {\n                 if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                     DifferenceElement diffEl \u003d elements.get(diffIndex);\n                     if (diffEl instanceof Kept) {\n                         Kept kept \u003d (Kept)diffEl;\n                         if (kept.element instanceof CsmToken) {\n                             CsmToken csmToken \u003d (CsmToken)kept.element;\n                             if (isWhitespace(csmToken.getTokenType())) {\n                                 diffIndex++;\n                             } else {\n                                 throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                             }\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n+                        comingFromRemoved \u003d false;\n                     } else {\n                         throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                     }\n                 } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                     nodeTextIndex++;\n                     throw new UnsupportedOperationException(\"B\");\n                 } else {\n                     DifferenceElement diffEl \u003d elements.get(diffIndex);\n                     TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                     if (diffEl instanceof Added) {\n                         nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                         diffIndex++;\n                         nodeTextIndex++;\n+                        comingFromRemoved \u003d false;\n                     } else if (diffEl instanceof Kept) {\n                         Kept kept \u003d (Kept)diffEl;\n                         if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                             diffIndex++;\n                             nodeTextIndex++;\n                         } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                             if (((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n-                                nodeTextIndex++;\n+                                if (comingFromRemoved) {\n+                                    nodeText.removeElement(nodeTextIndex);\n+                                } else {\n+                                    nodeTextIndex++;\n+                                }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n+                        comingFromRemoved \u003d false;\n                     } else if (diffEl instanceof Removed) {\n                         Removed removed \u003d (Removed)diffEl;\n                         if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n+                        comingFromRemoved \u003d true;\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                     }\n                 }\n             } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n         }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc13f68e3655ea43b56dd13ee55a81f3a2d37fee": {
      "type": "Ybodychange",
      "commitMessage": "issue124: applying differences\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "cc13f68e3655ea43b56dd13ee55a81f3a2d37fee",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-02-23, 11:19 a.m.",
      "commitNameOld": "c73ae5d79b62de91209477538b45ab5216fb108e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "        public void apply(NodeText nodeText) {\n            int diffIndex \u003d 0;\n            int nodeTextIndex \u003d 0;\n            do {\n                if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n                    if (diffEl instanceof Kept) {\n                        Kept kept \u003d (Kept)diffEl;\n                        if (kept.element instanceof CsmToken) {\n                            CsmToken csmToken \u003d (CsmToken)kept.element;\n                            if (isWhitespace(csmToken.getTokenType())) {\n                                diffIndex++;\n                            } else {\n                                throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                            }\n                        } else {\n                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                    }\n                } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n                    nodeTextIndex++;\n                    throw new UnsupportedOperationException(\"B\");\n                } else {\n                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n                    if (diffEl instanceof Added) {\n                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                        diffIndex++;\n                        nodeTextIndex++;\n                    } else if (diffEl instanceof Kept) {\n                        Kept kept \u003d (Kept)diffEl;\n                        if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                            diffIndex++;\n                            nodeTextIndex++;\n                        } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                            if (((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                                nodeTextIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    } else if (diffEl instanceof Removed) {\n                        Removed removed \u003d (Removed)diffEl;\n                        if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                            nodeText.removeElement(nodeTextIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                    }\n                }\n            } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n        }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
      "functionStartLine": 332,
      "functionName": "apply",
      "diff": "@@ -1,3 +1,59 @@\n         public void apply(NodeText nodeText) {\n-\n+            int diffIndex \u003d 0;\n+            int nodeTextIndex \u003d 0;\n+            do {\n+                if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n+                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n+                    if (diffEl instanceof Kept) {\n+                        Kept kept \u003d (Kept)diffEl;\n+                        if (kept.element instanceof CsmToken) {\n+                            CsmToken csmToken \u003d (CsmToken)kept.element;\n+                            if (isWhitespace(csmToken.getTokenType())) {\n+                                diffIndex++;\n+                            } else {\n+                                throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                            }\n+                        } else {\n+                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                        }\n+                    } else {\n+                        throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+                    }\n+                } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n+                    nodeTextIndex++;\n+                    throw new UnsupportedOperationException(\"B\");\n+                } else {\n+                    DifferenceElement diffEl \u003d elements.get(diffIndex);\n+                    TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n+                    if (diffEl instanceof Added) {\n+                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                        diffIndex++;\n+                        nodeTextIndex++;\n+                    } else if (diffEl instanceof Kept) {\n+                        Kept kept \u003d (Kept)diffEl;\n+                        if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                            diffIndex++;\n+                            nodeTextIndex++;\n+                        } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                            if (((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                                nodeTextIndex++;\n+                            } else {\n+                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                            }\n+                        } else {\n+                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                        }\n+                    } else if (diffEl instanceof Removed) {\n+                        Removed removed \u003d (Removed)diffEl;\n+                        if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                            nodeText.removeElement(nodeTextIndex);\n+                            diffIndex++;\n+                        } else {\n+                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                        }\n+                    } else {\n+                        throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n+                    }\n+                }\n+            } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n         }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c73ae5d79b62de91209477538b45ab5216fb108e": {
      "type": "Yintroduced",
      "commitMessage": "issue124: working on calculate the CSM difference before and after a property change\n",
      "commitDate": "2017-02-23, 11:19 a.m.",
      "commitName": "c73ae5d79b62de91209477538b45ab5216fb108e",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,3 @@\n+        public void apply(NodeText nodeText) {\n+\n+        }\n\\ No newline at end of file\n",
      "actualSource": "        public void apply(NodeText nodeText) {\n\n        }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
      "functionStartLine": 206,
      "functionName": "apply"
    }
  }
}