{
  "origin": "codeshovel",
  "repositoryName": "okhttp",
  "repositoryPath": "H:\\Projects\\square\\okhttp/.git",
  "startCommitName": "5224f3045ba9b171fce521777edf389f9206173c",
  "sourceFileName": "ConnectionPool.java",
  "functionName": "get",
  "functionId": "get___address-Address__streamAllocation-StreamAllocation__route-Route",
  "sourceFilePath": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
  "functionStartLine": 122,
  "functionEndLine": 131,
  "numCommitsSeen": 103,
  "timeTaken": 2148,
  "changeHistory": [
    "77471444ec81ad9452ebde7ca2b58db58a1f77d1",
    "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0",
    "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
    "75ebcd5cd13995c3b70e0b621d3204b9a5996806",
    "02d6b4e78c4f1bda5f20e3089af024c58fe6baf6",
    "c9a89876de476983f273edbf108c365127c18c5e",
    "c099f69d0b7198a40e4a6373ae564b65d04363ef",
    "4ae314a1f21d07ee5dbad024bc098182219e9e07",
    "c5f58e45454d1ffc621c65e377cb91345018e087",
    "c358656c8799d30fd422448153e99a5dd37e298a",
    "49a331385343f3ca49d26c4ddd947546867bcd3b",
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
    "98c74ace40b089f2769afb3e56c59a64eef327cb",
    "a8327d121b9eeb3b61ae63f06095d423936a5da2",
    "c26f9af0489869a9e1873ed5010c65f8464cff26",
    "fdee6f13a4c5bf5bd24f2c237c2996aea01cc5ff",
    "1ece746c815a26782042b1fca6069eb527d1029b",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3",
    "f373e2d6e5bfaa86afc147b877a72d600c224c5d",
    "6f6d959fdae64065521990413f86bc7ab038d7c1",
    "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
    "689f66222bd8984dd69229a4ee9caf8da528ae12",
    "67604f618d96ae00318ce696ec29a66bec6aafa8",
    "78c6624b11d5f33504dae8211b4592383468343e",
    "70e64037ff295874602133a1d254e5a0440ae4e3",
    "3d2547f18886e771aaa9baa996a21136c93460c4",
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
    "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e"
  ],
  "changeHistoryShort": {
    "77471444ec81ad9452ebde7ca2b58db58a1f77d1": "Ybodychange",
    "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0": "Ymultichange(Yparameterchange,Ybodychange)",
    "98443a9ca8ca9ad82d5fb9b05b32f180bb510601": "Ybodychange",
    "75ebcd5cd13995c3b70e0b621d3204b9a5996806": "Ybodychange",
    "02d6b4e78c4f1bda5f20e3089af024c58fe6baf6": "Ybodychange",
    "c9a89876de476983f273edbf108c365127c18c5e": "Yfilerename",
    "c099f69d0b7198a40e4a6373ae564b65d04363ef": "Ymultichange(Yreturntypechange,Ymodifierchange,Ybodychange)",
    "4ae314a1f21d07ee5dbad024bc098182219e9e07": "Ymultichange(Yparameterchange,Ybodychange)",
    "c5f58e45454d1ffc621c65e377cb91345018e087": "Ybodychange",
    "c358656c8799d30fd422448153e99a5dd37e298a": "Ybodychange",
    "49a331385343f3ca49d26c4ddd947546867bcd3b": "Ybodychange",
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80": "Ybodychange",
    "98c74ace40b089f2769afb3e56c59a64eef327cb": "Ybodychange",
    "a8327d121b9eeb3b61ae63f06095d423936a5da2": "Ybodychange",
    "c26f9af0489869a9e1873ed5010c65f8464cff26": "Ybodychange",
    "fdee6f13a4c5bf5bd24f2c237c2996aea01cc5ff": "Ybodychange",
    "1ece746c815a26782042b1fca6069eb527d1029b": "Ybodychange",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": "Yfilerename",
    "f373e2d6e5bfaa86afc147b877a72d600c224c5d": "Ybodychange",
    "6f6d959fdae64065521990413f86bc7ab038d7c1": "Ymultichange(Ymodifierchange,Ybodychange)",
    "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c": "Ybodychange",
    "689f66222bd8984dd69229a4ee9caf8da528ae12": "Ybodychange",
    "67604f618d96ae00318ce696ec29a66bec6aafa8": "Ybodychange",
    "78c6624b11d5f33504dae8211b4592383468343e": "Ymultichange(Yfilerename,Yreturntypechange,Ybodychange,Yparameterchange)",
    "70e64037ff295874602133a1d254e5a0440ae4e3": "Ybodychange",
    "3d2547f18886e771aaa9baa996a21136c93460c4": "Ybodychange",
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": "Yfilerename",
    "40ff76547064c3fb5acb9047a6f679dd4379a4d0": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "77471444ec81ad9452ebde7ca2b58db58a1f77d1": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t report connectionAcquired until actually connected. (#3566)\n\nCurrently our implementation acquires the connection early so that we have\r\nsomething to close if the call is canceled. Event listeners are simpler if\r\nthey only get a connectionAcquired event once the connection has been\r\nactually established.",
      "commitDate": "2017-09-01, 1:40 a.m.",
      "commitName": "77471444ec81ad9452ebde7ca2b58db58a1f77d1",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2017-05-06, 3:25 p.m.",
      "commitNameOld": "011b2ee76d41fc689be75e1aa4d2efd9fe33c285",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 117.43,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "actualSource": "  @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      if (connection.isEligible(address, route)) {\n        streamAllocation.acquire(connection, true);\n        return connection;\n      }\n    }\n    return null;\n  }",
      "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
      "functionStartLine": 122,
      "functionName": "get",
      "diff": "@@ -1,10 +1,10 @@\n   @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n       if (connection.isEligible(address, route)) {\n-        streamAllocation.acquire(connection);\n+        streamAllocation.acquire(connection, true);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Connection coalescing\n\nAs described here:\n\nhttps://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/\nhttps://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding\nhttps://tools.ietf.org/html/rfc7540#section-9.1.1\n\nWhen the following is true\n- HTTP/2 so we don\u0027t overload non multiplexed connections.\n- HTTPS since we need subjectAltNames (n.b. RFC 7540 defines as safe to use over plaintext, based purely on DNS).\n- Desired url host is part of the subjectAltNames for an existing connection.\n- One of the DNS results for desired host match the established connection.\n- HostnameVerifier is *not* overridden.\n- ConnectionPinner accepts the existing certificate chain.\n\nFrom https://tools.ietf.org/html/rfc7540#section-9.1.1\n\n\u003e A server that does not wish clients to reuse connections can indicate\n\u003e that it is not authoritative for a request by sending a 421\n\u003e (Misdirected Request) status code in response to the request (see\n\u003e Section 9.1.2).\n",
      "commitDate": "2017-03-05, 8:06 p.m.",
      "commitName": "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0",
      "commitAuthor": "Yuri Schimke",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Connection coalescing\n\nAs described here:\n\nhttps://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/\nhttps://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding\nhttps://tools.ietf.org/html/rfc7540#section-9.1.1\n\nWhen the following is true\n- HTTP/2 so we don\u0027t overload non multiplexed connections.\n- HTTPS since we need subjectAltNames (n.b. RFC 7540 defines as safe to use over plaintext, based purely on DNS).\n- Desired url host is part of the subjectAltNames for an existing connection.\n- One of the DNS results for desired host match the established connection.\n- HostnameVerifier is *not* overridden.\n- ConnectionPinner accepts the existing certificate chain.\n\nFrom https://tools.ietf.org/html/rfc7540#section-9.1.1\n\n\u003e A server that does not wish clients to reuse connections can indicate\n\u003e that it is not authoritative for a request by sending a 421\n\u003e (Misdirected Request) status code in response to the request (see\n\u003e Section 9.1.2).\n",
          "commitDate": "2017-03-05, 8:06 p.m.",
          "commitName": "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0",
          "commitAuthor": "Yuri Schimke",
          "commitDateOld": "2017-01-20, 2:54 p.m.",
          "commitNameOld": "5af089a71997fb454b0ef063664db267d8038a73",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 44.22,
          "commitsBetweenForRepo": 22,
          "commitsBetweenForFile": 1,
          "actualSource": "  RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      if (connection.isEligible(address, route)) {\n        streamAllocation.acquire(connection);\n        return connection;\n      }\n    }\n    return null;\n  }",
          "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
          "functionStartLine": 121,
          "functionName": "get",
          "diff": "@@ -1,10 +1,10 @@\n-  RealConnection get(Address address, StreamAllocation streamAllocation) {\n+  RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-      if (connection.isEligible(address)) {\n+      if (connection.isEligible(address, route)) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[address-Address, streamAllocation-StreamAllocation]",
            "newValue": "[address-Address, streamAllocation-StreamAllocation, route-Route]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Connection coalescing\n\nAs described here:\n\nhttps://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/\nhttps://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding\nhttps://tools.ietf.org/html/rfc7540#section-9.1.1\n\nWhen the following is true\n- HTTP/2 so we don\u0027t overload non multiplexed connections.\n- HTTPS since we need subjectAltNames (n.b. RFC 7540 defines as safe to use over plaintext, based purely on DNS).\n- Desired url host is part of the subjectAltNames for an existing connection.\n- One of the DNS results for desired host match the established connection.\n- HostnameVerifier is *not* overridden.\n- ConnectionPinner accepts the existing certificate chain.\n\nFrom https://tools.ietf.org/html/rfc7540#section-9.1.1\n\n\u003e A server that does not wish clients to reuse connections can indicate\n\u003e that it is not authoritative for a request by sending a 421\n\u003e (Misdirected Request) status code in response to the request (see\n\u003e Section 9.1.2).\n",
          "commitDate": "2017-03-05, 8:06 p.m.",
          "commitName": "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0",
          "commitAuthor": "Yuri Schimke",
          "commitDateOld": "2017-01-20, 2:54 p.m.",
          "commitNameOld": "5af089a71997fb454b0ef063664db267d8038a73",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 44.22,
          "commitsBetweenForRepo": 22,
          "commitsBetweenForFile": 1,
          "actualSource": "  RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      if (connection.isEligible(address, route)) {\n        streamAllocation.acquire(connection);\n        return connection;\n      }\n    }\n    return null;\n  }",
          "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
          "functionStartLine": 121,
          "functionName": "get",
          "diff": "@@ -1,10 +1,10 @@\n-  RealConnection get(Address address, StreamAllocation streamAllocation) {\n+  RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-      if (connection.isEligible(address)) {\n+      if (connection.isEligible(address, route)) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "98443a9ca8ca9ad82d5fb9b05b32f180bb510601": {
      "type": "Ybodychange",
      "commitMessage": "Release duplicated multiplexed connections.\n\nIf we make concurrent requests to an HTTP/2 server, close all but\nthe first connection. Creating multiple connections and then later\nreleasing them is somewhat pessimistic; it\u0027s also much safer for\nawkward cases like connect attempts being canceled.\n\nCloses: https://github.com/square/okhttp/issues/373\n",
      "commitDate": "2017-01-07, 2:15 p.m.",
      "commitName": "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-08-07, 11:51 a.m.",
      "commitNameOld": "ecbcd51fc99c565496be15cfd7eadca465ae4a06",
      "commitAuthorOld": "Dave Roberge",
      "daysBetweenCommits": 153.14,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "actualSource": "  RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      if (connection.isEligible(address)) {\n        streamAllocation.acquire(connection);\n        return connection;\n      }\n    }\n    return null;\n  }",
      "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
      "functionStartLine": 118,
      "functionName": "get",
      "diff": "@@ -1,12 +1,10 @@\n   RealConnection get(Address address, StreamAllocation streamAllocation) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-      if (connection.allocations.size() \u003c connection.allocationLimit\n-          \u0026\u0026 address.equals(connection.route().address)\n-          \u0026\u0026 !connection.noNewStreams) {\n+      if (connection.isEligible(address)) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "75ebcd5cd13995c3b70e0b621d3204b9a5996806": {
      "type": "Ybodychange",
      "commitMessage": "Use listeners to observe allocation limit changes.\n\nThis removes some awkward code where the synchronized connection pool is calling\na synchronized methond on a connection. Nested synchronized is gross.\n",
      "commitDate": "2016-01-16, 12:29 a.m.",
      "commitName": "75ebcd5cd13995c3b70e0b621d3204b9a5996806",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-01-02, 2:07 a.m.",
      "commitNameOld": "7826bcb2fb1facb697a4c512776756c05d8c9deb",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 13.93,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "  RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      if (connection.allocations.size() \u003c connection.allocationLimit\n          \u0026\u0026 address.equals(connection.route().address)\n          \u0026\u0026 !connection.noNewStreams) {\n        streamAllocation.acquire(connection);\n        return connection;\n      }\n    }\n    return null;\n  }",
      "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
      "functionStartLine": 117,
      "functionName": "get",
      "diff": "@@ -1,14 +1,12 @@\n   RealConnection get(Address address, StreamAllocation streamAllocation) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-      // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n-      //     connection.allocationLimit() may also lock the FramedConnection.\n-      if (connection.allocations.size() \u003c connection.allocationLimit()\n+      if (connection.allocations.size() \u003c connection.allocationLimit\n           \u0026\u0026 address.equals(connection.route().address)\n           \u0026\u0026 !connection.noNewStreams) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02d6b4e78c4f1bda5f20e3089af024c58fe6baf6": {
      "type": "Ybodychange",
      "commitMessage": "Drop the get prefix on Connection accessors.\n",
      "commitDate": "2015-12-21, 9:10 p.m.",
      "commitName": "02d6b4e78c4f1bda5f20e3089af024c58fe6baf6",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-12-16, 1:34 a.m.",
      "commitNameOld": "c9a89876de476983f273edbf108c365127c18c5e",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 5.82,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "  RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n      //     connection.allocationLimit() may also lock the FramedConnection.\n      if (connection.allocations.size() \u003c connection.allocationLimit()\n          \u0026\u0026 address.equals(connection.route().address)\n          \u0026\u0026 !connection.noNewStreams) {\n        streamAllocation.acquire(connection);\n        return connection;\n      }\n    }\n    return null;\n  }",
      "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
      "functionStartLine": 167,
      "functionName": "get",
      "diff": "@@ -1,14 +1,14 @@\n   RealConnection get(Address address, StreamAllocation streamAllocation) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n       // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n       //     connection.allocationLimit() may also lock the FramedConnection.\n       if (connection.allocations.size() \u003c connection.allocationLimit()\n-          \u0026\u0026 address.equals(connection.getRoute().address)\n+          \u0026\u0026 address.equals(connection.route().address)\n           \u0026\u0026 !connection.noNewStreams) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9a89876de476983f273edbf108c365127c18c5e": {
      "type": "Yfilerename",
      "commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
      "commitDate": "2015-12-16, 1:34 a.m.",
      "commitName": "c9a89876de476983f273edbf108c365127c18c5e",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-12-15, 9:36 p.m.",
      "commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n      //     connection.allocationLimit() may also lock the FramedConnection.\n      if (connection.allocations.size() \u003c connection.allocationLimit()\n          \u0026\u0026 address.equals(connection.getRoute().address)\n          \u0026\u0026 !connection.noNewStreams) {\n        streamAllocation.acquire(connection);\n        return connection;\n      }\n    }\n    return null;\n  }",
      "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
      "functionStartLine": 165,
      "functionName": "get",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
        "newPath": "okhttp/src/main/java/okhttp3/ConnectionPool.java"
      }
    },
    "c099f69d0b7198a40e4a6373ae564b65d04363ef": {
      "type": "Ymultichange(Yreturntypechange,Ymodifierchange,Ybodychange)",
      "commitMessage": "Hide overly-visible APIs in ConnectionPool.\n",
      "commitDate": "2015-12-13, 9:18 a.m.",
      "commitName": "c099f69d0b7198a40e4a6373ae564b65d04363ef",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Hide overly-visible APIs in ConnectionPool.\n",
          "commitDate": "2015-12-13, 9:18 a.m.",
          "commitName": "c099f69d0b7198a40e4a6373ae564b65d04363ef",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015-12-08, 10:05 p.m.",
          "commitNameOld": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.47,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "  RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n      //     connection.allocationLimit() may also lock the FramedConnection.\n      if (connection.allocations.size() \u003c connection.allocationLimit()\n          \u0026\u0026 address.equals(connection.getRoute().address)\n          \u0026\u0026 !connection.noNewStreams) {\n        streamAllocation.acquire(connection);\n        return connection;\n      }\n    }\n    return null;\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 171,
          "functionName": "get",
          "diff": "@@ -1,13 +1,14 @@\n-  public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n+  RealConnection get(Address address, StreamAllocation streamAllocation) {\n+    assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n       // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n       //     connection.allocationLimit() may also lock the FramedConnection.\n       if (connection.allocations.size() \u003c connection.allocationLimit()\n           \u0026\u0026 address.equals(connection.getRoute().address)\n           \u0026\u0026 !connection.noNewStreams) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Connection",
            "newValue": "RealConnection"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Hide overly-visible APIs in ConnectionPool.\n",
          "commitDate": "2015-12-13, 9:18 a.m.",
          "commitName": "c099f69d0b7198a40e4a6373ae564b65d04363ef",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015-12-08, 10:05 p.m.",
          "commitNameOld": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.47,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "  RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n      //     connection.allocationLimit() may also lock the FramedConnection.\n      if (connection.allocations.size() \u003c connection.allocationLimit()\n          \u0026\u0026 address.equals(connection.getRoute().address)\n          \u0026\u0026 !connection.noNewStreams) {\n        streamAllocation.acquire(connection);\n        return connection;\n      }\n    }\n    return null;\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 171,
          "functionName": "get",
          "diff": "@@ -1,13 +1,14 @@\n-  public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n+  RealConnection get(Address address, StreamAllocation streamAllocation) {\n+    assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n       // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n       //     connection.allocationLimit() may also lock the FramedConnection.\n       if (connection.allocations.size() \u003c connection.allocationLimit()\n           \u0026\u0026 address.equals(connection.getRoute().address)\n           \u0026\u0026 !connection.noNewStreams) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Hide overly-visible APIs in ConnectionPool.\n",
          "commitDate": "2015-12-13, 9:18 a.m.",
          "commitName": "c099f69d0b7198a40e4a6373ae564b65d04363ef",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015-12-08, 10:05 p.m.",
          "commitNameOld": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.47,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "  RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n      //     connection.allocationLimit() may also lock the FramedConnection.\n      if (connection.allocations.size() \u003c connection.allocationLimit()\n          \u0026\u0026 address.equals(connection.getRoute().address)\n          \u0026\u0026 !connection.noNewStreams) {\n        streamAllocation.acquire(connection);\n        return connection;\n      }\n    }\n    return null;\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 171,
          "functionName": "get",
          "diff": "@@ -1,13 +1,14 @@\n-  public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n+  RealConnection get(Address address, StreamAllocation streamAllocation) {\n+    assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n       // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n       //     connection.allocationLimit() may also lock the FramedConnection.\n       if (connection.allocations.size() \u003c connection.allocationLimit()\n           \u0026\u0026 address.equals(connection.getRoute().address)\n           \u0026\u0026 !connection.noNewStreams) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "4ae314a1f21d07ee5dbad024bc098182219e9e07": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Detect leaked connections.\n\nThis is already suggesting some bugs in OkHttp itself.\n",
      "commitDate": "2015-12-08, 10:05 p.m.",
      "commitName": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Detect leaked connections.\n\nThis is already suggesting some bugs in OkHttp itself.\n",
          "commitDate": "2015-12-08, 10:05 p.m.",
          "commitName": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015-12-07, 10:43 p.m.",
          "commitNameOld": "9ffc45dbe0b9ef80ab5cf972a176548781d2206a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 0.97,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "  public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n    for (RealConnection connection : connections) {\n      // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n      //     connection.allocationLimit() may also lock the FramedConnection.\n      if (connection.allocations.size() \u003c connection.allocationLimit()\n          \u0026\u0026 address.equals(connection.getRoute().address)\n          \u0026\u0026 !connection.noNewStreams) {\n        streamAllocation.acquire(connection);\n        return connection;\n      }\n    }\n    return null;\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 171,
          "functionName": "get",
          "diff": "@@ -1,13 +1,13 @@\n-  public synchronized Connection get(Address address) {\n+  public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n     for (RealConnection connection : connections) {\n       // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n       //     connection.allocationLimit() may also lock the FramedConnection.\n-      if (connection.allocationCount \u003c connection.allocationLimit()\n+      if (connection.allocations.size() \u003c connection.allocationLimit()\n           \u0026\u0026 address.equals(connection.getRoute().address)\n           \u0026\u0026 !connection.noNewStreams) {\n-        connection.allocationCount++;\n+        streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[address-Address]",
            "newValue": "[address-Address, streamAllocation-StreamAllocation]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Detect leaked connections.\n\nThis is already suggesting some bugs in OkHttp itself.\n",
          "commitDate": "2015-12-08, 10:05 p.m.",
          "commitName": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015-12-07, 10:43 p.m.",
          "commitNameOld": "9ffc45dbe0b9ef80ab5cf972a176548781d2206a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 0.97,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "  public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n    for (RealConnection connection : connections) {\n      // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n      //     connection.allocationLimit() may also lock the FramedConnection.\n      if (connection.allocations.size() \u003c connection.allocationLimit()\n          \u0026\u0026 address.equals(connection.getRoute().address)\n          \u0026\u0026 !connection.noNewStreams) {\n        streamAllocation.acquire(connection);\n        return connection;\n      }\n    }\n    return null;\n  }",
          "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 171,
          "functionName": "get",
          "diff": "@@ -1,13 +1,13 @@\n-  public synchronized Connection get(Address address) {\n+  public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n     for (RealConnection connection : connections) {\n       // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n       //     connection.allocationLimit() may also lock the FramedConnection.\n-      if (connection.allocationCount \u003c connection.allocationLimit()\n+      if (connection.allocations.size() \u003c connection.allocationLimit()\n           \u0026\u0026 address.equals(connection.getRoute().address)\n           \u0026\u0026 !connection.noNewStreams) {\n-        connection.allocationCount++;\n+        streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "c5f58e45454d1ffc621c65e377cb91345018e087": {
      "type": "Ybodychange",
      "commitMessage": "Honor the max concurrent streams setting.\n\nCloses https://github.com/square/okhttp/issues/1484\n",
      "commitDate": "2015-12-02, 12:44 p.m.",
      "commitName": "c5f58e45454d1ffc621c65e377cb91345018e087",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-11-28, 9:36 a.m.",
      "commitNameOld": "c358656c8799d30fd422448153e99a5dd37e298a",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 4.13,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "  public synchronized Connection get(Address address) {\n    for (RealConnection connection : connections) {\n      // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n      //     connection.allocationLimit() may also lock the FramedConnection.\n      if (connection.allocationCount \u003c connection.allocationLimit()\n          \u0026\u0026 address.equals(connection.getRoute().address)\n          \u0026\u0026 !connection.noNewStreams) {\n        connection.allocationCount++;\n        return connection;\n      }\n    }\n    return null;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 127,
      "functionName": "get",
      "diff": "@@ -1,11 +1,13 @@\n   public synchronized Connection get(Address address) {\n     for (RealConnection connection : connections) {\n-      if (connection.allocationCount \u003c connection.allocationLimit\n+      // TODO(jwilson): this is awkward. We\u0027re already holding a lock on \u0027this\u0027, and\n+      //     connection.allocationLimit() may also lock the FramedConnection.\n+      if (connection.allocationCount \u003c connection.allocationLimit()\n           \u0026\u0026 address.equals(connection.getRoute().address)\n           \u0026\u0026 !connection.noNewStreams) {\n         connection.allocationCount++;\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c358656c8799d30fd422448153e99a5dd37e298a": {
      "type": "Ybodychange",
      "commitMessage": "First draft of the new new stream allocations model.\n",
      "commitDate": "2015-11-28, 9:36 a.m.",
      "commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-11-09, 8:12 a.m.",
      "commitNameOld": "49a331385343f3ca49d26c4ddd947546867bcd3b",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 19.06,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "  public synchronized Connection get(Address address) {\n    for (RealConnection connection : connections) {\n      if (connection.allocationCount \u003c connection.allocationLimit\n          \u0026\u0026 address.equals(connection.getRoute().address)\n          \u0026\u0026 !connection.noNewStreams) {\n        connection.allocationCount++;\n        return connection;\n      }\n    }\n    return null;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 127,
      "functionName": "get",
      "diff": "@@ -1,30 +1,11 @@\n   public synchronized Connection get(Address address) {\n-    Connection foundConnection \u003d null;\n-    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n-      Connection connection \u003d i.next();\n-      if (!connection.getRoute().getAddress().equals(address)\n-          || !connection.isAlive()\n-          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n-        continue;\n+    for (RealConnection connection : connections) {\n+      if (connection.allocationCount \u003c connection.allocationLimit\n+          \u0026\u0026 address.equals(connection.getRoute().address)\n+          \u0026\u0026 !connection.noNewStreams) {\n+        connection.allocationCount++;\n+        return connection;\n       }\n-      i.remove();\n-      if (!connection.isFramed()) {\n-        try {\n-          Platform.get().tagSocket(connection.getSocket());\n-        } catch (SocketException e) {\n-          Util.closeQuietly(connection.getSocket());\n-          // When unable to tag, skip recycling and close\n-          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-          continue;\n-        }\n-      }\n-      foundConnection \u003d connection;\n-      break;\n     }\n-\n-    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isFramed()) {\n-      connections.addFirst(foundConnection); // Add it back after iteration.\n-    }\n-\n-    return foundConnection;\n+    return null;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "49a331385343f3ca49d26c4ddd947546867bcd3b": {
      "type": "Ybodychange",
      "commitMessage": "Connection allocations model.\n\nThis is intended to replace some of the state machines in HttpConnection, HttpEngine,\nand ConnectionPool. With this we\u0027ll keep track of all streams in flight, not just\nthe connections currently idle.\n\nNote that I\u0027ve sketched this out into a new Connection.java class. In a follow up\nchange I\u0027ll attempt to combine this with the existing Connection class.\n",
      "commitDate": "2015-11-09, 8:12 a.m.",
      "commitName": "49a331385343f3ca49d26c4ddd947546867bcd3b",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-06-17, 6:40 p.m.",
      "commitNameOld": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 144.61,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "actualSource": "  public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n      Connection connection \u003d i.next();\n      if (!connection.getRoute().getAddress().equals(address)\n          || !connection.isAlive()\n          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n        continue;\n      }\n      i.remove();\n      if (!connection.isFramed()) {\n        try {\n          Platform.get().tagSocket(connection.getSocket());\n        } catch (SocketException e) {\n          Util.closeQuietly(connection.getSocket());\n          // When unable to tag, skip recycling and close\n          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n          continue;\n        }\n      }\n      foundConnection \u003d connection;\n      break;\n    }\n\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isFramed()) {\n      connections.addFirst(foundConnection); // Add it back after iteration.\n    }\n\n    return foundConnection;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 137,
      "functionName": "get",
      "diff": "@@ -1,31 +1,30 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n-    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n-        i.hasPrevious(); ) {\n-      Connection connection \u003d i.previous();\n+    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n+      Connection connection \u003d i.next();\n       if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isFramed()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection.getSocket());\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection \u003d connection;\n       break;\n     }\n \n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isFramed()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n     }\n \n     return foundConnection;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80": {
      "type": "Ybodychange",
      "commitMessage": "Rename \u0027spdy\u0027 references to \u0027framed\u0027 where appropriate.\n",
      "commitDate": "2015-06-17, 6:40 p.m.",
      "commitName": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2015-01-13, 6:33 p.m.",
      "commitNameOld": "e3d39f7ec069ad49bac7c59c2f2384dd2adf71dd",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 154.96,
      "commitsBetweenForRepo": 131,
      "commitsBetweenForFile": 1,
      "actualSource": "  public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n        i.hasPrevious(); ) {\n      Connection connection \u003d i.previous();\n      if (!connection.getRoute().getAddress().equals(address)\n          || !connection.isAlive()\n          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n        continue;\n      }\n      i.remove();\n      if (!connection.isFramed()) {\n        try {\n          Platform.get().tagSocket(connection.getSocket());\n        } catch (SocketException e) {\n          Util.closeQuietly(connection.getSocket());\n          // When unable to tag, skip recycling and close\n          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n          continue;\n        }\n      }\n      foundConnection \u003d connection;\n      break;\n    }\n\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isFramed()) {\n      connections.addFirst(foundConnection); // Add it back after iteration.\n    }\n\n    return foundConnection;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 136,
      "functionName": "get",
      "diff": "@@ -1,31 +1,31 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n     for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n         i.hasPrevious(); ) {\n       Connection connection \u003d i.previous();\n       if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n-      if (!connection.isSpdy()) {\n+      if (!connection.isFramed()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection.getSocket());\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection \u003d connection;\n       break;\n     }\n \n-    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n+    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isFramed()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n     }\n \n     return foundConnection;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "98c74ace40b089f2769afb3e56c59a64eef327cb": {
      "type": "Ybodychange",
      "commitMessage": "Respect the max idle connections limit.\n\nThe structure here is a bit ugly. But it permits a single \u0027synchronized\u0027\nblock, which makes the method easier to reason about.\n\nCloses https://github.com/square/okhttp/issues/1239\n",
      "commitDate": "2014-12-29, 10:10 a.m.",
      "commitName": "98c74ace40b089f2769afb3e56c59a64eef327cb",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-12-26, 1:20 a.m.",
      "commitNameOld": "8c7c963c24c3e347fd0d0fd641c27058d4eadc2c",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 3.37,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "  public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n        i.hasPrevious(); ) {\n      Connection connection \u003d i.previous();\n      if (!connection.getRoute().getAddress().equals(address)\n          || !connection.isAlive()\n          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n        continue;\n      }\n      i.remove();\n      if (!connection.isSpdy()) {\n        try {\n          Platform.get().tagSocket(connection.getSocket());\n        } catch (SocketException e) {\n          Util.closeQuietly(connection.getSocket());\n          // When unable to tag, skip recycling and close\n          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n          continue;\n        }\n      }\n      foundConnection \u003d connection;\n      break;\n    }\n\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n      connections.addFirst(foundConnection); // Add it back after iteration.\n    }\n\n    return foundConnection;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 136,
      "functionName": "get",
      "diff": "@@ -1,32 +1,31 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n     for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n         i.hasPrevious(); ) {\n       Connection connection \u003d i.previous();\n       if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isSpdy()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection.getSocket());\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection \u003d connection;\n       break;\n     }\n \n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n-      scheduleCleanupAsRequired();\n     }\n \n     return foundConnection;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a8327d121b9eeb3b61ae63f06095d423936a5da2": {
      "type": "Ybodychange",
      "commitMessage": "Fix for a socket leak in OkHttp on Android\n\nWhen the preferred Android network changes from\ncell -\u003e wifi or wifi -\u003e cell the HTTP connection\npool in use is abandoned to avoid reuse of\nconnections on the old network. This was added\nin commit 8bced3e.\n\nThe design for the connection pool was such that\ncontinuous use of the connection pool was required to\nclean up idle / expired connections. If a connection\npool becomes idle (as when it is dereferenced on a\nnetwork change) it is possible for some connections\nto remain in the pool indefinitely.\n\nAfter the preferred network change, because the old\nconnection pool was no longer referenced the pool\nwould be garbage collected and Android\u0027s \"Strict Mode\"\nwould complain about sockets not being closed.\n\nThe only existing way to avoid this was to call\n\"evictAll()\", which would have had issues when a\nlarge number of connections were returned to the pool\nafter evictAll() was called. It also wouldn\u0027t work\nfor SPDY connections which are shared but not reference\ncounted, which makes knowing whether it is safe to\nclose them difficult.\n\nThe cleanModeRunnable serves two purposes:\n\n1) While scheduled / executing, it pins the connection\npool in memory to avoid it being garbage collected.\n2) It continues to close connections (safely) until the\npool is empty.\n\nIf a connection is then added back to the pool the\ncleanModeRunnable is restarted.\n",
      "commitDate": "2014-12-18, 11:19 a.m.",
      "commitName": "a8327d121b9eeb3b61ae63f06095d423936a5da2",
      "commitAuthor": "Neil Fuller",
      "commitDateOld": "2014-06-17, 4:36 p.m.",
      "commitNameOld": "cdd71f1bbd32f20d63d7100787b91c327d1b5b0c",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 183.82,
      "commitsBetweenForRepo": 121,
      "commitsBetweenForFile": 1,
      "actualSource": "  public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n        i.hasPrevious(); ) {\n      Connection connection \u003d i.previous();\n      if (!connection.getRoute().getAddress().equals(address)\n          || !connection.isAlive()\n          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n        continue;\n      }\n      i.remove();\n      if (!connection.isSpdy()) {\n        try {\n          Platform.get().tagSocket(connection.getSocket());\n        } catch (SocketException e) {\n          Util.closeQuietly(connection.getSocket());\n          // When unable to tag, skip recycling and close\n          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n          continue;\n        }\n      }\n      foundConnection \u003d connection;\n      break;\n    }\n\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n      connections.addFirst(foundConnection); // Add it back after iteration.\n      scheduleCleanupAsRequired();\n    }\n\n    return foundConnection;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 162,
      "functionName": "get",
      "diff": "@@ -1,32 +1,32 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n     for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n         i.hasPrevious(); ) {\n       Connection connection \u003d i.previous();\n       if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isSpdy()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection.getSocket());\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection \u003d connection;\n       break;\n     }\n \n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n+      scheduleCleanupAsRequired();\n     }\n \n-    executorService.execute(connectionsCleanupRunnable);\n     return foundConnection;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c26f9af0489869a9e1873ed5010c65f8464cff26": {
      "type": "Ybodychange",
      "commitMessage": "Hide ConnectionPool.recycle and share.\n",
      "commitDate": "2014-04-30, 10:02 p.m.",
      "commitName": "c26f9af0489869a9e1873ed5010c65f8464cff26",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-04-20, 11:26 a.m.",
      "commitNameOld": "6e373d870e1be071cd67c350928e44745c72f499",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 10.44,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "  public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n        i.hasPrevious(); ) {\n      Connection connection \u003d i.previous();\n      if (!connection.getRoute().getAddress().equals(address)\n          || !connection.isAlive()\n          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n        continue;\n      }\n      i.remove();\n      if (!connection.isSpdy()) {\n        try {\n          Platform.get().tagSocket(connection.getSocket());\n        } catch (SocketException e) {\n          Util.closeQuietly(connection.getSocket());\n          // When unable to tag, skip recycling and close\n          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n          continue;\n        }\n      }\n      foundConnection \u003d connection;\n      break;\n    }\n\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n      connections.addFirst(foundConnection); // Add it back after iteration.\n    }\n\n    executorService.execute(connectionsCleanupRunnable);\n    return foundConnection;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 177,
      "functionName": "get",
      "diff": "@@ -1,32 +1,32 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n     for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n         i.hasPrevious(); ) {\n       Connection connection \u003d i.previous();\n       if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isSpdy()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n-          Util.closeQuietly(connection);\n+          Util.closeQuietly(connection.getSocket());\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection \u003d connection;\n       break;\n     }\n \n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n     }\n \n     executorService.execute(connectionsCleanupRunnable);\n     return foundConnection;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fdee6f13a4c5bf5bd24f2c237c2996aea01cc5ff": {
      "type": "Ybodychange",
      "commitMessage": "FindBugs sweep.\n",
      "commitDate": "2014-02-05, 11:18 a.m.",
      "commitName": "fdee6f13a4c5bf5bd24f2c237c2996aea01cc5ff",
      "commitAuthor": "Adrian Cole and Jesse Wilson",
      "commitDateOld": "2014-01-12, 9:47 a.m.",
      "commitNameOld": "749a65b776c8fc4b39b6463695980275da34da51",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 24.06,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "actualSource": "  public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n        i.hasPrevious(); ) {\n      Connection connection \u003d i.previous();\n      if (!connection.getRoute().getAddress().equals(address)\n          || !connection.isAlive()\n          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n        continue;\n      }\n      i.remove();\n      if (!connection.isSpdy()) {\n        try {\n          Platform.get().tagSocket(connection.getSocket());\n        } catch (SocketException e) {\n          Util.closeQuietly(connection);\n          // When unable to tag, skip recycling and close\n          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n          continue;\n        }\n      }\n      foundConnection \u003d connection;\n      break;\n    }\n\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n      connections.addFirst(foundConnection); // Add it back after iteration.\n    }\n\n    executorService.execute(connectionsCleanupRunnable);\n    return foundConnection;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 177,
      "functionName": "get",
      "diff": "@@ -1,32 +1,32 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n     for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n         i.hasPrevious(); ) {\n       Connection connection \u003d i.previous();\n       if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isSpdy()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection);\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection \u003d connection;\n       break;\n     }\n \n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n     }\n \n-    executorService.submit(connectionsCleanupCallable);\n+    executorService.execute(connectionsCleanupRunnable);\n     return foundConnection;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1ece746c815a26782042b1fca6069eb527d1029b": {
      "type": "Ybodychange",
      "commitMessage": "RouteSelector tries previously failed routes last #106\n",
      "commitDate": "2013-04-10, 6:19 p.m.",
      "commitName": "1ece746c815a26782042b1fca6069eb527d1029b",
      "commitAuthor": "Marcelo Cortes",
      "commitDateOld": "2013-03-25, 11:04 p.m.",
      "commitNameOld": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 15.8,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "  public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n        i.hasPrevious(); ) {\n      Connection connection \u003d i.previous();\n      if (!connection.getRoute().getAddress().equals(address)\n          || !connection.isAlive()\n          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n        continue;\n      }\n      i.remove();\n      if (!connection.isSpdy()) {\n        try {\n          Platform.get().tagSocket(connection.getSocket());\n        } catch (SocketException e) {\n          Util.closeQuietly(connection);\n          // When unable to tag, skip recycling and close\n          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n          continue;\n        }\n      }\n      foundConnection \u003d connection;\n      break;\n    }\n\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n      connections.addFirst(foundConnection); // Add it back after iteration.\n    }\n\n    executorService.submit(connectionsCleanupCallable);\n    return foundConnection;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 162,
      "functionName": "get",
      "diff": "@@ -1,32 +1,32 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n     for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n         i.hasPrevious(); ) {\n       Connection connection \u003d i.previous();\n-      if (!connection.getAddress().equals(address)\n+      if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isSpdy()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection);\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection \u003d connection;\n       break;\n     }\n \n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n     }\n \n     executorService.submit(connectionsCleanupCallable);\n     return foundConnection;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": {
      "type": "Yfilerename",
      "commitMessage": "Move library into a module. Introduce sample module with simple GitHub client.\n",
      "commitDate": "2013-03-25, 11:04 p.m.",
      "commitName": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2013-03-15, 10:39 a.m.",
      "commitNameOld": "ba2b7432cb9fabfc725b09a9f14878cb128ef208",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 10.52,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n        i.hasPrevious(); ) {\n      Connection connection \u003d i.previous();\n      if (!connection.getAddress().equals(address)\n          || !connection.isAlive()\n          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n        continue;\n      }\n      i.remove();\n      if (!connection.isSpdy()) {\n        try {\n          Platform.get().tagSocket(connection.getSocket());\n        } catch (SocketException e) {\n          Util.closeQuietly(connection);\n          // When unable to tag, skip recycling and close\n          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n          continue;\n        }\n      }\n      foundConnection \u003d connection;\n      break;\n    }\n\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n      connections.addFirst(foundConnection); // Add it back after iteration.\n    }\n\n    executorService.submit(connectionsCleanupCallable);\n    return foundConnection;\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 162,
      "functionName": "get",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
        "newPath": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java"
      }
    },
    "f373e2d6e5bfaa86afc147b877a72d600c224c5d": {
      "type": "Ybodychange",
      "commitMessage": "Fix froyo bug: no more descendingIterator\n",
      "commitDate": "2013-02-27, 7:19 p.m.",
      "commitName": "f373e2d6e5bfaa86afc147b877a72d600c224c5d",
      "commitAuthor": "Eric Denman",
      "commitDateOld": "2013-02-27, 11:31 a.m.",
      "commitNameOld": "220b5f9a3bac6b78f6ad2d2e159057eb9bcb9908",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.33,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n        i.hasPrevious(); ) {\n      Connection connection \u003d i.previous();\n      if (!connection.getAddress().equals(address)\n          || !connection.isAlive()\n          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n        continue;\n      }\n      i.remove();\n      if (!connection.isSpdy()) {\n        try {\n          Platform.get().tagSocket(connection.getSocket());\n        } catch (SocketException e) {\n          Util.closeQuietly(connection);\n          // When unable to tag, skip recycling and close\n          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n          continue;\n        }\n      }\n      foundConnection \u003d connection;\n      break;\n    }\n\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n      connections.addFirst(foundConnection); // Add it back after iteration.\n    }\n\n    executorService.submit(connectionsCleanupCallable);\n    return foundConnection;\n  }",
      "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 162,
      "functionName": "get",
      "diff": "@@ -1,31 +1,32 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n-    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n-      Connection connection \u003d i.next();\n+    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size());\n+        i.hasPrevious(); ) {\n+      Connection connection \u003d i.previous();\n       if (!connection.getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isSpdy()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection);\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection \u003d connection;\n       break;\n     }\n \n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n     }\n \n     executorService.submit(connectionsCleanupCallable);\n     return foundConnection;\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f6d959fdae64065521990413f86bc7ab038d7c1": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "Improvements to connection pool\n",
      "commitDate": "2013-01-31, 5:23 p.m.",
      "commitName": "6f6d959fdae64065521990413f86bc7ab038d7c1",
      "commitAuthor": "Marcelo Cortes",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "Improvements to connection pool\n",
          "commitDate": "2013-01-31, 5:23 p.m.",
          "commitName": "6f6d959fdae64065521990413f86bc7ab038d7c1",
          "commitAuthor": "Marcelo Cortes",
          "commitDateOld": "2013-01-06, 6:30 p.m.",
          "commitNameOld": "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 24.95,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "  public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n      Connection connection \u003d i.next();\n      if (!connection.getAddress().equals(address)\n          || !connection.isAlive()\n          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n        continue;\n      }\n      i.remove();\n      if (!connection.isSpdy()) {\n        try {\n          Platform.get().tagSocket(connection.getSocket());\n        } catch (SocketException e) {\n          Util.closeQuietly(connection);\n          // When unable to tag, skip recycling and close\n          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n          continue;\n        }\n      }\n      foundConnection \u003d connection;\n      break;\n    }\n\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n      connections.addFirst(foundConnection); // Add it back after iteration.\n    }\n\n    executorService.submit(connectionsCleanupCallable);\n    return foundConnection;\n  }",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 163,
          "functionName": "get",
          "diff": "@@ -1,34 +1,31 @@\n-    public Connection get(Address address) {\n-        // First try to reuse an existing HTTP connection.\n-        synchronized (connectionPool) {\n-            List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n-            while (connections !\u003d null) {\n-                Connection connection \u003d connections.get(connections.size() - 1);\n-                boolean usable \u003d connection.isEligibleForRecycling();\n-                if (usable \u0026\u0026 !connection.isSpdy()) {\n-                    try {\n-                        Platform.get().tagSocket(connection.getSocket());\n-                    } catch (SocketException e) {\n-                        // When unable to tag, skip recycling and close\n-                        Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                        usable \u003d false;\n-                    }\n-                }\n-\n-                if (!connection.isSpdy() || !usable) {\n-                    connections.remove(connections.size() - 1);\n-                    if (connections.isEmpty()) {\n-                        connectionPool.remove(address);\n-                        connections \u003d null;\n-                    }\n-                }\n-\n-                if (usable) {\n-                    return connection;\n-                } else {\n-                    Util.closeQuietly(connection);\n-                }\n-            }\n+  public synchronized Connection get(Address address) {\n+    Connection foundConnection \u003d null;\n+    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n+      Connection connection \u003d i.next();\n+      if (!connection.getAddress().equals(address)\n+          || !connection.isAlive()\n+          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n+        continue;\n+      }\n+      i.remove();\n+      if (!connection.isSpdy()) {\n+        try {\n+          Platform.get().tagSocket(connection.getSocket());\n+        } catch (SocketException e) {\n+          Util.closeQuietly(connection);\n+          // When unable to tag, skip recycling and close\n+          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n+          continue;\n         }\n-        return null;\n-    }\n\\ No newline at end of file\n+      }\n+      foundConnection \u003d connection;\n+      break;\n+    }\n+\n+    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n+      connections.addFirst(foundConnection); // Add it back after iteration.\n+    }\n+\n+    executorService.submit(connectionsCleanupCallable);\n+    return foundConnection;\n+  }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[public, synchronized]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Improvements to connection pool\n",
          "commitDate": "2013-01-31, 5:23 p.m.",
          "commitName": "6f6d959fdae64065521990413f86bc7ab038d7c1",
          "commitAuthor": "Marcelo Cortes",
          "commitDateOld": "2013-01-06, 6:30 p.m.",
          "commitNameOld": "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 24.95,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "  public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n      Connection connection \u003d i.next();\n      if (!connection.getAddress().equals(address)\n          || !connection.isAlive()\n          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n        continue;\n      }\n      i.remove();\n      if (!connection.isSpdy()) {\n        try {\n          Platform.get().tagSocket(connection.getSocket());\n        } catch (SocketException e) {\n          Util.closeQuietly(connection);\n          // When unable to tag, skip recycling and close\n          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n          continue;\n        }\n      }\n      foundConnection \u003d connection;\n      break;\n    }\n\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n      connections.addFirst(foundConnection); // Add it back after iteration.\n    }\n\n    executorService.submit(connectionsCleanupCallable);\n    return foundConnection;\n  }",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 163,
          "functionName": "get",
          "diff": "@@ -1,34 +1,31 @@\n-    public Connection get(Address address) {\n-        // First try to reuse an existing HTTP connection.\n-        synchronized (connectionPool) {\n-            List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n-            while (connections !\u003d null) {\n-                Connection connection \u003d connections.get(connections.size() - 1);\n-                boolean usable \u003d connection.isEligibleForRecycling();\n-                if (usable \u0026\u0026 !connection.isSpdy()) {\n-                    try {\n-                        Platform.get().tagSocket(connection.getSocket());\n-                    } catch (SocketException e) {\n-                        // When unable to tag, skip recycling and close\n-                        Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                        usable \u003d false;\n-                    }\n-                }\n-\n-                if (!connection.isSpdy() || !usable) {\n-                    connections.remove(connections.size() - 1);\n-                    if (connections.isEmpty()) {\n-                        connectionPool.remove(address);\n-                        connections \u003d null;\n-                    }\n-                }\n-\n-                if (usable) {\n-                    return connection;\n-                } else {\n-                    Util.closeQuietly(connection);\n-                }\n-            }\n+  public synchronized Connection get(Address address) {\n+    Connection foundConnection \u003d null;\n+    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n+      Connection connection \u003d i.next();\n+      if (!connection.getAddress().equals(address)\n+          || !connection.isAlive()\n+          || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n+        continue;\n+      }\n+      i.remove();\n+      if (!connection.isSpdy()) {\n+        try {\n+          Platform.get().tagSocket(connection.getSocket());\n+        } catch (SocketException e) {\n+          Util.closeQuietly(connection);\n+          // When unable to tag, skip recycling and close\n+          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n+          continue;\n         }\n-        return null;\n-    }\n\\ No newline at end of file\n+      }\n+      foundConnection \u003d connection;\n+      break;\n+    }\n+\n+    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n+      connections.addFirst(foundConnection); // Add it back after iteration.\n+    }\n+\n+    executorService.submit(connectionsCleanupCallable);\n+    return foundConnection;\n+  }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c": {
      "type": "Ybodychange",
      "commitMessage": "Upgrade from spdy/2 to spdy/3.\n",
      "commitDate": "2013-01-06, 6:30 p.m.",
      "commitName": "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-01-01, 10:50 p.m.",
      "commitNameOld": "689f66222bd8984dd69229a4ee9caf8da528ae12",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 4.82,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Connection get(Address address) {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                Connection connection \u003d connections.get(connections.size() - 1);\n                boolean usable \u003d connection.isEligibleForRecycling();\n                if (usable \u0026\u0026 !connection.isSpdy()) {\n                    try {\n                        Platform.get().tagSocket(connection.getSocket());\n                    } catch (SocketException e) {\n                        // When unable to tag, skip recycling and close\n                        Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                        usable \u003d false;\n                    }\n                }\n\n                if (!connection.isSpdy() || !usable) {\n                    connections.remove(connections.size() - 1);\n                    if (connections.isEmpty()) {\n                        connectionPool.remove(address);\n                        connections \u003d null;\n                    }\n                }\n\n                if (usable) {\n                    return connection;\n                } else {\n                    Util.closeQuietly(connection);\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 77,
      "functionName": "get",
      "diff": "@@ -1,30 +1,34 @@\n     public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n             while (connections !\u003d null) {\n                 Connection connection \u003d connections.get(connections.size() - 1);\n-                if (!connection.isSpdy()) {\n+                boolean usable \u003d connection.isEligibleForRecycling();\n+                if (usable \u0026\u0026 !connection.isSpdy()) {\n+                    try {\n+                        Platform.get().tagSocket(connection.getSocket());\n+                    } catch (SocketException e) {\n+                        // When unable to tag, skip recycling and close\n+                        Platform.get().logW(\"Unable to tagSocket(): \" + e);\n+                        usable \u003d false;\n+                    }\n+                }\n+\n+                if (!connection.isSpdy() || !usable) {\n                     connections.remove(connections.size() - 1);\n+                    if (connections.isEmpty()) {\n+                        connectionPool.remove(address);\n+                        connections \u003d null;\n+                    }\n                 }\n-                if (connections.isEmpty()) {\n-                    connectionPool.remove(address);\n-                    connections \u003d null;\n-                }\n-                if (!connection.isEligibleForRecycling()) {\n+\n+                if (usable) {\n+                    return connection;\n+                } else {\n                     Util.closeQuietly(connection);\n-                    continue;\n                 }\n-                try {\n-                    Platform.get().tagSocket(connection.getSocket());\n-                } catch (SocketException e) {\n-                    // When unable to tag, skip recycling and close\n-                    Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                    Util.closeQuietly(connection);\n-                    continue;\n-                }\n-                return connection;\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "689f66222bd8984dd69229a4ee9caf8da528ae12": {
      "type": "Ybodychange",
      "commitMessage": "Flatten internal packages and utility classes.\n\nThe previous structure had hierarchy that was useful\nfor libcore but overkill for OkHttp.\n",
      "commitDate": "2013-01-01, 10:50 p.m.",
      "commitName": "689f66222bd8984dd69229a4ee9caf8da528ae12",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012-12-31, 2:35 a.m.",
      "commitNameOld": "60d5852c6676ece85b0e3d0c6e45fb0186303f83",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Connection get(Address address) {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                Connection connection \u003d connections.get(connections.size() - 1);\n                if (!connection.isSpdy()) {\n                    connections.remove(connections.size() - 1);\n                }\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n                if (!connection.isEligibleForRecycling()) {\n                    Util.closeQuietly(connection);\n                    continue;\n                }\n                try {\n                    Platform.get().tagSocket(connection.getSocket());\n                } catch (SocketException e) {\n                    // When unable to tag, skip recycling and close\n                    Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                    Util.closeQuietly(connection);\n                    continue;\n                }\n                return connection;\n            }\n        }\n        return null;\n    }",
      "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 77,
      "functionName": "get",
      "diff": "@@ -1,30 +1,30 @@\n     public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n             while (connections !\u003d null) {\n                 Connection connection \u003d connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections \u003d null;\n                 }\n                 if (!connection.isEligibleForRecycling()) {\n-                    IoUtils.closeQuietly(connection);\n+                    Util.closeQuietly(connection);\n                     continue;\n                 }\n                 try {\n                     Platform.get().tagSocket(connection.getSocket());\n                 } catch (SocketException e) {\n                     // When unable to tag, skip recycling and close\n                     Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                    IoUtils.closeQuietly(connection);\n+                    Util.closeQuietly(connection);\n                     continue;\n                 }\n                 return connection;\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "67604f618d96ae00318ce696ec29a66bec6aafa8": {
      "type": "Ybodychange",
      "commitMessage": "Clean up utility code for submission to AOSP.\n\nThis moves methods that will have Android-specific implementations\nto Platform.java; all other utility methods are in a junk drawer\nclass called Utils.java.\n\nThis also moves method names (like \"GET\") to compare with .equals\ninstead of \u0027\u003d\u003d\u0027. The old code took advantage of a hidden agreement\nbetween HttpURLConnection and HttpEngine; with these in separate\nprojects that behavior isn\u0027t as obvious and shouldn\u0027t be relied\nupon.\n",
      "commitDate": "2012-12-26, 1:31 p.m.",
      "commitName": "67604f618d96ae00318ce696ec29a66bec6aafa8",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012-12-24, 12:39 a.m.",
      "commitNameOld": "78c6624b11d5f33504dae8211b4592383468343e",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 2.54,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Connection get(Address address) {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                Connection connection \u003d connections.get(connections.size() - 1);\n                if (!connection.isSpdy()) {\n                    connections.remove(connections.size() - 1);\n                }\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n                if (!connection.isEligibleForRecycling()) {\n                    IoUtils.closeQuietly(connection);\n                    continue;\n                }\n                try {\n                    Platform.get().tagSocket(connection.getSocket());\n                } catch (SocketException e) {\n                    // When unable to tag, skip recycling and close\n                    Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                    IoUtils.closeQuietly(connection);\n                    continue;\n                }\n                return connection;\n            }\n        }\n        return null;\n    }",
      "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 77,
      "functionName": "get",
      "diff": "@@ -1,25 +1,30 @@\n     public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n             while (connections !\u003d null) {\n                 Connection connection \u003d connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections \u003d null;\n                 }\n-                if (connection.isEligibleForRecycling()) {\n-                    // Since Socket is recycled, re-tag before using\n-                    // TODO: don\u0027t tag SPDY connections\n-                    Libcore.tagSocket(connection.getSocket());\n-                    return connection;\n-                } else {\n-                    // TODO: is the connection leaked here?\n+                if (!connection.isEligibleForRecycling()) {\n+                    IoUtils.closeQuietly(connection);\n+                    continue;\n                 }\n+                try {\n+                    Platform.get().tagSocket(connection.getSocket());\n+                } catch (SocketException e) {\n+                    // When unable to tag, skip recycling and close\n+                    Platform.get().logW(\"Unable to tagSocket(): \" + e);\n+                    IoUtils.closeQuietly(connection);\n+                    continue;\n+                }\n+                return connection;\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "78c6624b11d5f33504dae8211b4592383468343e": {
      "type": "Ymultichange(Yfilerename,Yreturntypechange,Ybodychange,Yparameterchange)",
      "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
      "commitDate": "2012-12-24, 12:39 a.m.",
      "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012-12-24, 12:39 a.m.",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012-12-23, 4:38 p.m.",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Connection get(Address address) {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                Connection connection \u003d connections.get(connections.size() - 1);\n                if (!connection.isSpdy()) {\n                    connections.remove(connections.size() - 1);\n                }\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n                if (connection.isEligibleForRecycling()) {\n                    // Since Socket is recycled, re-tag before using\n                    // TODO: don\u0027t tag SPDY connections\n                    Libcore.tagSocket(connection.getSocket());\n                    return connection;\n                } else {\n                    // TODO: is the connection leaked here?\n                }\n            }\n        }\n        return null;\n    }",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 77,
          "functionName": "get",
          "diff": "@@ -1,25 +1,25 @@\n-    public HttpConnection get(HttpConnection.Address address) {\n+    public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n-            List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n+            List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n             while (connections !\u003d null) {\n-                HttpConnection connection \u003d connections.get(connections.size() - 1);\n+                Connection connection \u003d connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections \u003d null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     // TODO: don\u0027t tag SPDY connections\n                     Libcore.tagSocket(connection.getSocket());\n                     return connection;\n                 } else {\n                     // TODO: is the connection leaked here?\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnectionPool.java",
            "newPath": "src/main/java/com/squareup/okhttp/ConnectionPool.java"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012-12-24, 12:39 a.m.",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012-12-23, 4:38 p.m.",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Connection get(Address address) {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                Connection connection \u003d connections.get(connections.size() - 1);\n                if (!connection.isSpdy()) {\n                    connections.remove(connections.size() - 1);\n                }\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n                if (connection.isEligibleForRecycling()) {\n                    // Since Socket is recycled, re-tag before using\n                    // TODO: don\u0027t tag SPDY connections\n                    Libcore.tagSocket(connection.getSocket());\n                    return connection;\n                } else {\n                    // TODO: is the connection leaked here?\n                }\n            }\n        }\n        return null;\n    }",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 77,
          "functionName": "get",
          "diff": "@@ -1,25 +1,25 @@\n-    public HttpConnection get(HttpConnection.Address address) {\n+    public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n-            List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n+            List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n             while (connections !\u003d null) {\n-                HttpConnection connection \u003d connections.get(connections.size() - 1);\n+                Connection connection \u003d connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections \u003d null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     // TODO: don\u0027t tag SPDY connections\n                     Libcore.tagSocket(connection.getSocket());\n                     return connection;\n                 } else {\n                     // TODO: is the connection leaked here?\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "HttpConnection",
            "newValue": "Connection"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012-12-24, 12:39 a.m.",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012-12-23, 4:38 p.m.",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Connection get(Address address) {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                Connection connection \u003d connections.get(connections.size() - 1);\n                if (!connection.isSpdy()) {\n                    connections.remove(connections.size() - 1);\n                }\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n                if (connection.isEligibleForRecycling()) {\n                    // Since Socket is recycled, re-tag before using\n                    // TODO: don\u0027t tag SPDY connections\n                    Libcore.tagSocket(connection.getSocket());\n                    return connection;\n                } else {\n                    // TODO: is the connection leaked here?\n                }\n            }\n        }\n        return null;\n    }",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 77,
          "functionName": "get",
          "diff": "@@ -1,25 +1,25 @@\n-    public HttpConnection get(HttpConnection.Address address) {\n+    public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n-            List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n+            List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n             while (connections !\u003d null) {\n-                HttpConnection connection \u003d connections.get(connections.size() - 1);\n+                Connection connection \u003d connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections \u003d null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     // TODO: don\u0027t tag SPDY connections\n                     Libcore.tagSocket(connection.getSocket());\n                     return connection;\n                 } else {\n                     // TODO: is the connection leaked here?\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012-12-24, 12:39 a.m.",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012-12-23, 4:38 p.m.",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Connection get(Address address) {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                Connection connection \u003d connections.get(connections.size() - 1);\n                if (!connection.isSpdy()) {\n                    connections.remove(connections.size() - 1);\n                }\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n                if (connection.isEligibleForRecycling()) {\n                    // Since Socket is recycled, re-tag before using\n                    // TODO: don\u0027t tag SPDY connections\n                    Libcore.tagSocket(connection.getSocket());\n                    return connection;\n                } else {\n                    // TODO: is the connection leaked here?\n                }\n            }\n        }\n        return null;\n    }",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 77,
          "functionName": "get",
          "diff": "@@ -1,25 +1,25 @@\n-    public HttpConnection get(HttpConnection.Address address) {\n+    public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n-            List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n+            List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n             while (connections !\u003d null) {\n-                HttpConnection connection \u003d connections.get(connections.size() - 1);\n+                Connection connection \u003d connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections \u003d null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     // TODO: don\u0027t tag SPDY connections\n                     Libcore.tagSocket(connection.getSocket());\n                     return connection;\n                 } else {\n                     // TODO: is the connection leaked here?\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[address-HttpConnection.Address]",
            "newValue": "[address-Address]"
          }
        }
      ]
    },
    "70e64037ff295874602133a1d254e5a0440ae4e3": {
      "type": "Ybodychange",
      "commitMessage": "Prepare to promote HttpConnection + Pool to public API.\n\nGiving the application code access to the connection pool\nis tricky: it exposes more implementation details from\nOkHttp; details that are quite inaccessible through the\nconventional HttpURLConnection APIs. Currently the only\nthing regular users get are a pair of awkward system\nproperties.\n\nBut exposing these should also be useful: it\u0027ll allow the\napplication to observe the pool (for performance monitoring)\nand possibly also to directly manage it (by setting policy,\nor to evict when the application is paused).\n",
      "commitDate": "2012-12-22, 6:05 p.m.",
      "commitName": "70e64037ff295874602133a1d254e5a0440ae4e3",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012-12-22, 1:40 p.m.",
      "commitNameOld": "3d2547f18886e771aaa9baa996a21136c93460c4",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public HttpConnection get(HttpConnection.Address address) {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                HttpConnection connection \u003d connections.get(connections.size() - 1);\n                if (!connection.isSpdy()) {\n                    connections.remove(connections.size() - 1);\n                }\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n                if (connection.isEligibleForRecycling()) {\n                    // Since Socket is recycled, re-tag before using\n                    // TODO: don\u0027t tag SPDY connections\n                    Libcore.tagSocket(connection.getSocket());\n                    return connection;\n                } else {\n                    // TODO: is the connection leaked here?\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnectionPool.java",
      "functionStartLine": 61,
      "functionName": "get",
      "diff": "@@ -1,22 +1,25 @@\n     public HttpConnection get(HttpConnection.Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n             while (connections !\u003d null) {\n                 HttpConnection connection \u003d connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections \u003d null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n+                    // TODO: don\u0027t tag SPDY connections\n                     Libcore.tagSocket(connection.getSocket());\n                     return connection;\n+                } else {\n+                    // TODO: is the connection leaked here?\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3d2547f18886e771aaa9baa996a21136c93460c4": {
      "type": "Ybodychange",
      "commitMessage": "Restore tests for response caching + TLS.\n\nOne of the test cases bitrotted to failure as a consequence\nof the HTTP route selector change. I stopped assigning the\nsocket, which it needed to cache the TLS metadata. This is\nfixed.\n",
      "commitDate": "2012-12-22, 1:40 p.m.",
      "commitName": "3d2547f18886e771aaa9baa996a21136c93460c4",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012-12-15, 4:55 p.m.",
      "commitNameOld": "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 6.86,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "    public HttpConnection get(HttpConnection.Address address) {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                HttpConnection connection \u003d connections.get(connections.size() - 1);\n                if (!connection.isSpdy()) {\n                    connections.remove(connections.size() - 1);\n                }\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n                if (connection.isEligibleForRecycling()) {\n                    // Since Socket is recycled, re-tag before using\n                    Libcore.tagSocket(connection.getSocket());\n                    return connection;\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnectionPool.java",
      "functionStartLine": 60,
      "functionName": "get",
      "diff": "@@ -1,23 +1,22 @@\n     public HttpConnection get(HttpConnection.Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n             while (connections !\u003d null) {\n                 HttpConnection connection \u003d connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections \u003d null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n-                    Socket socket \u003d connection.getSocket();\n-                    Libcore.tagSocket(socket);\n+                    Libcore.tagSocket(connection.getSocket());\n                     return connection;\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": {
      "type": "Yfilerename",
      "commitMessage": "Move out of the libcore package.\n\nTo promote the code into AOSP, we\u0027ll keep this package as-is\nand do the jarjar in Android instead.\n",
      "commitDate": "2012-12-15, 4:55 p.m.",
      "commitName": "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012-12-15, 4:17 p.m.",
      "commitNameOld": "7f7aa90bc5d41d8f818fc988d2a91d22393c7329",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public HttpConnection get(HttpConnection.Address address) {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                HttpConnection connection \u003d connections.get(connections.size() - 1);\n                if (!connection.isSpdy()) {\n                    connections.remove(connections.size() - 1);\n                }\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n                if (connection.isEligibleForRecycling()) {\n                    // Since Socket is recycled, re-tag before using\n                    Socket socket \u003d connection.getSocket();\n                    Libcore.tagSocket(socket);\n                    return connection;\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnectionPool.java",
      "functionStartLine": 61,
      "functionName": "get",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/libcore/net/http/HttpConnectionPool.java",
        "newPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnectionPool.java"
      }
    },
    "40ff76547064c3fb5acb9047a6f679dd4379a4d0": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
      "commitDate": "2012-11-05, 11:25 p.m.",
      "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
          "commitDate": "2012-11-05, 11:25 p.m.",
          "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012-09-25, 2:29 p.m.",
          "commitNameOld": "60b3a6dd6240f40c29fffd897c2dac314af49836",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 41.41,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "    public HttpConnection get(HttpConnection.Address address) {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                HttpConnection connection \u003d connections.get(connections.size() - 1);\n                if (!connection.isSpdy()) {\n                    connections.remove(connections.size() - 1);\n                }\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n                if (connection.isEligibleForRecycling()) {\n                    // Since Socket is recycled, re-tag before using\n                    Socket socket \u003d connection.getSocket();\n                    Libcore.tagSocket(socket);\n                    return connection;\n                }\n            }\n        }\n        return null;\n    }",
          "path": "src/main/java/libcore/net/http/HttpConnectionPool.java",
          "functionStartLine": 61,
          "functionName": "get",
          "diff": "@@ -1,29 +1,23 @@\n-    public HttpConnection get(HttpConnection.Address address, int connectTimeout)\n-            throws IOException {\n+    public HttpConnection get(HttpConnection.Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n             while (connections !\u003d null) {\n                 HttpConnection connection \u003d connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections \u003d null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     Socket socket \u003d connection.getSocket();\n                     Libcore.tagSocket(socket);\n                     return connection;\n                 }\n             }\n         }\n-\n-        /*\n-         * We couldn\u0027t find a reusable connection, so we need to create a new\n-         * connection. We\u0027re careful not to do so while holding a lock!\n-         */\n-        return address.connect(connectTimeout);\n+        return null;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[address-HttpConnection.Address, connectTimeout-int]",
            "newValue": "[address-HttpConnection.Address]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
          "commitDate": "2012-11-05, 11:25 p.m.",
          "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012-09-25, 2:29 p.m.",
          "commitNameOld": "60b3a6dd6240f40c29fffd897c2dac314af49836",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 41.41,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "    public HttpConnection get(HttpConnection.Address address) {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                HttpConnection connection \u003d connections.get(connections.size() - 1);\n                if (!connection.isSpdy()) {\n                    connections.remove(connections.size() - 1);\n                }\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n                if (connection.isEligibleForRecycling()) {\n                    // Since Socket is recycled, re-tag before using\n                    Socket socket \u003d connection.getSocket();\n                    Libcore.tagSocket(socket);\n                    return connection;\n                }\n            }\n        }\n        return null;\n    }",
          "path": "src/main/java/libcore/net/http/HttpConnectionPool.java",
          "functionStartLine": 61,
          "functionName": "get",
          "diff": "@@ -1,29 +1,23 @@\n-    public HttpConnection get(HttpConnection.Address address, int connectTimeout)\n-            throws IOException {\n+    public HttpConnection get(HttpConnection.Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n             while (connections !\u003d null) {\n                 HttpConnection connection \u003d connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections \u003d null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     Socket socket \u003d connection.getSocket();\n                     Libcore.tagSocket(socket);\n                     return connection;\n                 }\n             }\n         }\n-\n-        /*\n-         * We couldn\u0027t find a reusable connection, so we need to create a new\n-         * connection. We\u0027re careful not to do so while holding a lock!\n-         */\n-        return address.connect(connectTimeout);\n+        return null;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
          "commitDate": "2012-11-05, 11:25 p.m.",
          "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012-09-25, 2:29 p.m.",
          "commitNameOld": "60b3a6dd6240f40c29fffd897c2dac314af49836",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 41.41,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "    public HttpConnection get(HttpConnection.Address address) {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                HttpConnection connection \u003d connections.get(connections.size() - 1);\n                if (!connection.isSpdy()) {\n                    connections.remove(connections.size() - 1);\n                }\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n                if (connection.isEligibleForRecycling()) {\n                    // Since Socket is recycled, re-tag before using\n                    Socket socket \u003d connection.getSocket();\n                    Libcore.tagSocket(socket);\n                    return connection;\n                }\n            }\n        }\n        return null;\n    }",
          "path": "src/main/java/libcore/net/http/HttpConnectionPool.java",
          "functionStartLine": 61,
          "functionName": "get",
          "diff": "@@ -1,29 +1,23 @@\n-    public HttpConnection get(HttpConnection.Address address, int connectTimeout)\n-            throws IOException {\n+    public HttpConnection get(HttpConnection.Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n             while (connections !\u003d null) {\n                 HttpConnection connection \u003d connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections \u003d null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     Socket socket \u003d connection.getSocket();\n                     Libcore.tagSocket(socket);\n                     return connection;\n                 }\n             }\n         }\n-\n-        /*\n-         * We couldn\u0027t find a reusable connection, so we need to create a new\n-         * connection. We\u0027re careful not to do so while holding a lock!\n-         */\n-        return address.connect(connectTimeout);\n+        return null;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": {
      "type": "Yintroduced",
      "commitMessage": "Initial import.\n\nThis is a fork of okhttp from http://code.google.com/p/okhttp.\nI\u0027m moving it to Github since that\u0027s where my code reviewers\nare. I\u0027ve renamed the core package from com.google.okhttp to\ncom.squareup.okhttp because Square is where I expect ongoing\ndevelopment of this project to take place.\n\nAll code in this project is subject to be contributed upstream\nto AOSP. In particular, all code in the libcore package is\nderived from AOSP and intended to be contributed back to AOSP\non an ongoing basis.\n",
      "commitDate": "2012-07-23, 10:02 a.m.",
      "commitName": "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,29 @@\n+    public HttpConnection get(HttpConnection.Address address, int connectTimeout)\n+            throws IOException {\n+        // First try to reuse an existing HTTP connection.\n+        synchronized (connectionPool) {\n+            List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n+            while (connections !\u003d null) {\n+                HttpConnection connection \u003d connections.get(connections.size() - 1);\n+                if (!connection.isSpdy()) {\n+                    connections.remove(connections.size() - 1);\n+                }\n+                if (connections.isEmpty()) {\n+                    connectionPool.remove(address);\n+                    connections \u003d null;\n+                }\n+                if (connection.isEligibleForRecycling()) {\n+                    // Since Socket is recycled, re-tag before using\n+                    Socket socket \u003d connection.getSocket();\n+                    Libcore.tagSocket(socket);\n+                    return connection;\n+                }\n+            }\n+        }\n+\n+        /*\n+         * We couldn\u0027t find a reusable connection, so we need to create a new\n+         * connection. We\u0027re careful not to do so while holding a lock!\n+         */\n+        return address.connect(connectTimeout);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public HttpConnection get(HttpConnection.Address address, int connectTimeout)\n            throws IOException {\n        // First try to reuse an existing HTTP connection.\n        synchronized (connectionPool) {\n            List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n            while (connections !\u003d null) {\n                HttpConnection connection \u003d connections.get(connections.size() - 1);\n                if (!connection.isSpdy()) {\n                    connections.remove(connections.size() - 1);\n                }\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n                if (connection.isEligibleForRecycling()) {\n                    // Since Socket is recycled, re-tag before using\n                    Socket socket \u003d connection.getSocket();\n                    Libcore.tagSocket(socket);\n                    return connection;\n                }\n            }\n        }\n\n        /*\n         * We couldn\u0027t find a reusable connection, so we need to create a new\n         * connection. We\u0027re careful not to do so while holding a lock!\n         */\n        return address.connect(connectTimeout);\n    }",
      "path": "src/main/java/libcore/net/http/HttpConnectionPool.java",
      "functionStartLine": 62,
      "functionName": "get"
    }
  }
}