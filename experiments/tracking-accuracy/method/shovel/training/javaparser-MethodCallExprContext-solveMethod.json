{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "H:\\Projects\\javaparser\\javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "MethodCallExprContext.java",
  "functionName": "solveMethod",
  "functionId": "solveMethod___name-String__argumentsTypes-List__ResolvedType____staticOnly-boolean__typeSolver-TypeSolver",
  "sourceFilePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
  "functionStartLine": 153,
  "functionEndLine": 162,
  "numCommitsSeen": 230,
  "timeTaken": 1441,
  "changeHistory": [
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
    "1db4cd7914d4f36224a4a8944e546650d5fc5a4d",
    "5d8d0cb7947efcf2282f7d056302dd905f348532",
    "acdac6790f4424f8097b3aa6c888e825cac485f9",
    "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
    "e5fe2b597be66d230f8824277c1d4167fa2bb609",
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
    "e47162df70ac5344d1a7b8c08220474224e64536",
    "c990d23490f5c4ac4322119b03d5951b63eef055",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
    "9c53c2cbc607ea694438ade8630be0c155a33162",
    "0d14741fef3a17451db153cfe379e398da4b4b79",
    "341e081a5f8909a3a467671befcca2941b786d3d",
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
    "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
    "82eb44707b620803d424188a1eb8708fcaf093cb",
    "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
    "a16d5b37001074f2fa6eea4d1d1ef7e0466ca51b",
    "cb7655f9661f11dab8ec9e2533722d649a16e715",
    "2c3f615e6b24358b86d6453e24dac35849ffde26",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
    "4a18b1ee8ed716d6e32e190f728f1eee57148872",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
    "40ddb5e17127d2139e4b66b980ad11004749e86a",
    "965ab8585c3e8be1dff784e749e37dad31151ec8",
    "362cdf49fd4c7ea6d60f3172fd2804f8aa765f4c",
    "b36f33050149a62a5b3c8c7451ae93f736715029",
    "d393205e2ee874242b73e4fe819d1bc874587d8a",
    "627b56302d259409e9bc50b20d77803484f18b5c",
    "80f951258992f75441239c79e0f31eda7d47e107",
    "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
    "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
    "2f49331fb22511346eea8800d27907de44409d5b"
  ],
  "changeHistoryShort": {
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": "Yfilerename",
    "1db4cd7914d4f36224a4a8944e546650d5fc5a4d": "Ybodychange",
    "5d8d0cb7947efcf2282f7d056302dd905f348532": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "acdac6790f4424f8097b3aa6c888e825cac485f9": "Ybodychange",
    "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60": "Ymultichange(Yparameterchange,Ybodychange)",
    "e5fe2b597be66d230f8824277c1d4167fa2bb609": "Ybodychange",
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1": "Ybodychange",
    "e47162df70ac5344d1a7b8c08220474224e64536": "Ybodychange",
    "c990d23490f5c4ac4322119b03d5951b63eef055": "Ybodychange",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": "Ybodychange",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": "Ybodychange",
    "9c53c2cbc607ea694438ade8630be0c155a33162": "Yfilerename",
    "0d14741fef3a17451db153cfe379e398da4b4b79": "Ybodychange",
    "341e081a5f8909a3a467671befcca2941b786d3d": "Ybodychange",
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": "Ymultichange(Yparameterchange,Ybodychange)",
    "656bb37a1dba87d61d24e69f2346f35dbc73d81d": "Ybodychange",
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": "Ybodychange",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": "Ybodychange",
    "82eb44707b620803d424188a1eb8708fcaf093cb": "Ymultichange(Yparameterchange,Ybodychange)",
    "401a56f412ca186a00a2282d9088e8cb7b67e0e5": "Ybodychange",
    "a16d5b37001074f2fa6eea4d1d1ef7e0466ca51b": "Ybodychange",
    "cb7655f9661f11dab8ec9e2533722d649a16e715": "Ybodychange",
    "2c3f615e6b24358b86d6453e24dac35849ffde26": "Ybodychange",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": "Yfilerename",
    "4a18b1ee8ed716d6e32e190f728f1eee57148872": "Ybodychange",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": "Yfilerename",
    "40ddb5e17127d2139e4b66b980ad11004749e86a": "Ybodychange",
    "965ab8585c3e8be1dff784e749e37dad31151ec8": "Ybodychange",
    "362cdf49fd4c7ea6d60f3172fd2804f8aa765f4c": "Ybodychange",
    "b36f33050149a62a5b3c8c7451ae93f736715029": "Yfilerename",
    "d393205e2ee874242b73e4fe819d1bc874587d8a": "Ybodychange",
    "627b56302d259409e9bc50b20d77803484f18b5c": "Ybodychange",
    "80f951258992f75441239c79e0f31eda7d47e107": "Ybodychange",
    "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b": "Ybodychange",
    "8b8cc6cddbf5af0c93c4ceffd015f6328c932149": "Ymultichange(Yparameterchange,Ybodychange)",
    "2f49331fb22511346eea8800d27907de44409d5b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
      "type": "Yfilerename",
      "commitMessage": "rename JSS modules\n",
      "commitDate": "2018-01-10, 7:52 a.m.",
      "commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018-01-10, 3:01 a.m.",
      "commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n        Collection\u003cResolvedReferenceTypeDeclaration\u003e rrtds \u003d findTypeDeclarations(wrappedNode.getScope(), typeSolver);\n        for (ResolvedReferenceTypeDeclaration rrtd : rrtds) {\n            SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(rrtd, name, argumentsTypes, false, typeSolver);\n            if (res.isSolved()) {\n                return res;\n            }\n        }\n        return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n    }",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 151,
      "functionName": "solveMethod",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
        "newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
      }
    },
    "1db4cd7914d4f36224a4a8944e546650d5fc5a4d": {
      "type": "Ybodychange",
      "commitMessage": "Fix issue #300\n",
      "commitDate": "2017-12-10, 9:34 a.m.",
      "commitName": "1db4cd7914d4f36224a4a8944e546650d5fc5a4d",
      "commitAuthor": "Marcos CÃ©sar de Oliveira",
      "commitDateOld": "2017-09-28, 4:36 p.m.",
      "commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 72.75,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n        Collection\u003cResolvedReferenceTypeDeclaration\u003e rrtds \u003d findTypeDeclarations(wrappedNode.getScope(), typeSolver);\n        for (ResolvedReferenceTypeDeclaration rrtd : rrtds) {\n            SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(rrtd, name, argumentsTypes, false, typeSolver);\n            if (res.isSolved()) {\n                return res;\n            }\n        }\n        return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 151,
      "functionName": "solveMethod",
      "diff": "@@ -1,47 +1,10 @@\n     public SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n-        if (wrappedNode.getScope().isPresent()) {\n-            Expression scope \u003d wrappedNode.getScope().get();\n-\n-            // consider static methods\n-            if (scope instanceof NameExpr) {\n-                NameExpr scopeAsName \u003d (NameExpr) scope;\n-                SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n-                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n-                    ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n-                }\n+        Collection\u003cResolvedReferenceTypeDeclaration\u003e rrtds \u003d findTypeDeclarations(wrappedNode.getScope(), typeSolver);\n+        for (ResolvedReferenceTypeDeclaration rrtd : rrtds) {\n+            SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(rrtd, name, argumentsTypes, false, typeSolver);\n+            if (res.isSolved()) {\n+                return res;\n             }\n-\n-            ResolvedType typeOfScope \u003d null;\n-            try {\n-                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n-            } catch (Exception e) {\n-                throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n-            }\n-            if (typeOfScope.isWildcard()) {\n-                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n-                } else {\n-                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n-                }\n-            } else if (typeOfScope.isArray()) {\n-                // method call on array are Object methods\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n-            } else if (typeOfScope.isTypeVariable()) {\n-                for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n-                    SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n-                    if (res.isSolved()) {\n-                        return res;\n-                    }\n-                }\n-                return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n-            } else if (typeOfScope.isConstraint()){\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n-            } else {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n-            }\n-        } else {\n-            ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n+        return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5d8d0cb7947efcf2282f7d056302dd905f348532": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "more work on converting to moved classes\n",
      "commitDate": "2017-09-28, 4:36 p.m.",
      "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017-09-28, 4:36 p.m.",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-08-28, 5:15 a.m.",
          "commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
          "commitAuthorOld": "mlangkabel",
          "daysBetweenCommits": 31.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "    public SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n\n            // consider static methods\n            if (scope instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr) scope;\n                SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n                }\n            }\n\n            ResolvedType typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n                }\n            } else if (typeOfScope.isArray()) {\n                // method call on array are Object methods\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n                    SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n            } else if (typeOfScope.isConstraint()){\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n            }\n        } else {\n            ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 150,
          "functionName": "solveMethod",
          "diff": "@@ -1,47 +1,47 @@\n-    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n+    public SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope \u003d wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr) scope;\n-                SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n+                SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n-                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n+                    ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n                 }\n             }\n \n-            Type typeOfScope \u003d null;\n+            ResolvedType typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n-                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n+                for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n+                    SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n-                return SymbolReference.unsolved(MethodDeclaration.class);\n+                return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n             } else if (typeOfScope.isConstraint()){\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n             }\n         } else {\n-            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, argumentsTypes-List\u003cType\u003e, staticOnly-boolean, typeSolver-TypeSolver]",
            "newValue": "[name-String, argumentsTypes-List\u003cResolvedType\u003e, staticOnly-boolean, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017-09-28, 4:36 p.m.",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-08-28, 5:15 a.m.",
          "commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
          "commitAuthorOld": "mlangkabel",
          "daysBetweenCommits": 31.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "    public SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n\n            // consider static methods\n            if (scope instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr) scope;\n                SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n                }\n            }\n\n            ResolvedType typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n                }\n            } else if (typeOfScope.isArray()) {\n                // method call on array are Object methods\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n                    SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n            } else if (typeOfScope.isConstraint()){\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n            }\n        } else {\n            ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 150,
          "functionName": "solveMethod",
          "diff": "@@ -1,47 +1,47 @@\n-    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n+    public SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope \u003d wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr) scope;\n-                SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n+                SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n-                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n+                    ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n                 }\n             }\n \n-            Type typeOfScope \u003d null;\n+            ResolvedType typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n-                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n+                for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n+                    SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n-                return SymbolReference.unsolved(MethodDeclaration.class);\n+                return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n             } else if (typeOfScope.isConstraint()){\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n             }\n         } else {\n-            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "SymbolReference\u003cMethodDeclaration\u003e",
            "newValue": "SymbolReference\u003cResolvedMethodDeclaration\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017-09-28, 4:36 p.m.",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-08-28, 5:15 a.m.",
          "commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
          "commitAuthorOld": "mlangkabel",
          "daysBetweenCommits": 31.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "    public SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n\n            // consider static methods\n            if (scope instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr) scope;\n                SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n                }\n            }\n\n            ResolvedType typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n                }\n            } else if (typeOfScope.isArray()) {\n                // method call on array are Object methods\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n                    SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n            } else if (typeOfScope.isConstraint()){\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n            }\n        } else {\n            ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 150,
          "functionName": "solveMethod",
          "diff": "@@ -1,47 +1,47 @@\n-    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n+    public SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope \u003d wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr) scope;\n-                SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n+                SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n-                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n+                    ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n                 }\n             }\n \n-            Type typeOfScope \u003d null;\n+            ResolvedType typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n-                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n+                for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n+                    SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n-                return SymbolReference.unsolved(MethodDeclaration.class);\n+                return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n             } else if (typeOfScope.isConstraint()){\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n             }\n         } else {\n-            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "acdac6790f4424f8097b3aa6c888e825cac485f9": {
      "type": "Ybodychange",
      "commitMessage": "Fixes for type inference\n",
      "commitDate": "2017-03-09, 8:22 p.m.",
      "commitName": "acdac6790f4424f8097b3aa6c888e825cac485f9",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017-03-08, 10:31 p.m.",
      "commitNameOld": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.91,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n\n            // consider static methods\n            if (scope instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr) scope;\n                SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n                }\n            } else if (typeOfScope.isArray()) {\n                // method call on array are Object methods\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else if (typeOfScope.isConstraint()){\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 133,
      "functionName": "solveMethod",
      "diff": "@@ -1,45 +1,47 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope \u003d wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr) scope;\n                 SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n+                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n+                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                 } else {\n-                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n+                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n+                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n+            } else if (typeOfScope.isConstraint()){\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Fix issues with inherited methods in interfaces not being resolved\n",
      "commitDate": "2017-03-08, 10:31 p.m.",
      "commitName": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
      "commitAuthor": "xdrop",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fix issues with inherited methods in interfaces not being resolved\n",
          "commitDate": "2017-03-08, 10:31 p.m.",
          "commitName": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
          "commitAuthor": "xdrop",
          "commitDateOld": "2017-03-08, 4:40 p.m.",
          "commitNameOld": "e5fe2b597be66d230f8824277c1d4167fa2bb609",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.24,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n\n            // consider static methods\n            if (scope instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr) scope;\n                SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n                }\n            } else if (typeOfScope.isArray()) {\n                // method call on array are Object methods\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 133,
          "functionName": "solveMethod",
          "diff": "@@ -1,45 +1,45 @@\n-    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n+    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope \u003d wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr) scope;\n                 SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                 } else {\n-                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, argumentsTypes-List\u003cType\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, argumentsTypes-List\u003cType\u003e, staticOnly-boolean, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fix issues with inherited methods in interfaces not being resolved\n",
          "commitDate": "2017-03-08, 10:31 p.m.",
          "commitName": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
          "commitAuthor": "xdrop",
          "commitDateOld": "2017-03-08, 4:40 p.m.",
          "commitNameOld": "e5fe2b597be66d230f8824277c1d4167fa2bb609",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.24,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n\n            // consider static methods\n            if (scope instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr) scope;\n                SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n                }\n            } else if (typeOfScope.isArray()) {\n                // method call on array are Object methods\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 133,
          "functionName": "solveMethod",
          "diff": "@@ -1,45 +1,45 @@\n-    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n+    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope \u003d wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr) scope;\n                 SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                 } else {\n-                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "e5fe2b597be66d230f8824277c1d4167fa2bb609": {
      "type": "Ybodychange",
      "commitMessage": "typo\n",
      "commitDate": "2017-03-08, 4:40 p.m.",
      "commitName": "e5fe2b597be66d230f8824277c1d4167fa2bb609",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-01-11, 7:45 p.m.",
      "commitNameOld": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 55.87,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n\n            // consider static methods\n            if (scope instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr) scope;\n                SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                }\n            } else if (typeOfScope.isArray()) {\n                // method call on array are Object methods\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 133,
      "functionName": "solveMethod",
      "diff": "@@ -1,45 +1,45 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope \u003d wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr) scope;\n                 SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n-                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n+                throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1": {
      "type": "Ybodychange",
      "commitMessage": "Update for JavaParser 3.0.0\n",
      "commitDate": "2017-01-11, 7:45 p.m.",
      "commitName": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017-01-06, 4:11 a.m.",
      "commitNameOld": "860a4c0c034e1b8232e3d1ec17e7f11879850470",
      "commitAuthorOld": "",
      "daysBetweenCommits": 5.65,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n\n            // consider static methods\n            if (scope instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr) scope;\n                SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                }\n            } else if (typeOfScope.isArray()) {\n                // method call on array are Object methods\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 133,
      "functionName": "solveMethod",
      "diff": "@@ -1,44 +1,45 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n-        if (wrappedNode.getScope() !\u003d null) {\n+        if (wrappedNode.getScope().isPresent()) {\n+            Expression scope \u003d wrappedNode.getScope().get();\n \n             // consider static methods\n-            if (wrappedNode.getScope() instanceof NameExpr) {\n-                NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n+            if (scope instanceof NameExpr) {\n+                NameExpr scopeAsName \u003d (NameExpr) scope;\n                 SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n-                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e47162df70ac5344d1a7b8c08220474224e64536": {
      "type": "Ybodychange",
      "commitMessage": "minor\n",
      "commitDate": "2016-12-13, 11:55 a.m.",
      "commitName": "e47162df70ac5344d1a7b8c08220474224e64536",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-12-13, 11:45 a.m.",
      "commitNameOld": "cb5ffb7fdd56f1b768d25da330fa3b29ecb74eaf",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                }\n            } else if (typeOfScope.isArray()) {\n                // method call on array are Object methods\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 127,
      "functionName": "solveMethod",
      "diff": "@@ -1,45 +1,44 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n \n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n-            } else if (typeOfScope.isArray() /*\u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()*/) {\n+            } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n-//                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c990d23490f5c4ac4322119b03d5951b63eef055": {
      "type": "Ybodychange",
      "commitMessage": "loads of changes to support our code",
      "commitDate": "2016-12-13, 8:10 a.m.",
      "commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
      "commitAuthor": "Fred LefÃ©vÃ¨re-Laoide",
      "commitDateOld": "2016-11-21, 1:58 p.m.",
      "commitNameOld": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 21.76,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                }\n            } else if (typeOfScope.isArray() /*\u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()*/) {\n                // method call on array are Object methods\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n//                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 133,
      "functionName": "solveMethod",
      "diff": "@@ -1,43 +1,45 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n \n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n-                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n+                SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n-            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+            } else if (typeOfScope.isArray() /*\u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()*/) {\n+                // method call on array are Object methods\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+//                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": {
      "type": "Ybodychange",
      "commitMessage": "adapt to alpha.10\n",
      "commitDate": "2016-11-21, 1:58 p.m.",
      "commitName": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-09, 12:15 p.m.",
      "commitNameOld": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 12.07,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 124,
      "functionName": "solveMethod",
      "diff": "@@ -1,43 +1,43 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n \n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n-                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n+                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": {
      "type": "Ybodychange",
      "commitMessage": "changes necessary to support jpalpha8\n",
      "commitDate": "2016-11-09, 12:15 p.m.",
      "commitName": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-06, 8:49 a.m.",
      "commitNameOld": "03055f925053b3970b9d14cce3a3b9a0d002366d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 3.14,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 124,
      "functionName": "solveMethod",
      "diff": "@@ -1,43 +1,43 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n-        if (wrappedNode.getScope().isPresent()) {\n+        if (wrappedNode.getScope() !\u003d null) {\n \n             // consider static methods\n-            if (wrappedNode.getScope().get() instanceof NameExpr) {\n-                NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope().get();\n+            if (wrappedNode.getScope() instanceof NameExpr) {\n+                NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n                 SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n-                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n+                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c53c2cbc607ea694438ade8630be0c155a33162": {
      "type": "Yfilerename",
      "commitMessage": "renamed packages to com.github.javapaerser\n",
      "commitDate": "2016-10-20, 2:39 a.m.",
      "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-20, 2:32 a.m.",
      "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            // consider static methods\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope().get();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 243,
      "functionName": "solveMethod",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
      }
    },
    "0d14741fef3a17451db153cfe379e398da4b4b79": {
      "type": "Ybodychange",
      "commitMessage": "minor fix\n",
      "commitDate": "2016-10-19, 1:35 p.m.",
      "commitName": "0d14741fef3a17451db153cfe379e398da4b4b79",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:35 p.m.",
      "commitNameOld": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            // consider static methods\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope().get();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 245,
      "functionName": "solveMethod",
      "diff": "@@ -1,42 +1,42 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n-        if (wrappedNode.getScope() !\u003d null) {\n+        if (wrappedNode.getScope().isPresent()) {\n             // consider static methods\n             if (wrappedNode.getScope().get() instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope().get();\n                 SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "341e081a5f8909a3a467671befcca2941b786d3d": {
      "type": "Ybodychange",
      "commitMessage": "issue91: solve compilation issues\n",
      "commitDate": "2016-10-19, 1:33 p.m.",
      "commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 11:04 a.m.",
      "commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            // consider static methods\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope().get();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 245,
      "functionName": "solveMethod",
      "diff": "@@ -1,42 +1,42 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             // consider static methods\n-            if (wrappedNode.getScope() instanceof NameExpr) {\n-                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n+            if (wrappedNode.getScope().get() instanceof NameExpr) {\n+                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope().get();\n                 SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n-                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
      "commitDate": "2016-10-17, 1:25 p.m.",
      "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
          "commitDate": "2016-10-17, 1:25 p.m.",
          "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-16, 12:48 p.m.",
          "commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.03,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 229,
          "functionName": "solveMethod",
          "diff": "@@ -1,42 +1,42 @@\n-    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n+    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, parameterTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n-                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, parameterTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, parameterTypes-List\u003cType\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, argumentsTypes-List\u003cType\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
          "commitDate": "2016-10-17, 1:25 p.m.",
          "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-16, 12:48 p.m.",
          "commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.03,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 229,
          "functionName": "solveMethod",
          "diff": "@@ -1,42 +1,42 @@\n-    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n+    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, parameterTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n-                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, parameterTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "656bb37a1dba87d61d24e69f2346f35dbc73d81d": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeDeclaration.solveMethod\n",
      "commitDate": "2016-10-16, 12:13 p.m.",
      "commitName": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-14, 4:57 p.m.",
      "commitNameOld": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.8,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, parameterTypes, typeSolver);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n                } else {\n                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, parameterTypes, typeSolver);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 237,
      "functionName": "solveMethod",
      "diff": "@@ -1,42 +1,42 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                    return typeDeclaration.solveMethod(name, parameterTypes);\n+                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, parameterTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return typeOfScope.asWildcard().getBoundedType().asReferenceType().solveMethod(name, parameterTypes);\n+                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n                 } else {\n-                    return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n+                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, parameterTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n-                return typeOfScope.asArrayType().getComponentType().asReferenceType().solveMethod(name, parameterTypes);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceType().solveMethod(name, parameterTypes);\n+                    SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n-                return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": {
      "type": "Ybodychange",
      "commitMessage": "add test JavaParserClassDeclarationTest.testGetSuperclassWithTypeParameters\n",
      "commitDate": "2016-10-14, 4:57 p.m.",
      "commitName": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-14, 1:24 p.m.",
      "commitNameOld": "70f3e66c944670a818922f101162226ef604b263",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return typeDeclaration.solveMethod(name, parameterTypes);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return typeOfScope.asWildcard().getBoundedType().asReferenceType().solveMethod(name, parameterTypes);\n                } else {\n                    return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                return typeOfScope.asArrayType().getComponentType().asReferenceType().solveMethod(name, parameterTypes);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceType().solveMethod(name, parameterTypes);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 237,
      "functionName": "solveMethod",
      "diff": "@@ -1,42 +1,42 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return typeDeclaration.solveMethod(name, parameterTypes);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+                    return typeOfScope.asWildcard().getBoundedType().asReferenceType().solveMethod(name, parameterTypes);\n                 } else {\n                     return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n-            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n-                return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n+                return typeOfScope.asArrayType().getComponentType().asReferenceType().solveMethod(name, parameterTypes);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+                    SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceType().solveMethod(name, parameterTypes);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n-                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+                return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+            return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": {
      "type": "Ybodychange",
      "commitMessage": "reorganize packages in model\n",
      "commitDate": "2016-10-14, 12:51 p.m.",
      "commitName": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-14, 2:36 a.m.",
      "commitNameOld": "8d234965b572759181da7787fead07b225e9e5ca",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return typeDeclaration.solveMethod(name, parameterTypes);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                } else {\n                    return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 237,
      "functionName": "solveMethod",
      "diff": "@@ -1,42 +1,42 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return typeDeclaration.solveMethod(name, parameterTypes);\n                 }\n             }\n \n             Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n                     return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                 return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else if (typeOfScope.isTypeVariable()) {\n-                for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n+                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82eb44707b620803d424188a1eb8708fcaf093cb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "rename TypeUsage into Type\n",
      "commitDate": "2016-10-13, 4:11 p.m.",
      "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016-10-13, 4:11 p.m.",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-12, 5:43 p.m.",
          "commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.94,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return typeDeclaration.solveMethod(name, parameterTypes);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                } else {\n                    return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 235,
          "functionName": "solveMethod",
          "diff": "@@ -1,42 +1,42 @@\n-    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n+    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return typeDeclaration.solveMethod(name, parameterTypes);\n                 }\n             }\n \n-            TypeUsage typeOfScope \u003d null;\n+            Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n-                    return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n+                    return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                 return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else if (typeOfScope.isTypeVariable()) {\n-                for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n+                for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n-            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, parameterTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, parameterTypes-List\u003cType\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016-10-13, 4:11 p.m.",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-12, 5:43 p.m.",
          "commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.94,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return typeDeclaration.solveMethod(name, parameterTypes);\n                }\n            }\n\n            Type typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                } else {\n                    return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            }\n        } else {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 235,
          "functionName": "solveMethod",
          "diff": "@@ -1,42 +1,42 @@\n-    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n+    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return typeDeclaration.solveMethod(name, parameterTypes);\n                 }\n             }\n \n-            TypeUsage typeOfScope \u003d null;\n+            Type typeOfScope \u003d null;\n             try {\n                 typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n-                    return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n+                    return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                 return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else if (typeOfScope.isTypeVariable()) {\n-                for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n+                for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n-            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "401a56f412ca186a00a2282d9088e8cb7b67e0e5": {
      "type": "Ybodychange",
      "commitMessage": "issue80: working on lambdas assigned to variables\n",
      "commitDate": "2016-10-12, 5:43 p.m.",
      "commitName": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-12, 4:53 p.m.",
      "commitNameOld": "38d780df85a22c9baffb1f772a45b063cad73aab",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return typeDeclaration.solveMethod(name, parameterTypes);\n                }\n            }\n\n            TypeUsage typeOfScope \u003d null;\n            try {\n                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n            }\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                } else {\n                    return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            }\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 234,
      "functionName": "solveMethod",
      "diff": "@@ -1,37 +1,42 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return typeDeclaration.solveMethod(name, parameterTypes);\n                 }\n             }\n \n-            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+            TypeUsage typeOfScope \u003d null;\n+            try {\n+                typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+            } catch (Exception e) {\n+                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n+            }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n                     return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                 return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a16d5b37001074f2fa6eea4d1d1ef7e0466ca51b": {
      "type": "Ybodychange",
      "commitMessage": "issue80: improving resolution of methods on type parameters\n",
      "commitDate": "2016-10-09, 5:06 a.m.",
      "commitName": "a16d5b37001074f2fa6eea4d1d1ef7e0466ca51b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-08, 4:17 p.m.",
      "commitNameOld": "cb7655f9661f11dab8ec9e2533722d649a16e715",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.53,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return typeDeclaration.solveMethod(name, parameterTypes);\n                }\n            }\n\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                } else {\n                    return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else if (typeOfScope.isTypeVariable()) {\n                for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                    SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                    if (res.isSolved()) {\n                        return res;\n                    }\n                }\n                return SymbolReference.unsolved(MethodDeclaration.class);\n            } else {\n                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            }\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 201,
      "functionName": "solveMethod",
      "diff": "@@ -1,29 +1,37 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                     return typeDeclaration.solveMethod(name, parameterTypes);\n                 }\n             }\n \n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n                     return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                 return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+            } else if (typeOfScope.isTypeVariable()) {\n+                for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n+                    SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+                    if (res.isSolved()) {\n+                        return res;\n+                    }\n+                }\n+                return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cb7655f9661f11dab8ec9e2533722d649a16e715": {
      "type": "Ybodychange",
      "commitMessage": "issue80: improving resolution of static methods\n",
      "commitDate": "2016-10-08, 4:17 p.m.",
      "commitName": "cb7655f9661f11dab8ec9e2533722d649a16e715",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-05, 9:04 a.m.",
      "commitNameOld": "84afc7be2fabd511eccc69e29fca9c4238c9469e",
      "commitAuthorOld": "rpau",
      "daysBetweenCommits": 3.3,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            // consider static methods\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                    return typeDeclaration.solveMethod(name, parameterTypes);\n                }\n            }\n\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                } else {\n                    return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            }\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 201,
      "functionName": "solveMethod",
      "diff": "@@ -1,19 +1,29 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n+            // consider static methods\n+            if (wrappedNode.getScope() instanceof NameExpr) {\n+                NameExpr scopeAsName \u003d (NameExpr)wrappedNode.getScope();\n+                SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n+                if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n+                    TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n+                    return typeDeclaration.solveMethod(name, parameterTypes);\n+                }\n+            }\n+\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n                     return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                 return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2c3f615e6b24358b86d6453e24dac35849ffde26": {
      "type": "Ybodychange",
      "commitMessage": "added another fix and tests for method call on array access\n",
      "commitDate": "2016-09-23, 6:10 a.m.",
      "commitName": "2c3f615e6b24358b86d6453e24dac35849ffde26",
      "commitAuthor": "malte_langkabel",
      "commitDateOld": "2016-09-22, 8:06 a.m.",
      "commitNameOld": "a541f77a5a66a911e347d294aa76d8703e72e7db",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 0.92,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                } else {\n                    return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                }\n            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            }\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 206,
      "functionName": "solveMethod",
      "diff": "@@ -1,17 +1,19 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n                     return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n+            } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n+                return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
      "type": "Yfilerename",
      "commitMessage": "test JavaParserClassDeclaration\n",
      "commitDate": "2015-11-22, 5:45 a.m.",
      "commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-22, 5:03 a.m.",
      "commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                } else {\n                    return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                }\n            } else {\n                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            }\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 201,
      "functionName": "solveMethod",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
      }
    },
    "4a18b1ee8ed716d6e32e190f728f1eee57148872": {
      "type": "Ybodychange",
      "commitMessage": "modules: extraction of the model module\n",
      "commitDate": "2015-11-13, 4:59 a.m.",
      "commitName": "4a18b1ee8ed716d6e32e190f728f1eee57148872",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 4:12 a.m.",
      "commitNameOld": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                } else {\n                    return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                }\n            } else {\n                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            }\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 128,
      "functionName": "solveMethod",
      "diff": "@@ -1,17 +1,17 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n-                    return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n+                    return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
      "type": "Yfilerename",
      "commitMessage": "modules: organization in modules\n",
      "commitDate": "2015-11-13, 4:12 a.m.",
      "commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 3:53 a.m.",
      "commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                } else {\n                    return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                }\n            } else {\n                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            }\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 128,
      "functionName": "solveMethod",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java"
      }
    },
    "40ddb5e17127d2139e4b66b980ad11004749e86a": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeSolver from ReferenceTypeUsage interface\n",
      "commitDate": "2015-11-02, 3:14 p.m.",
      "commitName": "40ddb5e17127d2139e4b66b980ad11004749e86a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-02, 3:11 p.m.",
      "commitNameOld": "e21fca16e413a8bf31d613aa97a744d075c374dd",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                } else {\n                    return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                }\n            } else {\n                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            }\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 129,
      "functionName": "solveMethod",
      "diff": "@@ -1,17 +1,17 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n-                    return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes, typeSolver);\n+                    return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else {\n-                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "965ab8585c3e8be1dff784e749e37dad31151ec8": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-11-01, 9:57 a.m.",
      "commitName": "965ab8585c3e8be1dff784e749e37dad31151ec8",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-01, 6:29 a.m.",
      "commitNameOld": "26c12a20f1206e2a1f63c46b6b41c304af8c7389",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            if (typeOfScope.isWildcard()) {\n                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n                } else {\n                    return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes, typeSolver);\n                }\n            } else {\n                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n            }\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 129,
      "functionName": "solveMethod",
      "diff": "@@ -1,9 +1,17 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+            if (typeOfScope.isWildcard()) {\n+                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n+                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+                } else {\n+                    return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes, typeSolver);\n+                }\n+            } else {\n+                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+            }\n         } else {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "362cdf49fd4c7ea6d60f3172fd2804f8aa765f4c": {
      "type": "Ybodychange",
      "commitMessage": "simpligy TypeUsage\n",
      "commitDate": "2015-10-30, 9:30 a.m.",
      "commitName": "362cdf49fd4c7ea6d60f3172fd2804f8aa765f4c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-30, 8:49 a.m.",
      "commitNameOld": "392bb1e6e3f4b86c3bb812a95752e4921772c705",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 86,
      "functionName": "solveMethod",
      "diff": "@@ -1,9 +1,9 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n+            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n         } else {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n+            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b36f33050149a62a5b3c8c7451ae93f736715029": {
      "type": "Yfilerename",
      "commitMessage": "reorganize packages\n",
      "commitDate": "2015-10-30, 5:53 a.m.",
      "commitName": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-30, 5:29 a.m.",
      "commitNameOld": "90999800bdc73eacb5ef25dafcd36c8518af3072",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 86,
      "functionName": "solveMethod",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java"
      }
    },
    "d393205e2ee874242b73e4fe819d1bc874587d8a": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-17, 12:43 p.m.",
      "commitName": "d393205e2ee874242b73e4fe819d1bc874587d8a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-17, 2:28 a.m.",
      "commitNameOld": "542ea71d2308fcf66c1942862737bfcf04178797",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 61,
      "functionName": "solveMethod",
      "diff": "@@ -1,9 +1,9 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n         } else {\n-            throw new UnsupportedOperationException();\n-            //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n+            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "627b56302d259409e9bc50b20d77803484f18b5c": {
      "type": "Ybodychange",
      "commitMessage": "introduce cache in JavaParserFacade\n",
      "commitDate": "2015-08-05, 10:25 a.m.",
      "commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-05, 9:30 a.m.",
      "commitNameOld": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n        } else {\n            throw new UnsupportedOperationException();\n            //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 52,
      "functionName": "solveMethod",
      "diff": "@@ -1,9 +1,9 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n-            TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n         } else {\n             throw new UnsupportedOperationException();\n             //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "80f951258992f75441239c79e0f31eda7d47e107": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-04, 9:54 a.m.",
      "commitName": "80f951258992f75441239c79e0f31eda7d47e107",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-03, 2:53 a.m.",
      "commitNameOld": "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.29,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n        } else {\n            throw new UnsupportedOperationException();\n            //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 34,
      "functionName": "solveMethod",
      "diff": "@@ -1,9 +1,9 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n-            return typeOfScope.solveMethod(name, parameterTypes);\n+            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n         } else {\n             throw new UnsupportedOperationException();\n             //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-03, 2:53 a.m.",
      "commitName": "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-03, 2:37 a.m.",
      "commitNameOld": "630eb94d43670f2080c7273584d49c0b0d4162f1",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethod(name, parameterTypes);\n        } else {\n            throw new UnsupportedOperationException();\n            //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 34,
      "functionName": "solveMethod",
      "diff": "@@ -1,8 +1,9 @@\n     public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethod(name, parameterTypes);\n         } else {\n-            return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n+            throw new UnsupportedOperationException();\n+            //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8b8cc6cddbf5af0c93c4ceffd015f6328c932149": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "wip\n",
      "commitDate": "2015-07-31, 2:52 p.m.",
      "commitName": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "wip\n",
          "commitDate": "2015-07-31, 2:52 p.m.",
          "commitName": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015-07-31, 12:08 p.m.",
          "commitNameOld": "2f49331fb22511346eea8800d27907de44409d5b",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.11,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethod(name, parameterTypes);\n        } else {\n            return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n        }\n    }",
          "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
          "functionStartLine": 30,
          "functionName": "solveMethod",
          "diff": "@@ -1,15 +1,8 @@\n-    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeReference\u003e parameterTypes, TypeSolver typeSolver) {\n+    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n-            // TODO resolve the scope and get a context from there\n-            SymbolReference\u003cSymbolDeclaration\u003e declScope \u003d new JavaParserFacade(typeSolver).solve(wrappedNode.getScope());\n-            if (declScope.isSolved()) {\n-                TypeDeclaration typeOfDeclScope \u003d declScope.getCorrespondingDeclaration().getType();\n-                return typeOfDeclScope.getContext().solveMethod(name, parameterTypes, typeSolver);\n-            } else {\n-                // TODO this should be improved to indicate that is the scope that has not been solved\n-                throw new UnsolvedSymbolException(this, name);\n-            }\n+            TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+            return typeOfScope.solveMethod(name, parameterTypes);\n         } else {\n             return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, parameterTypes-List\u003cTypeReference\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, parameterTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "wip\n",
          "commitDate": "2015-07-31, 2:52 p.m.",
          "commitName": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015-07-31, 12:08 p.m.",
          "commitNameOld": "2f49331fb22511346eea8800d27907de44409d5b",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.11,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethod(name, parameterTypes);\n        } else {\n            return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n        }\n    }",
          "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
          "functionStartLine": 30,
          "functionName": "solveMethod",
          "diff": "@@ -1,15 +1,8 @@\n-    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeReference\u003e parameterTypes, TypeSolver typeSolver) {\n+    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n-            // TODO resolve the scope and get a context from there\n-            SymbolReference\u003cSymbolDeclaration\u003e declScope \u003d new JavaParserFacade(typeSolver).solve(wrappedNode.getScope());\n-            if (declScope.isSolved()) {\n-                TypeDeclaration typeOfDeclScope \u003d declScope.getCorrespondingDeclaration().getType();\n-                return typeOfDeclScope.getContext().solveMethod(name, parameterTypes, typeSolver);\n-            } else {\n-                // TODO this should be improved to indicate that is the scope that has not been solved\n-                throw new UnsolvedSymbolException(this, name);\n-            }\n+            TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+            return typeOfScope.solveMethod(name, parameterTypes);\n         } else {\n             return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "2f49331fb22511346eea8800d27907de44409d5b": {
      "type": "Yintroduced",
      "commitMessage": "start to resolve references to method\n",
      "commitDate": "2015-07-31, 12:08 p.m.",
      "commitName": "2f49331fb22511346eea8800d27907de44409d5b",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,15 @@\n+    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeReference\u003e parameterTypes, TypeSolver typeSolver) {\n+        if (wrappedNode.getScope() !\u003d null) {\n+            // TODO resolve the scope and get a context from there\n+            SymbolReference\u003cSymbolDeclaration\u003e declScope \u003d new JavaParserFacade(typeSolver).solve(wrappedNode.getScope());\n+            if (declScope.isSolved()) {\n+                TypeDeclaration typeOfDeclScope \u003d declScope.getCorrespondingDeclaration().getType();\n+                return typeOfDeclScope.getContext().solveMethod(name, parameterTypes, typeSolver);\n+            } else {\n+                // TODO this should be improved to indicate that is the scope that has not been solved\n+                throw new UnsolvedSymbolException(this, name);\n+            }\n+        } else {\n+            return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeReference\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            // TODO resolve the scope and get a context from there\n            SymbolReference\u003cSymbolDeclaration\u003e declScope \u003d new JavaParserFacade(typeSolver).solve(wrappedNode.getScope());\n            if (declScope.isSolved()) {\n                TypeDeclaration typeOfDeclScope \u003d declScope.getCorrespondingDeclaration().getType();\n                return typeOfDeclScope.getContext().solveMethod(name, parameterTypes, typeSolver);\n            } else {\n                // TODO this should be improved to indicate that is the scope that has not been solved\n                throw new UnsolvedSymbolException(this, name);\n            }\n        } else {\n            return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 31,
      "functionName": "solveMethod"
    }
  }
}