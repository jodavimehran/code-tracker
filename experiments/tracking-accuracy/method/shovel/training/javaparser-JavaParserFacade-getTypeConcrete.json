{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "H:\\Projects\\javaparser\\javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "JavaParserFacade.java",
  "functionName": "getTypeConcrete",
  "functionId": "getTypeConcrete___node-Node__solveLambdas-boolean",
  "sourceFilePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
  "functionStartLine": 465,
  "functionEndLine": 468,
  "numCommitsSeen": 205,
  "timeTaken": 1087,
  "changeHistory": [
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
    "198ba6cbe49832ac09ca84c6920e9be661a3b56a",
    "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
    "90c22f84a61e12130a8750d235acf7ed06305796",
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
    "c990d23490f5c4ac4322119b03d5951b63eef055",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
    "a1c7c58143a592965f8378767adc69709e4c0043",
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
    "e0d63587820f7e8900af0c9060a2f149cc643c6c",
    "e174058b92c209ba1d818e53db34993236592db7",
    "6ca549e39bc3b05bd6eb96ba9dc697a8c1bd6552",
    "78ee47e2e07cdb0b3cf80664a4e892c9dc76df00",
    "631896a1d2f34eed89c41cc717f463ebbd69e401",
    "13d789de30e6c3d29efb17a2acdff443f8c48db1",
    "697432aaf0e6a42825e52f956bd51f0486b411d2",
    "7c43ba3c700d72a0d613bce3659af6d74bc87434",
    "15ac26bcc19e8bed431a35edd3e3c176d7d56355",
    "9c53c2cbc607ea694438ade8630be0c155a33162",
    "6624f3653734698f477561c8407357e2395d411c",
    "967b0302143d4d6868c3d9035a8615ccfd198b6e",
    "9dc06a758c00cc235372dbc225a7e20c1f5269d3",
    "0d14741fef3a17451db153cfe379e398da4b4b79",
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
    "03e407957d600a18ef0a4a83224c17d155ef8645",
    "341e081a5f8909a3a467671befcca2941b786d3d",
    "70f3e66c944670a818922f101162226ef604b263",
    "82eb44707b620803d424188a1eb8708fcaf093cb",
    "acf74024c2d341bf4009af7173c9b1b972f19c32",
    "7317fe7d60ad0af88e9ee692e95dd5dde832863e",
    "2c6d213f0359d5b52a9d570323aa10505415f6ac",
    "68b3e019e1216a941ff5d8dcf63aefc9b35a3787",
    "47a5cc851b7db16ab0bcd4b1c0a4dceccfe13f74",
    "cb7655f9661f11dab8ec9e2533722d649a16e715",
    "31433fc385c0fea7ead68e4c853807752e061565",
    "a541f77a5a66a911e347d294aa76d8703e72e7db",
    "651f1ca3e9c7a8fec6826f9da14f9abb5fe921e0",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
    "ead147279ca0b84d2f479a714943b20cd689e7c7",
    "a6849db3884e47909d2d97fcac0b057ab13d544b",
    "94446666d149c898131d04e7fd567777258e4e1e",
    "b9725d0d363bb2b1364fb159eefdfbfbc1e3fa97",
    "a75fd9d3835fade5c3a1a6ef7a9d36d108a1367e",
    "f20bec1be7e976300ef4857e347bc735ded0f305",
    "4a18b1ee8ed716d6e32e190f728f1eee57148872",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
    "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
    "fb388c36c0045c50744cf215521e5c280036aa70",
    "c04083d20425a664115db6b0df3ca9632e66ecca",
    "0e81f51c40996b42cb262dc2397126cee8f60965",
    "fb0467dc222157e9f485ae4b3f6c7a637fdfcd1c",
    "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b",
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
    "d0348de241a6cf6be9c51500870ee1fb26172101",
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
    "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
    "00f005b38e8b83eb1d60db9070c6e9e3beffe403",
    "d6edae7874d2e78cbd401619ad53a9f9e2288597",
    "d0b5fa9e41aaf140b9a30c716ac7a74b24508451",
    "31b108cbfd418f43e7b568374af2e635a580e171",
    "bac18a129c45335e69d811b3872fcb938e1f0ff8",
    "46aefdd68f2f2597a19b72da36681123cb3090e6",
    "6c297529e31036058837adbaa57cee652d4cc918",
    "7b2a0b366461674aa6320b11a38a17909d8a74a3",
    "feab46de5d87b02bf38b29962613676adf14f78a",
    "54b73148ab5bfb5e3c2f1c2aa463265d033ac926",
    "0c4c859f472f7243919f1af7a0871cf8155af1ba",
    "09ceccd596e6aeebb5eca309093ef32216291f1e",
    "850c0caa4c64df32d5fc44a5512d6d41f4534a08",
    "22bf613d486d43114d1547e5bc623535aa2aca2a",
    "627b56302d259409e9bc50b20d77803484f18b5c",
    "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
    "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
    "80f951258992f75441239c79e0f31eda7d47e107",
    "2568d9ebe91ceb0a13c98b16f99593cd22084efa",
    "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
    "630eb94d43670f2080c7273584d49c0b0d4162f1",
    "fa3b6f1d0199dacb9069c24a1c2de0e31de38cb3",
    "3def8748ada27ac91166941a892adfd83ca3db2a",
    "381c389ea62cf20d6109dac96bb5f8202ccc0b34",
    "8b8cc6cddbf5af0c93c4ceffd015f6328c932149"
  ],
  "changeHistoryShort": {
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": "Yfilerename",
    "198ba6cbe49832ac09ca84c6920e9be661a3b56a": "Yreturntypechange",
    "0f40221492b47df25615a1b5909fefa6f2d6fa0e": "Ybodychange",
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1": "Ybodychange",
    "90c22f84a61e12130a8750d235acf7ed06305796": "Ybodychange",
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923": "Ybodychange",
    "c990d23490f5c4ac4322119b03d5951b63eef055": "Ybodychange",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": "Ybodychange",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": "Ybodychange",
    "a1c7c58143a592965f8378767adc69709e4c0043": "Ybodychange",
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae": "Ybodychange",
    "e0d63587820f7e8900af0c9060a2f149cc643c6c": "Ybodychange",
    "e174058b92c209ba1d818e53db34993236592db7": "Ybodychange",
    "6ca549e39bc3b05bd6eb96ba9dc697a8c1bd6552": "Ybodychange",
    "78ee47e2e07cdb0b3cf80664a4e892c9dc76df00": "Ybodychange",
    "631896a1d2f34eed89c41cc717f463ebbd69e401": "Ybodychange",
    "13d789de30e6c3d29efb17a2acdff443f8c48db1": "Ybodychange",
    "697432aaf0e6a42825e52f956bd51f0486b411d2": "Ybodychange",
    "7c43ba3c700d72a0d613bce3659af6d74bc87434": "Ybodychange",
    "15ac26bcc19e8bed431a35edd3e3c176d7d56355": "Ybodychange",
    "9c53c2cbc607ea694438ade8630be0c155a33162": "Ymultichange(Yfilerename,Ybodychange)",
    "6624f3653734698f477561c8407357e2395d411c": "Ybodychange",
    "967b0302143d4d6868c3d9035a8615ccfd198b6e": "Ybodychange",
    "9dc06a758c00cc235372dbc225a7e20c1f5269d3": "Ybodychange",
    "0d14741fef3a17451db153cfe379e398da4b4b79": "Ybodychange",
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7": "Ybodychange",
    "03e407957d600a18ef0a4a83224c17d155ef8645": "Ybodychange",
    "341e081a5f8909a3a467671befcca2941b786d3d": "Ybodychange",
    "70f3e66c944670a818922f101162226ef604b263": "Ybodychange",
    "82eb44707b620803d424188a1eb8708fcaf093cb": "Ymultichange(Yreturntypechange,Ybodychange)",
    "acf74024c2d341bf4009af7173c9b1b972f19c32": "Ybodychange",
    "7317fe7d60ad0af88e9ee692e95dd5dde832863e": "Ybodychange",
    "2c6d213f0359d5b52a9d570323aa10505415f6ac": "Ybodychange",
    "68b3e019e1216a941ff5d8dcf63aefc9b35a3787": "Ybodychange",
    "47a5cc851b7db16ab0bcd4b1c0a4dceccfe13f74": "Ybodychange",
    "cb7655f9661f11dab8ec9e2533722d649a16e715": "Ybodychange",
    "31433fc385c0fea7ead68e4c853807752e061565": "Ybodychange",
    "a541f77a5a66a911e347d294aa76d8703e72e7db": "Ybodychange",
    "651f1ca3e9c7a8fec6826f9da14f9abb5fe921e0": "Ybodychange",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": "Yfilerename",
    "ead147279ca0b84d2f479a714943b20cd689e7c7": "Ybodychange",
    "a6849db3884e47909d2d97fcac0b057ab13d544b": "Ybodychange",
    "94446666d149c898131d04e7fd567777258e4e1e": "Ybodychange",
    "b9725d0d363bb2b1364fb159eefdfbfbc1e3fa97": "Ybodychange",
    "a75fd9d3835fade5c3a1a6ef7a9d36d108a1367e": "Ybodychange",
    "f20bec1be7e976300ef4857e347bc735ded0f305": "Ybodychange",
    "4a18b1ee8ed716d6e32e190f728f1eee57148872": "Ybodychange",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": "Yfilerename",
    "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8": "Ybodychange",
    "fb388c36c0045c50744cf215521e5c280036aa70": "Yfilerename",
    "c04083d20425a664115db6b0df3ca9632e66ecca": "Ybodychange",
    "0e81f51c40996b42cb262dc2397126cee8f60965": "Ybodychange",
    "fb0467dc222157e9f485ae4b3f6c7a637fdfcd1c": "Ybodychange",
    "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b": "Ybodychange",
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6": "Ybodychange",
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4": "Ybodychange",
    "d0348de241a6cf6be9c51500870ee1fb26172101": "Ybodychange",
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481": "Ybodychange",
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176": "Ybodychange",
    "416e7b16f820700af08a94e4b38a2b4c24ef6a2c": "Ybodychange",
    "00f005b38e8b83eb1d60db9070c6e9e3beffe403": "Ybodychange",
    "d6edae7874d2e78cbd401619ad53a9f9e2288597": "Ybodychange",
    "d0b5fa9e41aaf140b9a30c716ac7a74b24508451": "Ybodychange",
    "31b108cbfd418f43e7b568374af2e635a580e171": "Ybodychange",
    "bac18a129c45335e69d811b3872fcb938e1f0ff8": "Ybodychange",
    "46aefdd68f2f2597a19b72da36681123cb3090e6": "Ybodychange",
    "6c297529e31036058837adbaa57cee652d4cc918": "Ybodychange",
    "7b2a0b366461674aa6320b11a38a17909d8a74a3": "Ybodychange",
    "feab46de5d87b02bf38b29962613676adf14f78a": "Ybodychange",
    "54b73148ab5bfb5e3c2f1c2aa463265d033ac926": "Ybodychange",
    "0c4c859f472f7243919f1af7a0871cf8155af1ba": "Ybodychange",
    "09ceccd596e6aeebb5eca309093ef32216291f1e": "Ybodychange",
    "850c0caa4c64df32d5fc44a5512d6d41f4534a08": "Ybodychange",
    "22bf613d486d43114d1547e5bc623535aa2aca2a": "Ybodychange",
    "627b56302d259409e9bc50b20d77803484f18b5c": "Ymultichange(Yrename,Ymodifierchange)",
    "1adb8b4c97103ac5b15d009f3eda791a53b83d6f": "Ybodychange",
    "fd2e083224d3ee0e9ccca4431d63a84601e0d606": "Ymultichange(Yparameterchange,Ybodychange)",
    "80f951258992f75441239c79e0f31eda7d47e107": "Ybodychange",
    "2568d9ebe91ceb0a13c98b16f99593cd22084efa": "Ybodychange",
    "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b": "Ybodychange",
    "630eb94d43670f2080c7273584d49c0b0d4162f1": "Ybodychange",
    "fa3b6f1d0199dacb9069c24a1c2de0e31de38cb3": "Ybodychange",
    "3def8748ada27ac91166941a892adfd83ca3db2a": "Ybodychange",
    "381c389ea62cf20d6109dac96bb5f8202ccc0b34": "Ybodychange",
    "8b8cc6cddbf5af0c93c4ceffd015f6328c932149": "Yintroduced"
  },
  "changeHistoryDetails": {
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
      "type": "Yfilerename",
      "commitMessage": "rename JSS modules\n",
      "commitDate": "2018-01-10, 7:52 a.m.",
      "commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018-01-10, 3:01 a.m.",
      "commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 391,
      "functionName": "getTypeConcrete",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java"
      }
    },
    "198ba6cbe49832ac09ca84c6920e9be661a3b56a": {
      "type": "Yreturntypechange",
      "commitMessage": "issue1154: correct most compilation errors in the jp model\n",
      "commitDate": "2017-09-29, 2:30 a.m.",
      "commitName": "198ba6cbe49832ac09ca84c6920e9be661a3b56a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-09-28, 4:36 p.m.",
      "commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.41,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 388,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,4 +1,4 @@\n-    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n+    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         return node.accept(typeExtractor, solveLambdas);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "Type",
        "newValue": "ResolvedType"
      }
    },
    "0f40221492b47df25615a1b5909fefa6f2d6fa0e": {
      "type": "Ybodychange",
      "commitMessage": "Refactored out huge method from facade to visitor\n",
      "commitDate": "2017-02-13, 6:49 p.m.",
      "commitName": "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017-02-01, 7:04 p.m.",
      "commitNameOld": "a12a91a78591323403230d5654879a44ab4afb20",
      "commitAuthorOld": "Brandon Fergerson",
      "daysBetweenCommits": 11.99,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 357,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,322 +1,4 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n-        if (node instanceof NameExpr) {\n-            NameExpr nameExpr \u003d (NameExpr) node;\n-            logger.finest(\"getType on name expr \" + node);\n-            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n-            if (!value.isPresent()) {\n-                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n-            } else {\n-                return value.get().getType();\n-            }\n-        } else if (node instanceof MethodCallExpr) {\n-            logger.finest(\"getType on method call \" + node);\n-            // first solve the method\n-            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n-            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n-            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n-            return ref.returnType();\n-            // the type is the return type of the method\n-        } else if (node instanceof LambdaExpr) {\n-            if (getParentNode(node) instanceof MethodCallExpr) {\n-                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n-                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n-                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n-                if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n-                }\n-                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n-                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-                if (solveLambdas) {\n-\n-                    // The type parameter referred here should be the java.util.stream.Stream.T\n-                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-\n-                    // FIXME: here we should replace the type parameters that can be resolved\n-                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n-                    //        the MethodDeclaration of filter is:\n-                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n-                    //        but T in this case is equal to String\n-                    if (callExpr.getScope().isPresent()) {\n-                        Expression scope \u003d callExpr.getScope().get();\n-\n-                        // If it is a static call we should not try to get the type of the scope\n-                        boolean staticCall \u003d false;\n-                        if (scope instanceof NameExpr) {\n-                            NameExpr nameExpr \u003d (NameExpr) scope;\n-                            try {\n-                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n-                                staticCall \u003d true;\n-                            } catch (Exception e) {\n-\n-                            }\n-                        }\n-\n-                        if (!staticCall) {\n-                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(scope);\n-                            if (scopeType.isReferenceType()) {\n-                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n-                            }\n-                        }\n-                    }\n-\n-                    // We need to replace the type variables\n-                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n-                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n-\n-                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n-                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n-                    //lambdas\n-                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n-                    if (functionalMethod.isPresent()) {\n-                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-\n-                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n-                        // At this point parameterType\n-                        // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n-                        // we should replace Stream.T\n-                        Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n-                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n-                        //inferenceContext.addPair(parameterType, result);\n-                        inferenceContext.addPair(result, functionalInterfaceType);\n-                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                            Type actualType \u003d getType(expressionStmt.getExpression());\n-                            Type formalType \u003d functionalMethod.get().returnType();\n-                            inferenceContext.addPair(formalType, actualType);\n-                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n-                        } else {\n-                            throw new UnsupportedOperationException();\n-                        }\n-                    }\n-\n-                    return result;\n-                } else {\n-                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-                }\n-            } else {\n-                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n-            }\n-        } else if (node instanceof MethodReferenceExpr) {\n-            if (getParentNode(node) instanceof MethodCallExpr) {\n-                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n-                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n-                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n-                if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n-                }\n-                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n-                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-                if (solveLambdas) {\n-                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-                    // We need to replace the type variables\n-                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n-                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n-\n-                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n-                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n-                    //lambdas\n-                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n-                    if (functionalMethod.isPresent()) {\n-                        if (node instanceof MethodReferenceExpr) {\n-                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n-\n-                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n-                            Type formalType \u003d functionalMethod.get().returnType();\n-\n-                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n-                            inferenceContext.addPair(formalType, actualType);\n-                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n-                        } else {\n-                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-\n-                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                                Type actualType \u003d getType(expressionStmt.getExpression());\n-                                Type formalType \u003d functionalMethod.get().returnType();\n-\n-                                InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n-                                inferenceContext.addPair(formalType, actualType);\n-                                result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n-                            } else {\n-                                throw new UnsupportedOperationException();\n-                            }\n-                        }\n-                    }\n-\n-                    return result;\n-                } else {\n-                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-                }\n-            } else {\n-                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n-            }\n-        } else if (node instanceof VariableDeclarator) {\n-            if (getParentNode(node) instanceof FieldDeclaration) {\n-//                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n-                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n-            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n-//                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n-                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n-            } else {\n-                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n-            }\n-        } else if (node instanceof Parameter) {\n-            Parameter parameter \u003d (Parameter) node;\n-            if (parameter.getType() instanceof UnknownType) {\n-                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n-            }\n-            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n-        } else if (node instanceof FieldAccessExpr) {\n-            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n-            // We should understand if this is a static access\n-            if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n-                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n-                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n-                if (typeAccessedStatically.isSolved()) {\n-                    // TODO here maybe we have to substitute type typeParametersValues\n-                    return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n-                }\n-            } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n-                // try to find fully qualified name\n-                SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n-                if (sr.isSolved()) {\n-                    return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n-                }\n-            }\n-            Optional\u003cValue\u003e value \u003d null;\n-            try {\n-                value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n-            } catch (UnsolvedSymbolException use) {\n-                // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n-                if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n-                    throw use;\n-                }\n-                SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n-                if (sref.isSolved()) {\n-                    return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n-                }\n-            }\n-            if (value !\u003d null \u0026\u0026 value.isPresent()) {\n-                return value.get().getType();\n-            } else {\n-                throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n-            }\n-        } else if (node instanceof ObjectCreationExpr) {\n-            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n-            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n-            return type;\n-        } else if (node instanceof NullLiteralExpr) {\n-            return NullType.INSTANCE;\n-        } else if (node instanceof BooleanLiteralExpr) {\n-            return PrimitiveType.BOOLEAN;\n-        } else if (node instanceof IntegerLiteralExpr) {\n-            return PrimitiveType.INT;\n-        } else if (node instanceof LongLiteralExpr) {\n-            return PrimitiveType.LONG;\n-        } else if (node instanceof CharLiteralExpr) {\n-            return PrimitiveType.CHAR;\n-        } else if (node instanceof DoubleLiteralExpr) {\n-            if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n-                return PrimitiveType.FLOAT;\n-            }\n-            return PrimitiveType.DOUBLE;\n-        } else if (node instanceof StringLiteralExpr) {\n-            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n-        } else if (node instanceof UnaryExpr) {\n-            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n-            switch (unaryExpr.getOperator()) {\n-                case MINUS:\n-                case PLUS:\n-                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n-                case LOGICAL_COMPLEMENT:\n-                    return PrimitiveType.BOOLEAN;\n-                case POSTFIX_DECREMENT:\n-                case PREFIX_DECREMENT:\n-                case POSTFIX_INCREMENT:\n-                case PREFIX_INCREMENT:\n-                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n-                default:\n-                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n-            }\n-        } else if (node instanceof BinaryExpr) {\n-            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n-            switch (binaryExpr.getOperator()) {\n-                case PLUS:\n-                case MINUS:\n-                case DIVIDE:\n-                case MULTIPLY:\n-                    return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n-                case LESS_EQUALS:\n-                case LESS:\n-                case GREATER:\n-                case GREATER_EQUALS:\n-                case EQUALS:\n-                case NOT_EQUALS:\n-                case OR:\n-                case AND:\n-                    return PrimitiveType.BOOLEAN;\n-                case BINARY_AND:\n-                case BINARY_OR:\n-                case SIGNED_RIGHT_SHIFT:\n-                case UNSIGNED_RIGHT_SHIFT:\n-                case LEFT_SHIFT:\n-                case REMAINDER:\n-                case XOR:\n-                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n-                default:\n-                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n-            }\n-        } else if (node instanceof VariableDeclarationExpr) {\n-            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n-            if (expr.getVariables().size() !\u003d 1) {\n-                throw new UnsupportedOperationException();\n-            }\n-            return convertToUsageVariableType(expr.getVariables().get(0));\n-        } else if (node instanceof InstanceOfExpr) {\n-            return PrimitiveType.BOOLEAN;\n-        } else if (node instanceof EnclosedExpr) {\n-            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n-            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n-        } else if (node instanceof CastExpr) {\n-            CastExpr enclosedExpr \u003d (CastExpr) node;\n-            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n-        } else if (node instanceof AssignExpr) {\n-            AssignExpr assignExpr \u003d (AssignExpr) node;\n-            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n-        } else if (node instanceof ThisExpr) {\n-            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n-        } else if (node instanceof ConditionalExpr) {\n-            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n-            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n-        } else if (node instanceof ArrayCreationExpr) {\n-            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n-            Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n-            for (int i\u003d0;i\u003carrayCreationExpr.getLevels().size();i++) {\n-                res \u003d new ArrayType(res);\n-            }\n-            return res;\n-        } else if (node instanceof ArrayAccessExpr) {\n-            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n-            Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n-            if (arrayUsageType.isArray()) {\n-                return ((ArrayType) arrayUsageType).getComponentType();\n-            }\n-            return arrayUsageType;\n-        } else if (node instanceof SuperExpr) {\n-            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n-            if (typeOfNode instanceof ClassDeclaration) {\n-                return ((ClassDeclaration) typeOfNode).getSuperClass();\n-            } else {\n-                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n-            }\n-        } else if (node instanceof ClassExpr) {\n-            // This implementation does not regard the actual type argument of the ClassExpr.\n-            ClassExpr classExpr \u003d (ClassExpr) node;\n-            com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n-            Type jssType \u003d convertToUsage(astType, classExpr.getType());\n-            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n-        } else {\n-            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n-        }\n+        return node.accept(typeExtractor, solveLambdas);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1": {
      "type": "Ybodychange",
      "commitMessage": "Update for JavaParser 3.0.0\n",
      "commitDate": "2017-01-11, 7:45 p.m.",
      "commitName": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017-01-10, 5:19 p.m.",
      "commitNameOld": "dd73ec538fbacfc1a05acb6d0ac35da3b4e87bc3",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 1.1,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope().isPresent()) {\n                        Expression scope \u003d callExpr.getScope().get();\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (scope instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr) scope;\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(scope);\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        // At this point parameterType\n                        // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                        // we should replace Stream.T\n                        Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                        //inferenceContext.addPair(parameterType, result);\n                        inferenceContext.addPair(result, functionalInterfaceType);\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n\n                                InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                inferenceContext.addPair(formalType, actualType);\n                                result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n//                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n//                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                }\n            } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n                // try to find fully qualified name\n                SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n                if (sr.isSolved()) {\n                    return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n                }\n            }\n            Optional\u003cValue\u003e value \u003d null;\n            try {\n                value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n            } catch (UnsolvedSymbolException use) {\n                // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n                if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                    throw use;\n                }\n                SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n                if (sref.isSolved()) {\n                    return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n                }\n            }\n            if (value !\u003d null \u0026\u0026 value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n                return PrimitiveType.FLOAT;\n            }\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case MINUS:\n                case PLUS:\n                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                case LOGICAL_COMPLEMENT:\n                    return PrimitiveType.BOOLEAN;\n                case POSTFIX_DECREMENT:\n                case PREFIX_DECREMENT:\n                case POSTFIX_INCREMENT:\n                case PREFIX_INCREMENT:\n                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case PLUS:\n                case MINUS:\n                case DIVIDE:\n                case MULTIPLY:\n                    return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n                case LESS_EQUALS:\n                case LESS:\n                case GREATER:\n                case GREATER_EQUALS:\n                case EQUALS:\n                case NOT_EQUALS:\n                case OR:\n                case AND:\n                    return PrimitiveType.BOOLEAN;\n                case BINARY_AND:\n                case BINARY_OR:\n                case SIGNED_RIGHT_SHIFT:\n                case UNSIGNED_RIGHT_SHIFT:\n                case LEFT_SHIFT:\n                case REMAINDER:\n                case XOR:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0;i\u003carrayCreationExpr.getLevels().size();i++) {\n                res \u003d new ArrayType(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n            if (arrayUsageType.isArray()) {\n                return ((ArrayType) arrayUsageType).getComponentType();\n            }\n            return arrayUsageType;\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            ClassExpr classExpr \u003d (ClassExpr) node;\n            com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n            Type jssType \u003d convertToUsage(astType, classExpr.getType());\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 356,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,321 +1,322 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n-                    if (callExpr.getScope() !\u003d null) {\n+                    if (callExpr.getScope().isPresent()) {\n+                        Expression scope \u003d callExpr.getScope().get();\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall \u003d false;\n-                        if (callExpr.getScope() instanceof NameExpr) {\n-                            NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n+                        if (scope instanceof NameExpr) {\n+                            NameExpr nameExpr \u003d (NameExpr) scope;\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                 staticCall \u003d true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n-                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n+                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(scope);\n                             if (scopeType.isReferenceType()) {\n                                 result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                         // we should replace Stream.T\n                         Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n //                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n //                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n                 // try to find fully qualified name\n                 SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n                 if (sr.isSolved()) {\n                     return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             }\n             Optional\u003cValue\u003e value \u003d null;\n             try {\n                 value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n             } catch (UnsolvedSymbolException use) {\n                 // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n                 if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                     throw use;\n                 }\n                 SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n                 if (sref.isSolved()) {\n                     return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n                 }\n             }\n             if (value !\u003d null \u0026\u0026 value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n                 return PrimitiveType.FLOAT;\n             }\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case MINUS:\n                 case PLUS:\n                     return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                 case LOGICAL_COMPLEMENT:\n                     return PrimitiveType.BOOLEAN;\n                 case POSTFIX_DECREMENT:\n                 case PREFIX_DECREMENT:\n                 case POSTFIX_INCREMENT:\n                 case PREFIX_INCREMENT:\n                     return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case PLUS:\n                 case MINUS:\n                 case DIVIDE:\n                 case MULTIPLY:\n                     return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n                 case LESS_EQUALS:\n                 case LESS:\n                 case GREATER:\n                 case GREATER_EQUALS:\n                 case EQUALS:\n                 case NOT_EQUALS:\n                 case OR:\n                 case AND:\n                     return PrimitiveType.BOOLEAN;\n                 case BINARY_AND:\n                 case BINARY_OR:\n                 case SIGNED_RIGHT_SHIFT:\n                 case UNSIGNED_RIGHT_SHIFT:\n                 case LEFT_SHIFT:\n                 case REMAINDER:\n                 case XOR:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0;i\u003carrayCreationExpr.getLevels().size();i++) {\n                 res \u003d new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n             if (arrayUsageType.isArray()) {\n                 return ((ArrayType) arrayUsageType).getComponentType();\n             }\n             return arrayUsageType;\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr \u003d (ClassExpr) node;\n             com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n             Type jssType \u003d convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "90c22f84a61e12130a8750d235acf7ed06305796": {
      "type": "Ybodychange",
      "commitMessage": "migration to JavaParser 3.0.0-RC.3\n",
      "commitDate": "2016-12-19, 11:01 a.m.",
      "commitName": "90c22f84a61e12130a8750d235acf7ed06305796",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-12-13, 2:42 p.m.",
      "commitNameOld": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 5.85,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope() !\u003d null) {\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (callExpr.getScope() instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        // At this point parameterType\n                        // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                        // we should replace Stream.T\n                        Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                        //inferenceContext.addPair(parameterType, result);\n                        inferenceContext.addPair(result, functionalInterfaceType);\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n\n                                InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                inferenceContext.addPair(formalType, actualType);\n                                result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n//                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n//                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                }\n            } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n                // try to find fully qualified name\n                SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n                if (sr.isSolved()) {\n                    return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n                }\n            }\n            Optional\u003cValue\u003e value \u003d null;\n            try {\n                value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n            } catch (UnsolvedSymbolException use) {\n                // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n                if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                    throw use;\n                }\n                SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n                if (sref.isSolved()) {\n                    return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n                }\n            }\n            if (value !\u003d null \u0026\u0026 value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n                return PrimitiveType.FLOAT;\n            }\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case MINUS:\n                case PLUS:\n                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                case LOGICAL_COMPLEMENT:\n                    return PrimitiveType.BOOLEAN;\n                case POSTFIX_DECREMENT:\n                case PREFIX_DECREMENT:\n                case POSTFIX_INCREMENT:\n                case PREFIX_INCREMENT:\n                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case PLUS:\n                case MINUS:\n                case DIVIDE:\n                case MULTIPLY:\n                    return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n                case LESS_EQUALS:\n                case LESS:\n                case GREATER:\n                case GREATER_EQUALS:\n                case EQUALS:\n                case NOT_EQUALS:\n                case OR:\n                case AND:\n                    return PrimitiveType.BOOLEAN;\n                case BINARY_AND:\n                case BINARY_OR:\n                case SIGNED_RIGHT_SHIFT:\n                case UNSIGNED_RIGHT_SHIFT:\n                case LEFT_SHIFT:\n                case REMAINDER:\n                case XOR:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0;i\u003carrayCreationExpr.getLevels().size();i++) {\n                res \u003d new ArrayType(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n            if (arrayUsageType.isArray()) {\n                return ((ArrayType) arrayUsageType).getComponentType();\n            }\n            return arrayUsageType;\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            ClassExpr classExpr \u003d (ClassExpr) node;\n            com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n            Type jssType \u003d convertToUsage(astType, classExpr.getType());\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 355,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,321 +1,321 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope() !\u003d null) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall \u003d false;\n                         if (callExpr.getScope() instanceof NameExpr) {\n                             NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                 staticCall \u003d true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                             if (scopeType.isReferenceType()) {\n                                 result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                         // we should replace Stream.T\n                         Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n //                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n //                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n                 // try to find fully qualified name\n                 SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n                 if (sr.isSolved()) {\n                     return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             }\n             Optional\u003cValue\u003e value \u003d null;\n             try {\n                 value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n             } catch (UnsolvedSymbolException use) {\n                 // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n                 if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                     throw use;\n                 }\n                 SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n                 if (sref.isSolved()) {\n                     return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n                 }\n             }\n             if (value !\u003d null \u0026\u0026 value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n                 return PrimitiveType.FLOAT;\n             }\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case MINUS:\n                 case PLUS:\n                     return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                 case LOGICAL_COMPLEMENT:\n                     return PrimitiveType.BOOLEAN;\n                 case POSTFIX_DECREMENT:\n                 case PREFIX_DECREMENT:\n                 case POSTFIX_INCREMENT:\n                 case PREFIX_INCREMENT:\n                     return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case PLUS:\n                 case MINUS:\n                 case DIVIDE:\n                 case MULTIPLY:\n                     return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n                 case LESS_EQUALS:\n                 case LESS:\n                 case GREATER:\n                 case GREATER_EQUALS:\n                 case EQUALS:\n                 case NOT_EQUALS:\n                 case OR:\n                 case AND:\n                     return PrimitiveType.BOOLEAN;\n                 case BINARY_AND:\n                 case BINARY_OR:\n                 case SIGNED_RIGHT_SHIFT:\n                 case UNSIGNED_RIGHT_SHIFT:\n                 case LEFT_SHIFT:\n                 case REMAINDER:\n                 case XOR:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0;i\u003carrayCreationExpr.getLevels().size();i++) {\n                 res \u003d new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n             if (arrayUsageType.isArray()) {\n                 return ((ArrayType) arrayUsageType).getComponentType();\n             }\n             return arrayUsageType;\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr \u003d (ClassExpr) node;\n-            com.github.javaparser.ast.type.Type\u003c?\u003e astType \u003d classExpr.getType();\n+            com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n             Type jssType \u003d convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923": {
      "type": "Ybodychange",
      "commitMessage": "porting to JavaParser 3.0.0 RC2\n",
      "commitDate": "2016-12-13, 2:42 p.m.",
      "commitName": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-12-13, 11:45 a.m.",
      "commitNameOld": "cb5ffb7fdd56f1b768d25da330fa3b29ecb74eaf",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope() !\u003d null) {\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (callExpr.getScope() instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        // At this point parameterType\n                        // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                        // we should replace Stream.T\n                        Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                        //inferenceContext.addPair(parameterType, result);\n                        inferenceContext.addPair(result, functionalInterfaceType);\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n\n                                InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                inferenceContext.addPair(formalType, actualType);\n                                result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n//                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n//                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                }\n            } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n                // try to find fully qualified name\n                SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n                if (sr.isSolved()) {\n                    return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n                }\n            }\n            Optional\u003cValue\u003e value \u003d null;\n            try {\n                value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n            } catch (UnsolvedSymbolException use) {\n                // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n                if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                    throw use;\n                }\n                SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n                if (sref.isSolved()) {\n                    return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n                }\n            }\n            if (value !\u003d null \u0026\u0026 value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n                return PrimitiveType.FLOAT;\n            }\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case MINUS:\n                case PLUS:\n                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                case LOGICAL_COMPLEMENT:\n                    return PrimitiveType.BOOLEAN;\n                case POSTFIX_DECREMENT:\n                case PREFIX_DECREMENT:\n                case POSTFIX_INCREMENT:\n                case PREFIX_INCREMENT:\n                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case PLUS:\n                case MINUS:\n                case DIVIDE:\n                case MULTIPLY:\n                    return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n                case LESS_EQUALS:\n                case LESS:\n                case GREATER:\n                case GREATER_EQUALS:\n                case EQUALS:\n                case NOT_EQUALS:\n                case OR:\n                case AND:\n                    return PrimitiveType.BOOLEAN;\n                case BINARY_AND:\n                case BINARY_OR:\n                case SIGNED_RIGHT_SHIFT:\n                case UNSIGNED_RIGHT_SHIFT:\n                case LEFT_SHIFT:\n                case REMAINDER:\n                case XOR:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0;i\u003carrayCreationExpr.getLevels().size();i++) {\n                res \u003d new ArrayType(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n            if (arrayUsageType.isArray()) {\n                return ((ArrayType) arrayUsageType).getComponentType();\n            }\n            return arrayUsageType;\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            ClassExpr classExpr \u003d (ClassExpr) node;\n            com.github.javaparser.ast.type.Type\u003c?\u003e astType \u003d classExpr.getType();\n            Type jssType \u003d convertToUsage(astType, classExpr.getType());\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 355,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,318 +1,321 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope() !\u003d null) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall \u003d false;\n                         if (callExpr.getScope() instanceof NameExpr) {\n                             NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                 staticCall \u003d true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                             if (scopeType.isReferenceType()) {\n                                 result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                         // we should replace Stream.T\n                         Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n //                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n //                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n                 // try to find fully qualified name\n                 SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n                 if (sr.isSolved()) {\n                     return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             }\n             Optional\u003cValue\u003e value \u003d null;\n             try {\n                 value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n             } catch (UnsolvedSymbolException use) {\n                 // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n                 if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                     throw use;\n                 }\n                 SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n                 if (sref.isSolved()) {\n                     return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n                 }\n             }\n             if (value !\u003d null \u0026\u0026 value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n                 return PrimitiveType.FLOAT;\n             }\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n-                case negative:\n-                case positive:\n-                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n-                case not:\n+                case MINUS:\n+                case PLUS:\n+                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n+                case LOGICAL_COMPLEMENT:\n                     return PrimitiveType.BOOLEAN;\n-                case postIncrement:\n-                case preIncrement:\n-                case preDecrement:\n-                case postDecrement:\n-                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n+                case POSTFIX_DECREMENT:\n+                case PREFIX_DECREMENT:\n+                case POSTFIX_INCREMENT:\n+                case PREFIX_INCREMENT:\n+                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n-                case plus:\n-                case minus:\n-                case divide:\n-                case times:\n+                case PLUS:\n+                case MINUS:\n+                case DIVIDE:\n+                case MULTIPLY:\n                     return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n-                case lessEquals:\n-                case less:\n-                case greater:\n-                case greaterEquals:\n-                case equals:\n-                case notEquals:\n-                case or:\n-                case and:\n+                case LESS_EQUALS:\n+                case LESS:\n+                case GREATER:\n+                case GREATER_EQUALS:\n+                case EQUALS:\n+                case NOT_EQUALS:\n+                case OR:\n+                case AND:\n                     return PrimitiveType.BOOLEAN;\n-                case binAnd:\n-                case binOr:\n-                case rSignedShift:\n-                case rUnsignedShift:\n-                case lShift:\n-                case remainder:\n-                case xor:\n+                case BINARY_AND:\n+                case BINARY_OR:\n+                case SIGNED_RIGHT_SHIFT:\n+                case UNSIGNED_RIGHT_SHIFT:\n+                case LEFT_SHIFT:\n+                case REMAINDER:\n+                case XOR:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n-            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+            Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n+            for (int i\u003d0;i\u003carrayCreationExpr.getLevels().size();i++) {\n+                res \u003d new ArrayType(res);\n+            }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n             if (arrayUsageType.isArray()) {\n                 return ((ArrayType) arrayUsageType).getComponentType();\n             }\n             return arrayUsageType;\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr \u003d (ClassExpr) node;\n             com.github.javaparser.ast.type.Type\u003c?\u003e astType \u003d classExpr.getType();\n             Type jssType \u003d convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c990d23490f5c4ac4322119b03d5951b63eef055": {
      "type": "Ybodychange",
      "commitMessage": "loads of changes to support our code",
      "commitDate": "2016-12-13, 8:10 a.m.",
      "commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
      "commitAuthor": "Fred Lefvre-Laoide",
      "commitDateOld": "2016-11-21, 3:52 p.m.",
      "commitNameOld": "dfebf682a440aa48a8a444562f7fdfc1819b9a1e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 21.68,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope() !\u003d null) {\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (callExpr.getScope() instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        // At this point parameterType\n                        // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                        // we should replace Stream.T\n                        Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                        //inferenceContext.addPair(parameterType, result);\n                        inferenceContext.addPair(result, functionalInterfaceType);\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n\n                                InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                inferenceContext.addPair(formalType, actualType);\n                                result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n//                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n//                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                }\n            } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n              // try to find fully qualified name\n              SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n              if (sr.isSolved()) {\n                return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n              }\n            }\n            Optional\u003cValue\u003e value \u003d null;\n            try {\n              value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n            } catch (UnsolvedSymbolException use) {\n              // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n              if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                throw use;\n              }\n              SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n              if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n              }\n            }\n            if (value !\u003d null \u0026\u0026 value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n              return PrimitiveType.FLOAT;\n            }\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                case divide:\n                case times:\n                    return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                case rSignedShift:\n                case rUnsignedShift:\n                case lShift:\n                case remainder:\n                case xor:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n            if (arrayUsageType.isArray()) {\n              return ((ArrayType) arrayUsageType).getComponentType();\n            }\n            return arrayUsageType;\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            ClassExpr classExpr \u003d (ClassExpr)node;\n            com.github.javaparser.ast.type.Type\u003c?\u003e astType \u003d classExpr.getType();\n            Type jssType \u003d convertToUsage(astType, classExpr.getType());\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 407,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,286 +1,318 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope() !\u003d null) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall \u003d false;\n                         if (callExpr.getScope() instanceof NameExpr) {\n                             NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                 staticCall \u003d true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                             if (scopeType.isReferenceType()) {\n                                 result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                         // we should replace Stream.T\n                         Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n-                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n+//                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n-                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n+//                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n+            } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n+              // try to find fully qualified name\n+              SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n+              if (sr.isSolved()) {\n+                return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n+              }\n             }\n-            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n-            if (value.isPresent()) {\n+            Optional\u003cValue\u003e value \u003d null;\n+            try {\n+              value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n+            } catch (UnsolvedSymbolException use) {\n+              // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n+              if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n+                throw use;\n+              }\n+              SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n+              if (sref.isSolved()) {\n+                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n+              }\n+            }\n+            if (value !\u003d null \u0026\u0026 value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n+            if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n+              return PrimitiveType.FLOAT;\n+            }\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n-                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n+                case divide:\n+                case times:\n+                    return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n+                case rSignedShift:\n+                case rUnsignedShift:\n+                case lShift:\n+                case remainder:\n+                case xor:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n-            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n+            Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n+            if (arrayUsageType.isArray()) {\n+              return ((ArrayType) arrayUsageType).getComponentType();\n+            }\n+            return arrayUsageType;\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr \u003d (ClassExpr)node;\n-            com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n+            com.github.javaparser.ast.type.Type\u003c?\u003e astType \u003d classExpr.getType();\n             Type jssType \u003d convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": {
      "type": "Ybodychange",
      "commitMessage": "adapt to alpha.10\n",
      "commitDate": "2016-11-21, 1:58 p.m.",
      "commitName": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-09, 12:15 p.m.",
      "commitNameOld": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 12.07,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope() !\u003d null) {\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (callExpr.getScope() instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        // At this point parameterType\n                        // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                        // we should replace Stream.T\n                        Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                        //inferenceContext.addPair(parameterType, result);\n                        inferenceContext.addPair(result, functionalInterfaceType);\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n\n                                InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                inferenceContext.addPair(formalType, actualType);\n                                result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                }\n            }\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            ClassExpr classExpr \u003d (ClassExpr)node;\n            com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n            Type jssType \u003d convertToUsage(astType, classExpr.getType());\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,286 +1,286 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n             if (!value.isPresent()) {\n-                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n+                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n+                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope() !\u003d null) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall \u003d false;\n                         if (callExpr.getScope() instanceof NameExpr) {\n                             NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                             try {\n-                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n+                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                 staticCall \u003d true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                             if (scopeType.isReferenceType()) {\n                                 result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                         // we should replace Stream.T\n                         Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n+                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n-            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n-                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n+            if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n+                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n-                    return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField()).getType();\n+                    return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             }\n-            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n-                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n+                throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n-            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n+            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr \u003d (ClassExpr)node;\n             com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n             Type jssType \u003d convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": {
      "type": "Ybodychange",
      "commitMessage": "changes necessary to support jpalpha8\n",
      "commitDate": "2016-11-09, 12:15 p.m.",
      "commitName": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-06, 3:40 a.m.",
      "commitNameOld": "c746c4ef7711a05c27827ab749d96155046a4f91",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 3.36,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope() !\u003d null) {\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (callExpr.getScope() instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        // At this point parameterType\n                        // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                        // we should replace Stream.T\n                        Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                        //inferenceContext.addPair(parameterType, result);\n                        inferenceContext.addPair(result, functionalInterfaceType);\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n\n                                InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                inferenceContext.addPair(formalType, actualType);\n                                result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField()).getType();\n                }\n            }\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            ClassExpr classExpr \u003d (ClassExpr)node;\n            com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n            Type jssType \u003d convertToUsage(astType, classExpr.getType());\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,286 +1,286 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n-                    if (callExpr.getScope().isPresent()) {\n+                    if (callExpr.getScope() !\u003d null) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall \u003d false;\n-                        if (callExpr.getScope().get() instanceof NameExpr) {\n-                            NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n+                        if (callExpr.getScope() instanceof NameExpr) {\n+                            NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall \u003d true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n-                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n+                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                             if (scopeType.isReferenceType()) {\n                                 result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                         // we should replace Stream.T\n                         Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n-            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n+            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr \u003d (ClassExpr)node;\n             com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n             Type jssType \u003d convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a1c7c58143a592965f8378767adc69709e4c0043": {
      "type": "Ybodychange",
      "commitMessage": "more refactoring for ReferenceTypeDeclaration\n",
      "commitDate": "2016-11-05, 11:22 a.m.",
      "commitName": "a1c7c58143a592965f8378767adc69709e4c0043",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-05, 11:08 a.m.",
      "commitNameOld": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope().isPresent()) {\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (callExpr.getScope().get() instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        // At this point parameterType\n                        // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                        // we should replace Stream.T\n                        Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                        //inferenceContext.addPair(parameterType, result);\n                        inferenceContext.addPair(result, functionalInterfaceType);\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n\n                                InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                inferenceContext.addPair(formalType, actualType);\n                                result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField()).getType();\n                }\n            }\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            ClassExpr classExpr \u003d (ClassExpr)node;\n            com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n            Type jssType \u003d convertToUsage(astType, classExpr.getType());\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 269,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,286 +1,286 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall \u003d false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall \u003d true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                         // we should replace Stream.T\n                         Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n-                SymbolReference\u003cReferenceTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n+                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n-                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n+                    return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr \u003d (ClassExpr)node;\n             com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n             Type jssType \u003d convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae": {
      "type": "Ybodychange",
      "commitMessage": "creating ReferenceTypeDeclaration\n",
      "commitDate": "2016-11-05, 11:08 a.m.",
      "commitName": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-05, 3:58 a.m.",
      "commitNameOld": "2fde8a6409906ab1e0b5e846f2e54b82da7878b7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope().isPresent()) {\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (callExpr.getScope().get() instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        // At this point parameterType\n                        // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                        // we should replace Stream.T\n                        Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                        //inferenceContext.addPair(parameterType, result);\n                        inferenceContext.addPair(result, functionalInterfaceType);\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n\n                                InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                inferenceContext.addPair(formalType, actualType);\n                                result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cReferenceTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            }\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            ClassExpr classExpr \u003d (ClassExpr)node;\n            com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n            Type jssType \u003d convertToUsage(astType, classExpr.getType());\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 269,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,286 +1,286 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall \u003d false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall \u003d true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                         // we should replace Stream.T\n                         Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n-                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n+                SymbolReference\u003cReferenceTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr \u003d (ClassExpr)node;\n             com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n             Type jssType \u003d convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e0d63587820f7e8900af0c9060a2f149cc643c6c": {
      "type": "Ybodychange",
      "commitMessage": "use InferenceContext in more cases\n",
      "commitDate": "2016-11-05, 3:39 a.m.",
      "commitName": "e0d63587820f7e8900af0c9060a2f149cc643c6c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-05, 3:19 a.m.",
      "commitNameOld": "e174058b92c209ba1d818e53db34993236592db7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope().isPresent()) {\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (callExpr.getScope().get() instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        // At this point parameterType\n                        // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                        // we should replace Stream.T\n                        Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                        //inferenceContext.addPair(parameterType, result);\n                        inferenceContext.addPair(result, functionalInterfaceType);\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n\n                                InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                                inferenceContext.addPair(formalType, actualType);\n                                result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            }\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            ClassExpr classExpr \u003d (ClassExpr)node;\n            com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n            Type jssType \u003d convertToUsage(astType, classExpr.getType());\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 272,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,291 +1,286 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall \u003d false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall \u003d true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                         // we should replace Stream.T\n                         Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n-                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n-                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n-                            }\n \n+                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n+                            inferenceContext.addPair(formalType, actualType);\n+                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n-                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n-                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                                Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                                for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                    result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n-                                }\n+\n+                                InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n+                                inferenceContext.addPair(formalType, actualType);\n+                                result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr \u003d (ClassExpr)node;\n             com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n             Type jssType \u003d convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e174058b92c209ba1d818e53db34993236592db7": {
      "type": "Ybodychange",
      "commitMessage": "derive the type parameters in ClassExpr\n",
      "commitDate": "2016-11-05, 3:19 a.m.",
      "commitName": "e174058b92c209ba1d818e53db34993236592db7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-04, 7:05 p.m.",
      "commitNameOld": "6ca549e39bc3b05bd6eb96ba9dc697a8c1bd6552",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.34,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope().isPresent()) {\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (callExpr.getScope().get() instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        // At this point parameterType\n                        // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                        // we should replace Stream.T\n                        Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                        //inferenceContext.addPair(parameterType, result);\n                        inferenceContext.addPair(result, functionalInterfaceType);\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            }\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            ClassExpr classExpr \u003d (ClassExpr)node;\n            com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n            Type jssType \u003d convertToUsage(astType, classExpr.getType());\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 274,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,289 +1,291 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall \u003d false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall \u003d true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                         // we should replace Stream.T\n-                        Type parameterType \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                         Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n-            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n+            ClassExpr classExpr \u003d (ClassExpr)node;\n+            com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n+            Type jssType \u003d convertToUsage(astType, classExpr.getType());\n+            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6ca549e39bc3b05bd6eb96ba9dc697a8c1bd6552": {
      "type": "Ybodychange",
      "commitMessage": "improving inference logic\n",
      "commitDate": "2016-11-04, 7:05 p.m.",
      "commitName": "6ca549e39bc3b05bd6eb96ba9dc697a8c1bd6552",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-02, 4:08 p.m.",
      "commitNameOld": "effd4c172ad6e4d60d68a749121a0960040edd63",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 2.12,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope().isPresent()) {\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (callExpr.getScope().get() instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        // At this point parameterType\n                        // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n                        // we should replace Stream.T\n                        Type parameterType \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                        Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                        //inferenceContext.addPair(parameterType, result);\n                        inferenceContext.addPair(result, functionalInterfaceType);\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            }\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 273,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,284 +1,289 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall \u003d false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall \u003d true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n-                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n+                        // At this point parameterType\n+                        // if Function\u003cT\u003d? super Stream.T, ? extends map.R\u003e\n+                        // we should replace Stream.T\n+                        Type parameterType \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                        Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n+                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n+                        //inferenceContext.addPair(parameterType, result);\n+                        inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n-                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n-                            }\n+                            inferenceContext.addPair(formalType, actualType);\n+                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "78ee47e2e07cdb0b3cf80664a4e892c9dc76df00": {
      "type": "Ybodychange",
      "commitMessage": "rename JreTypeSolver to ReflectionTypeSolver\n",
      "commitDate": "2016-10-26, 12:12 p.m.",
      "commitName": "78ee47e2e07cdb0b3cf80664a4e892c9dc76df00",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-24, 4:41 p.m.",
      "commitNameOld": "08322b4714f672bed5ec424d3ace0a40da9ccd47",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.81,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope().isPresent()){\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (callExpr.getScope().get() instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr)callExpr.getScope().get();\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            }\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,284 +1,284 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()){\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall \u003d false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr \u003d (NameExpr)callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall \u003d true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n-            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n+            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "631896a1d2f34eed89c41cc717f463ebbd69e401": {
      "type": "Ybodychange",
      "commitMessage": "commenting classes in model\n",
      "commitDate": "2016-10-23, 5:26 a.m.",
      "commitName": "631896a1d2f34eed89c41cc717f463ebbd69e401",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-23, 4:58 a.m.",
      "commitNameOld": "13d789de30e6c3d29efb17a2acdff443f8c48db1",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope().isPresent()){\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (callExpr.getScope().get() instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr)callExpr.getScope().get();\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            }\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,284 +1,284 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()){\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall \u003d false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr \u003d (NameExpr)callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall \u003d true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                                    result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "13d789de30e6c3d29efb17a2acdff443f8c48db1": {
      "type": "Ybodychange",
      "commitMessage": "handling static calls\n",
      "commitDate": "2016-10-23, 4:58 a.m.",
      "commitName": "13d789de30e6c3d29efb17a2acdff443f8c48db1",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-23, 4:27 a.m.",
      "commitNameOld": "697432aaf0e6a42825e52f956bd51f0486b411d2",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope().isPresent()){\n\n                        // If it is a static call we should not try to get the type of the scope\n                        boolean staticCall \u003d false;\n                        if (callExpr.getScope().get() instanceof NameExpr) {\n                            NameExpr nameExpr \u003d (NameExpr)callExpr.getScope().get();\n                            try {\n                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                staticCall \u003d true;\n                            } catch (Exception e) {\n\n                            }\n                        }\n\n                        if (!staticCall) {\n                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                            if (scopeType.isReferenceType()) {\n                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                            }\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (typeAccessedStatically.isSolved()) {\n                    // TODO here maybe we have to substitute type typeParametersValues\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            }\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,279 +1,284 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()){\n \n+                        // If it is a static call we should not try to get the type of the scope\n+                        boolean staticCall \u003d false;\n+                        if (callExpr.getScope().get() instanceof NameExpr) {\n+                            NameExpr nameExpr \u003d (NameExpr)callExpr.getScope().get();\n+                            try {\n+                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n+                                staticCall \u003d true;\n+                            } catch (Exception e) {\n \n-                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n-                        if (scopeType.isReferenceType()) {\n-                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n+                            }\n+                        }\n+\n+                        if (!staticCall) {\n+                            Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n+                            if (scopeType.isReferenceType()) {\n+                                result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n+                            }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n-            try {\n-                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n-                if (value.isPresent()) {\n-                    return value.get().getType();\n-                } else {\n-                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n+            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n+                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n+                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n+                if (typeAccessedStatically.isSolved()) {\n+                    // TODO here maybe we have to substitute type typeParametersValues\n+                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n-            } catch (UnsolvedSymbolException e) {\n-                // Sure, it was not found as value because maybe it is a type and this is a static access\n-                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n-                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n-                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n-                    if (!typeAccessedStatically.isSolved()) {\n-                        throw e;\n-                    } else {\n-                        // TODO here maybe we have to substitute type typeParametersValues\n-                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n-                    }\n-                } else {\n-                    throw e;\n-                }\n+            }\n+            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+            if (value.isPresent()) {\n+                return value.get().getType();\n+            } else {\n+                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "697432aaf0e6a42825e52f956bd51f0486b411d2": {
      "type": "Ybodychange",
      "commitMessage": "working on resolving type parameters\n",
      "commitDate": "2016-10-23, 4:27 a.m.",
      "commitName": "697432aaf0e6a42825e52f956bd51f0486b411d2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-22, 8:36 a.m.",
      "commitNameOld": "7c43ba3c700d72a0d613bce3659af6d74bc87434",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.83,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n\n                    // The type parameter referred here should be the java.util.stream.Stream.T\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                    // FIXME: here we should replace the type parameters that can be resolved\n                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n                    //        the MethodDeclaration of filter is:\n                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n                    //        but T in this case is equal to String\n                    if (callExpr.getScope().isPresent()){\n\n\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getType();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type typeParametersValues\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 269,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,262 +1,279 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n+\n+                    // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+\n+                    // FIXME: here we should replace the type parameters that can be resolved\n+                    //        for example when invoking myListOfStrings.stream().filter(s -\u003e s.length \u003e 0);\n+                    //        the MethodDeclaration of filter is:\n+                    //        Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)\n+                    //        but T in this case is equal to String\n+                    if (callExpr.getScope().isPresent()){\n+\n+\n+                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n+                        if (scopeType.isReferenceType()) {\n+                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n+                        }\n+                    }\n+\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getType();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c43ba3c700d72a0d613bce3659af6d74bc87434": {
      "type": "Ybodychange",
      "commitMessage": "using full TypeParameterDeclarations instead of names\n",
      "commitDate": "2016-10-22, 8:36 a.m.",
      "commitName": "7c43ba3c700d72a0d613bce3659af6d74bc87434",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-22, 5:34 a.m.",
      "commitNameOld": "a3b7fa9a03cb172d50bf54feddaf90300a6d8d07",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getType();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type typeParametersValues\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 269,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                            for (String typeName : inferredTypes.keySet()) {\n+                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                            for (String typeName : inferredTypes.keySet()) {\n+                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                                for (String typeName : inferredTypes.keySet()) {\n+                                Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                                for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getType();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "15ac26bcc19e8bed431a35edd3e3c176d7d56355": {
      "type": "Ybodychange",
      "commitMessage": "minor\n",
      "commitDate": "2016-10-21, 12:08 p.m.",
      "commitName": "15ac26bcc19e8bed431a35edd3e3c176d7d56355",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-21, 2:55 a.m.",
      "commitNameOld": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.38,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getType();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getType();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type typeParametersValues\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n        } else if (node instanceof DoubleLiteralExpr) {\n            return PrimitiveType.DOUBLE;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration) typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 273,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n-                return value.get().getUsage();\n+                return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n-                    return value.get().getUsage();\n+                    return value.get().getType();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c53c2cbc607ea694438ade8630be0c155a33162": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "renamed packages to com.github.javapaerser\n",
      "commitDate": "2016-10-20, 2:39 a.m.",
      "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "renamed packages to com.github.javapaerser\n",
          "commitDate": "2016-10-20, 2:39 a.m.",
          "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-20, 2:32 a.m.",
          "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type typeParametersValues\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveType.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 269,
          "functionName": "getTypeConcrete",
          "diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n-                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
            "newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "renamed packages to com.github.javapaerser\n",
          "commitDate": "2016-10-20, 2:39 a.m.",
          "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-20, 2:32 a.m.",
          "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type typeParametersValues\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveType.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 269,
          "functionName": "getTypeConcrete",
          "diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n-                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6624f3653734698f477561c8407357e2395d411c": {
      "type": "Ybodychange",
      "commitMessage": "fix type of ArrayCreationExpr\n",
      "commitDate": "2016-10-19, 2:21 p.m.",
      "commitName": "6624f3653734698f477561c8407357e2395d411c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:36 p.m.",
      "commitNameOld": "967b0302143d4d6868c3d9035a8615ccfd198b6e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type typeParametersValues\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveType.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 273,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,265 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() !\u003d 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n-            for (int i\u003d0; i\u003carrayCreationExpr.getLevels().size();i++) {\n-                res \u003d new ArrayType(res);\n-            }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "967b0302143d4d6868c3d9035a8615ccfd198b6e": {
      "type": "Ybodychange",
      "commitMessage": "use VariableDeclarator.getType\n",
      "commitDate": "2016-10-19, 1:36 p.m.",
      "commitName": "967b0302143d4d6868c3d9035a8615ccfd198b6e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:36 p.m.",
      "commitNameOld": "9dc06a758c00cc235372dbc225a7e20c1f5269d3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type typeParametersValues\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveType.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            if (expr.getVariables().size() !\u003d 1) {\n                throw new UnsupportedOperationException();\n            }\n            return convertToUsageVariableType(expr.getVariables().get(0));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getLevels().size();i++) {\n                res \u003d new ArrayType(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 273,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,262 +1,265 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n-                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n-                return JavaParserFacade.get(typeSolver).convertToUsageVariableType(parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n-            return convertToUsageVariableType(expr);\n+            if (expr.getVariables().size() !\u003d 1) {\n+                throw new UnsupportedOperationException();\n+            }\n+            return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getLevels().size();i++) {\n                 res \u003d new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9dc06a758c00cc235372dbc225a7e20c1f5269d3": {
      "type": "Ybodychange",
      "commitMessage": "considering the ArrayBrackets\n",
      "commitDate": "2016-10-19, 1:36 p.m.",
      "commitName": "9dc06a758c00cc235372dbc225a7e20c1f5269d3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:36 p.m.",
      "commitNameOld": "4c6207acd87601844c87c13fb253ae8fd8a4a289",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsageVariableType(parent);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type typeParametersValues\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveType.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsageVariableType(expr);\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getLevels().size();i++) {\n                res \u003d new ArrayType(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n-                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsageVariableType(parent);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n-            return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n+            return convertToUsageVariableType(expr);\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getLevels().size();i++) {\n                 res \u003d new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0d14741fef3a17451db153cfe379e398da4b4b79": {
      "type": "Ybodychange",
      "commitMessage": "minor fix\n",
      "commitDate": "2016-10-19, 1:35 p.m.",
      "commitName": "0d14741fef3a17451db153cfe379e398da4b4b79",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:35 p.m.",
      "commitNameOld": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (getParentNode(node) instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type typeParametersValues\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveType.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getLevels().size();i++) {\n                res \u003d new ArrayType(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 275,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n-            if (node.getParentNode() instanceof MethodCallExpr) {\n-                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n+            if (getParentNode(node) instanceof MethodCallExpr) {\n+                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n+                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n-            if (node.getParentNode() instanceof MethodCallExpr) {\n-                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n+            if (getParentNode(node) instanceof MethodCallExpr) {\n+                MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n+                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getLevels().size();i++) {\n                 res \u003d new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7": {
      "type": "Ybodychange",
      "commitMessage": "revision of modified code to use Navigator.getParentNode\n",
      "commitDate": "2016-10-19, 1:35 p.m.",
      "commitName": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:34 p.m.",
      "commitNameOld": "03e407957d600a18ef0a4a83224c17d155ef8645",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (getParentNode(node) instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n            } else {\n                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type typeParametersValues\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveType.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getLevels().size();i++) {\n                res \u003d new ArrayType(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 275,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n-            if (node.getParentNode().getParentNode() instanceof FieldDeclaration) {\n-                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode().getParentNode();\n+            if (getParentNode(node) instanceof FieldDeclaration) {\n+                FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n-            } else if (node.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n-                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode().getParentNode();\n+            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n+                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else {\n-                throw new UnsupportedOperationException(node.getParentNode().getParentNode().getClass().getCanonicalName());\n+                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getLevels().size();i++) {\n                 res \u003d new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "03e407957d600a18ef0a4a83224c17d155ef8645": {
      "type": "Ybodychange",
      "commitMessage": "fixing a few more tests\n",
      "commitDate": "2016-10-19, 1:34 p.m.",
      "commitName": "03e407957d600a18ef0a4a83224c17d155ef8645",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:33 p.m.",
      "commitNameOld": "3fcd7b41f404d112b13d3bfe732b26eceec0dbfe",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode().getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode().getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n            } else if (node.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode().getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type typeParametersValues\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveType.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getLevels().size();i++) {\n                res \u003d new ArrayType(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n-            if (node.getParentNode() instanceof FieldDeclaration) {\n-                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n+            if (node.getParentNode().getParentNode() instanceof FieldDeclaration) {\n+                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode().getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n-            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n-                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n+            } else if (node.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n+                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode().getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else {\n-                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n+                throw new UnsupportedOperationException(node.getParentNode().getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getLevels().size();i++) {\n                 res \u003d new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "341e081a5f8909a3a467671befcca2941b786d3d": {
      "type": "Ybodychange",
      "commitMessage": "issue91: solve compilation issues\n",
      "commitDate": "2016-10-19, 1:33 p.m.",
      "commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 11:04 a.m.",
      "commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type typeParametersValues\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveType.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case postIncrement:\n                case preIncrement:\n                case preDecrement:\n                case postDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getLevels().size();i++) {\n                res \u003d new ArrayType(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n-                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n-                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n-                case posIncrement:\n+                case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n-                case posDecrement:\n+                case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n-            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+            return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n-            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n+            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n-            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n+            for (int i\u003d0; i\u003carrayCreationExpr.getLevels().size();i++) {\n                 res \u003d new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "70f3e66c944670a818922f101162226ef604b263": {
      "type": "Ybodychange",
      "commitMessage": "deprecating some methods involving type parameters\n",
      "commitDate": "2016-10-14, 1:24 p.m.",
      "commitName": "70f3e66c944670a818922f101162226ef604b263",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-14, 12:51 p.m.",
      "commitNameOld": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type typeParametersValues\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveType.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayType(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 256,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                             List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType \u003d getType(expressionStmt.getExpression());\n                                 Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                 Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n-                        // TODO here maybe we have to substitute type parameters\n+                        // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                 res \u003d new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82eb44707b620803d424188a1eb8708fcaf093cb": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "rename TypeUsage into Type\n",
      "commitDate": "2016-10-13, 4:11 p.m.",
      "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016-10-13, 4:11 p.m.",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-13, 8:20 a.m.",
          "commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveType.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayType(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 254,
          "functionName": "getTypeConcrete",
          "diff": "@@ -1,262 +1,262 @@\n-    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n+    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n-                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n-                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                            Type actualType \u003d getType(expressionStmt.getExpression());\n+                            Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n-                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n-                            TypeUsage actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n-                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n+                            Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n-                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                                TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n-                                TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                                Type actualType \u003d getType(expressionStmt.getExpression());\n+                                Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                                Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n-            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n-            return typeUsage;\n+            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+            return type;\n         } else if (node instanceof NullLiteralExpr) {\n-            return NullTypeUsage.INSTANCE;\n+            return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n-            return PrimitiveTypeUsage.BOOLEAN;\n+            return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n-            return PrimitiveTypeUsage.INT;\n+            return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n-            return PrimitiveTypeUsage.LONG;\n+            return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n-            return PrimitiveTypeUsage.CHAR;\n+            return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n-\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n+\t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n-            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n+            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n-                    return PrimitiveTypeUsage.BOOLEAN;\n+                    return PrimitiveType.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n-                    return PrimitiveTypeUsage.BOOLEAN;\n+                    return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n-            return PrimitiveTypeUsage.BOOLEAN;\n+            return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n-            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n+            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n-            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n-                res \u003d new ArrayTypeUsage(res);\n+                res \u003d new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n-            return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n+            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "TypeUsage",
            "newValue": "Type"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016-10-13, 4:11 p.m.",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-13, 8:20 a.m.",
          "commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                Type actualType \u003d getType(expressionStmt.getExpression());\n                                Type formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return type;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullType.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveType.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveType.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveType.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveType.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveType.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveType.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveType.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayType(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 254,
          "functionName": "getTypeConcrete",
          "diff": "@@ -1,262 +1,262 @@\n-    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n+    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n-                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n-                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                            Type actualType \u003d getType(expressionStmt.getExpression());\n+                            Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                    Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n-                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n-                            TypeUsage actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n-                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                            Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n+                            Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n-                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                            List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                                TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n-                                TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                                Type actualType \u003d getType(expressionStmt.getExpression());\n+                                Type formalType \u003d functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                                Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                                Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n-            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n-            return typeUsage;\n+            Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+            return type;\n         } else if (node instanceof NullLiteralExpr) {\n-            return NullTypeUsage.INSTANCE;\n+            return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n-            return PrimitiveTypeUsage.BOOLEAN;\n+            return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n-            return PrimitiveTypeUsage.INT;\n+            return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n-            return PrimitiveTypeUsage.LONG;\n+            return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n-            return PrimitiveTypeUsage.CHAR;\n+            return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n-\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n+\t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n-            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n+            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n-                    return PrimitiveTypeUsage.BOOLEAN;\n+                    return PrimitiveType.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n-                    return PrimitiveTypeUsage.BOOLEAN;\n+                    return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n-            return PrimitiveTypeUsage.BOOLEAN;\n+            return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n-            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n+            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n-            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+            Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n-                res \u003d new ArrayTypeUsage(res);\n+                res \u003d new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n-            return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n+            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "acf74024c2d341bf4009af7173c9b1b972f19c32": {
      "type": "Ybodychange",
      "commitMessage": "issue80: resolving MethodRefExpr\n",
      "commitDate": "2016-10-11, 1:37 p.m.",
      "commitName": "acf74024c2d341bf4009af7173c9b1b972f19c32",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-10, 5:28 p.m.",
      "commitNameOld": "7317fe7d60ad0af88e9ee692e95dd5dde832863e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.84,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            TypeUsage actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                                TypeUsage formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayTypeUsage(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 253,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,248 +1,262 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n-                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n+                        if (node instanceof MethodReferenceExpr) {\n+                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n-                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n-                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n-                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n+                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                            TypeUsage actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n+\n                         } else {\n-                            throw new UnsupportedOperationException();\n+                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n+\n+                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n+                                TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n+                                TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n+                                Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                                for (String typeName : inferredTypes.keySet()) {\n+                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                                }\n+                            } else {\n+                                throw new UnsupportedOperationException();\n+                            }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                 res \u003d new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7317fe7d60ad0af88e9ee692e95dd5dde832863e": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"issue80: working on resolving methodref generic type parameters\"\n\nThis reverts commit 2c6d213f0359d5b52a9d570323aa10505415f6ac.\n",
      "commitDate": "2016-10-10, 5:28 p.m.",
      "commitName": "7317fe7d60ad0af88e9ee692e95dd5dde832863e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-10, 3:51 p.m.",
      "commitNameOld": "2c6d213f0359d5b52a9d570323aa10505415f6ac",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayTypeUsage(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 224,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,266 +1,248 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n-                        if (node instanceof MethodReferenceExpr) {\n-                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n+                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n \n-                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n-\n-                            MethodUsage methodUsage \u003d  resolveMethodRef(methodReferenceExpr);\n-\n-\n-                            TypeUsage actualType \u003d methodUsage.returnType();\n+                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n+                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n-\n                         } else {\n-                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-\n-                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n-                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                                TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n-                                TypeUsage formalType \u003d functionalMethod.get().returnType();\n-                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                                Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                                for (String typeName : inferredTypes.keySet()) {\n-                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n-                                }\n-                            } else {\n-                                throw new UnsupportedOperationException();\n-                            }\n+                            throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                 res \u003d new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2c6d213f0359d5b52a9d570323aa10505415f6ac": {
      "type": "Ybodychange",
      "commitMessage": "issue80: working on resolving methodref generic type parameters\n",
      "commitDate": "2016-10-10, 3:51 p.m.",
      "commitName": "2c6d213f0359d5b52a9d570323aa10505415f6ac",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-09, 1:11 p.m.",
      "commitNameOld": "68b3e019e1216a941ff5d8dcf63aefc9b35a3787",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.11,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        if (node instanceof MethodReferenceExpr) {\n                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n\n                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n\n                            MethodUsage methodUsage \u003d  resolveMethodRef(methodReferenceExpr);\n\n\n                            TypeUsage actualType \u003d methodUsage.returnType();\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n\n                        } else {\n                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                                TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                                TypeUsage formalType \u003d functionalMethod.get().returnType();\n                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                                Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                for (String typeName : inferredTypes.keySet()) {\n                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                                }\n                            } else {\n                                throw new UnsupportedOperationException();\n                            }\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayTypeUsage(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 252,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,248 +1,266 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n \n                         List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n-                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n+                        if (node instanceof MethodReferenceExpr) {\n+                            MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n \n-                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n-                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n-                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n+                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+\n+                            MethodUsage methodUsage \u003d  resolveMethodRef(methodReferenceExpr);\n+\n+\n+                            TypeUsage actualType \u003d methodUsage.returnType();\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n+\n                         } else {\n-                            throw new UnsupportedOperationException();\n+                            LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n+\n+                            List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                                ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n+                                TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n+                                TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                                formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n+                                Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                                for (String typeName : inferredTypes.keySet()) {\n+                                    result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                                }\n+                            } else {\n+                                throw new UnsupportedOperationException();\n+                            }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                 res \u003d new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "68b3e019e1216a941ff5d8dcf63aefc9b35a3787": {
      "type": "Ybodychange",
      "commitMessage": "issue80: progress in supporting Method references\n",
      "commitDate": "2016-10-09, 1:11 p.m.",
      "commitName": "68b3e019e1216a941ff5d8dcf63aefc9b35a3787",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-09, 1:00 p.m.",
      "commitNameOld": "91127219c066635d47cfe8d849a2814308d14cdc",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof MethodReferenceExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayTypeUsage(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 224,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,203 +1,248 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n+                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n+\n+                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n+                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n+                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n+                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            for (String typeName : inferredTypes.keySet()) {\n+                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                            }\n+                        } else {\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    }\n+\n+                    return result;\n+                } else {\n+                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+            }\n+        } else if (node instanceof MethodReferenceExpr) {\n+            if (node.getParentNode() instanceof MethodCallExpr) {\n+                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n+                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n+                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n+                if (!refMethod.isSolved()) {\n+                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n+                }\n+                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n+                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n+                if (solveLambdas) {\n+                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                    // We need to replace the type variables\n+                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n+                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n+\n+                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n+                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n+                    //lambdas\n+                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n+                    if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n \n                         List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n-                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                 res \u003d new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "47a5cc851b7db16ab0bcd4b1c0a4dceccfe13f74": {
      "type": "Ybodychange",
      "commitMessage": "issue80: better handling of Lambdas and FunctionInterface\n",
      "commitDate": "2016-10-09, 4:42 a.m.",
      "commitName": "47a5cc851b7db16ab0bcd4b1c0a4dceccfe13f74",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-08, 4:17 p.m.",
      "commitNameOld": "cb7655f9661f11dab8ec9e2533722d649a16e715",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.52,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayTypeUsage(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 215,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,203 +1,203 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(callExpr.getName());\n+                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n \n                         List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                 res \u003d new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cb7655f9661f11dab8ec9e2533722d649a16e715": {
      "type": "Ybodychange",
      "commitMessage": "issue80: improving resolution of static methods\n",
      "commitDate": "2016-10-08, 4:17 p.m.",
      "commitName": "cb7655f9661f11dab8ec9e2533722d649a16e715",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-09-29, 11:28 a.m.",
      "commitNameOld": "31433fc385c0fea7ead68e4c853807752e061565",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 9.2,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayTypeUsage(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 215,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,203 +1,203 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n-                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n+                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n \n                         List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                 res \u003d new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "31433fc385c0fea7ead68e4c853807752e061565": {
      "type": "Ybodychange",
      "commitMessage": "Implemented solving type of a ClassExpr. This fixes issue #64.\n",
      "commitDate": "2016-09-29, 11:28 a.m.",
      "commitName": "31433fc385c0fea7ead68e4c853807752e061565",
      "commitAuthor": "malte_langkabel",
      "commitDateOld": "2016-09-27, 5:57 a.m.",
      "commitNameOld": "cb2a7efc0de1197ac95d22171bd861623c7e0e27",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 2.23,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayTypeUsage(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else if (node instanceof ClassExpr) {\n            // This implementation does not regard the actual type argument of the ClassExpr.\n            return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 215,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,200 +1,203 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n \n                         List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                 res \u003d new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n+        } else if (node instanceof ClassExpr) {\n+            // This implementation does not regard the actual type argument of the ClassExpr.\n+            return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a541f77a5a66a911e347d294aa76d8703e72e7db": {
      "type": "Ybodychange",
      "commitMessage": "Implemented solving method calls on ArrayAccessExpr and SuperExpr. This fixes issue #41.\n",
      "commitDate": "2016-09-22, 8:06 a.m.",
      "commitName": "a541f77a5a66a911e347d294aa76d8703e72e7db",
      "commitAuthor": "malte_langkabel",
      "commitDateOld": "2016-09-20, 4:11 p.m.",
      "commitNameOld": "511490972b01d148a30dce013ede4ce213b3f05e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.66,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayTypeUsage(res);\n            }\n            return res;\n        } else if (node instanceof ArrayAccessExpr) {\n            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        } else if (node instanceof SuperExpr) {\n            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n            if (typeOfNode instanceof ClassDeclaration) {\n                return ((ClassDeclaration)typeOfNode).getSuperClass();\n            } else {\n                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n            }\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 214,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,191 +1,200 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n \n                         List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n-\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                 res \u003d new ArrayTypeUsage(res);\n             }\n             return res;\n+        } else if (node instanceof ArrayAccessExpr) {\n+            ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n+            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n+        } else if (node instanceof SuperExpr) {\n+            TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n+            if (typeOfNode instanceof ClassDeclaration) {\n+                return ((ClassDeclaration)typeOfNode).getSuperClass();\n+            } else {\n+                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n+            }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "651f1ca3e9c7a8fec6826f9da14f9abb5fe921e0": {
      "type": "Ybodychange",
      "commitMessage": "Make typesolver recognize double literals\n",
      "commitDate": "2016-01-04, 1:59 p.m.",
      "commitName": "651f1ca3e9c7a8fec6826f9da14f9abb5fe921e0",
      "commitAuthor": "Evan",
      "commitDateOld": "2015-11-22, 5:45 a.m.",
      "commitNameOld": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 43.34,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n\t\t} else if (node instanceof DoubleLiteralExpr) {\n\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n\t\t} else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayTypeUsage(res);\n            }\n            return res;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 206,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,189 +1,191 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n \n                         List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n-        } else if (node instanceof StringLiteralExpr) {\n+\t\t} else if (node instanceof DoubleLiteralExpr) {\n+\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n+\t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                 res \u003d new ArrayTypeUsage(res);\n             }\n             return res;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
      "type": "Yfilerename",
      "commitMessage": "test JavaParserClassDeclaration\n",
      "commitDate": "2015-11-22, 5:45 a.m.",
      "commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-22, 5:03 a.m.",
      "commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayTypeUsage(res);\n            }\n            return res;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 206,
      "functionName": "getTypeConcrete",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java"
      }
    },
    "ead147279ca0b84d2f479a714943b20cd689e7c7": {
      "type": "Ybodychange",
      "commitMessage": "issue7: consider type parameters and varargs combinations\n",
      "commitDate": "2015-11-20, 11:04 a.m.",
      "commitName": "ead147279ca0b84d2f479a714943b20cd689e7c7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-14, 6:41 a.m.",
      "commitNameOld": "454904fe0cb3b15aa506e3f5fa8f0c9fb1313f61",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 6.18,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n                res \u003d new ArrayTypeUsage(res);\n            }\n            return res;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 206,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,186 +1,189 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n-            JavaParserFacade javaParserFacade \u003d JavaParserFacade.get(typeSolver);\n-            MethodUsage ref \u003d javaParserFacade.solveMethodAsUsage((MethodCallExpr) node);\n+            MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n \n                         List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n-            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+            TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+            for (int i\u003d0; i\u003carrayCreationExpr.getArrayCount();i++) {\n+                res \u003d new ArrayTypeUsage(res);\n+            }\n+            return res;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a6849db3884e47909d2d97fcac0b057ab13d544b": {
      "type": "Ybodychange",
      "commitMessage": "fix lambda solving\n",
      "commitDate": "2015-11-14, 5:15 a.m.",
      "commitName": "a6849db3884e47909d2d97fcac0b057ab13d544b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 5:07 p.m.",
      "commitNameOld": "94446666d149c898131d04e7fd567777258e4e1e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.51,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            JavaParserFacade javaParserFacade \u003d JavaParserFacade.get(typeSolver);\n            MethodUsage ref \u003d javaParserFacade.solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 206,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,185 +1,186 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n-            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n+            JavaParserFacade javaParserFacade \u003d JavaParserFacade.get(typeSolver);\n+            MethodUsage ref \u003d javaParserFacade.solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n-                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n+                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                     result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n \n                         List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                             TypeUsage formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n-                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n-                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n-            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n+            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n-            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+            TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "94446666d149c898131d04e7fd567777258e4e1e": {
      "type": "Ybodychange",
      "commitMessage": "fix LambdaTest.lambdaMapParameter\n",
      "commitDate": "2015-11-13, 5:07 p.m.",
      "commitName": "94446666d149c898131d04e7fd567777258e4e1e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 2:41 p.m.",
      "commitNameOld": "b9725d0d363bb2b1364fb159eefdfbfbc1e3fa97",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 156,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,174 +1,185 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n-                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n+                    Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n+                    result \u003d solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n \n-                        //for (lambdaExpr.getParameters())\n-                        // TODO invoke GenericTypeInferenceLogic and the use results\n-                        throw new UnsupportedOperationException();\n+                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                            ExpressionStmt expressionStmt \u003d (ExpressionStmt)lambdaExpr.getBody();\n+                            TypeUsage actualType \u003d getType (expressionStmt.getExpression());\n+                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n+                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            for (String typeName : inferredTypes.keySet()) {\n+                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                            }\n+                        } else {\n+                            throw new UnsupportedOperationException();\n+                        }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b9725d0d363bb2b1364fb159eefdfbfbc1e3fa97": {
      "type": "Ybodychange",
      "commitMessage": "add GenericTypeInferenceLogic\n",
      "commitDate": "2015-11-13, 2:41 p.m.",
      "commitName": "b9725d0d363bb2b1364fb159eefdfbfbc1e3fa97",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 2:06 p.m.",
      "commitNameOld": "a75fd9d3835fade5c3a1a6ef7a9d36d108a1367e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n\n                        //for (lambdaExpr.getParameters())\n                        // TODO invoke GenericTypeInferenceLogic and the use results\n                        throw new UnsupportedOperationException();\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 141,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,170 +1,174 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n+                        LambdaExpr lambdaExpr \u003d (LambdaExpr)node;\n+\n+                        //for (lambdaExpr.getParameters())\n+                        // TODO invoke GenericTypeInferenceLogic and the use results\n                         throw new UnsupportedOperationException();\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a75fd9d3835fade5c3a1a6ef7a9d36d108a1367e": {
      "type": "Ybodychange",
      "commitMessage": "add FunctionInterfaceLogic\n",
      "commitDate": "2015-11-13, 2:06 p.m.",
      "commitName": "a75fd9d3835fade5c3a1a6ef7a9d36d108a1367e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 1:19 p.m.",
      "commitNameOld": "f20bec1be7e976300ef4857e347bc735ded0f305",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 141,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,170 +1,170 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n-                    Optional\u003cMethodUsage\u003e functionalMethod \u003d getFunctionalMethod(result);\n+                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         throw new UnsupportedOperationException();\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f20bec1be7e976300ef4857e347bc735ded0f305": {
      "type": "Ybodychange",
      "commitMessage": "add RedlectionInterfaceDeclarationTest\n",
      "commitDate": "2015-11-13, 1:19 p.m.",
      "commitName": "f20bec1be7e976300ef4857e347bc735ded0f305",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 4:59 a.m.",
      "commitNameOld": "4a18b1ee8ed716d6e32e190f728f1eee57148872",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.35,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n\n                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                    //lambdas\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d getFunctionalMethod(result);\n                    if (functionalMethod.isPresent()) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 140,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,161 +1,170 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n+\n+                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n+                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n+                    //lambdas\n+                    Optional\u003cMethodUsage\u003e functionalMethod \u003d getFunctionalMethod(result);\n+                    if (functionalMethod.isPresent()) {\n+                        throw new UnsupportedOperationException();\n+                    }\n+\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4a18b1ee8ed716d6e32e190f728f1eee57148872": {
      "type": "Ybodychange",
      "commitMessage": "modules: extraction of the model module\n",
      "commitDate": "2015-11-13, 4:59 a.m.",
      "commitName": "4a18b1ee8ed716d6e32e190f728f1eee57148872",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 4:12 a.m.",
      "commitNameOld": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 140,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,161 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n-                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+                Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n-            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n+            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n-            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n+            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
      "type": "Yfilerename",
      "commitMessage": "modules: organization in modules\n",
      "commitDate": "2015-11-13, 4:12 a.m.",
      "commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 3:53 a.m.",
      "commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()) {\n                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter) node;\n            if (parameter.getType() instanceof UnknownType) {\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e) {\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                    NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr) node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 136,
      "functionName": "getTypeConcrete",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java"
      }
    },
    "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8": {
      "type": "Ybodychange",
      "commitMessage": "removing TypeSolver from model.declarations\n",
      "commitDate": "2015-11-02, 2:48 p.m.",
      "commitName": "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-31, 11:01 a.m.",
      "commitNameOld": "03ec309bba14eaf50a32b05353fa9711b831de7f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 2.2,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    // We need to replace the type variables\n                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 145,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,161 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n+                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                     return result;\n                 } else {\n-                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n+                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n-                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType(typeSolver);\n+                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb388c36c0045c50744cf215521e5c280036aa70": {
      "type": "Yfilerename",
      "commitMessage": "move JavaParser specific code to specific package\n",
      "commitDate": "2015-10-31, 7:11 a.m.",
      "commitName": "fb388c36c0045c50744cf215521e5c280036aa70",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-31, 5:57 a.m.",
      "commitNameOld": "b2bf624be5d1ef59480250e66224aeaa1886df36",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 145,
      "functionName": "getTypeConcrete",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java"
      }
    },
    "c04083d20425a664115db6b0df3ca9632e66ecca": {
      "type": "Ybodychange",
      "commitMessage": "removing TypeSolver from fields related methods of TypeDeclaration\n",
      "commitDate": "2015-10-31, 5:52 a.m.",
      "commitName": "c04083d20425a664115db6b0df3ca9632e66ecca",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-31, 5:22 a.m.",
      "commitNameOld": "960364fad3fc2ead6113d4c5d4b7d9ebf23e2f9a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 147,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,161 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n-                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n+                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e81f51c40996b42cb262dc2397126cee8f60965": {
      "type": "Ybodychange",
      "commitMessage": "embedding TypeSolver\n",
      "commitDate": "2015-10-30, 6:37 p.m.",
      "commitName": "0e81f51c40996b42cb262dc2397126cee8f60965",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-30, 11:43 a.m.",
      "commitNameOld": "005ec580724781a825aaf08a496ad7f8f667b27f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 146,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,161 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n-                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node), typeSolver);\n+                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n-                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n+                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n-            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"));\n+            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n-            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n+            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n-            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n+            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n-            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)));\n+            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n-            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n+            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb0467dc222157e9f485ae4b3f6c7a637fdfcd1c": {
      "type": "Ybodychange",
      "commitMessage": "simplify TypeUsage\n",
      "commitDate": "2015-10-30, 9:13 a.m.",
      "commitName": "fb0467dc222157e9f485ae4b3f6c7a637fdfcd1c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-30, 5:53 a.m.",
      "commitNameOld": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)));\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 144,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,161 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n-                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n+                    result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b": {
      "type": "Ybodychange",
      "commitMessage": "renaming\n",
      "commitDate": "2015-10-28, 11:18 a.m.",
      "commitName": "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-27, 10:40 a.m.",
      "commitNameOld": "bed91989f7354552d72b2b7f0c28fcbd24fee003",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 62.03,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)));\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 125,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,161 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n-            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n+            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n-            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n+            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6": {
      "type": "Ybodychange",
      "commitMessage": "remove noise\n",
      "commitDate": "2015-08-24, 5:05 p.m.",
      "commitName": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 3:57 p.m.",
      "commitNameOld": "ee58eb8363ecd8fad15a63eb2fdc94a387b58807",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 125,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,168 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            if (nameExpr.getName().equals(\"Boolean\") \u0026\u0026 nameExpr.getBeginLine()\u003d\u003d452 \u0026\u0026 !new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).isPresent()) {\n-                System.out.println(\"GOTCHA\");\n-            }\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n-                //System.out.println(\"LAMBDA \" + node.getParentNode());\n-                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n-                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n-                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4": {
      "type": "Ybodychange",
      "commitMessage": "consider method override\n",
      "commitDate": "2015-08-24, 3:19 p.m.",
      "commitName": "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 2:45 p.m.",
      "commitNameOld": "d0348de241a6cf6be9c51500870ee1fb26172101",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            if (nameExpr.getName().equals(\"Boolean\") \u0026\u0026 nameExpr.getBeginLine()\u003d\u003d452 \u0026\u0026 !new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).isPresent()) {\n                System.out.println(\"GOTCHA\");\n            }\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return NullTypeUsage.INSTANCE;\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 125,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,168 +1,168 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             if (nameExpr.getName().equals(\"Boolean\") \u0026\u0026 nameExpr.getBeginLine()\u003d\u003d452 \u0026\u0026 !new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).isPresent()) {\n                 System.out.println(\"GOTCHA\");\n             }\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n-            return new NullTypeUsage();\n+            return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d0348de241a6cf6be9c51500870ee1fb26172101": {
      "type": "Ybodychange",
      "commitMessage": "fix switch on enums\n",
      "commitDate": "2015-08-24, 2:45 p.m.",
      "commitName": "d0348de241a6cf6be9c51500870ee1fb26172101",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 12:29 p.m.",
      "commitNameOld": "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            if (nameExpr.getName().equals(\"Boolean\") \u0026\u0026 nameExpr.getBeginLine()\u003d\u003d452 \u0026\u0026 !new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).isPresent()) {\n                System.out.println(\"GOTCHA\");\n            }\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 125,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,165 +1,168 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n+            if (nameExpr.getName().equals(\"Boolean\") \u0026\u0026 nameExpr.getBeginLine()\u003d\u003d452 \u0026\u0026 !new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).isPresent()) {\n+                System.out.println(\"GOTCHA\");\n+            }\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481": {
      "type": "Ybodychange",
      "commitMessage": "add test on switch on enum value\n",
      "commitDate": "2015-08-24, 12:29 p.m.",
      "commitName": "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 10:31 a.m.",
      "commitNameOld": "ee35b15a04539af508d29081ac5c7f8f6fadba4a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 125,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,165 +1,165 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n-                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n+                throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176": {
      "type": "Ybodychange",
      "commitMessage": "remove JavaParserFacade.convert\n",
      "commitDate": "2015-08-24, 10:22 a.m.",
      "commitName": "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 10:06 a.m.",
      "commitNameOld": "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case binAnd:\n                case binOr:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 124,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,162 +1,165 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n+                case binAnd:\n+                case binOr:\n+                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "416e7b16f820700af08a94e4b38a2b4c24ef6a2c": {
      "type": "Ybodychange",
      "commitMessage": "minor corrections for enums\n",
      "commitDate": "2015-08-24, 10:06 a.m.",
      "commitName": "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 9:58 a.m.",
      "commitNameOld": "1829d9560d37efd59722aaa2f1f22e392918429b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                default:\n                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 124,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,162 +1,162 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n-                    throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n+                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "00f005b38e8b83eb1d60db9070c6e9e3beffe403": {
      "type": "Ybodychange",
      "commitMessage": "Consider ConditionalExpr and ArrayCreationExpr in getTypeConcrete\n",
      "commitDate": "2015-08-24, 9:26 a.m.",
      "commitName": "00f005b38e8b83eb1d60db9070c6e9e3beffe403",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 9:22 a.m.",
      "commitNameOld": "d6edae7874d2e78cbd401619ad53a9f9e2288597",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                default:\n                    throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n        } else if (node instanceof ConditionalExpr) {\n            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n        } else if (node instanceof ArrayCreationExpr) {\n            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,156 +1,162 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n+        } else if (node instanceof ConditionalExpr) {\n+            ConditionalExpr conditionalExpr \u003d (ConditionalExpr)node;\n+            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n+        } else if (node instanceof ArrayCreationExpr) {\n+            ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr)node;\n+            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n-            throw new UnsupportedOperationException(\"FOO \" + node.getClass().getCanonicalName());\n+            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d6edae7874d2e78cbd401619ad53a9f9e2288597": {
      "type": "Ybodychange",
      "commitMessage": "Testing access to field through this keyword\n",
      "commitDate": "2015-08-24, 9:22 a.m.",
      "commitName": "d6edae7874d2e78cbd401619ad53a9f9e2288597",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 5:28 p.m.",
      "commitNameOld": "d0b5fa9e41aaf140b9a30c716ac7a74b24508451",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.66,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                default:\n                    throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n        } else {\n            throw new UnsupportedOperationException(\"FOO \" + node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,156 +1,156 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else {\n-            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n+            throw new UnsupportedOperationException(\"FOO \" + node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d0b5fa9e41aaf140b9a30c716ac7a74b24508451": {
      "type": "Ybodychange",
      "commitMessage": "completing various missing elements\n",
      "commitDate": "2015-08-23, 5:28 p.m.",
      "commitName": "d0b5fa9e41aaf140b9a30c716ac7a74b24508451",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 3:27 p.m.",
      "commitNameOld": "31b108cbfd418f43e7b568374af2e635a580e171",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                case positive:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case posIncrement:\n                case preIncrement:\n                case preDecrement:\n                case posDecrement:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                default:\n                    throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,155 +1,156 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            if (nameExpr.getName().equals(\"commentsInsideChild\")) {\n-                System.out.println(\"Foo\");\n-            }\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n+                case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n-                case inverse:\n                 case posIncrement:\n+                case preIncrement:\n+                case preDecrement:\n+                case posDecrement:\n+                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "31b108cbfd418f43e7b568374af2e635a580e171": {
      "type": "Ybodychange",
      "commitMessage": "add StatementContextTest\n",
      "commitDate": "2015-08-23, 3:27 p.m.",
      "commitName": "31b108cbfd418f43e7b568374af2e635a580e171",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 9:43 a.m.",
      "commitNameOld": "bac18a129c45335e69d811b3872fcb938e1f0ff8",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            if (nameExpr.getName().equals(\"commentsInsideChild\")) {\n                System.out.println(\"Foo\");\n            }\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case inverse:\n                case posIncrement:\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                default:\n                    throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,165 +1,155 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n+            if (nameExpr.getName().equals(\"commentsInsideChild\")) {\n+                System.out.println(\"Foo\");\n+            }\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n-                /*// Maybe we are accessing a static field\n-                SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n-                if (!type.isSolved()) {\n-                    throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n-                } else {\n-                    throw new UnsupportedOperationException(\"da finire\");\n-                    /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n-                    if (!value.isPresent()) {\n-                        throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n-                    } else {\n-                        return value.get().getUsage();\n-                    }\n-                }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case inverse:\n                 case posIncrement:\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bac18a129c45335e69d811b3872fcb938e1f0ff8": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-23, 9:43 a.m.",
      "commitName": "bac18a129c45335e69d811b3872fcb938e1f0ff8",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 8:43 a.m.",
      "commitNameOld": "5c62d5981fb47c4e1e02baa91eb8e2c6ce20c969",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                /*// Maybe we are accessing a static field\n                SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                if (!type.isSolved()) {\n                    throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                } else {\n                    throw new UnsupportedOperationException(\"da finire\");\n                    /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                    if (!value.isPresent()) {\n                        throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                    } else {\n                        return value.get().getUsage();\n                    }\n                }*/\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case inverse:\n                case posIncrement:\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                default:\n                    throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr) node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else if (node instanceof ThisExpr) {\n            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,163 +1,165 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 /*// Maybe we are accessing a static field\n                 SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                 if (!type.isSolved()) {\n                     throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 } else {\n                     throw new UnsupportedOperationException(\"da finire\");\n                     /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                     if (!value.isPresent()) {\n                         throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                     } else {\n                         return value.get().getUsage();\n                     }\n                 }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case inverse:\n                 case posIncrement:\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n-            AssignExpr assignExpr \u003d (AssignExpr)node;\n+            AssignExpr assignExpr \u003d (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n+        } else if (node instanceof ThisExpr) {\n+            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "46aefdd68f2f2597a19b72da36681123cb3090e6": {
      "type": "Ybodychange",
      "commitMessage": "improve resolution of calls to static methods\n",
      "commitDate": "2015-08-23, 6:34 a.m.",
      "commitName": "46aefdd68f2f2597a19b72da36681123cb3090e6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 5:38 a.m.",
      "commitNameOld": "6c297529e31036058837adbaa57cee652d4cc918",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                /*// Maybe we are accessing a static field\n                SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                if (!type.isSolved()) {\n                    throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                } else {\n                    throw new UnsupportedOperationException(\"da finire\");\n                    /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                    if (!value.isPresent()) {\n                        throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                    } else {\n                        return value.get().getUsage();\n                    }\n                }*/\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case not:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                case inverse:\n                case posIncrement:\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                case or:\n                case and:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                default:\n                    throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof AssignExpr) {\n            AssignExpr assignExpr \u003d (AssignExpr)node;\n            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,157 +1,163 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 /*// Maybe we are accessing a static field\n                 SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                 if (!type.isSolved()) {\n                     throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 } else {\n                     throw new UnsupportedOperationException(\"da finire\");\n                     /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                     if (!value.isPresent()) {\n                         throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                     } else {\n                         return value.get().getUsage();\n                     }\n                 }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n-                case inverse:\n                 case not:\n+                    return PrimitiveTypeUsage.BOOLEAN;\n+                case inverse:\n                 case posIncrement:\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n+                case or:\n+                case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr \u003d (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n+        } else if (node instanceof AssignExpr) {\n+            AssignExpr assignExpr \u003d (AssignExpr)node;\n+            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6c297529e31036058837adbaa57cee652d4cc918": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-23, 5:38 a.m.",
      "commitName": "6c297529e31036058837adbaa57cee652d4cc918",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 4:24 a.m.",
      "commitNameOld": "7b2a0b366461674aa6320b11a38a17909d8a74a3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                /*// Maybe we are accessing a static field\n                SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                if (!type.isSolved()) {\n                    throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                } else {\n                    throw new UnsupportedOperationException(\"da finire\");\n                    /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                    if (!value.isPresent()) {\n                        throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                    } else {\n                        return value.get().getUsage();\n                    }\n                }*/\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case inverse:\n                case not:\n                case posIncrement:\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                default:\n                    throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else if (node instanceof InstanceOfExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof EnclosedExpr) {\n            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n        } else if (node instanceof CastExpr) {\n            CastExpr enclosedExpr \u003d (CastExpr)node;\n            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,149 +1,157 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 /*// Maybe we are accessing a static field\n                 SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                 if (!type.isSolved()) {\n                     throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 } else {\n                     throw new UnsupportedOperationException(\"da finire\");\n                     /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                     if (!value.isPresent()) {\n                         throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                     } else {\n                         return value.get().getUsage();\n                     }\n                 }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case inverse:\n                 case not:\n                 case posIncrement:\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n+        } else if (node instanceof InstanceOfExpr) {\n+            return PrimitiveTypeUsage.BOOLEAN;\n+        } else if (node instanceof EnclosedExpr) {\n+            EnclosedExpr enclosedExpr \u003d (EnclosedExpr)node;\n+            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n+        } else if (node instanceof CastExpr) {\n+            CastExpr enclosedExpr \u003d (CastExpr)node;\n+            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7b2a0b366461674aa6320b11a38a17909d8a74a3": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-23, 4:24 a.m.",
      "commitName": "7b2a0b366461674aa6320b11a38a17909d8a74a3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 3:50 a.m.",
      "commitNameOld": "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                /*// Maybe we are accessing a static field\n                SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                if (!type.isSolved()) {\n                    throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                } else {\n                    throw new UnsupportedOperationException(\"da finire\");\n                    /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                    if (!value.isPresent()) {\n                        throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                    } else {\n                        return value.get().getUsage();\n                    }\n                }*/\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case inverse:\n                case not:\n                case posIncrement:\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                case minus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                case lessEquals:\n                case less:\n                case greater:\n                case greaterEquals:\n                case equals:\n                case notEquals:\n                    return PrimitiveTypeUsage.BOOLEAN;\n                default:\n                    throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n            }\n        } else if (node instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,138 +1,149 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 /*// Maybe we are accessing a static field\n                 SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                 if (!type.isSolved()) {\n                     throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 } else {\n                     throw new UnsupportedOperationException(\"da finire\");\n                     /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                     if (!value.isPresent()) {\n                         throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                     } else {\n                         return value.get().getUsage();\n                     }\n                 }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case inverse:\n                 case not:\n                 case posIncrement:\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n-            BinaryExpr binaryExpr \u003d (BinaryExpr)node;\n+            BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n+                case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n+                case lessEquals:\n+                case less:\n+                case greater:\n+                case greaterEquals:\n+                case equals:\n+                case notEquals:\n+                    return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n+        } else if (node instanceof VariableDeclarationExpr) {\n+            VariableDeclarationExpr expr \u003d (VariableDeclarationExpr)node;\n+            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "feab46de5d87b02bf38b29962613676adf14f78a": {
      "type": "Ybodychange",
      "commitMessage": "implementing missing bits while solving symbols on JavaParser\n",
      "commitDate": "2015-08-22, 6:08 a.m.",
      "commitName": "feab46de5d87b02bf38b29962613676adf14f78a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-21, 5:01 p.m.",
      "commitNameOld": "54b73148ab5bfb5e3c2f1c2aa463265d033ac926",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.55,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                /*// Maybe we are accessing a static field\n                SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                if (!type.isSolved()) {\n                    throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                } else {\n                    throw new UnsupportedOperationException(\"da finire\");\n                    /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                    if (!value.isPresent()) {\n                        throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                    } else {\n                        return value.get().getUsage();\n                    }\n                }*/\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else if (node instanceof IntegerLiteralExpr) {\n            return PrimitiveTypeUsage.INT;\n        } else if (node instanceof LongLiteralExpr) {\n            return PrimitiveTypeUsage.LONG;\n        } else if (node instanceof CharLiteralExpr) {\n            return PrimitiveTypeUsage.CHAR;\n        } else if (node instanceof StringLiteralExpr) {\n            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n        } else if (node instanceof UnaryExpr) {\n            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n            switch (unaryExpr.getOperator()) {\n                case negative:\n                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                case inverse:\n                case not:\n                case posIncrement:\n                default:\n                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n            }\n        } else if (node instanceof BinaryExpr) {\n            BinaryExpr binaryExpr \u003d (BinaryExpr)node;\n            switch (binaryExpr.getOperator()) {\n                case plus:\n                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                default:\n                    throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n            }\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 125,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,111 +1,138 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 /*// Maybe we are accessing a static field\n                 SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                 if (!type.isSolved()) {\n                     throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 } else {\n                     throw new UnsupportedOperationException(\"da finire\");\n                     /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                     if (!value.isPresent()) {\n                         throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                     } else {\n                         return value.get().getUsage();\n                     }\n                 }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n+        } else if (node instanceof IntegerLiteralExpr) {\n+            return PrimitiveTypeUsage.INT;\n+        } else if (node instanceof LongLiteralExpr) {\n+            return PrimitiveTypeUsage.LONG;\n+        } else if (node instanceof CharLiteralExpr) {\n+            return PrimitiveTypeUsage.CHAR;\n+        } else if (node instanceof StringLiteralExpr) {\n+            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n+        } else if (node instanceof UnaryExpr) {\n+            UnaryExpr unaryExpr \u003d (UnaryExpr)node;\n+            switch (unaryExpr.getOperator()) {\n+                case negative:\n+                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n+                case inverse:\n+                case not:\n+                case posIncrement:\n+                default:\n+                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n+            }\n+        } else if (node instanceof BinaryExpr) {\n+            BinaryExpr binaryExpr \u003d (BinaryExpr)node;\n+            switch (binaryExpr.getOperator()) {\n+                case plus:\n+                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n+                default:\n+                    throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n+            }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "54b73148ab5bfb5e3c2f1c2aa463265d033ac926": {
      "type": "Ybodychange",
      "commitMessage": "remove spurios log\n",
      "commitDate": "2015-08-21, 5:01 p.m.",
      "commitName": "54b73148ab5bfb5e3c2f1c2aa463265d033ac926",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-21, 5:00 p.m.",
      "commitNameOld": "0c4c859f472f7243919f1af7a0871cf8155af1ba",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                /*// Maybe we are accessing a static field\n                SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                if (!type.isSolved()) {\n                    throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                } else {\n                    throw new UnsupportedOperationException(\"da finire\");\n                    /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                    if (!value.isPresent()) {\n                        throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                    } else {\n                        return value.get().getUsage();\n                    }\n                }*/\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 124,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,112 +1,111 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 /*// Maybe we are accessing a static field\n                 SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                 if (!type.isSolved()) {\n                     throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 } else {\n                     throw new UnsupportedOperationException(\"da finire\");\n                     /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                     if (!value.isPresent()) {\n                         throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                     } else {\n                         return value.get().getUsage();\n                     }\n                 }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n-                System.out.println(\"FOO\");\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0c4c859f472f7243919f1af7a0871cf8155af1ba": {
      "type": "Ybodychange",
      "commitMessage": "add tests for static field access\n",
      "commitDate": "2015-08-21, 5:00 p.m.",
      "commitName": "0c4c859f472f7243919f1af7a0871cf8155af1ba",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-21, 2:45 p.m.",
      "commitNameOld": "7b6c27e95fef9e725fbf9e15afb852bb952dfa34",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n            if (!value.isPresent()){\n                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                /*// Maybe we are accessing a static field\n                SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                if (!type.isSolved()) {\n                    throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                } else {\n                    throw new UnsupportedOperationException(\"da finire\");\n                    /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                    if (!value.isPresent()) {\n                        throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                    } else {\n                        return value.get().getUsage();\n                    }\n                }*/\n            } else {\n                return value.get().getUsage();\n            }\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            // We should understand if this is a static access\n            try {\n                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                if (value.isPresent()) {\n                    return value.get().getUsage();\n                } else {\n                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                }\n            } catch (UnsolvedSymbolException e){\n                System.out.println(\"FOO\");\n                // Sure, it was not found as value because maybe it is a type and this is a static access\n                if (fieldAccessExpr.getScope() instanceof NameExpr){\n                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                    if (!typeAccessedStatically.isSolved()) {\n                        throw e;\n                    } else {\n                        // TODO here maybe we have to substitute type parameters\n                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                    }\n                } else {\n                    throw e;\n                }\n\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else if (node instanceof BooleanLiteralExpr) {\n            return PrimitiveTypeUsage.BOOLEAN;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 124,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,73 +1,112 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n+            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+            if (!value.isPresent()){\n+                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n+                /*// Maybe we are accessing a static field\n+                SymbolReference\u003cTypeDeclaration\u003e type \u003d JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n+                if (!type.isSolved()) {\n+                    throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n+                } else {\n+                    throw new UnsupportedOperationException(\"da finire\");\n+                    /*value \u003d type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n+                    if (!value.isPresent()) {\n+                        throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n+                    } else {\n+                        return value.get().getUsage();\n+                    }\n+                }*/\n+            } else {\n+                return value.get().getUsage();\n+            }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(null, callExpr.getName());\n+                    throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n-            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n-            if (value.isPresent()) {\n-                return value.get().getUsage();\n-            } else {\n-                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n+            // We should understand if this is a static access\n+            try {\n+                Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+                if (value.isPresent()) {\n+                    return value.get().getUsage();\n+                } else {\n+                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n+                }\n+            } catch (UnsolvedSymbolException e){\n+                System.out.println(\"FOO\");\n+                // Sure, it was not found as value because maybe it is a type and this is a static access\n+                if (fieldAccessExpr.getScope() instanceof NameExpr){\n+                    NameExpr staticValue \u003d (NameExpr)fieldAccessExpr.getScope();\n+                    SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n+                    if (!typeAccessedStatically.isSolved()) {\n+                        throw e;\n+                    } else {\n+                        // TODO here maybe we have to substitute type parameters\n+                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n+                    }\n+                } else {\n+                    throw e;\n+                }\n+\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n+        } else if (node instanceof BooleanLiteralExpr) {\n+            return PrimitiveTypeUsage.BOOLEAN;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "09ceccd596e6aeebb5eca309093ef32216291f1e": {
      "type": "Ybodychange",
      "commitMessage": "first step\n",
      "commitDate": "2015-08-21, 3:18 a.m.",
      "commitName": "09ceccd596e6aeebb5eca309093ef32216291f1e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-18, 5:15 a.m.",
      "commitNameOld": "1d5332815b543d569be3d7ec672a65b7efc39a04",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 2.92,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 123,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,73 +1,73 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n-                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n+                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "850c0caa4c64df32d5fc44a5512d6d41f4534a08": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-17, 12:43 p.m.",
      "commitName": "850c0caa4c64df32d5fc44a5512d6d41f4534a08",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-17, 12:43 p.m.",
      "commitNameOld": "d393205e2ee874242b73e4fe819d1bc874587d8a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else if (node instanceof NullLiteralExpr) {\n            return new NullTypeUsage();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 131,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,71 +1,73 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                     // We need to replace the type variables\n                     result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n-            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n+            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n+        } else if (node instanceof NullLiteralExpr) {\n+            return new NullTypeUsage();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "22bf613d486d43114d1547e5bc623535aa2aca2a": {
      "type": "Ybodychange",
      "commitMessage": "add test resolveLambdaType\n",
      "commitDate": "2015-08-17, 3:14 a.m.",
      "commitName": "22bf613d486d43114d1547e5bc623535aa2aca2a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-17, 1:55 a.m.",
      "commitNameOld": "9f625af2721bfb3f764d5f4dd23eef55324c94bc",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                    // We need to replace the type variables\n                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                    return result;\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 128,
      "functionName": "getTypeConcrete",
      "diff": "@@ -1,68 +1,71 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                    TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                    // We need to replace the type variables\n+                    result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n+                    return result;\n                 } else {\n                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "627b56302d259409e9bc50b20d77803484f18b5c": {
      "type": "Ymultichange(Yrename,Ymodifierchange)",
      "commitMessage": "introduce cache in JavaParserFacade\n",
      "commitDate": "2015-08-05, 10:25 a.m.",
      "commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "introduce cache in JavaParserFacade\n",
          "commitDate": "2015-08-05, 10:25 a.m.",
          "commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015-08-05, 10:08 a.m.",
          "commitNameOld": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
          "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
          "functionStartLine": 124,
          "functionName": "getTypeConcrete",
          "diff": "@@ -1,68 +1,68 @@\n-    public TypeUsage getType(Node node, boolean solveLambdas) {\n+    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                 } else {\n                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "getType",
            "newValue": "getTypeConcrete"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "introduce cache in JavaParserFacade\n",
          "commitDate": "2015-08-05, 10:25 a.m.",
          "commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015-08-05, 10:08 a.m.",
          "commitNameOld": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
          "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
          "functionStartLine": 124,
          "functionName": "getTypeConcrete",
          "diff": "@@ -1,68 +1,68 @@\n-    public TypeUsage getType(Node node, boolean solveLambdas) {\n+    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                 } else {\n                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[private]"
          }
        }
      ]
    },
    "1adb8b4c97103ac5b15d009f3eda791a53b83d6f": {
      "type": "Ybodychange",
      "commitMessage": "add resolveReferenceToLambdaParamBase\n",
      "commitDate": "2015-08-05, 10:08 a.m.",
      "commitName": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-05, 9:30 a.m.",
      "commitNameOld": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage getType(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 97,
      "functionName": "getType",
      "diff": "@@ -1,64 +1,68 @@\n     public TypeUsage getType(Node node, boolean solveLambdas) {\n         if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n+            logger.finest(\"getType on name expr \" + node);\n             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                 } else {\n                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter \u003d (Parameter)node;\n+            if (parameter.getType() instanceof UnknownType){\n+                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n+            }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd2e083224d3ee0e9ccca4431d63a84601e0d606": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "fix resolveReferenceToMethodWithLambda\n",
      "commitDate": "2015-08-05, 9:30 a.m.",
      "commitName": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "fix resolveReferenceToMethodWithLambda\n",
          "commitDate": "2015-08-05, 9:30 a.m.",
          "commitName": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015-08-05, 4:09 a.m.",
          "commitNameOld": "6650e5a3818c15de2883b71cd41524b0337e26f6",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.22,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "    public TypeUsage getType(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
          "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
          "functionStartLine": 96,
          "functionName": "getType",
          "diff": "@@ -1,57 +1,64 @@\n-    public TypeUsage getType(Node node) {\n+    public TypeUsage getType(Node node, boolean solveLambdas) {\n+        if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n-            SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n-            if (!ref.isSolved()) {\n-                throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n-            }\n-            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType(typeSolver));\n+            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n+            logger.finest(\"getType on method call \" + node);\n             // first solve the method\n-            SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n-            if (!ref.isSolved()) {\n-                throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n-            }\n-            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n+            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n+            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n+            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n+            return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n-                System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n-                System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n+                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n+                if (solveLambdas) {\n+                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                } else {\n+                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n+                }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n+                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n+                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n+        } else if (node instanceof Parameter) {\n+            Parameter parameter \u003d (Parameter)node;\n+            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[node-Node]",
            "newValue": "[node-Node, solveLambdas-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "fix resolveReferenceToMethodWithLambda\n",
          "commitDate": "2015-08-05, 9:30 a.m.",
          "commitName": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015-08-05, 4:09 a.m.",
          "commitNameOld": "6650e5a3818c15de2883b71cd41524b0337e26f6",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.22,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "    public TypeUsage getType(Node node, boolean solveLambdas) {\n        if (node \u003d\u003d null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter \u003d (Parameter)node;\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
          "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
          "functionStartLine": 96,
          "functionName": "getType",
          "diff": "@@ -1,57 +1,64 @@\n-    public TypeUsage getType(Node node) {\n+    public TypeUsage getType(Node node, boolean solveLambdas) {\n+        if (node \u003d\u003d null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n-            SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n-            if (!ref.isSolved()) {\n-                throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n-            }\n-            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType(typeSolver));\n+            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n+            logger.finest(\"getType on method call \" + node);\n             // first solve the method\n-            SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n-            if (!ref.isSolved()) {\n-                throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n-            }\n-            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n+            MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n+            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n+            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n+            return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n-                System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n-                System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n+                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n+                if (solveLambdas) {\n+                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                } else {\n+                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n+                }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n+                VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n+                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n+        } else if (node instanceof Parameter) {\n+            Parameter parameter \u003d (Parameter)node;\n+            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n             TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "80f951258992f75441239c79e0f31eda7d47e107": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-04, 9:54 a.m.",
      "commitName": "80f951258992f75441239c79e0f31eda7d47e107",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-04, 5:02 a.m.",
      "commitNameOld": "2568d9ebe91ceb0a13c98b16f99593cd22084efa",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage getType(Node node) {\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType(typeSolver));\n        } else if (node instanceof MethodCallExpr) {\n            // first solve the method\n            SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n                System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 69,
      "functionName": "getType",
      "diff": "@@ -1,45 +1,57 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n-            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n+            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType(typeSolver));\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n                 System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-                return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n+                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n-                FieldDeclaration parent \u003d (FieldDeclaration)node.getParentNode();\n+                FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n+        } else if (node instanceof FieldAccessExpr) {\n+            FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n+            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+            if (value.isPresent()) {\n+                return value.get().getUsage();\n+            } else {\n+                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n+            }\n+        } else if (node instanceof ObjectCreationExpr) {\n+            ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr)node;\n+            TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+            return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2568d9ebe91ceb0a13c98b16f99593cd22084efa": {
      "type": "Ybodychange",
      "commitMessage": "solving first case of generic type\n",
      "commitDate": "2015-08-04, 5:02 a.m.",
      "commitName": "2568d9ebe91ceb0a13c98b16f99593cd22084efa",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-03, 2:53 a.m.",
      "commitNameOld": "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.09,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage getType(Node node) {\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n        } else if (node instanceof MethodCallExpr) {\n            // first solve the method\n            SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n                System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent \u003d (FieldDeclaration)node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 74,
      "functionName": "getType",
      "diff": "@@ -1,38 +1,45 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n-                MethodCallExpr callExpr \u003d (MethodCallExpr)node.getParentNode();\n+                MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n-                System.out.println(\"Method \"+refMethod.getCorrespondingDeclaration().getName());\n-                System.out.println(\"Method param \"+refMethod.getCorrespondingDeclaration().getParam(pos));\n+                System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n+                System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n+        } else if (node instanceof VariableDeclarator) {\n+            if (node.getParentNode() instanceof FieldDeclaration) {\n+                FieldDeclaration parent \u003d (FieldDeclaration)node.getParentNode();\n+                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+            } else {\n+                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n+            }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-03, 2:53 a.m.",
      "commitName": "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-03, 2:37 a.m.",
      "commitNameOld": "630eb94d43670f2080c7273584d49c0b0d4162f1",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage getType(Node node) {\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n        } else if (node instanceof MethodCallExpr) {\n            // first solve the method\n            SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr)node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                System.out.println(\"Method \"+refMethod.getCorrespondingDeclaration().getName());\n                System.out.println(\"Method param \"+refMethod.getCorrespondingDeclaration().getParam(pos));\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 70,
      "functionName": "getType",
      "diff": "@@ -1,38 +1,38 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n-            SymbolReference\u003cValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n+            SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr)node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 System.out.println(\"Method \"+refMethod.getCorrespondingDeclaration().getName());\n                 System.out.println(\"Method param \"+refMethod.getCorrespondingDeclaration().getParam(pos));\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "630eb94d43670f2080c7273584d49c0b0d4162f1": {
      "type": "Ybodychange",
      "commitMessage": "initial refactoring\n",
      "commitDate": "2015-08-03, 2:37 a.m.",
      "commitName": "630eb94d43670f2080c7273584d49c0b0d4162f1",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-02, 8:22 a.m.",
      "commitNameOld": "241cd249688d1e7c621c495746d2603433599eb9",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage getType(Node node) {\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            SymbolReference\u003cValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n        } else if (node instanceof MethodCallExpr) {\n            // first solve the method\n            SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr)node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                System.out.println(\"Method \"+refMethod.getCorrespondingDeclaration().getName());\n                System.out.println(\"Method param \"+refMethod.getCorrespondingDeclaration().getParam(pos));\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 70,
      "functionName": "getType",
      "diff": "@@ -1,38 +1,38 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n-            SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n+            SymbolReference\u003cValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr)node.getParentNode();\n                 int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 System.out.println(\"Method \"+refMethod.getCorrespondingDeclaration().getName());\n                 System.out.println(\"Method param \"+refMethod.getCorrespondingDeclaration().getParam(pos));\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fa3b6f1d0199dacb9069c24a1c2de0e31de38cb3": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-02, 6:18 a.m.",
      "commitName": "fa3b6f1d0199dacb9069c24a1c2de0e31de38cb3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-02, 5:48 a.m.",
      "commitNameOld": "3def8748ada27ac91166941a892adfd83ca3db2a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage getType(Node node) {\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n        } else if (node instanceof MethodCallExpr) {\n            // first solve the method\n            SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr)node.getParentNode();\n                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                System.out.println(\"Method \"+refMethod.getCorrespondingDeclaration().getName());\n                System.out.println(\"Method param \"+refMethod.getCorrespondingDeclaration().getParam(pos));\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 63,
      "functionName": "getType",
      "diff": "@@ -1,34 +1,38 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr \u003d (MethodCallExpr)node.getParentNode();\n+                int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n+                System.out.println(\"Method \"+refMethod.getCorrespondingDeclaration().getName());\n+                System.out.println(\"Method param \"+refMethod.getCorrespondingDeclaration().getParam(pos));\n+                return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n-                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3def8748ada27ac91166941a892adfd83ca3db2a": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-02, 5:48 a.m.",
      "commitName": "3def8748ada27ac91166941a892adfd83ca3db2a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-02, 4:52 a.m.",
      "commitNameOld": "381c389ea62cf20d6109dac96bb5f8202ccc0b34",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage getType(Node node) {\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n        } else if (node instanceof MethodCallExpr) {\n            // first solve the method\n            SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr \u003d (MethodCallExpr)node.getParentNode();\n                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 62,
      "functionName": "getType",
      "diff": "@@ -1,22 +1,34 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n-            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+            if (node.getParentNode() instanceof MethodCallExpr) {\n+                MethodCallExpr callExpr \u003d (MethodCallExpr)node.getParentNode();\n+                SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n+                if (!refMethod.isSolved()) {\n+                    throw new UnsolvedSymbolException(null, callExpr.getName());\n+                }\n+                //System.out.println(\"LAMBDA \" + node.getParentNode());\n+                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n+                //TypeUsage typeOfMethod \u003d new JavaParserFacade(typeSolver).getType(node.getParentNode());\n+                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+            } else {\n+                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+            }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "381c389ea62cf20d6109dac96bb5f8202ccc0b34": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-02, 4:52 a.m.",
      "commitName": "381c389ea62cf20d6109dac96bb5f8202ccc0b34",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-07-31, 2:52 p.m.",
      "commitNameOld": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.58,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public TypeUsage getType(Node node) {\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n        } else if (node instanceof MethodCallExpr) {\n            // first solve the method\n            SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 53,
      "functionName": "getType",
      "diff": "@@ -1,20 +1,22 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr \u003d (NameExpr) node;\n             SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n+        } else if (node instanceof LambdaExpr) {\n+            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8b8cc6cddbf5af0c93c4ceffd015f6328c932149": {
      "type": "Yintroduced",
      "commitMessage": "wip\n",
      "commitDate": "2015-07-31, 2:52 p.m.",
      "commitName": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,20 @@\n+    public TypeUsage getType(Node node) {\n+        if (node instanceof NameExpr) {\n+            NameExpr nameExpr \u003d (NameExpr) node;\n+            SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n+            if (!ref.isSolved()) {\n+                throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n+            }\n+            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n+        } else if (node instanceof MethodCallExpr) {\n+            // first solve the method\n+            SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n+            if (!ref.isSolved()) {\n+                throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n+            }\n+            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n+            // the type is the return type of the method\n+        } else {\n+            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public TypeUsage getType(Node node) {\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr \u003d (NameExpr) node;\n            SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n        } else if (node instanceof MethodCallExpr) {\n            // first solve the method\n            SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n            }\n            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n            // the type is the return type of the method\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 52,
      "functionName": "getType"
    }
  }
}