{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "H:\\Projects\\eclipse\\jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "UploadPack.java",
  "functionName": "sendPack",
  "functionId": "sendPack___sideband-boolean(modifiers-final)__accumulator-PackStatistics.Accumulator__allTags-Collection__Ref__(annotations-@Nullable)__unshallowCommits-List__ObjectId__",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
  "functionStartLine": 1983,
  "functionEndLine": 2128,
  "numCommitsSeen": 514,
  "timeTaken": 7836,
  "changeHistory": [
    "cd0d69ffec9eedff24a2692d18024e752cadc7c8",
    "f6c4a492d06e0dd345679bfba3399dabbf778f41",
    "c79e7f1c27c73732310bc64c2071a79902447dcc",
    "4ac32e79b751944107470d5f4cb290eacd1b7cf9",
    "67df4986cef270144c7cae3485dc8541ca180649",
    "cc19f649666704e5bf0184d3839be0c0c17439fc",
    "302596cc675d00e41f0ff07efef58063afe20c79",
    "21d22e6f63a1adcfaeaee155f1be32f8123fd789",
    "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
    "b16e207742beb6a82b2b74df7bb87893a38bdd04",
    "f84370feaaf319b7fe9bd272a7ceba235cc1e86a",
    "1fa6f3a7509dc937551006e11dfd3bdaea921cd0",
    "bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379",
    "6a415915c2dab31f9e69b9a55dcb87c579649bf5",
    "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df",
    "0e73d395061d1bfee365acaa2f79c392175d13bf",
    "7b7d033ee1fdd8e81ae2ad7dc9e1ae12cbd9ddfa",
    "b0174a089ce886d02c8d7fb80d63f0e50329bec3",
    "557471da2eee6752ad4305a883843bcdc8d66536",
    "6e896ba66ba095b97a89a622d43f05ce9ad501e7",
    "eb17495ca4ce95c63bacf81af16ab19ff042b65c",
    "43ea887c8b43de26a6b7a9ea547033d3c04022e7",
    "9b86cf574b230a9b3a71d7cb53a4f6712bfa33eb",
    "1f2022e3a7e9482caa4823e031504b6bbe8246af",
    "d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3",
    "01888db892aa9590862d886c01f3b293140db153",
    "9952223e0645fd7a8cddc6093a7f449c6390238d",
    "7ff6eb584cf8b83f83a3b5edf897feb53dbf42c0"
  ],
  "changeHistoryShort": {
    "cd0d69ffec9eedff24a2692d18024e752cadc7c8": "Yparameterchange",
    "f6c4a492d06e0dd345679bfba3399dabbf778f41": "Ybodychange",
    "c79e7f1c27c73732310bc64c2071a79902447dcc": "Ymultichange(Yparameterchange,Ybodychange)",
    "4ac32e79b751944107470d5f4cb290eacd1b7cf9": "Ybodychange",
    "67df4986cef270144c7cae3485dc8541ca180649": "Ybodychange",
    "cc19f649666704e5bf0184d3839be0c0c17439fc": "Ybodychange",
    "302596cc675d00e41f0ff07efef58063afe20c79": "Ymultichange(Yparameterchange,Ybodychange)",
    "21d22e6f63a1adcfaeaee155f1be32f8123fd789": "Ybodychange",
    "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1": "Ybodychange",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": "Ybodychange",
    "b16e207742beb6a82b2b74df7bb87893a38bdd04": "Ybodychange",
    "f84370feaaf319b7fe9bd272a7ceba235cc1e86a": "Ybodychange",
    "1fa6f3a7509dc937551006e11dfd3bdaea921cd0": "Ybodychange",
    "bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379": "Ybodychange",
    "6a415915c2dab31f9e69b9a55dcb87c579649bf5": "Ybodychange",
    "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df": "Ybodychange",
    "0e73d395061d1bfee365acaa2f79c392175d13bf": "Ybodychange",
    "7b7d033ee1fdd8e81ae2ad7dc9e1ae12cbd9ddfa": "Ybodychange",
    "b0174a089ce886d02c8d7fb80d63f0e50329bec3": "Ybodychange",
    "557471da2eee6752ad4305a883843bcdc8d66536": "Ybodychange",
    "6e896ba66ba095b97a89a622d43f05ce9ad501e7": "Ybodychange",
    "eb17495ca4ce95c63bacf81af16ab19ff042b65c": "Ybodychange",
    "43ea887c8b43de26a6b7a9ea547033d3c04022e7": "Ybodychange",
    "9b86cf574b230a9b3a71d7cb53a4f6712bfa33eb": "Ybodychange",
    "1f2022e3a7e9482caa4823e031504b6bbe8246af": "Ybodychange",
    "d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3": "Ybodychange",
    "01888db892aa9590862d886c01f3b293140db153": "Ybodychange",
    "9952223e0645fd7a8cddc6093a7f449c6390238d": "Ybodychange",
    "7ff6eb584cf8b83f83a3b5edf897feb53dbf42c0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cd0d69ffec9eedff24a2692d18024e752cadc7c8": {
      "type": "Yparameterchange",
      "commitMessage": "Refactor unshallowCommits to local variable\n\nThis reduces the amount of state held as instance variables in\nUploadPack, and makes it easier for a future patch to contain a clearer\nversion of UploadPack#processShallow.\n\nChange-Id: I6df80b42f9e5118fda1420692e02e417670cced3\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
      "commitDate": "2018-06-05, 1:04 a.m.",
      "commitName": "cd0d69ffec9eedff24a2692d18024e752cadc7c8",
      "commitAuthor": "Jonathan Tan",
      "commitDateOld": "2018-06-05, 12:59 a.m.",
      "commitNameOld": "f516c1df9d18ff9aaba1dd5668db1776d42dd2bb",
      "commitAuthorOld": "Jonathan Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband,\n\t\t\tPackStatistics.Accumulator accumulator,\n\t\t\t@Nullable Collection\u003cRef\u003e allTags,\n\t\t\tList\u003cObjectId\u003e unshallowCommits) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n\t\t\t\t\t\t\t\t\t\t// block, and is closed there\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n\t\t\t\taccumulator);\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tif (filterBlobLimit \u003e\u003d 0) {\n\t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n\t\t\t\tpw.setUseCachedPacks(false);\n\t\t\t} else {\n\t\t\t\tpw.setUseCachedPacks(true);\n\t\t\t}\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\t// Objects named directly by references go at the beginning\n\t\t\t// of the pack.\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n\t\t\t\tfor (Ref ref : allTags) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t// skip unborn branch\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.getRefDatabase().peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1859,
      "functionName": "sendPack",
      "diff": "@@ -1,145 +1,146 @@\n \tprivate void sendPack(final boolean sideband,\n \t\t\tPackStatistics.Accumulator accumulator,\n-\t\t\t@Nullable Collection\u003cRef\u003e allTags) throws IOException {\n+\t\t\t@Nullable Collection\u003cRef\u003e allTags,\n+\t\t\tList\u003cObjectId\u003e unshallowCommits) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n \t\t\t\t\t\t\t\t\t\t// block, and is closed there\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tif (filterBlobLimit \u003e\u003d 0) {\n \t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n \t\t\t\tpw.setUseCachedPacks(false);\n \t\t\t} else {\n \t\t\t\tpw.setUseCachedPacks(true);\n \t\t\t}\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\t// Objects named directly by references go at the beginning\n \t\t\t// of the pack.\n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (depth \u003e 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n \t\t\t\tfor (Ref ref : allTags) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.getRefDatabase().peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator, allTags-Collection\u003cRef\u003e(annotations-@Nullable)]",
        "newValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator, allTags-Collection\u003cRef\u003e(annotations-@Nullable), unshallowCommits-List\u003cObjectId\u003e]"
      }
    },
    "f6c4a492d06e0dd345679bfba3399dabbf778f41": {
      "type": "Ybodychange",
      "commitMessage": "Repository: Deprecate #peel method\n\nCallers should use getRefDatabase().peel(ref) instead since it\ndoesn\u0027t swallow the IOException.\n\nAdapt all trivial callers to user the alternative.\n\nDescribeCommand still uses the deprecated method and is not adapted in\nthis change since it will require more refactoring to add handling of\nthe IOException.\n\nChange-Id: I14d4a95a5e0570548753b9fc5c03d024dc3ff832\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018-05-21, 10:49 p.m.",
      "commitName": "f6c4a492d06e0dd345679bfba3399dabbf778f41",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2018-05-17, 10:15 p.m.",
      "commitNameOld": "667e30678a6bad26f4d4d412e996b293e52e5b87",
      "commitAuthorOld": "Masaya Suzuki",
      "daysBetweenCommits": 4.02,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband,\n\t\t\tPackStatistics.Accumulator accumulator,\n\t\t\t@Nullable Collection\u003cRef\u003e allTags) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n\t\t\t\t\t\t\t\t\t\t// block, and is closed there\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n\t\t\t\taccumulator);\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tif (filterBlobLimit \u003e\u003d 0) {\n\t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n\t\t\t\tpw.setUseCachedPacks(false);\n\t\t\t} else {\n\t\t\t\tpw.setUseCachedPacks(true);\n\t\t\t}\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\t// Objects named directly by references go at the beginning\n\t\t\t// of the pack.\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n\t\t\t\tfor (Ref ref : allTags) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t// skip unborn branch\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.getRefDatabase().peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1822,
      "functionName": "sendPack",
      "diff": "@@ -1,145 +1,145 @@\n \tprivate void sendPack(final boolean sideband,\n \t\t\tPackStatistics.Accumulator accumulator,\n \t\t\t@Nullable Collection\u003cRef\u003e allTags) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n \t\t\t\t\t\t\t\t\t\t// block, and is closed there\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tif (filterBlobLimit \u003e\u003d 0) {\n \t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n \t\t\t\tpw.setUseCachedPacks(false);\n \t\t\t} else {\n \t\t\t\tpw.setUseCachedPacks(true);\n \t\t\t}\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\t// Objects named directly by references go at the beginning\n \t\t\t// of the pack.\n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (depth \u003e 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n \t\t\t\tfor (Ref ref : allTags) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n-\t\t\t\t\t\tref \u003d db.peel(ref);\n+\t\t\t\t\t\tref \u003d db.getRefDatabase().peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c79e7f1c27c73732310bc64c2071a79902447dcc": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Avoid using #refs in UploadPack#sendPack\n\nWhen OPTION_INCLUDE_TAG is set, UploadPack#sendPack uses the #refs\ninstance variable as a source of information of tags. A subsequent patch\nwill need to supply this information to #sendPack without\nmodifying #refs, so refactor #sendPack to take in this information\nthrough a parameter instead.\n\nNote that prior to this patch, #refs was used twice in #sendPack: once\nto generate the argument to PackWriter#setTagTargets, and once to\ndetermine if any tags need to be included in the packfile. This patch\nonly updates the latter use, since the former is meant not only for\n\"true\" tag targets but any object that should be hoisted earlier during\npacking (see the documentation of PackWriter#setTagTargets).\n\nThis patch does not introduce any functionality change.\n\nChange-Id: I70ed65a1041334abeda8d4bac98cce7cae7efcdf\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
      "commitDate": "2018-05-16, 7:57 p.m.",
      "commitName": "c79e7f1c27c73732310bc64c2071a79902447dcc",
      "commitAuthor": "Jonathan Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Avoid using #refs in UploadPack#sendPack\n\nWhen OPTION_INCLUDE_TAG is set, UploadPack#sendPack uses the #refs\ninstance variable as a source of information of tags. A subsequent patch\nwill need to supply this information to #sendPack without\nmodifying #refs, so refactor #sendPack to take in this information\nthrough a parameter instead.\n\nNote that prior to this patch, #refs was used twice in #sendPack: once\nto generate the argument to PackWriter#setTagTargets, and once to\ndetermine if any tags need to be included in the packfile. This patch\nonly updates the latter use, since the former is meant not only for\n\"true\" tag targets but any object that should be hoisted earlier during\npacking (see the documentation of PackWriter#setTagTargets).\n\nThis patch does not introduce any functionality change.\n\nChange-Id: I70ed65a1041334abeda8d4bac98cce7cae7efcdf\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
          "commitDate": "2018-05-16, 7:57 p.m.",
          "commitName": "c79e7f1c27c73732310bc64c2071a79902447dcc",
          "commitAuthor": "Jonathan Tan",
          "commitDateOld": "2018-05-15, 5:05 p.m.",
          "commitNameOld": "6d370d837c5faa7caff2e6e3e4723b887f2fbdca",
          "commitAuthorOld": "Han-Wen Nienhuys",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void sendPack(final boolean sideband,\n\t\t\tPackStatistics.Accumulator accumulator,\n\t\t\t@Nullable Collection\u003cRef\u003e allTags) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n\t\t\t\t\t\t\t\t\t\t// block, and is closed there\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n\t\t\t\taccumulator);\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tif (filterBlobLimit \u003e\u003d 0) {\n\t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n\t\t\t\tpw.setUseCachedPacks(false);\n\t\t\t} else {\n\t\t\t\tpw.setUseCachedPacks(true);\n\t\t\t}\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\t// Objects named directly by references go at the beginning\n\t\t\t// of the pack.\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n\t\t\t\tfor (Ref ref : allTags) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t// skip unborn branch\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
          "functionStartLine": 1813,
          "functionName": "sendPack",
          "diff": "@@ -1,142 +1,145 @@\n \tprivate void sendPack(final boolean sideband,\n-\t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n+\t\t\tPackStatistics.Accumulator accumulator,\n+\t\t\t@Nullable Collection\u003cRef\u003e allTags) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n \t\t\t\t\t\t\t\t\t\t// block, and is closed there\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tif (filterBlobLimit \u003e\u003d 0) {\n \t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n \t\t\t\tpw.setUseCachedPacks(false);\n \t\t\t} else {\n \t\t\t\tpw.setUseCachedPacks(true);\n \t\t\t}\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n+\t\t\t// Objects named directly by references go at the beginning\n+\t\t\t// of the pack.\n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (depth \u003e 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n-\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n-\t\t\t\tfor (Ref ref : refs.values()) {\n+\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n+\t\t\t\tfor (Ref ref : allTags) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator]",
            "newValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator, allTags-Collection\u003cRef\u003e(annotations-@Nullable)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Avoid using #refs in UploadPack#sendPack\n\nWhen OPTION_INCLUDE_TAG is set, UploadPack#sendPack uses the #refs\ninstance variable as a source of information of tags. A subsequent patch\nwill need to supply this information to #sendPack without\nmodifying #refs, so refactor #sendPack to take in this information\nthrough a parameter instead.\n\nNote that prior to this patch, #refs was used twice in #sendPack: once\nto generate the argument to PackWriter#setTagTargets, and once to\ndetermine if any tags need to be included in the packfile. This patch\nonly updates the latter use, since the former is meant not only for\n\"true\" tag targets but any object that should be hoisted earlier during\npacking (see the documentation of PackWriter#setTagTargets).\n\nThis patch does not introduce any functionality change.\n\nChange-Id: I70ed65a1041334abeda8d4bac98cce7cae7efcdf\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
          "commitDate": "2018-05-16, 7:57 p.m.",
          "commitName": "c79e7f1c27c73732310bc64c2071a79902447dcc",
          "commitAuthor": "Jonathan Tan",
          "commitDateOld": "2018-05-15, 5:05 p.m.",
          "commitNameOld": "6d370d837c5faa7caff2e6e3e4723b887f2fbdca",
          "commitAuthorOld": "Han-Wen Nienhuys",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void sendPack(final boolean sideband,\n\t\t\tPackStatistics.Accumulator accumulator,\n\t\t\t@Nullable Collection\u003cRef\u003e allTags) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n\t\t\t\t\t\t\t\t\t\t// block, and is closed there\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n\t\t\t\taccumulator);\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tif (filterBlobLimit \u003e\u003d 0) {\n\t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n\t\t\t\tpw.setUseCachedPacks(false);\n\t\t\t} else {\n\t\t\t\tpw.setUseCachedPacks(true);\n\t\t\t}\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\t// Objects named directly by references go at the beginning\n\t\t\t// of the pack.\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n\t\t\t\tfor (Ref ref : allTags) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t// skip unborn branch\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
          "functionStartLine": 1813,
          "functionName": "sendPack",
          "diff": "@@ -1,142 +1,145 @@\n \tprivate void sendPack(final boolean sideband,\n-\t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n+\t\t\tPackStatistics.Accumulator accumulator,\n+\t\t\t@Nullable Collection\u003cRef\u003e allTags) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n \t\t\t\t\t\t\t\t\t\t// block, and is closed there\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tif (filterBlobLimit \u003e\u003d 0) {\n \t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n \t\t\t\tpw.setUseCachedPacks(false);\n \t\t\t} else {\n \t\t\t\tpw.setUseCachedPacks(true);\n \t\t\t}\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n+\t\t\t// Objects named directly by references go at the beginning\n+\t\t\t// of the pack.\n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (depth \u003e 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n-\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n-\t\t\t\tfor (Ref ref : refs.values()) {\n+\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n+\t\t\t\tfor (Ref ref : allTags) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "4ac32e79b751944107470d5f4cb290eacd1b7cf9": {
      "type": "Ybodychange",
      "commitMessage": "Teach UploadPack to support filtering by blob size\n\nTeach UploadPack to advertise the filter capability and support a\n\"filter\" line in the request, accepting blob sizes only, if the\nconfiguration variable \"uploadpack.allowfilter\" is true. This feature is\ncurrently in the \"master\" branch of Git, and as of the time of writing,\nthis feature is to be released in Git 2.17.\n\nThis is incomplete in that the filter-by-sparse-specification feature\nalso supported by Git is not included in this patch.\n\nIf a JGit server were to be patched with this commit, and a repository\non that server configured with RequestPolicy.ANY or\nRequestPolicy.REACHABLE_COMMIT_TIP, a Git client built from the \"master\"\nbranch would be able to perform a partial clone.\n\nChange-Id: If72b4b422c06ab432137e9e5272d353b14b73259\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\n",
      "commitDate": "2018-03-15, 4:46 p.m.",
      "commitName": "4ac32e79b751944107470d5f4cb290eacd1b7cf9",
      "commitAuthor": "Jonathan Tan",
      "commitDateOld": "2018-03-13, 9:44 p.m.",
      "commitNameOld": "67df4986cef270144c7cae3485dc8541ca180649",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 1.79,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband,\n\t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n\t\t\t\t\t\t\t\t\t\t// block, and is closed there\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n\t\t\t\taccumulator);\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tif (filterBlobLimit \u003e\u003d 0) {\n\t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n\t\t\t\tpw.setUseCachedPacks(false);\n\t\t\t} else {\n\t\t\t\tpw.setUseCachedPacks(true);\n\t\t\t}\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t// skip unborn branch\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1544,
      "functionName": "sendPack",
      "diff": "@@ -1,137 +1,142 @@\n \tprivate void sendPack(final boolean sideband,\n \t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n \t\t\t\t\t\t\t\t\t\t// block, and is closed there\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n-\t\t\tpw.setUseCachedPacks(true);\n+\t\t\tif (filterBlobLimit \u003e\u003d 0) {\n+\t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n+\t\t\t\tpw.setUseCachedPacks(false);\n+\t\t\t} else {\n+\t\t\t\tpw.setUseCachedPacks(true);\n+\t\t\t}\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (depth \u003e 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "67df4986cef270144c7cae3485dc8541ca180649": {
      "type": "Ybodychange",
      "commitMessage": "UploadPack: Suppress resource warning about PackWriter\n\nPackWriter is auto-closeable and should be opened in try-with-resource,\nbut this is not possible since the variable is being referenced in the\nfinally block before being explicitly closed there.\n\nSuppress the warning and add an explanatory comment.\n\nChange-Id: I161923f35142132234fd951c0146d3cb30920b7b\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018-03-13, 9:44 p.m.",
      "commitName": "67df4986cef270144c7cae3485dc8541ca180649",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2018-03-11, 9:52 p.m.",
      "commitNameOld": "d88d5b94c669b4c23af4e1de797a4d130b6612f8",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 1.99,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband,\n\t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n\t\t\t\t\t\t\t\t\t\t// block, and is closed there\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n\t\t\t\taccumulator);\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t// skip unborn branch\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1502,
      "functionName": "sendPack",
      "diff": "@@ -1,135 +1,137 @@\n \tprivate void sendPack(final boolean sideband,\n \t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n+\t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n+\t\t\t\t\t\t\t\t\t\t// block, and is closed there\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (depth \u003e 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc19f649666704e5bf0184d3839be0c0c17439fc": {
      "type": "Ybodychange",
      "commitMessage": "Remove deprecated Statistics, UploadPackLogger, UploadPackLoggerChain\n\nUse PackStatistics and PostUploadHook and PostUploadHookChain instead.\nAlso remove\n- UploadPack#getPackStatistics replaced by #getStatistics\n- UploadPack#getLogger and UploadPack#setLogger\n\nChange-Id: I70881c539af3094d68d594f19983dea0973604e8\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2018-03-10, 1:38 p.m.",
      "commitName": "cc19f649666704e5bf0184d3839be0c0c17439fc",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2018-02-12, 4:59 p.m.",
      "commitNameOld": "302596cc675d00e41f0ff07efef58063afe20c79",
      "commitAuthorOld": "Terry Parker",
      "daysBetweenCommits": 25.86,
      "commitsBetweenForRepo": 125,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband,\n\t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n\t\t\t\taccumulator);\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t// skip unborn branch\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1503,
      "functionName": "sendPack",
      "diff": "@@ -1,136 +1,135 @@\n \tprivate void sendPack(final boolean sideband,\n \t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (depth \u003e 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n-\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "302596cc675d00e41f0ff07efef58063afe20c79": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Add negotiation statistics to PackStatistics\n\nAdd fetch statistics for the counts of advertised refs, wants and haves.\nAlso add the duration in milliseconds for the negotiation phase. For\nnon-bidirectional transports like HTTP, this is the time for the final\nround that sends the pack back to the user.\n\nChange-Id: I1af7ffd3cb7b62182340682e2a243691ea24ec2e\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2018-02-12, 4:59 p.m.",
      "commitName": "302596cc675d00e41f0ff07efef58063afe20c79",
      "commitAuthor": "Terry Parker",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Add negotiation statistics to PackStatistics\n\nAdd fetch statistics for the counts of advertised refs, wants and haves.\nAlso add the duration in milliseconds for the negotiation phase. For\nnon-bidirectional transports like HTTP, this is the time for the final\nround that sends the pack back to the user.\n\nChange-Id: I1af7ffd3cb7b62182340682e2a243691ea24ec2e\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
          "commitDate": "2018-02-12, 4:59 p.m.",
          "commitName": "302596cc675d00e41f0ff07efef58063afe20c79",
          "commitAuthor": "Terry Parker",
          "commitDateOld": "2018-01-03, 5:21 p.m.",
          "commitNameOld": "21d22e6f63a1adcfaeaee155f1be32f8123fd789",
          "commitAuthorOld": "Zhen Chen",
          "daysBetweenCommits": 39.99,
          "commitsBetweenForRepo": 46,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void sendPack(final boolean sideband,\n\t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n\t\t\t\taccumulator);\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t// skip unborn branch\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
          "functionStartLine": 1544,
          "functionName": "sendPack",
          "diff": "@@ -1,134 +1,136 @@\n-\tprivate void sendPack(final boolean sideband) throws IOException {\n+\tprivate void sendPack(final boolean sideband,\n+\t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n-\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n+\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n+\t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (depth \u003e 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[sideband-boolean(modifiers-final)]",
            "newValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Add negotiation statistics to PackStatistics\n\nAdd fetch statistics for the counts of advertised refs, wants and haves.\nAlso add the duration in milliseconds for the negotiation phase. For\nnon-bidirectional transports like HTTP, this is the time for the final\nround that sends the pack back to the user.\n\nChange-Id: I1af7ffd3cb7b62182340682e2a243691ea24ec2e\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
          "commitDate": "2018-02-12, 4:59 p.m.",
          "commitName": "302596cc675d00e41f0ff07efef58063afe20c79",
          "commitAuthor": "Terry Parker",
          "commitDateOld": "2018-01-03, 5:21 p.m.",
          "commitNameOld": "21d22e6f63a1adcfaeaee155f1be32f8123fd789",
          "commitAuthorOld": "Zhen Chen",
          "daysBetweenCommits": 39.99,
          "commitsBetweenForRepo": 46,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void sendPack(final boolean sideband,\n\t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n\t\t\t\taccumulator);\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t// skip unborn branch\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
          "functionStartLine": 1544,
          "functionName": "sendPack",
          "diff": "@@ -1,134 +1,136 @@\n-\tprivate void sendPack(final boolean sideband) throws IOException {\n+\tprivate void sendPack(final boolean sideband,\n+\t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n-\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n+\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(),\n+\t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (depth \u003e 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \t\t\t\t\tif (objectId \u003d\u003d null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "21d22e6f63a1adcfaeaee155f1be32f8123fd789": {
      "type": "Ybodychange",
      "commitMessage": "Skip unborn branches in UploadPack\n\nThe ObjectId of an unborn branch is null, skip those in UploadPack.\n\nChange-Id: I7cbf66b05dff98c4fe9f33e20a647ba6acf364b2\nSigned-off-by: Zhen Chen \u003cczhen@google.com\u003e\n",
      "commitDate": "2018-01-03, 5:21 p.m.",
      "commitName": "21d22e6f63a1adcfaeaee155f1be32f8123fd789",
      "commitAuthor": "Zhen Chen",
      "commitDateOld": "2017-12-20, 4:10 p.m.",
      "commitNameOld": "781e106a2607665a7a47b626fd5b67fa8b491d18",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 14.05,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\t\t\t\t\tif (objectId \u003d\u003d null) {\n\t\t\t\t\t\t// skip unborn branch\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1535,
      "functionName": "sendPack",
      "diff": "@@ -1,129 +1,134 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (depth \u003e 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n+\t\t\t\t\tif (objectId \u003d\u003d null) {\n+\t\t\t\t\t\t// skip unborn branch\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n-\t\t\t\t\tif (peeledId \u003d\u003d null)\n+\t\t\t\t\tobjectId \u003d ref.getObjectId();\n+\t\t\t\t\tif (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n-\t\t\t\t\tobjectId \u003d ref.getObjectId();\n-\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n+\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1": {
      "type": "Ybodychange",
      "commitMessage": "Exclude refs/tags from bitmap commit selection\n\nCommit db77610 ensured that all refs/tags commits are added to the\nprimary GC pack. It did that by adding all of the refs/tags commits\nto the primary GC pack PackWriter\u0027s \"interesting\" object set.\n\nUnfortunately, all commit objects in the \"interesting\" set are\nselected as commits for which bitmap indices will be built. In a\nrepository like chromium with lots of tags, this changed the number of\nbitmaps created from \u003c700 to \u003e10000. That puts huge memory pressure on\nthe GC task.\n\nThis change restores the original behavior of ignoring tags when\nselecting commits for bitmaps.\n\nIn the \"uninteresting\" set, commits for refs/heads and refs/tags for\nunannotated tags can not be differentiated. We instead identify\nrefs/tags commits by passing their ObjectIds as a new \"noBitmaps\"\nparameter to the PackWriter.preparePack() methods.\nPackWriterBitmapPreparer.setupTipCommitBitmaps() can then use that\n\"noBitmaps\" parameter to exclude those commits.\n\nChange-Id: Icd287c6b04fc1e48de773033fe432a9b0e904ac5\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2017-05-18, 6:25 p.m.",
      "commitName": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2017-04-05, 3:51 a.m.",
      "commitNameOld": "7476baebfc457e75c984de61dc8ae08a359b52e8",
      "commitAuthorOld": "Andrey Loskutov",
      "daysBetweenCommits": 43.61,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1448,
      "functionName": "sendPack",
      "diff": "@@ -1,129 +1,129 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (depth \u003e 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n-\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n+\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
      "type": "Ybodychange",
      "commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit\u0027s not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017-02-20, 4:47 p.m.",
      "commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017-02-19, 7:05 p.m.",
      "commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1438,
      "functionName": "sendPack",
      "diff": "@@ -1,129 +1,129 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n-\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n+\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (depth \u003e 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b16e207742beb6a82b2b74df7bb87893a38bdd04": {
      "type": "Ybodychange",
      "commitMessage": "Shallow fetch: Pass along \"shallow\"s in unparsed-wants case, too\n\nSince 84d2738ff21c (Don\u0027t skip want validation when the client sends no\nhaves, 2013-06-21), this branch is not taken.  Process the\n\"shallow\"s anyway as a defensive measure in case the code path gets\nrevived.\n\nChange-Id: Idfb834825d77f51e17191c1635c9d78c78738cfd\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
      "commitDate": "2016-08-08, 4:49 p.m.",
      "commitName": "b16e207742beb6a82b2b74df7bb87893a38bdd04",
      "commitAuthor": "Jonathan Nieder",
      "commitDateOld": "2016-08-08, 4:48 p.m.",
      "commitNameOld": "f84370feaaf319b7fe9bd272a7ceba235cc1e86a",
      "commitAuthorOld": "Jonathan Nieder",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1422,
      "functionName": "sendPack",
      "diff": "@@ -1,129 +1,129 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (depth \u003e 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n-\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n+\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f84370feaaf319b7fe9bd272a7ceba235cc1e86a": {
      "type": "Ybodychange",
      "commitMessage": "Shallow fetch: Pass a DepthWalk to PackWriter\n\nd385a7a5e5ca (Shallow fetch: Respect \"shallow\" lines, 2016-08-03) forgot\nthat UploadPack wasn\u0027t passing a DepthWalk to PackWriter in the first\nplace.  As a result, shallow clones fail:\n\n  java.lang.IllegalArgumentException: Shallow packs require a DepthWalk\n        at org.eclipse.jgit.internal.storage.pack.PackWriter.preparePack(PackWriter.java:756)\n        at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:1497)\n        at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:1381)\n        at org.eclipse.jgit.transport.UploadPack.service(UploadPack.java:774)\n        at org.eclipse.jgit.transport.UploadPack.upload(UploadPack.java:667)\n        at org.eclipse.jgit.http.server.UploadPackServlet.doPost(UploadPackServlet.java:191)\n\nChange-Id: Ib0d8c2946eebfea910a2b767fb92e23da15d4749\n",
      "commitDate": "2016-08-08, 4:48 p.m.",
      "commitName": "f84370feaaf319b7fe9bd272a7ceba235cc1e86a",
      "commitAuthor": "Jonathan Nieder",
      "commitDateOld": "2016-07-05, 12:18 p.m.",
      "commitNameOld": "5196798cb743aa9e9a0e7d92c64e9c930656acaa",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 34.19,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (depth \u003e 0) {\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth);\n\t\t\t\trw.assumeShallow(clientShallowCommits);\n\t\t\t}\n\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1422,
      "functionName": "sendPack",
      "diff": "@@ -1,126 +1,129 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n-\t\t\tif (depth \u003e 0)\n-\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n-\n \t\t\tRevWalk rw \u003d walk;\n+\t\t\tif (depth \u003e 0) {\n+\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n+\t\t\t\trw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth);\n+\t\t\t\trw.assumeShallow(clientShallowCommits);\n+\t\t\t}\n+\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n-\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n+\t\t\t\tObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1fa6f3a7509dc937551006e11dfd3bdaea921cd0": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Remove PackWriter.Statistics and other deprecated classes\"\n\nThis reverts commit bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379.\nThese classes were part of the public API and should not be removed\nuntil JGit 5.0.\n\nChange-Id: Ife4bee69f82151de6ef8ea1a4c6c146d91bbf0d5\n",
      "commitDate": "2015-11-10, 8:14 p.m.",
      "commitName": "1fa6f3a7509dc937551006e11dfd3bdaea921cd0",
      "commitAuthor": "Jonathan Nieder",
      "commitDateOld": "2015-11-09, 9:55 p.m.",
      "commitNameOld": "bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379",
      "commitAuthorOld": "Terry Parker",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1432,
      "functionName": "sendPack",
      "diff": "@@ -1,125 +1,126 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n+\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379": {
      "type": "Ybodychange",
      "commitMessage": "Remove PackWriter.Statistics and other deprecated classes\n\nThese classes make improper use of internal classes in the public API\nand were replaced by corresponding classes in the JGit 4.1 release.\n\nChange-Id: I3d474210e49089aa788314b4e08f505f0d26619b\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2015-11-09, 9:55 p.m.",
      "commitName": "bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2015-09-14, 3:53 p.m.",
      "commitNameOld": "b46c4463959f45b32e471e4c10b5ddc71232949e",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 56.29,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1393,
      "functionName": "sendPack",
      "diff": "@@ -1,126 +1,125 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n-\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a415915c2dab31f9e69b9a55dcb87c579649bf5": {
      "type": "Ybodychange",
      "commitMessage": "Add the set of shallow commits to PackStatistics\n\nChange-Id: I976102e054369b045340d4b9209984b5243e3750\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2015-06-15, 5:49 p.m.",
      "commitName": "6a415915c2dab31f9e69b9a55dcb87c579649bf5",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2015-06-12, 4:56 p.m.",
      "commitNameOld": "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df",
      "commitAuthorOld": "Terry Parker",
      "daysBetweenCommits": 3.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1401,
      "functionName": "sendPack",
      "diff": "@@ -1,125 +1,126 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n+\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df": {
      "type": "Ybodychange",
      "commitMessage": "Introduce PostUploadHook to replace UploadPackLogger\n\nUploadPackLogger is incorrectly named--it can be used to trigger any\npost upload action, such as GC/compaction. This change introduces\nPostUploadHook/PostUploadHookChain to replace\nUploadPackLogger/UploadPackLoggerChain and deprecates the latter.\n\nIt also introduces PackStatistics as a replacement for\nPackWriter.Statistics, since the latter is not public API.\nIt changes PackWriter to use PackStatistics and reimplements\nPackWriter.Statistics to delegate to PackStatistics.\n\nChange-Id: Ic51df1613e471f568ffee25ae67e118425b38986\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2015-06-12, 4:56 p.m.",
      "commitName": "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2015-06-09, 12:43 p.m.",
      "commitNameOld": "96f210f4b7172a0d427061d2f9624872efbcad39",
      "commitAuthorOld": "Fredrik Medley",
      "daysBetweenCommits": 3.18,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null) {\n\t\t\t\tpostUploadHook.onPostUpload(statistics);\n\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1401,
      "functionName": "sendPack",
      "diff": "@@ -1,123 +1,125 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n-\t\t\tif (statistics !\u003d null)\n-\t\t\t\tlogger.onPackStatistics(statistics);\n+\t\t\tif (statistics !\u003d null) {\n+\t\t\t\tpostUploadHook.onPostUpload(statistics);\n+\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n+\t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e73d395061d1bfee365acaa2f79c392175d13bf": {
      "type": "Ybodychange",
      "commitMessage": "Use AutoClosable to close resources in bundle org.eclipse.jgit\n\n- use try-with-resource where possible\n- replace use of deprecated release() by close()\n\nChange-Id: I0f139c3535679087b7fa09649166bca514750b81\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015-05-20, 6:01 p.m.",
      "commitName": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2015-04-30, 5:40 p.m.",
      "commitNameOld": "4a984e20332a765a81cadeaa4875b228ebf290fb",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 20.01,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null)\n\t\t\t\tlogger.onPackStatistics(statistics);\n\t\t\tpw.close();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1346,
      "functionName": "sendPack",
      "diff": "@@ -1,123 +1,123 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics \u003d pw.getStatistics();\n \t\t\tif (statistics !\u003d null)\n \t\t\t\tlogger.onPackStatistics(statistics);\n-\t\t\tpw.release();\n+\t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7b7d033ee1fdd8e81ae2ad7dc9e1ae12cbd9ddfa": {
      "type": "Ybodychange",
      "commitMessage": "UploadPack: Always make PackWriter.Statistics available\n\nIf the packer fails, still obtain the stats and make them available\nto the logger and the caller. Failures can frequently happen when\na client disconnects in the middle of a pack stream. Server admins\nmay still want to examine the timing metrics from counting and\ncompressing phases.\n\nChange-Id: Iceae4f68b5473f4223d85c9edfb57837fc818eed\n",
      "commitDate": "2014-08-29, 3:56 p.m.",
      "commitName": "7b7d033ee1fdd8e81ae2ad7dc9e1ae12cbd9ddfa",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2014-01-28, 8:29 p.m.",
      "commitNameOld": "b0174a089ce886d02c8d7fb80d63f0e50329bec3",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 212.77,
      "commitsBetweenForRepo": 300,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tstatistics \u003d pw.getStatistics();\n\t\t\tif (statistics !\u003d null)\n\t\t\t\tlogger.onPackStatistics(statistics);\n\t\t\tpw.release();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1310,
      "functionName": "sendPack",
      "diff": "@@ -1,124 +1,123 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n-\t\t\tstatistics \u003d pw.getStatistics();\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n+\t\t\tstatistics \u003d pw.getStatistics();\n+\t\t\tif (statistics !\u003d null)\n+\t\t\t\tlogger.onPackStatistics(statistics);\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n-\n-\t\tif (statistics !\u003d null)\n-\t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b0174a089ce886d02c8d7fb80d63f0e50329bec3": {
      "type": "Ybodychange",
      "commitMessage": "Fix serving fetch of existing shallow client\n\nIn certain cases a JGit server updating an existing shallow client\nselected a common ancestor that was behind the shallow edge of\nthe client. This allowed the server to assume the client had some\nobjects it did not have and allowed creation of pack deltas the\nclient could never inflate.\n\nAny commit the client has advertised as shallow must be treated\nby UploadPack server as though it has no parents. With no parents\nthe walker cannot visit graph history the client does not have,\nand PackWriter cannot consider delta base candidates the client\nis lacking.\n\nChange-Id: I4922b9354df9f490966a586fb693762e897345a2\n",
      "commitDate": "2014-01-28, 8:29 p.m.",
      "commitName": "b0174a089ce886d02c8d7fb80d63f0e50329bec3",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013-11-01, 10:57 p.m.",
      "commitNameOld": "b0dbb78e7d2287a5391a75e399009bf2203c4f24",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 87.94,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\t\t\tstatistics \u003d pw.getStatistics();\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tpw.release();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\n\t\tif (statistics !\u003d null)\n\t\t\tlogger.onPackStatistics(statistics);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1310,
      "functionName": "sendPack",
      "diff": "@@ -1,124 +1,124 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n-\t\t\tpw.setUseBitmaps(true);\n+\t\t\tpw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics \u003d pw.getStatistics();\n \n \t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics !\u003d null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "557471da2eee6752ad4305a883843bcdc8d66536": {
      "type": "Ybodychange",
      "commitMessage": "Use NullOutputStream not DisabledOutputStream in UploadPack\n\nThe stream should not throw IllegalStateException if it is off.\nFlush the stream after the hook runs, in case any messages need\nto be sent ahead of the pack.\n\nChange-Id: I21c7a0258ab1308406d226293fa0e7da69b4f57b\n",
      "commitDate": "2013-05-23, 4:07 p.m.",
      "commitName": "557471da2eee6752ad4305a883843bcdc8d66536",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013-05-22, 3:14 p.m.",
      "commitNameOld": "6e896ba66ba095b97a89a622d43f05ce9ad501e7",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 1.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t\tmsgOut.flush();\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(true);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\t\t\tstatistics \u003d pw.getStatistics();\n\n\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tpw.release();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\n\t\tif (statistics !\u003d null)\n\t\t\tlogger.onPackStatistics(statistics);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1106,
      "functionName": "sendPack",
      "diff": "@@ -1,123 +1,124 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n+\t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics \u003d pw.getStatistics();\n \n-\t\t\tif (msgOut !\u003d DisabledOutputStream.INSTANCE) {\n+\t\t\tif (msgOut !\u003d NullOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics !\u003d null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e896ba66ba095b97a89a622d43f05ce9ad501e7": {
      "type": "Ybodychange",
      "commitMessage": "Allow PreUploadHook.onSendPack to send messages to the client\n\nBefore transmitting to the client a hook may want to send along\na text message ahead of the pack, such as a \"message of the day\".\nEnable this usage by mirroring the message sending API from\nReceivePack on the UploadPack instance, using the side band.\n\nChange-Id: I31cd254a4ddb816641397a3e9c2c20212471c37f\n",
      "commitDate": "2013-05-22, 3:14 p.m.",
      "commitName": "6e896ba66ba095b97a89a622d43f05ce9ad501e7",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013-04-10, 3:58 p.m.",
      "commitNameOld": "eb17495ca4ce95c63bacf81af16ab19ff042b65c",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 41.97,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(true);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\t\t\tstatistics \u003d pw.getStatistics();\n\n\t\t\tif (msgOut !\u003d DisabledOutputStream.INSTANCE) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tpw.release();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\n\t\tif (statistics !\u003d null)\n\t\t\tlogger.onPackStatistics(statistics);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1105,
      "functionName": "sendPack",
      "diff": "@@ -1,124 +1,123 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n-\t\tSideBandOutputStream msgOut \u003d null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics \u003d pw.getStatistics();\n \n-\t\t\tif (msgOut !\u003d null) {\n+\t\t\tif (msgOut !\u003d DisabledOutputStream.INSTANCE) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics !\u003d null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eb17495ca4ce95c63bacf81af16ab19ff042b65c": {
      "type": "Ybodychange",
      "commitMessage": "Disable CRC32 computation when no PackIndex will be created\n\nIf a server is streaming 3GiB worth of pack data to a client there\nis no reason to compute the CRC32 checksum on the objects. The\nCRC32 code computed by PackWriter is used only in the new index\ncreated by writeIndex(), which is never invoked for the native Git\nnetwork protocols.\n\nObject reuse may still compute its own CRC32 to verify the data\nbeing copied from an existing pack has not been corrupted. This\ncheck is done by the ObjectReader that implements ObjectReuseAsIs\nand has no relationship to the CRC32 being skipped during output.\n\nChange-Id: I05626f2e0d6ce19119b57d8a27193922636d60a7\n",
      "commitDate": "2013-04-10, 3:58 p.m.",
      "commitName": "eb17495ca4ce95c63bacf81af16ab19ff042b65c",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013-03-22, 4:21 p.m.",
      "commitNameOld": "dd6f41e4010680115c00dd8dc250b1674eb42f42",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 18.98,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\t\tSideBandOutputStream msgOut \u003d null;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setIndexDisabled(true);\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(true);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\t\t\tstatistics \u003d pw.getStatistics();\n\n\t\t\tif (msgOut !\u003d null) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tpw.release();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\n\t\tif (statistics !\u003d null)\n\t\t\tlogger.onPackStatistics(statistics);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1076,
      "functionName": "sendPack",
      "diff": "@@ -1,123 +1,124 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \t\tSideBandOutputStream msgOut \u003d null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n+\t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics \u003d pw.getStatistics();\n \n \t\t\tif (msgOut !\u003d null) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics !\u003d null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "43ea887c8b43de26a6b7a9ea547033d3c04022e7": {
      "type": "Ybodychange",
      "commitMessage": "Enable serving upload requests using bitmaps.\n\nIf the pack index has bitmaps, allow the PackWriter to use the bitmaps\nfor upload requests.\n\nChange-Id: Iefa995fe927a11e4fd78afb34530995614221fc0\n",
      "commitDate": "2013-03-05, 2:14 p.m.",
      "commitName": "43ea887c8b43de26a6b7a9ea547033d3c04022e7",
      "commitAuthor": "Colby Ranger",
      "commitDateOld": "2012-12-27, 10:57 a.m.",
      "commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 68.14,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\t\tSideBandOutputStream msgOut \u003d null;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setUseBitmaps(true);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\t\t\tstatistics \u003d pw.getStatistics();\n\n\t\t\tif (msgOut !\u003d null) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tpw.release();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\n\t\tif (statistics !\u003d null)\n\t\t\tlogger.onPackStatistics(statistics);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1096,
      "functionName": "sendPack",
      "diff": "@@ -1,122 +1,123 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \t\tSideBandOutputStream msgOut \u003d null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setUseCachedPacks(true);\n+\t\t\tpw.setUseBitmaps(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics \u003d pw.getStatistics();\n \n \t\t\tif (msgOut !\u003d null) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics !\u003d null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9b86cf574b230a9b3a71d7cb53a4f6712bfa33eb": {
      "type": "Ybodychange",
      "commitMessage": "Suppress two resource warnings\n\nChange-Id: I829bb135b2347f79aa6d8979a0934042e40d212f\n",
      "commitDate": "2012-08-17, 9:49 a.m.",
      "commitName": "9b86cf574b230a9b3a71d7cb53a4f6712bfa33eb",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012-03-12, 10:20 a.m.",
      "commitNameOld": "95d311f8886f42f31a4475f84aa23c6345ab7059",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 157.98,
      "commitsBetweenForRepo": 158,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\t\tSideBandOutputStream msgOut \u003d null;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\t@SuppressWarnings(\"resource\")\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\t\t\tstatistics \u003d pw.getStatistics();\n\n\t\t\tif (msgOut !\u003d null) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tpw.release();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\n\t\tif (statistics !\u003d null)\n\t\t\tlogger.onPackStatistics(statistics);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1096,
      "functionName": "sendPack",
      "diff": "@@ -1,121 +1,122 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \t\tSideBandOutputStream msgOut \u003d null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n+\t\t\t\t@SuppressWarnings(\"resource\")\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics \u003d pw.getStatistics();\n \n \t\t\tif (msgOut !\u003d null) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics !\u003d null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1f2022e3a7e9482caa4823e031504b6bbe8246af": {
      "type": "Ybodychange",
      "commitMessage": "Modify refs in UploadPack/ReceivePack using a hook interface\n\nThis is intended to replace the RefFilter interface (but does not yet,\nfor backwards compatibility). That interface required lots of extra\nscanning and copying in filter cases such as only advertising a subtree\nof the refs directory. Instead, provide a hook that can be executed\nright before ref advertisement, using the public methods on\nUploadPack/ReceivePack to explicitly set the map of advertised refs.\n\nChange-Id: I0067019a191c8148af2cfb71a675f2258c5af0ca\n",
      "commitDate": "2012-02-29, 10:09 p.m.",
      "commitName": "1f2022e3a7e9482caa4823e031504b6bbe8246af",
      "commitAuthor": "Dave Borowitz",
      "commitDateOld": "2011-12-08, 11:26 a.m.",
      "commitNameOld": "d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3",
      "commitAuthorOld": "Dave Borowitz",
      "daysBetweenCommits": 83.45,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\t\tSideBandOutputStream msgOut \u003d null;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t} catch (ServiceMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\t\t\tstatistics \u003d pw.getStatistics();\n\n\t\t\tif (msgOut !\u003d null) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tpw.release();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\n\t\tif (statistics !\u003d null)\n\t\t\tlogger.onPackStatistics(statistics);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1043,
      "functionName": "sendPack",
      "diff": "@@ -1,121 +1,121 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \t\tSideBandOutputStream msgOut \u003d null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n-\t\t} catch (UploadPackMayNotContinueException noPack) {\n+\t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics \u003d pw.getStatistics();\n \n \t\t\tif (msgOut !\u003d null) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics !\u003d null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3": {
      "type": "Ybodychange",
      "commitMessage": "Add a no-op UploadPackLogger and use it by default\n\nThis matches the behavior of the hooks in UploadPack.\n\nChange-Id: I21277e52ee9452237d87084f06bb140dfa6bf608\n",
      "commitDate": "2011-12-08, 11:26 a.m.",
      "commitName": "d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3",
      "commitAuthor": "Dave Borowitz",
      "commitDateOld": "2011-09-14, 6:34 p.m.",
      "commitNameOld": "01888db892aa9590862d886c01f3b293140db153",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 84.74,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\t\tSideBandOutputStream msgOut \u003d null;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t} catch (UploadPackMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\t\t\tstatistics \u003d pw.getStatistics();\n\n\t\t\tif (msgOut !\u003d null) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tpw.release();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\n\t\tif (statistics !\u003d null)\n\t\t\tlogger.onPackStatistics(statistics);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1001,
      "functionName": "sendPack",
      "diff": "@@ -1,121 +1,121 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \t\tSideBandOutputStream msgOut \u003d null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (UploadPackMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics \u003d pw.getStatistics();\n \n \t\t\tif (msgOut !\u003d null) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n-\t\tif (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n+\t\tif (statistics !\u003d null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "01888db892aa9590862d886c01f3b293140db153": {
      "type": "Ybodychange",
      "commitMessage": "UploadPack: Fix races in smart HTTP negotiation\n\nClients cache the set of advertised references at the start of a\nnegotiation, and keep replaying the same \"want SHA1\" list to the\nserver on each negotiation step.  If another client pushes into\na branch and moves it by fast-forward, any request to obtain that\nbranch\u0027s prior SHA-1 is still valid, the commit is reachable from\nthe new position of the reference.  Unfortunately the fast-forward\ncauses smart HTTP negotations to fail, as the server no longer is\nadvertising that prior SHA-1.\n\nInstead of causing clients to fail out with a \"want invalid\" error\nand forcing the end-user retry, possibly getting into a never ending\ntry-fail-retry race while other clients are pushing into the same\nbusy repository, allow the slightly stale want request so long as\nit is still reachable.\n\nC Git implemented this same change recently to fix races on the\nsmart HTTP protocol when the C Git git-http-backend is used.\n\nThe new RequestPolicy feature also allows server authors to make\nan even more lenient configuration that exports any SHA-1 to the\nclient. This might be useful in certain settings where a server\nhas authenticated the client as the \"repository owner\" and wants\nto allow them to grab any content from the server as a complete\nunbroken history chain.\n\nThe new setAdvertisedRefs() method allows server authors to manually\nfix the references that are advertised, possibly bypassing the\ngetAllRefs() call on the Repository object.\n\nChange-Id: I7cdb563bf9c55c83653f217f6e53c3add55a0541\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011-09-14, 6:34 p.m.",
      "commitName": "01888db892aa9590862d886c01f3b293140db153",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011-08-21, 5:04 p.m.",
      "commitNameOld": "9952223e0645fd7a8cddc6093a7f449c6390238d",
      "commitAuthorOld": "Matt Fischer",
      "daysBetweenCommits": 24.06,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\t\tSideBandOutputStream msgOut \u003d null;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t} catch (UploadPackMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\t\t\tstatistics \u003d pw.getStatistics();\n\n\t\t\tif (msgOut !\u003d null) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tpw.release();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\n\t\tif (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n\t\t\tlogger.onPackStatistics(statistics);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 996,
      "functionName": "sendPack",
      "diff": "@@ -1,121 +1,121 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \t\tSideBandOutputStream msgOut \u003d null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (UploadPackMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n-\t\t\tif (commonBase.isEmpty()) {\n+\t\t\tif (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth \u003e 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n-\t\t\tif (options.contains(OPTION_INCLUDE_TAG)) {\n+\t\t\tif (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics \u003d pw.getStatistics();\n \n \t\t\tif (msgOut !\u003d null) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9952223e0645fd7a8cddc6093a7f449c6390238d": {
      "type": "Ybodychange",
      "commitMessage": "Implement server support for shallow clones\n\nThis implements the server side of shallow clones only (i.e.\ngit-upload-pack), not the client side.\n\nCQ: 5517\nBug: 301627\nChange-Id: Ied5f501f9c8d1fe90ab2ba44fac5fa67ed0035a4\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011-08-21, 5:04 p.m.",
      "commitName": "9952223e0645fd7a8cddc6093a7f449c6390238d",
      "commitAuthor": "Matt Fischer",
      "commitDateOld": "2011-08-16, 3:18 p.m.",
      "commitNameOld": "74333e63b60440be5ff9f591f2203b635e26e3a0",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 5.07,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\t\tSideBandOutputStream msgOut \u003d null;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t} catch (UploadPackMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty()) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tif (depth \u003e 0)\n\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG)) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\t\t\tstatistics \u003d pw.getStatistics();\n\n\t\t\tif (msgOut !\u003d null) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tpw.release();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\n\t\tif (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n\t\t\tlogger.onPackStatistics(statistics);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 896,
      "functionName": "sendPack",
      "diff": "@@ -1,118 +1,121 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut \u003d rawOut;\n \t\tSideBandOutputStream msgOut \u003d null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (UploadPackMayNotContinueException noPack) {\n \t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg \u003d packConfig;\n \t\tif (cfg \u003d\u003d null)\n \t\t\tcfg \u003d new PackConfig(db);\n \t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty()) {\n \t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n+\t\t\tif (depth \u003e 0)\n+\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n+\n \t\t\tRevWalk rw \u003d walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw \u003d ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG)) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref \u003d db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId \u003d\u003d null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId \u003d ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics \u003d pw.getStatistics();\n \n \t\t\tif (msgOut !\u003d null) {\n \t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7ff6eb584cf8b83f83a3b5edf897feb53dbf42c0": {
      "type": "Yintroduced",
      "commitMessage": "Push errors back over sideband when possible\n\nIf an internal exception occurs while packing and the request\nneeds to abort, the HTTP response might already be committed due\nto progress message having already been delivered to the client.\nThis prevents UploadPackServlet from resetting the response and\nsending back an HTTP 500 response.\n\nTry to catch all exceptions and report internal errors over the\nsideband stream or as an ERR command during the initial ACK/NAK\nnegotiation phase. This allows JGit to transmit an error message\nthat the user will receive on their console without needing to\nworry about resetting the (already gone) HTTP response.\n\nChange-Id: Ie393fb8bb55d2b79ab1276adf71c781c1807f9fe\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011-06-09, 8:29 p.m.",
      "commitName": "7ff6eb584cf8b83f83a3b5edf897feb53dbf42c0",
      "commitAuthor": "Shawn O. Pearce",
      "diff": "@@ -0,0 +1,118 @@\n+\tprivate void sendPack(final boolean sideband) throws IOException {\n+\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n+\t\tOutputStream packOut \u003d rawOut;\n+\t\tSideBandOutputStream msgOut \u003d null;\n+\n+\t\tif (sideband) {\n+\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n+\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n+\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n+\n+\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n+\t\t\t\t\tbufsz, rawOut);\n+\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n+\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n+\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n+\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n+\t\t\t}\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tif (wantAll.isEmpty()) {\n+\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n+\t\t\t} else {\n+\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n+\t\t\t}\n+\t\t} catch (UploadPackMayNotContinueException noPack) {\n+\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n+\t\t\t\tnoPack.setOutput();\n+\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n+\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n+\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n+\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n+\t\t\t\terr.flush();\n+\t\t\t}\n+\t\t\tthrow noPack;\n+\t\t}\n+\n+\t\tPackConfig cfg \u003d packConfig;\n+\t\tif (cfg \u003d\u003d null)\n+\t\t\tcfg \u003d new PackConfig(db);\n+\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n+\t\ttry {\n+\t\t\tpw.setUseCachedPacks(true);\n+\t\t\tpw.setReuseDeltaCommits(true);\n+\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n+\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n+\t\t\tpw.setReuseValidatingObjects(false);\n+\n+\t\t\tif (commonBase.isEmpty()) {\n+\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n+\t\t\t\tfor (Ref ref : refs.values()) {\n+\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n+\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n+\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n+\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n+\t\t\t\t}\n+\t\t\t\tpw.setTagTargets(tagTargets);\n+\t\t\t}\n+\n+\t\t\tRevWalk rw \u003d walk;\n+\t\t\tif (wantAll.isEmpty()) {\n+\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n+\t\t\t} else {\n+\t\t\t\twalk.reset();\n+\n+\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n+\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n+\t\t\t\trw \u003d ow;\n+\t\t\t}\n+\n+\t\t\tif (options.contains(OPTION_INCLUDE_TAG)) {\n+\t\t\t\tfor (Ref ref : refs.values()) {\n+\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n+\n+\t\t\t\t\t// If the object was already requested, skip it.\n+\t\t\t\t\tif (wantAll.isEmpty()) {\n+\t\t\t\t\t\tif (wantIds.contains(objectId))\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n+\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (!ref.isPeeled())\n+\t\t\t\t\t\tref \u003d db.peel(ref);\n+\n+\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n+\t\t\t\t\tif (peeledId \u003d\u003d null)\n+\t\t\t\t\t\tcontinue;\n+\n+\t\t\t\t\tobjectId \u003d ref.getObjectId();\n+\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n+\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n+\t\t\tstatistics \u003d pw.getStatistics();\n+\n+\t\t\tif (msgOut !\u003d null) {\n+\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n+\t\t\t\tmsgOut.write(Constants.encode(msg));\n+\t\t\t\tmsgOut.flush();\n+\t\t\t}\n+\n+\t\t} finally {\n+\t\t\tpw.release();\n+\t\t}\n+\n+\t\tif (sideband)\n+\t\t\tpckOut.end();\n+\n+\t\tif (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n+\t\t\tlogger.onPackStatistics(statistics);\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tprivate void sendPack(final boolean sideband) throws IOException {\n\t\tProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n\t\tOutputStream packOut \u003d rawOut;\n\t\tSideBandOutputStream msgOut \u003d null;\n\n\t\tif (sideband) {\n\t\t\tint bufsz \u003d SideBandOutputStream.SMALL_BUF;\n\t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n\t\t\t\tbufsz \u003d SideBandOutputStream.MAX_BUF;\n\n\t\t\tpackOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n\t\t\t\t\tbufsz, rawOut);\n\t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n\t\t\t\tmsgOut \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n\t\t\t\tpm \u003d new SideBandProgressMonitor(msgOut);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n\t\t\t}\n\t\t} catch (UploadPackMayNotContinueException noPack) {\n\t\t\tif (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n\t\t\t\tnoPack.setOutput();\n\t\t\t\tSideBandOutputStream err \u003d new SideBandOutputStream(\n\t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n\t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n\t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n\t\t\t\terr.flush();\n\t\t\t}\n\t\t\tthrow noPack;\n\t\t}\n\n\t\tPackConfig cfg \u003d packConfig;\n\t\tif (cfg \u003d\u003d null)\n\t\t\tcfg \u003d new PackConfig(db);\n\t\tfinal PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n\t\ttry {\n\t\t\tpw.setUseCachedPacks(true);\n\t\t\tpw.setReuseDeltaCommits(true);\n\t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n\t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n\t\t\tpw.setReuseValidatingObjects(false);\n\n\t\t\tif (commonBase.isEmpty()) {\n\t\t\t\tSet\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tif (ref.getPeeledObjectId() !\u003d null)\n\t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n\t\t\t\t\telse if (ref.getObjectId() \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n\t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n\t\t\t\t}\n\t\t\t\tpw.setTagTargets(tagTargets);\n\t\t\t}\n\n\t\t\tRevWalk rw \u003d walk;\n\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n\t\t\t} else {\n\t\t\t\twalk.reset();\n\n\t\t\t\tObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n\t\t\t\trw \u003d ow;\n\t\t\t}\n\n\t\t\tif (options.contains(OPTION_INCLUDE_TAG)) {\n\t\t\t\tfor (Ref ref : refs.values()) {\n\t\t\t\t\tObjectId objectId \u003d ref.getObjectId();\n\n\t\t\t\t\t// If the object was already requested, skip it.\n\t\t\t\t\tif (wantAll.isEmpty()) {\n\t\t\t\t\t\tif (wantIds.contains(objectId))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRevObject obj \u003d rw.lookupOrNull(objectId);\n\t\t\t\t\t\tif (obj !\u003d null \u0026\u0026 obj.has(WANT))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ref.isPeeled())\n\t\t\t\t\t\tref \u003d db.peel(ref);\n\n\t\t\t\t\tObjectId peeledId \u003d ref.getPeeledObjectId();\n\t\t\t\t\tif (peeledId \u003d\u003d null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tobjectId \u003d ref.getObjectId();\n\t\t\t\t\tif (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n\t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n\t\t\tstatistics \u003d pw.getStatistics();\n\n\t\t\tif (msgOut !\u003d null) {\n\t\t\t\tString msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n\t\t\t\tmsgOut.write(Constants.encode(msg));\n\t\t\t\tmsgOut.flush();\n\t\t\t}\n\n\t\t} finally {\n\t\t\tpw.release();\n\t\t}\n\n\t\tif (sideband)\n\t\t\tpckOut.end();\n\n\t\tif (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n\t\t\tlogger.onPackStatistics(statistics);\n\t}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 829,
      "functionName": "sendPack"
    }
  }
}