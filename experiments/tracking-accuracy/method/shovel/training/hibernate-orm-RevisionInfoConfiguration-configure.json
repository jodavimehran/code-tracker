{
  "origin": "codeshovel",
  "repositoryName": "hibernate-orm",
  "repositoryPath": "H:\\Projects\\hibernate\\hibernate-orm/.git",
  "startCommitName": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b",
  "sourceFileName": "RevisionInfoConfiguration.java",
  "functionName": "configure",
  "functionId": "configure___metadata-MetadataImplementor__reflectionManager-ReflectionManager",
  "sourceFilePath": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
  "functionStartLine": 296,
  "functionEndLine": 438,
  "numCommitsSeen": 58,
  "timeTaken": 7434,
  "changeHistory": [
    "9e063ffa2577f06d98a9e912bb16d20424df8d6d",
    "410a785dfe40ae030bec31c4c06a5a7998f1feeb",
    "b70bc0080e8e206f83debf8f456fe323caccc01b",
    "63a0f03c5ae773f96c92c02fba9d13133d02485b",
    "364a47f2c746a5eeb1642102580a9daa8bc27fc9",
    "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
    "6c6df695350f917fe707b4f830e29c8c52c3f5d0",
    "95ec3457af961c4116015509180dcca04967604f",
    "c4822556c19a6ea2d7be93b505548e834c83d955",
    "45f3ced6daf96f1a697f350e134512562b48d3fd",
    "13c9fd4f9d177fb7d022c72d674f1a23b909c443",
    "403b15cae8d19f83c35c9490826d24b0bf5c2fa0",
    "1878b238503f3b52a6e7b31f849d7253206c7465",
    "dd55a99b00c447e53fe97bdbc423f3e6d7d59557",
    "b36b095c3ce32d2981f5780463bbea8d48105f5a",
    "53699cecac7477d64ac3dff6c3a24d5658bfc789",
    "98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217",
    "86c15fd21234381e2cc713d07e9652f01078613d",
    "ac49a906e8566f29767927a0dd8dc6b9328115ab",
    "e21fed8304935dc8a1efeee115a4e720b9d2667b",
    "6c6e6ab193f48ed93d5b76f394e6bef78205921a",
    "558d9469e018962a2b3159561bcc0996ecfc62fc",
    "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09",
    "f39550fff19a72faec27632409b50970d4d9d2da",
    "4603c8a4dd267aab345ec915b932f736d404daa7",
    "cc03033e59af53aeb49dbba8dd58bdf1fe3a8578",
    "a94515206db0eee8867d399bee6a87aa9e8cb074",
    "90f70231c682e22693f85977497d2dc429ef29da",
    "dd35cf7b1461fc883148b148e5c81731d9c08a35",
    "78e5d9fd89aa571f8ad5cf5b8a5046b9b74cb09b"
  ],
  "changeHistoryShort": {
    "9e063ffa2577f06d98a9e912bb16d20424df8d6d": "Ybodychange",
    "410a785dfe40ae030bec31c4c06a5a7998f1feeb": "Ybodychange",
    "b70bc0080e8e206f83debf8f456fe323caccc01b": "Ybodychange",
    "63a0f03c5ae773f96c92c02fba9d13133d02485b": "Ymultichange(Yparameterchange,Ybodychange)",
    "364a47f2c746a5eeb1642102580a9daa8bc27fc9": "Ybodychange",
    "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2": "Ymultichange(Yfilerename,Ybodychange)",
    "6c6df695350f917fe707b4f830e29c8c52c3f5d0": "Ybodychange",
    "95ec3457af961c4116015509180dcca04967604f": "Ybodychange",
    "c4822556c19a6ea2d7be93b505548e834c83d955": "Ybodychange",
    "45f3ced6daf96f1a697f350e134512562b48d3fd": "Ybodychange",
    "13c9fd4f9d177fb7d022c72d674f1a23b909c443": "Ybodychange",
    "403b15cae8d19f83c35c9490826d24b0bf5c2fa0": "Ybodychange",
    "1878b238503f3b52a6e7b31f849d7253206c7465": "Ybodychange",
    "dd55a99b00c447e53fe97bdbc423f3e6d7d59557": "Ybodychange",
    "b36b095c3ce32d2981f5780463bbea8d48105f5a": "Ybodychange",
    "53699cecac7477d64ac3dff6c3a24d5658bfc789": "Ybodychange",
    "98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217": "Ybodychange",
    "86c15fd21234381e2cc713d07e9652f01078613d": "Ybodychange",
    "ac49a906e8566f29767927a0dd8dc6b9328115ab": "Ybodychange",
    "e21fed8304935dc8a1efeee115a4e720b9d2667b": "Yfilerename",
    "6c6e6ab193f48ed93d5b76f394e6bef78205921a": "Ybodychange",
    "558d9469e018962a2b3159561bcc0996ecfc62fc": "Ybodychange",
    "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09": "Ybodychange",
    "f39550fff19a72faec27632409b50970d4d9d2da": "Ybodychange",
    "4603c8a4dd267aab345ec915b932f736d404daa7": "Ybodychange",
    "cc03033e59af53aeb49dbba8dd58bdf1fe3a8578": "Ybodychange",
    "a94515206db0eee8867d399bee6a87aa9e8cb074": "Ymultichange(Yparameterchange,Ybodychange)",
    "90f70231c682e22693f85977497d2dc429ef29da": "Ybodychange",
    "dd35cf7b1461fc883148b148e5c81731d9c08a35": "Yfilerename",
    "78e5d9fd89aa571f8ad5cf5b8a5046b9b74cb09b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9e063ffa2577f06d98a9e912bb16d20424df8d6d": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9837 - Remove reliance during annotation binding on org.hibernate.internal.util.ClassLoaderHelper\nHHH-9841 - Redesign org.hibernate.property.PropertyAccessorFactory\n",
      "commitDate": "2015-06-04, 3:12 p.m.",
      "commitName": "9e063ffa2577f06d98a9e912bb16d20424df8d6d",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015-05-19, 12:25 a.m.",
      "commitNameOld": "bd256e4783219f4a765219cf625bb658fcb5fde1",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 16.62,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n\t\tboolean revisionEntityFound \u003d false;\n\t\tRevisionInfoGenerator revisionInfoGenerator \u003d null;\n\t\tClass\u003c?\u003e revisionInfoClass \u003d null;\n\n\t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n\t\t\t// Ensure we\u0027re in POJO, not dynamic model, mapping.\n\t\t\tif (persistentClass.getClassName() !\u003d null) {\n\t\t\t\tXClass clazz;\n\t\t\t\ttry {\n\t\t\t\t\tclazz \u003d reflectionManager.classForName( persistentClass.getClassName() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassLoadingException e) {\n\t\t\t\t\tthrow new MappingException( e );\n\t\t\t\t}\n\n\t\t\t\tfinal RevisionEntity revisionEntity \u003d clazz.getAnnotation( RevisionEntity.class );\n\t\t\t\tif ( revisionEntity !\u003d null ) {\n\t\t\t\t\tif (revisionEntityFound) {\n\t\t\t\t\t\tthrow new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Checking if custom revision entity isn\u0027t audited\n\t\t\t\t\tif (clazz.getAnnotation(Audited.class) !\u003d null) {\n\t\t\t\t\t\tthrow new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n\t\t\t\t\t}\n\n\t\t\t\t\trevisionEntityFound \u003d true;\n\n\t\t\t\t\tfinal MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n\t\t\t\t\tfinal MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\t\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n\t\t\t\t\tsearchForRevisionInfoCfg(\n\t\t\t\t\t\t\tclazz,\n\t\t\t\t\t\t\treflectionManager,\n\t\t\t\t\t\t\trevisionNumberFound,\n\t\t\t\t\t\t\trevisionTimestampFound,\n\t\t\t\t\t\t\tmodifiedEntityNamesFound\n\t\t\t\t\t);\n\n\t\t\t\t\tif (!revisionNumberFound.isSet()) {\n\t\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n\t\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!revisionTimestampFound.isSet()) {\n\t\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n\t\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\trevisionInfoEntityName \u003d persistentClass.getEntityName();\n\t\t\t\t\trevisionInfoClass \u003d persistentClass.getMappedClass();\n\t\t\t\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n\t\t\t\t\trevisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n\t\t\t\t\tif (globalCfg.isTrackEntitiesChangedInRevision()\n\t\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n\t\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n\t\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet()) {\n\t\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n\t\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n\t\t\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n\t\t\t\t\t\t\t\trevisionInfoEntityName,\n\t\t\t\t\t\t\t\trevisionInfoClass,\n\t\t\t\t\t\t\t\trevisionListenerClass,\n\t\t\t\t\t\t\t\trevisionInfoTimestampData,\n\t\t\t\t\t\t\t\tisTimestampAsDate(),\n\t\t\t\t\t\t\t\tmodifiedEntityNamesData,\n\t\t\t\t\t\t\t\tmetadata.getMetadataBuildingOptions().getServiceRegistry()\n\t\t\t\t\t\t);\n\t\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision(true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n\t\t\t\t\t\t\t\trevisionInfoEntityName,\n\t\t\t\t\t\t\t\trevisionInfoClass,\n\t\t\t\t\t\t\t\trevisionListenerClass,\n\t\t\t\t\t\t\t\trevisionInfoTimestampData,\n\t\t\t\t\t\t\t\tisTimestampAsDate(),\n\t\t\t\t\t\t\t\tmetadata.getMetadataBuildingOptions().getServiceRegistry()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// In case of a custom revision info generator, the mapping will be null.\n\t\tDocument revisionInfoXmlMapping \u003d null;\n\n\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( RevisionListener.class );\n\n\t\tif ( revisionInfoGenerator \u003d\u003d null ) {\n\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId()\n\t\t\t\t\t\t? DefaultTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t: SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n\t\t\t\trevisionInfoEntityName \u003d revisionInfoClass.getName();\n\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n\t\t\t\t\t\trevisionInfoEntityName,\n\t\t\t\t\t\trevisionInfoClass,\n\t\t\t\t\t\trevisionListenerClass,\n\t\t\t\t\t\trevisionInfoTimestampData,\n\t\t\t\t\t\tisTimestampAsDate(),\n\t\t\t\t\t\tmodifiedEntityNamesData,\n\t\t\t\t\t\tmetadata.getMetadataBuildingOptions().getServiceRegistry()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId()\n\t\t\t\t\t\t? DefaultRevisionEntity.class\n\t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n\t\t\t\t\t\trevisionInfoEntityName,\n\t\t\t\t\t\trevisionInfoClass,\n\t\t\t\t\t\trevisionListenerClass,\n\t\t\t\t\t\trevisionInfoTimestampData,\n\t\t\t\t\t\tisTimestampAsDate(),\n\t\t\t\t\t\tmetadata.getMetadataBuildingOptions().getServiceRegistry()\n\t\t\t\t);\n\t\t\t}\n\t\t\trevisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n\t\t}\n\n\t\treturn new RevisionInfoConfigurationResult(\n\t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n\t\t\t\tnew RevisionInfoQueryCreator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n\t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n\t\t\t\t),\n\t\t\t\tgenerateRevisionInfoRelationMapping(),\n\t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData, metadata.getMetadataBuildingOptions().getServiceRegistry() ),\n\t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision()\n\t\t\t\t\t\t? new ModifiedEntityNamesReader( revisionInfoClass, modifiedEntityNamesData, metadata.getMetadataBuildingOptions().getServiceRegistry() )\n\t\t\t\t\t\t: null,\n\t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n\t\t);\n\t}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
      "functionStartLine": 296,
      "functionName": "configure",
      "diff": "@@ -1,128 +1,143 @@\n \tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n \t\tboolean revisionEntityFound \u003d false;\n \t\tRevisionInfoGenerator revisionInfoGenerator \u003d null;\n \t\tClass\u003c?\u003e revisionInfoClass \u003d null;\n \n \t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n \t\t\t// Ensure we\u0027re in POJO, not dynamic model, mapping.\n \t\t\tif (persistentClass.getClassName() !\u003d null) {\n \t\t\t\tXClass clazz;\n \t\t\t\ttry {\n \t\t\t\t\tclazz \u003d reflectionManager.classForName( persistentClass.getClassName() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassLoadingException e) {\n \t\t\t\t\tthrow new MappingException( e );\n \t\t\t\t}\n \n \t\t\t\tfinal RevisionEntity revisionEntity \u003d clazz.getAnnotation( RevisionEntity.class );\n \t\t\t\tif ( revisionEntity !\u003d null ) {\n \t\t\t\t\tif (revisionEntityFound) {\n \t\t\t\t\t\tthrow new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n \t\t\t\t\t}\n \n \t\t\t\t\t// Checking if custom revision entity isn\u0027t audited\n \t\t\t\t\tif (clazz.getAnnotation(Audited.class) !\u003d null) {\n \t\t\t\t\t\tthrow new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n \t\t\t\t\t}\n \n \t\t\t\t\trevisionEntityFound \u003d true;\n \n \t\t\t\t\tfinal MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n \t\t\t\t\tfinal MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \t\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n \t\t\t\t\tsearchForRevisionInfoCfg(\n \t\t\t\t\t\t\tclazz,\n \t\t\t\t\t\t\treflectionManager,\n \t\t\t\t\t\t\trevisionNumberFound,\n \t\t\t\t\t\t\trevisionTimestampFound,\n \t\t\t\t\t\t\tmodifiedEntityNamesFound\n \t\t\t\t\t);\n \n \t\t\t\t\tif (!revisionNumberFound.isSet()) {\n \t\t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!revisionTimestampFound.isSet()) {\n \t\t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \n \t\t\t\t\trevisionInfoEntityName \u003d persistentClass.getEntityName();\n \t\t\t\t\trevisionInfoClass \u003d persistentClass.getMappedClass();\n \t\t\t\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n \t\t\t\t\trevisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n \t\t\t\t\tif (globalCfg.isTrackEntitiesChangedInRevision()\n \t\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n \t\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n \t\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet()) {\n \t\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n \t\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n \t\t\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\t\t\trevisionInfoEntityName,\n-\t\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n-\t\t\t\t\t\t\t\tmodifiedEntityNamesData\n+\t\t\t\t\t\t\t\trevisionInfoClass,\n+\t\t\t\t\t\t\t\trevisionListenerClass,\n+\t\t\t\t\t\t\t\trevisionInfoTimestampData,\n+\t\t\t\t\t\t\t\tisTimestampAsDate(),\n+\t\t\t\t\t\t\t\tmodifiedEntityNamesData,\n+\t\t\t\t\t\t\t\tmetadata.getMetadataBuildingOptions().getServiceRegistry()\n \t\t\t\t\t\t);\n \t\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision(true);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n-\t\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n-\t\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n+\t\t\t\t\t\t\t\trevisionInfoEntityName,\n+\t\t\t\t\t\t\t\trevisionInfoClass,\n+\t\t\t\t\t\t\t\trevisionListenerClass,\n+\t\t\t\t\t\t\t\trevisionInfoTimestampData,\n+\t\t\t\t\t\t\t\tisTimestampAsDate(),\n+\t\t\t\t\t\t\t\tmetadata.getMetadataBuildingOptions().getServiceRegistry()\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// In case of a custom revision info generator, the mapping will be null.\n \t\tDocument revisionInfoXmlMapping \u003d null;\n \n \t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( RevisionListener.class );\n \n \t\tif ( revisionInfoGenerator \u003d\u003d null ) {\n \t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n-\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ?\n-\t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n-\t\t\t\t\t\t:\n-\t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n+\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId()\n+\t\t\t\t\t\t? DefaultTrackingModifiedEntitiesRevisionEntity.class\n+\t\t\t\t\t\t: SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n \t\t\t\trevisionInfoEntityName \u003d revisionInfoClass.getName();\n \t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n-\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n-\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n+\t\t\t\t\t\trevisionInfoEntityName,\n+\t\t\t\t\t\trevisionInfoClass,\n+\t\t\t\t\t\trevisionListenerClass,\n+\t\t\t\t\t\trevisionInfoTimestampData,\n+\t\t\t\t\t\tisTimestampAsDate(),\n+\t\t\t\t\t\tmodifiedEntityNamesData,\n+\t\t\t\t\t\tmetadata.getMetadataBuildingOptions().getServiceRegistry()\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n-\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n+\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId()\n+\t\t\t\t\t\t? DefaultRevisionEntity.class\n \t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n \t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n-\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n-\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n+\t\t\t\t\t\trevisionInfoEntityName,\n+\t\t\t\t\t\trevisionInfoClass,\n+\t\t\t\t\t\trevisionListenerClass,\n+\t\t\t\t\t\trevisionInfoTimestampData,\n+\t\t\t\t\t\tisTimestampAsDate(),\n+\t\t\t\t\t\tmetadata.getMetadataBuildingOptions().getServiceRegistry()\n \t\t\t\t);\n \t\t\t}\n \t\t\trevisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n \t\t}\n \n \t\treturn new RevisionInfoConfigurationResult(\n \t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n \t\t\t\tnew RevisionInfoQueryCreator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n \t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n \t\t\t\t),\n \t\t\t\tgenerateRevisionInfoRelationMapping(),\n-\t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n-\t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n-\t\t\t\t\t\trevisionInfoClass,\n-\t\t\t\t\t\tmodifiedEntityNamesData\n-\t\t\t\t)\n+\t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData, metadata.getMetadataBuildingOptions().getServiceRegistry() ),\n+\t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision()\n+\t\t\t\t\t\t? new ModifiedEntityNamesReader( revisionInfoClass, modifiedEntityNamesData, metadata.getMetadataBuildingOptions().getServiceRegistry() )\n \t\t\t\t\t\t: null,\n \t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "410a785dfe40ae030bec31c4c06a5a7998f1feeb": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9680 updated OSGi quickstarts, added necessary contracts to Envers blueprint, corrected a few uses of ReflectionManager\n",
      "commitDate": "2015-03-30, 3:36 p.m.",
      "commitName": "410a785dfe40ae030bec31c4c06a5a7998f1feeb",
      "commitAuthor": "Brett Meyer",
      "commitDateOld": "2015-03-22, 1:30 a.m.",
      "commitNameOld": "b70bc0080e8e206f83debf8f456fe323caccc01b",
      "commitAuthorOld": "Brett Meyer",
      "daysBetweenCommits": 8.59,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n\t\tboolean revisionEntityFound \u003d false;\n\t\tRevisionInfoGenerator revisionInfoGenerator \u003d null;\n\t\tClass\u003c?\u003e revisionInfoClass \u003d null;\n\n\t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n\t\t\t// Ensure we\u0027re in POJO, not dynamic model, mapping.\n\t\t\tif (persistentClass.getClassName() !\u003d null) {\n\t\t\t\tXClass clazz;\n\t\t\t\ttry {\n\t\t\t\t\tclazz \u003d reflectionManager.classForName( persistentClass.getClassName() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassLoadingException e) {\n\t\t\t\t\tthrow new MappingException( e );\n\t\t\t\t}\n\n\t\t\t\tfinal RevisionEntity revisionEntity \u003d clazz.getAnnotation( RevisionEntity.class );\n\t\t\t\tif ( revisionEntity !\u003d null ) {\n\t\t\t\t\tif (revisionEntityFound) {\n\t\t\t\t\t\tthrow new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Checking if custom revision entity isn\u0027t audited\n\t\t\t\t\tif (clazz.getAnnotation(Audited.class) !\u003d null) {\n\t\t\t\t\t\tthrow new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n\t\t\t\t\t}\n\n\t\t\t\t\trevisionEntityFound \u003d true;\n\n\t\t\t\t\tfinal MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n\t\t\t\t\tfinal MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\t\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n\t\t\t\t\tsearchForRevisionInfoCfg(\n\t\t\t\t\t\t\tclazz,\n\t\t\t\t\t\t\treflectionManager,\n\t\t\t\t\t\t\trevisionNumberFound,\n\t\t\t\t\t\t\trevisionTimestampFound,\n\t\t\t\t\t\t\tmodifiedEntityNamesFound\n\t\t\t\t\t);\n\n\t\t\t\t\tif (!revisionNumberFound.isSet()) {\n\t\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n\t\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!revisionTimestampFound.isSet()) {\n\t\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n\t\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\trevisionInfoEntityName \u003d persistentClass.getEntityName();\n\t\t\t\t\trevisionInfoClass \u003d persistentClass.getMappedClass();\n\t\t\t\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n\t\t\t\t\trevisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n\t\t\t\t\tif (globalCfg.isTrackEntitiesChangedInRevision()\n\t\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n\t\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n\t\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet()) {\n\t\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n\t\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n\t\t\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n\t\t\t\t\t\t\t\trevisionInfoEntityName,\n\t\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n\t\t\t\t\t\t\t\tmodifiedEntityNamesData\n\t\t\t\t\t\t);\n\t\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision(true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n\t\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// In case of a custom revision info generator, the mapping will be null.\n\t\tDocument revisionInfoXmlMapping \u003d null;\n\n\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( RevisionListener.class );\n\n\t\tif ( revisionInfoGenerator \u003d\u003d null ) {\n\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ?\n\t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t:\n\t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n\t\t\t\trevisionInfoEntityName \u003d revisionInfoClass.getName();\n\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n\t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n\t\t\t\t);\n\t\t\t}\n\t\t\trevisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n\t\t}\n\n\t\treturn new RevisionInfoConfigurationResult(\n\t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n\t\t\t\tnew RevisionInfoQueryCreator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n\t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n\t\t\t\t),\n\t\t\t\tgenerateRevisionInfoRelationMapping(),\n\t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n\t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n\t\t\t\t\t\trevisionInfoClass,\n\t\t\t\t\t\tmodifiedEntityNamesData\n\t\t\t\t)\n\t\t\t\t\t\t: null,\n\t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n\t\t);\n\t}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
      "functionStartLine": 313,
      "functionName": "configure",
      "diff": "@@ -1,127 +1,127 @@\n \tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n \t\tboolean revisionEntityFound \u003d false;\n \t\tRevisionInfoGenerator revisionInfoGenerator \u003d null;\n \t\tClass\u003c?\u003e revisionInfoClass \u003d null;\n \n \t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n \t\t\t// Ensure we\u0027re in POJO, not dynamic model, mapping.\n \t\t\tif (persistentClass.getClassName() !\u003d null) {\n \t\t\t\tXClass clazz;\n \t\t\t\ttry {\n-\t\t\t\t\tclazz \u003d reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );\n+\t\t\t\t\tclazz \u003d reflectionManager.classForName( persistentClass.getClassName() );\n \t\t\t\t}\n-\t\t\t\tcatch (ClassNotFoundException e) {\n+\t\t\t\tcatch (ClassLoadingException e) {\n \t\t\t\t\tthrow new MappingException( e );\n \t\t\t\t}\n \n \t\t\t\tfinal RevisionEntity revisionEntity \u003d clazz.getAnnotation( RevisionEntity.class );\n \t\t\t\tif ( revisionEntity !\u003d null ) {\n \t\t\t\t\tif (revisionEntityFound) {\n \t\t\t\t\t\tthrow new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n \t\t\t\t\t}\n \n \t\t\t\t\t// Checking if custom revision entity isn\u0027t audited\n \t\t\t\t\tif (clazz.getAnnotation(Audited.class) !\u003d null) {\n \t\t\t\t\t\tthrow new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n \t\t\t\t\t}\n \n \t\t\t\t\trevisionEntityFound \u003d true;\n \n \t\t\t\t\tfinal MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n \t\t\t\t\tfinal MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \t\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n \t\t\t\t\tsearchForRevisionInfoCfg(\n \t\t\t\t\t\t\tclazz,\n \t\t\t\t\t\t\treflectionManager,\n \t\t\t\t\t\t\trevisionNumberFound,\n \t\t\t\t\t\t\trevisionTimestampFound,\n \t\t\t\t\t\t\tmodifiedEntityNamesFound\n \t\t\t\t\t);\n \n \t\t\t\t\tif (!revisionNumberFound.isSet()) {\n \t\t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!revisionTimestampFound.isSet()) {\n \t\t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \n \t\t\t\t\trevisionInfoEntityName \u003d persistentClass.getEntityName();\n \t\t\t\t\trevisionInfoClass \u003d persistentClass.getMappedClass();\n \t\t\t\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n \t\t\t\t\trevisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n \t\t\t\t\tif (globalCfg.isTrackEntitiesChangedInRevision()\n \t\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n \t\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n \t\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet()) {\n \t\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n \t\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n \t\t\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\t\t\trevisionInfoEntityName,\n \t\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n \t\t\t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t\t\t);\n \t\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision(true);\n \t\t\t\t\t} else {\n \t\t\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// In case of a custom revision info generator, the mapping will be null.\n \t\tDocument revisionInfoXmlMapping \u003d null;\n \n \t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( RevisionListener.class );\n \n \t\tif ( revisionInfoGenerator \u003d\u003d null ) {\n \t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n \t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ?\n \t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t:\n \t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n \t\t\t\trevisionInfoEntityName \u003d revisionInfoClass.getName();\n \t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n \t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n \t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t);\n \t\t\t}\n \t\t\trevisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n \t\t}\n \n \t\treturn new RevisionInfoConfigurationResult(\n \t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n \t\t\t\tnew RevisionInfoQueryCreator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n \t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n \t\t\t\t),\n \t\t\t\tgenerateRevisionInfoRelationMapping(),\n \t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n \t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n \t\t\t\t\t\trevisionInfoClass,\n \t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t)\n \t\t\t\t\t\t: null,\n \t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b70bc0080e8e206f83debf8f456fe323caccc01b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8769 gracefully handle the lack of dynamic mode support in Envers\n",
      "commitDate": "2015-03-22, 1:30 a.m.",
      "commitName": "b70bc0080e8e206f83debf8f456fe323caccc01b",
      "commitAuthor": "Brett Meyer",
      "commitDateOld": "2015-03-18, 9:22 p.m.",
      "commitNameOld": "63a0f03c5ae773f96c92c02fba9d13133d02485b",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 3.17,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n\t\tboolean revisionEntityFound \u003d false;\n\t\tRevisionInfoGenerator revisionInfoGenerator \u003d null;\n\t\tClass\u003c?\u003e revisionInfoClass \u003d null;\n\n\t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n\t\t\t// Ensure we\u0027re in POJO, not dynamic model, mapping.\n\t\t\tif (persistentClass.getClassName() !\u003d null) {\n\t\t\t\tXClass clazz;\n\t\t\t\ttry {\n\t\t\t\t\tclazz \u003d reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException e) {\n\t\t\t\t\tthrow new MappingException( e );\n\t\t\t\t}\n\n\t\t\t\tfinal RevisionEntity revisionEntity \u003d clazz.getAnnotation( RevisionEntity.class );\n\t\t\t\tif ( revisionEntity !\u003d null ) {\n\t\t\t\t\tif (revisionEntityFound) {\n\t\t\t\t\t\tthrow new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Checking if custom revision entity isn\u0027t audited\n\t\t\t\t\tif (clazz.getAnnotation(Audited.class) !\u003d null) {\n\t\t\t\t\t\tthrow new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n\t\t\t\t\t}\n\n\t\t\t\t\trevisionEntityFound \u003d true;\n\n\t\t\t\t\tfinal MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n\t\t\t\t\tfinal MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\t\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n\t\t\t\t\tsearchForRevisionInfoCfg(\n\t\t\t\t\t\t\tclazz,\n\t\t\t\t\t\t\treflectionManager,\n\t\t\t\t\t\t\trevisionNumberFound,\n\t\t\t\t\t\t\trevisionTimestampFound,\n\t\t\t\t\t\t\tmodifiedEntityNamesFound\n\t\t\t\t\t);\n\n\t\t\t\t\tif (!revisionNumberFound.isSet()) {\n\t\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n\t\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!revisionTimestampFound.isSet()) {\n\t\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n\t\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\trevisionInfoEntityName \u003d persistentClass.getEntityName();\n\t\t\t\t\trevisionInfoClass \u003d persistentClass.getMappedClass();\n\t\t\t\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n\t\t\t\t\trevisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n\t\t\t\t\tif (globalCfg.isTrackEntitiesChangedInRevision()\n\t\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n\t\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n\t\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet()) {\n\t\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n\t\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n\t\t\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n\t\t\t\t\t\t\t\trevisionInfoEntityName,\n\t\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n\t\t\t\t\t\t\t\tmodifiedEntityNamesData\n\t\t\t\t\t\t);\n\t\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision(true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n\t\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// In case of a custom revision info generator, the mapping will be null.\n\t\tDocument revisionInfoXmlMapping \u003d null;\n\n\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( RevisionListener.class );\n\n\t\tif ( revisionInfoGenerator \u003d\u003d null ) {\n\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ?\n\t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t:\n\t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n\t\t\t\trevisionInfoEntityName \u003d revisionInfoClass.getName();\n\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n\t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n\t\t\t\t);\n\t\t\t}\n\t\t\trevisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n\t\t}\n\n\t\treturn new RevisionInfoConfigurationResult(\n\t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n\t\t\t\tnew RevisionInfoQueryCreator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n\t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n\t\t\t\t),\n\t\t\t\tgenerateRevisionInfoRelationMapping(),\n\t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n\t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n\t\t\t\t\t\trevisionInfoClass,\n\t\t\t\t\t\tmodifiedEntityNamesData\n\t\t\t\t)\n\t\t\t\t\t\t: null,\n\t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n\t\t);\n\t}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
      "functionStartLine": 312,
      "functionName": "configure",
      "diff": "@@ -1,125 +1,127 @@\n \tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n \t\tboolean revisionEntityFound \u003d false;\n \t\tRevisionInfoGenerator revisionInfoGenerator \u003d null;\n \t\tClass\u003c?\u003e revisionInfoClass \u003d null;\n \n \t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n-\t\t\tXClass clazz;\n-\t\t\ttry {\n-\t\t\t\tclazz \u003d reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );\n-\t\t\t}\n-\t\t\tcatch (ClassNotFoundException e) {\n-\t\t\t\tthrow new MappingException( e );\n-\t\t\t}\n-\n-\t\t\tfinal RevisionEntity revisionEntity \u003d clazz.getAnnotation( RevisionEntity.class );\n-\t\t\tif ( revisionEntity !\u003d null ) {\n-\t\t\t\tif ( revisionEntityFound ) {\n-\t\t\t\t\tthrow new MappingException( \"Only one entity may be annotated with @RevisionEntity!\" );\n+\t\t\t// Ensure we\u0027re in POJO, not dynamic model, mapping.\n+\t\t\tif (persistentClass.getClassName() !\u003d null) {\n+\t\t\t\tXClass clazz;\n+\t\t\t\ttry {\n+\t\t\t\t\tclazz \u003d reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );\n+\t\t\t\t}\n+\t\t\t\tcatch (ClassNotFoundException e) {\n+\t\t\t\t\tthrow new MappingException( e );\n \t\t\t\t}\n \n-\t\t\t\t// Checking if custom revision entity isn\u0027t audited\n-\t\t\t\tif ( clazz.getAnnotation( Audited.class ) !\u003d null ) {\n-\t\t\t\t\tthrow new MappingException( \"An entity annotated with @RevisionEntity cannot be audited!\" );\n-\t\t\t\t}\n+\t\t\t\tfinal RevisionEntity revisionEntity \u003d clazz.getAnnotation( RevisionEntity.class );\n+\t\t\t\tif ( revisionEntity !\u003d null ) {\n+\t\t\t\t\tif (revisionEntityFound) {\n+\t\t\t\t\t\tthrow new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n+\t\t\t\t\t}\n \n-\t\t\t\trevisionEntityFound \u003d true;\n+\t\t\t\t\t// Checking if custom revision entity isn\u0027t audited\n+\t\t\t\t\tif (clazz.getAnnotation(Audited.class) !\u003d null) {\n+\t\t\t\t\t\tthrow new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n+\t\t\t\t\t}\n \n-\t\t\t\tfinal MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n-\t\t\t\tfinal MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n-\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n+\t\t\t\t\trevisionEntityFound \u003d true;\n \n-\t\t\t\tsearchForRevisionInfoCfg(\n-\t\t\t\t\t\tclazz,\n-\t\t\t\t\t\treflectionManager,\n-\t\t\t\t\t\trevisionNumberFound,\n-\t\t\t\t\t\trevisionTimestampFound,\n-\t\t\t\t\t\tmodifiedEntityNamesFound\n-\t\t\t\t);\n+\t\t\t\t\tfinal MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n+\t\t\t\t\tfinal MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n+\t\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n-\t\t\t\tif ( !revisionNumberFound.isSet() ) {\n-\t\t\t\t\tthrow new MappingException(\n-\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n-\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n+\t\t\t\t\tsearchForRevisionInfoCfg(\n+\t\t\t\t\t\t\tclazz,\n+\t\t\t\t\t\t\treflectionManager,\n+\t\t\t\t\t\t\trevisionNumberFound,\n+\t\t\t\t\t\t\trevisionTimestampFound,\n+\t\t\t\t\t\t\tmodifiedEntityNamesFound\n \t\t\t\t\t);\n-\t\t\t\t}\n \n-\t\t\t\tif ( !revisionTimestampFound.isSet() ) {\n-\t\t\t\t\tthrow new MappingException(\n-\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n-\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n-\t\t\t\t\t);\n-\t\t\t\t}\n+\t\t\t\t\tif (!revisionNumberFound.isSet()) {\n+\t\t\t\t\t\tthrow new MappingException(\n+\t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n+\t\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n \n-\t\t\t\trevisionInfoEntityName \u003d persistentClass.getEntityName();\n-\t\t\t\trevisionInfoClass \u003d persistentClass.getMappedClass();\n-\t\t\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( revisionEntity.value() );\n-\t\t\t\trevisionInfoTimestampType \u003d persistentClass.getProperty( revisionInfoTimestampData.getName() ).getType();\n-\t\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision()\n-\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class\n-\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n-\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n-\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n-\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet() ) {\n-\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n-\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n-\t\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n-\t\t\t\t\t\t\trevisionInfoEntityName,\n-\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n-\t\t\t\t\t\t\tmodifiedEntityNamesData\n-\t\t\t\t\t);\n-\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision( true );\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n-\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n-\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n-\t\t\t\t\t);\n+\t\t\t\t\tif (!revisionTimestampFound.isSet()) {\n+\t\t\t\t\t\tthrow new MappingException(\n+\t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n+\t\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\trevisionInfoEntityName \u003d persistentClass.getEntityName();\n+\t\t\t\t\trevisionInfoClass \u003d persistentClass.getMappedClass();\n+\t\t\t\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n+\t\t\t\t\trevisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n+\t\t\t\t\tif (globalCfg.isTrackEntitiesChangedInRevision()\n+\t\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class\n+\t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n+\t\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n+\t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n+\t\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet()) {\n+\t\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n+\t\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n+\t\t\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n+\t\t\t\t\t\t\t\trevisionInfoEntityName,\n+\t\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n+\t\t\t\t\t\t\t\tmodifiedEntityNamesData\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision(true);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n+\t\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n+\t\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// In case of a custom revision info generator, the mapping will be null.\n \t\tDocument revisionInfoXmlMapping \u003d null;\n \n \t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( RevisionListener.class );\n \n \t\tif ( revisionInfoGenerator \u003d\u003d null ) {\n \t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n \t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ?\n \t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t:\n \t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n \t\t\t\trevisionInfoEntityName \u003d revisionInfoClass.getName();\n \t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n \t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n \t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t);\n \t\t\t}\n \t\t\trevisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n \t\t}\n \n \t\treturn new RevisionInfoConfigurationResult(\n \t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n \t\t\t\tnew RevisionInfoQueryCreator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n \t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n \t\t\t\t),\n \t\t\t\tgenerateRevisionInfoRelationMapping(),\n \t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n \t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n \t\t\t\t\t\trevisionInfoClass,\n \t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t)\n \t\t\t\t\t\t: null,\n \t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "63a0f03c5ae773f96c92c02fba9d13133d02485b": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HHH-9654 - Adjust envers for 5.0 APIs + JAXB\n",
      "commitDate": "2015-03-18, 9:22 p.m.",
      "commitName": "63a0f03c5ae773f96c92c02fba9d13133d02485b",
      "commitAuthor": "Steve Ebersole",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HHH-9654 - Adjust envers for 5.0 APIs + JAXB\n",
          "commitDate": "2015-03-18, 9:22 p.m.",
          "commitName": "63a0f03c5ae773f96c92c02fba9d13133d02485b",
          "commitAuthor": "Steve Ebersole",
          "commitDateOld": "2013-11-24, 10:44 a.m.",
          "commitNameOld": "cd590470c0059981537e558a5ff6d114fd24df61",
          "commitAuthorOld": "Steve Ebersole",
          "daysBetweenCommits": 479.4,
          "commitsBetweenForRepo": 421,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n\t\tboolean revisionEntityFound \u003d false;\n\t\tRevisionInfoGenerator revisionInfoGenerator \u003d null;\n\t\tClass\u003c?\u003e revisionInfoClass \u003d null;\n\n\t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n\t\t\tXClass clazz;\n\t\t\ttry {\n\t\t\t\tclazz \u003d reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException e) {\n\t\t\t\tthrow new MappingException( e );\n\t\t\t}\n\n\t\t\tfinal RevisionEntity revisionEntity \u003d clazz.getAnnotation( RevisionEntity.class );\n\t\t\tif ( revisionEntity !\u003d null ) {\n\t\t\t\tif ( revisionEntityFound ) {\n\t\t\t\t\tthrow new MappingException( \"Only one entity may be annotated with @RevisionEntity!\" );\n\t\t\t\t}\n\n\t\t\t\t// Checking if custom revision entity isn\u0027t audited\n\t\t\t\tif ( clazz.getAnnotation( Audited.class ) !\u003d null ) {\n\t\t\t\t\tthrow new MappingException( \"An entity annotated with @RevisionEntity cannot be audited!\" );\n\t\t\t\t}\n\n\t\t\t\trevisionEntityFound \u003d true;\n\n\t\t\t\tfinal MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n\t\t\t\tfinal MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n\t\t\t\tsearchForRevisionInfoCfg(\n\t\t\t\t\t\tclazz,\n\t\t\t\t\t\treflectionManager,\n\t\t\t\t\t\trevisionNumberFound,\n\t\t\t\t\t\trevisionTimestampFound,\n\t\t\t\t\t\tmodifiedEntityNamesFound\n\t\t\t\t);\n\n\t\t\t\tif ( !revisionNumberFound.isSet() ) {\n\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( !revisionTimestampFound.isSet() ) {\n\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\trevisionInfoEntityName \u003d persistentClass.getEntityName();\n\t\t\t\trevisionInfoClass \u003d persistentClass.getMappedClass();\n\t\t\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( revisionEntity.value() );\n\t\t\t\trevisionInfoTimestampType \u003d persistentClass.getProperty( revisionInfoTimestampData.getName() ).getType();\n\t\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision()\n\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet() ) {\n\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n\t\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n\t\t\t\t\t\t\trevisionInfoEntityName,\n\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n\t\t\t\t\t\t\tmodifiedEntityNamesData\n\t\t\t\t\t);\n\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision( true );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// In case of a custom revision info generator, the mapping will be null.\n\t\tDocument revisionInfoXmlMapping \u003d null;\n\n\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( RevisionListener.class );\n\n\t\tif ( revisionInfoGenerator \u003d\u003d null ) {\n\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ?\n\t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t:\n\t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n\t\t\t\trevisionInfoEntityName \u003d revisionInfoClass.getName();\n\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n\t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n\t\t\t\t);\n\t\t\t}\n\t\t\trevisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n\t\t}\n\n\t\treturn new RevisionInfoConfigurationResult(\n\t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n\t\t\t\tnew RevisionInfoQueryCreator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n\t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n\t\t\t\t),\n\t\t\t\tgenerateRevisionInfoRelationMapping(),\n\t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n\t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n\t\t\t\t\t\trevisionInfoClass,\n\t\t\t\t\t\tmodifiedEntityNamesData\n\t\t\t\t)\n\t\t\t\t\t\t: null,\n\t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n\t\t);\n\t}",
          "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
          "functionStartLine": 313,
          "functionName": "configure",
          "diff": "@@ -1,127 +1,125 @@\n-\tpublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n+\tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n \t\tboolean revisionEntityFound \u003d false;\n \t\tRevisionInfoGenerator revisionInfoGenerator \u003d null;\n \t\tClass\u003c?\u003e revisionInfoClass \u003d null;\n \n-\t\tfinal Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n-\t\twhile ( classes.hasNext() ) {\n-\t\t\tPersistentClass pc \u003d classes.next();\n+\t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n \t\t\tXClass clazz;\n \t\t\ttry {\n-\t\t\t\tclazz \u003d reflectionManager.classForName( pc.getClassName(), this.getClass() );\n+\t\t\t\tclazz \u003d reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );\n \t\t\t}\n \t\t\tcatch (ClassNotFoundException e) {\n \t\t\t\tthrow new MappingException( e );\n \t\t\t}\n \n \t\t\tfinal RevisionEntity revisionEntity \u003d clazz.getAnnotation( RevisionEntity.class );\n \t\t\tif ( revisionEntity !\u003d null ) {\n \t\t\t\tif ( revisionEntityFound ) {\n \t\t\t\t\tthrow new MappingException( \"Only one entity may be annotated with @RevisionEntity!\" );\n \t\t\t\t}\n \n \t\t\t\t// Checking if custom revision entity isn\u0027t audited\n \t\t\t\tif ( clazz.getAnnotation( Audited.class ) !\u003d null ) {\n \t\t\t\t\tthrow new MappingException( \"An entity annotated with @RevisionEntity cannot be audited!\" );\n \t\t\t\t}\n \n \t\t\t\trevisionEntityFound \u003d true;\n \n \t\t\t\tfinal MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n \t\t\t\tfinal MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \t\t\t\tfinal MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n \t\t\t\tsearchForRevisionInfoCfg(\n \t\t\t\t\t\tclazz,\n \t\t\t\t\t\treflectionManager,\n \t\t\t\t\t\trevisionNumberFound,\n \t\t\t\t\t\trevisionTimestampFound,\n \t\t\t\t\t\tmodifiedEntityNamesFound\n \t\t\t\t);\n \n \t\t\t\tif ( !revisionNumberFound.isSet() ) {\n \t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n \t\t\t\t\t);\n \t\t\t\t}\n \n \t\t\t\tif ( !revisionTimestampFound.isSet() ) {\n \t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n \t\t\t\t\t);\n \t\t\t\t}\n \n-\t\t\t\trevisionInfoEntityName \u003d pc.getEntityName();\n-\t\t\t\trevisionInfoClass \u003d pc.getMappedClass();\n+\t\t\t\trevisionInfoEntityName \u003d persistentClass.getEntityName();\n+\t\t\t\trevisionInfoClass \u003d persistentClass.getMappedClass();\n \t\t\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( revisionEntity.value() );\n-\t\t\t\trevisionInfoTimestampType \u003d pc.getProperty( revisionInfoTimestampData.getName() ).getType();\n+\t\t\t\trevisionInfoTimestampType \u003d persistentClass.getProperty( revisionInfoTimestampData.getName() ).getType();\n \t\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision()\n \t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n \t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n \t\t\t\t\t\t|| modifiedEntityNamesFound.isSet() ) {\n \t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n \t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n \t\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\t\trevisionInfoEntityName,\n \t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n \t\t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t\t);\n \t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision( true );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// In case of a custom revision info generator, the mapping will be null.\n \t\tDocument revisionInfoXmlMapping \u003d null;\n \n \t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( RevisionListener.class );\n \n \t\tif ( revisionInfoGenerator \u003d\u003d null ) {\n \t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n \t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ?\n \t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t:\n \t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n \t\t\t\trevisionInfoEntityName \u003d revisionInfoClass.getName();\n \t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n \t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n \t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t);\n \t\t\t}\n \t\t\trevisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n \t\t}\n \n \t\treturn new RevisionInfoConfigurationResult(\n \t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n \t\t\t\tnew RevisionInfoQueryCreator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n \t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n \t\t\t\t),\n \t\t\t\tgenerateRevisionInfoRelationMapping(),\n \t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n \t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n \t\t\t\t\t\trevisionInfoClass,\n \t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t)\n \t\t\t\t\t\t: null,\n \t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n \t\t);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[cfg-Configuration, reflectionManager-ReflectionManager]",
            "newValue": "[metadata-MetadataImplementor, reflectionManager-ReflectionManager]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HHH-9654 - Adjust envers for 5.0 APIs + JAXB\n",
          "commitDate": "2015-03-18, 9:22 p.m.",
          "commitName": "63a0f03c5ae773f96c92c02fba9d13133d02485b",
          "commitAuthor": "Steve Ebersole",
          "commitDateOld": "2013-11-24, 10:44 a.m.",
          "commitNameOld": "cd590470c0059981537e558a5ff6d114fd24df61",
          "commitAuthorOld": "Steve Ebersole",
          "daysBetweenCommits": 479.4,
          "commitsBetweenForRepo": 421,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n\t\tboolean revisionEntityFound \u003d false;\n\t\tRevisionInfoGenerator revisionInfoGenerator \u003d null;\n\t\tClass\u003c?\u003e revisionInfoClass \u003d null;\n\n\t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n\t\t\tXClass clazz;\n\t\t\ttry {\n\t\t\t\tclazz \u003d reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException e) {\n\t\t\t\tthrow new MappingException( e );\n\t\t\t}\n\n\t\t\tfinal RevisionEntity revisionEntity \u003d clazz.getAnnotation( RevisionEntity.class );\n\t\t\tif ( revisionEntity !\u003d null ) {\n\t\t\t\tif ( revisionEntityFound ) {\n\t\t\t\t\tthrow new MappingException( \"Only one entity may be annotated with @RevisionEntity!\" );\n\t\t\t\t}\n\n\t\t\t\t// Checking if custom revision entity isn\u0027t audited\n\t\t\t\tif ( clazz.getAnnotation( Audited.class ) !\u003d null ) {\n\t\t\t\t\tthrow new MappingException( \"An entity annotated with @RevisionEntity cannot be audited!\" );\n\t\t\t\t}\n\n\t\t\t\trevisionEntityFound \u003d true;\n\n\t\t\t\tfinal MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n\t\t\t\tfinal MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n\t\t\t\tsearchForRevisionInfoCfg(\n\t\t\t\t\t\tclazz,\n\t\t\t\t\t\treflectionManager,\n\t\t\t\t\t\trevisionNumberFound,\n\t\t\t\t\t\trevisionTimestampFound,\n\t\t\t\t\t\tmodifiedEntityNamesFound\n\t\t\t\t);\n\n\t\t\t\tif ( !revisionNumberFound.isSet() ) {\n\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( !revisionTimestampFound.isSet() ) {\n\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\trevisionInfoEntityName \u003d persistentClass.getEntityName();\n\t\t\t\trevisionInfoClass \u003d persistentClass.getMappedClass();\n\t\t\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( revisionEntity.value() );\n\t\t\t\trevisionInfoTimestampType \u003d persistentClass.getProperty( revisionInfoTimestampData.getName() ).getType();\n\t\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision()\n\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet() ) {\n\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n\t\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n\t\t\t\t\t\t\trevisionInfoEntityName,\n\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n\t\t\t\t\t\t\tmodifiedEntityNamesData\n\t\t\t\t\t);\n\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision( true );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// In case of a custom revision info generator, the mapping will be null.\n\t\tDocument revisionInfoXmlMapping \u003d null;\n\n\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( RevisionListener.class );\n\n\t\tif ( revisionInfoGenerator \u003d\u003d null ) {\n\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ?\n\t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t:\n\t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n\t\t\t\trevisionInfoEntityName \u003d revisionInfoClass.getName();\n\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n\t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n\t\t\t\t);\n\t\t\t}\n\t\t\trevisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n\t\t}\n\n\t\treturn new RevisionInfoConfigurationResult(\n\t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n\t\t\t\tnew RevisionInfoQueryCreator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n\t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n\t\t\t\t),\n\t\t\t\tgenerateRevisionInfoRelationMapping(),\n\t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n\t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n\t\t\t\t\t\trevisionInfoClass,\n\t\t\t\t\t\tmodifiedEntityNamesData\n\t\t\t\t)\n\t\t\t\t\t\t: null,\n\t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n\t\t);\n\t}",
          "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
          "functionStartLine": 313,
          "functionName": "configure",
          "diff": "@@ -1,127 +1,125 @@\n-\tpublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n+\tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n \t\tboolean revisionEntityFound \u003d false;\n \t\tRevisionInfoGenerator revisionInfoGenerator \u003d null;\n \t\tClass\u003c?\u003e revisionInfoClass \u003d null;\n \n-\t\tfinal Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n-\t\twhile ( classes.hasNext() ) {\n-\t\t\tPersistentClass pc \u003d classes.next();\n+\t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n \t\t\tXClass clazz;\n \t\t\ttry {\n-\t\t\t\tclazz \u003d reflectionManager.classForName( pc.getClassName(), this.getClass() );\n+\t\t\t\tclazz \u003d reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );\n \t\t\t}\n \t\t\tcatch (ClassNotFoundException e) {\n \t\t\t\tthrow new MappingException( e );\n \t\t\t}\n \n \t\t\tfinal RevisionEntity revisionEntity \u003d clazz.getAnnotation( RevisionEntity.class );\n \t\t\tif ( revisionEntity !\u003d null ) {\n \t\t\t\tif ( revisionEntityFound ) {\n \t\t\t\t\tthrow new MappingException( \"Only one entity may be annotated with @RevisionEntity!\" );\n \t\t\t\t}\n \n \t\t\t\t// Checking if custom revision entity isn\u0027t audited\n \t\t\t\tif ( clazz.getAnnotation( Audited.class ) !\u003d null ) {\n \t\t\t\t\tthrow new MappingException( \"An entity annotated with @RevisionEntity cannot be audited!\" );\n \t\t\t\t}\n \n \t\t\t\trevisionEntityFound \u003d true;\n \n \t\t\t\tfinal MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n \t\t\t\tfinal MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \t\t\t\tfinal MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n \t\t\t\tsearchForRevisionInfoCfg(\n \t\t\t\t\t\tclazz,\n \t\t\t\t\t\treflectionManager,\n \t\t\t\t\t\trevisionNumberFound,\n \t\t\t\t\t\trevisionTimestampFound,\n \t\t\t\t\t\tmodifiedEntityNamesFound\n \t\t\t\t);\n \n \t\t\t\tif ( !revisionNumberFound.isSet() ) {\n \t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n \t\t\t\t\t);\n \t\t\t\t}\n \n \t\t\t\tif ( !revisionTimestampFound.isSet() ) {\n \t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n \t\t\t\t\t);\n \t\t\t\t}\n \n-\t\t\t\trevisionInfoEntityName \u003d pc.getEntityName();\n-\t\t\t\trevisionInfoClass \u003d pc.getMappedClass();\n+\t\t\t\trevisionInfoEntityName \u003d persistentClass.getEntityName();\n+\t\t\t\trevisionInfoClass \u003d persistentClass.getMappedClass();\n \t\t\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( revisionEntity.value() );\n-\t\t\t\trevisionInfoTimestampType \u003d pc.getProperty( revisionInfoTimestampData.getName() ).getType();\n+\t\t\t\trevisionInfoTimestampType \u003d persistentClass.getProperty( revisionInfoTimestampData.getName() ).getType();\n \t\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision()\n \t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n \t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n \t\t\t\t\t\t|| modifiedEntityNamesFound.isSet() ) {\n \t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n \t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n \t\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\t\trevisionInfoEntityName,\n \t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n \t\t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t\t);\n \t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision( true );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// In case of a custom revision info generator, the mapping will be null.\n \t\tDocument revisionInfoXmlMapping \u003d null;\n \n \t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( RevisionListener.class );\n \n \t\tif ( revisionInfoGenerator \u003d\u003d null ) {\n \t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n \t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ?\n \t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t:\n \t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n \t\t\t\trevisionInfoEntityName \u003d revisionInfoClass.getName();\n \t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n \t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n \t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t);\n \t\t\t}\n \t\t\trevisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n \t\t}\n \n \t\treturn new RevisionInfoConfigurationResult(\n \t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n \t\t\t\tnew RevisionInfoQueryCreator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n \t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n \t\t\t\t),\n \t\t\t\tgenerateRevisionInfoRelationMapping(),\n \t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n \t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n \t\t\t\t\t\trevisionInfoClass,\n \t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t)\n \t\t\t\t\t\t: null,\n \t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n \t\t);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "364a47f2c746a5eeb1642102580a9daa8bc27fc9": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8159 - Apply fixups indicated by analysis tools\n",
      "commitDate": "2013-05-02, 11:01 a.m.",
      "commitName": "364a47f2c746a5eeb1642102580a9daa8bc27fc9",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2013-04-08, 8:43 a.m.",
      "commitNameOld": "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 24.1,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n\t\tboolean revisionEntityFound \u003d false;\n\t\tRevisionInfoGenerator revisionInfoGenerator \u003d null;\n\t\tClass\u003c?\u003e revisionInfoClass \u003d null;\n\n\t\tfinal Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n\t\twhile ( classes.hasNext() ) {\n\t\t\tPersistentClass pc \u003d classes.next();\n\t\t\tXClass clazz;\n\t\t\ttry {\n\t\t\t\tclazz \u003d reflectionManager.classForName( pc.getClassName(), this.getClass() );\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException e) {\n\t\t\t\tthrow new MappingException( e );\n\t\t\t}\n\n\t\t\tfinal RevisionEntity revisionEntity \u003d clazz.getAnnotation( RevisionEntity.class );\n\t\t\tif ( revisionEntity !\u003d null ) {\n\t\t\t\tif ( revisionEntityFound ) {\n\t\t\t\t\tthrow new MappingException( \"Only one entity may be annotated with @RevisionEntity!\" );\n\t\t\t\t}\n\n\t\t\t\t// Checking if custom revision entity isn\u0027t audited\n\t\t\t\tif ( clazz.getAnnotation( Audited.class ) !\u003d null ) {\n\t\t\t\t\tthrow new MappingException( \"An entity annotated with @RevisionEntity cannot be audited!\" );\n\t\t\t\t}\n\n\t\t\t\trevisionEntityFound \u003d true;\n\n\t\t\t\tfinal MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n\t\t\t\tfinal MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n\t\t\t\tsearchForRevisionInfoCfg(\n\t\t\t\t\t\tclazz,\n\t\t\t\t\t\treflectionManager,\n\t\t\t\t\t\trevisionNumberFound,\n\t\t\t\t\t\trevisionTimestampFound,\n\t\t\t\t\t\tmodifiedEntityNamesFound\n\t\t\t\t);\n\n\t\t\t\tif ( !revisionNumberFound.isSet() ) {\n\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( !revisionTimestampFound.isSet() ) {\n\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\trevisionInfoEntityName \u003d pc.getEntityName();\n\t\t\t\trevisionInfoClass \u003d pc.getMappedClass();\n\t\t\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( revisionEntity.value() );\n\t\t\t\trevisionInfoTimestampType \u003d pc.getProperty( revisionInfoTimestampData.getName() ).getType();\n\t\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision()\n\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet() ) {\n\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n\t\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n\t\t\t\t\t\t\trevisionInfoEntityName,\n\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n\t\t\t\t\t\t\tmodifiedEntityNamesData\n\t\t\t\t\t);\n\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision( true );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// In case of a custom revision info generator, the mapping will be null.\n\t\tDocument revisionInfoXmlMapping \u003d null;\n\n\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( RevisionListener.class );\n\n\t\tif ( revisionInfoGenerator \u003d\u003d null ) {\n\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ?\n\t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n\t\t\t\t\t\t:\n\t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n\t\t\t\trevisionInfoEntityName \u003d revisionInfoClass.getName();\n\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n\t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n\t\t\t\t);\n\t\t\t}\n\t\t\trevisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n\t\t}\n\n\t\treturn new RevisionInfoConfigurationResult(\n\t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n\t\t\t\tnew RevisionInfoQueryCreator(\n\t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n\t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n\t\t\t\t),\n\t\t\t\tgenerateRevisionInfoRelationMapping(),\n\t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n\t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n\t\t\t\t\t\trevisionInfoClass,\n\t\t\t\t\t\tmodifiedEntityNamesData\n\t\t\t\t)\n\t\t\t\t\t\t: null,\n\t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n\t\t);\n\t}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
      "functionStartLine": 314,
      "functionName": "configure",
      "diff": "@@ -1,97 +1,127 @@\n-    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n-        Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n-        boolean revisionEntityFound \u003d false;\n-        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n+\tpublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n+\t\tboolean revisionEntityFound \u003d false;\n+\t\tRevisionInfoGenerator revisionInfoGenerator \u003d null;\n+\t\tClass\u003c?\u003e revisionInfoClass \u003d null;\n \n-        Class\u003c?\u003e revisionInfoClass \u003d null;\n+\t\tfinal Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n+\t\twhile ( classes.hasNext() ) {\n+\t\t\tPersistentClass pc \u003d classes.next();\n+\t\t\tXClass clazz;\n+\t\t\ttry {\n+\t\t\t\tclazz \u003d reflectionManager.classForName( pc.getClassName(), this.getClass() );\n+\t\t\t}\n+\t\t\tcatch (ClassNotFoundException e) {\n+\t\t\t\tthrow new MappingException( e );\n+\t\t\t}\n \n-        while (classes.hasNext()) {\n-            PersistentClass pc \u003d classes.next();\n-            XClass clazz;\n-            try {\n-                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n-            } catch (ClassNotFoundException e) {\n-                throw new MappingException(e);\n-            }\n+\t\t\tfinal RevisionEntity revisionEntity \u003d clazz.getAnnotation( RevisionEntity.class );\n+\t\t\tif ( revisionEntity !\u003d null ) {\n+\t\t\t\tif ( revisionEntityFound ) {\n+\t\t\t\t\tthrow new MappingException( \"Only one entity may be annotated with @RevisionEntity!\" );\n+\t\t\t\t}\n \n-            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n-            if (revisionEntity !\u003d null) {\n-                if (revisionEntityFound) {\n-                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n-                }\n+\t\t\t\t// Checking if custom revision entity isn\u0027t audited\n+\t\t\t\tif ( clazz.getAnnotation( Audited.class ) !\u003d null ) {\n+\t\t\t\t\tthrow new MappingException( \"An entity annotated with @RevisionEntity cannot be audited!\" );\n+\t\t\t\t}\n \n-                // Checking if custom revision entity isn\u0027t audited\n-                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n-                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n-                }\n+\t\t\t\trevisionEntityFound \u003d true;\n \n-                revisionEntityFound \u003d true;\n+\t\t\t\tfinal MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n+\t\t\t\tfinal MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n+\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n-                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n-                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n-                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n+\t\t\t\tsearchForRevisionInfoCfg(\n+\t\t\t\t\t\tclazz,\n+\t\t\t\t\t\treflectionManager,\n+\t\t\t\t\t\trevisionNumberFound,\n+\t\t\t\t\t\trevisionTimestampFound,\n+\t\t\t\t\t\tmodifiedEntityNamesFound\n+\t\t\t\t);\n \n-                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n+\t\t\t\tif ( !revisionNumberFound.isSet() ) {\n+\t\t\t\t\tthrow new MappingException(\n+\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n+\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n+\t\t\t\t\t);\n+\t\t\t\t}\n \n-                if (!revisionNumberFound.isSet()) {\n-                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n-                            \"with @RevisionNumber!\");\n-                }\n+\t\t\t\tif ( !revisionTimestampFound.isSet() ) {\n+\t\t\t\t\tthrow new MappingException(\n+\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n+\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n+\t\t\t\t\t);\n+\t\t\t\t}\n \n-                if (!revisionTimestampFound.isSet()) {\n-                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n-                            \"with @RevisionTimestamp!\");\n-                }\n+\t\t\t\trevisionInfoEntityName \u003d pc.getEntityName();\n+\t\t\t\trevisionInfoClass \u003d pc.getMappedClass();\n+\t\t\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( revisionEntity.value() );\n+\t\t\t\trevisionInfoTimestampType \u003d pc.getProperty( revisionInfoTimestampData.getName() ).getType();\n+\t\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision()\n+\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class\n+\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n+\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n+\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n+\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet() ) {\n+\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n+\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n+\t\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n+\t\t\t\t\t\t\trevisionInfoEntityName,\n+\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n+\t\t\t\t\t\t\tmodifiedEntityNamesData\n+\t\t\t\t\t);\n+\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision( true );\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n+\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n+\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-                revisionInfoEntityName \u003d pc.getEntityName();\n-                revisionInfoClass \u003d pc.getMappedClass();\n-                Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n-                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-                if (globalCfg.isTrackEntitiesChangedInRevision()\n-                        || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n-                        || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n-                        || modifiedEntityNamesFound.isSet()) {\n-                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n-                    // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n-                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n-                            revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n-                            modifiedEntityNamesData);\n-                    globalCfg.setTrackEntitiesChangedInRevision(true);\n-                } else {\n-                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                            revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n-                }\n-            }\n-        }\n+\t\t// In case of a custom revision info generator, the mapping will be null.\n+\t\tDocument revisionInfoXmlMapping \u003d null;\n \n-        // In case of a custom revision info generator, the mapping will be null.\n-        Document revisionInfoXmlMapping \u003d null;\n+\t\tfinal Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass( RevisionListener.class );\n \n-        Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n+\t\tif ( revisionInfoGenerator \u003d\u003d null ) {\n+\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n+\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ?\n+\t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n+\t\t\t\t\t\t:\n+\t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n+\t\t\t\trevisionInfoEntityName \u003d revisionInfoClass.getName();\n+\t\t\t\trevisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n+\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n+\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\trevisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n+\t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n+\t\t\t\trevisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(\n+\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n+\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\trevisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n+\t\t}\n \n-        if (revisionInfoGenerator \u003d\u003d null) {\n-            if (globalCfg.isTrackEntitiesChangedInRevision()) {\n-                revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n-                                                                                : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n-                revisionInfoEntityName \u003d revisionInfoClass.getName();\n-                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n-            } else {\n-                revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n-                                                                                : SequenceIdRevisionEntity.class;\n-                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n-            }\n-            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n-        }\n-\n-        return new RevisionInfoConfigurationResult(\n-                revisionInfoGenerator, revisionInfoXmlMapping,\n-                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n-                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n-                generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n-                globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n-                                                             : null,\n-                revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n-    }\n\\ No newline at end of file\n+\t\treturn new RevisionInfoConfigurationResult(\n+\t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n+\t\t\t\tnew RevisionInfoQueryCreator(\n+\t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n+\t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n+\t\t\t\t),\n+\t\t\t\tgenerateRevisionInfoRelationMapping(),\n+\t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n+\t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n+\t\t\t\t\t\trevisionInfoClass,\n+\t\t\t\t\t\tmodifiedEntityNamesData\n+\t\t\t\t)\n+\t\t\t\t\t\t: null,\n+\t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n+\t\t);\n+\t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "HHH-7944 - Separation of Envers API, SPI and internal packages\n",
      "commitDate": "2013-04-08, 8:43 a.m.",
      "commitName": "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
      "commitAuthor": "Lukasz Antoniak",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "HHH-7944 - Separation of Envers API, SPI and internal packages\n",
          "commitDate": "2013-04-08, 8:43 a.m.",
          "commitName": "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
          "commitAuthor": "Lukasz Antoniak",
          "commitDateOld": "2013-04-05, 4:15 p.m.",
          "commitNameOld": "2b2f333593c1989624d332d47b1358afd1999a91",
          "commitAuthorOld": "Steve Ebersole",
          "daysBetweenCommits": 2.69,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n                revisionInfoClass \u003d pc.getMappedClass();\n                Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevision()\n                        || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                        || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                        || modifiedEntityNamesFound.isSet()) {\n                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                    // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                            revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                            modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevision(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            if (globalCfg.isTrackEntitiesChangedInRevision()) {\n                revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n                                                                                : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n                revisionInfoEntityName \u003d revisionInfoClass.getName();\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n            } else {\n                revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n                                                                                : SequenceIdRevisionEntity.class;\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                             : null,\n                revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n    }",
          "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
          "functionStartLine": 251,
          "functionName": "configure",
          "diff": "@@ -1,97 +1,97 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n                 revisionInfoClass \u003d pc.getMappedClass();\n                 Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()\n+                if (globalCfg.isTrackEntitiesChangedInRevision()\n                         || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n-                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n+                    globalCfg.setTrackEntitiesChangedInRevision(true);\n                 } else {\n                     revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n-            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n+            if (globalCfg.isTrackEntitiesChangedInRevision()) {\n                 revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n                                                                                 : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n                 revisionInfoEntityName \u003d revisionInfoClass.getName();\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n                                                                                 : SequenceIdRevisionEntity.class;\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n-                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n-                                                                    : null,\n+                globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n+                                                             : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
            "newPath": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HHH-7944 - Separation of Envers API, SPI and internal packages\n",
          "commitDate": "2013-04-08, 8:43 a.m.",
          "commitName": "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
          "commitAuthor": "Lukasz Antoniak",
          "commitDateOld": "2013-04-05, 4:15 p.m.",
          "commitNameOld": "2b2f333593c1989624d332d47b1358afd1999a91",
          "commitAuthorOld": "Steve Ebersole",
          "daysBetweenCommits": 2.69,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n                revisionInfoClass \u003d pc.getMappedClass();\n                Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevision()\n                        || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                        || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                        || modifiedEntityNamesFound.isSet()) {\n                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                    // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                            revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                            modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevision(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            if (globalCfg.isTrackEntitiesChangedInRevision()) {\n                revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n                                                                                : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n                revisionInfoEntityName \u003d revisionInfoClass.getName();\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n            } else {\n                revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n                                                                                : SequenceIdRevisionEntity.class;\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                             : null,\n                revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n    }",
          "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
          "functionStartLine": 251,
          "functionName": "configure",
          "diff": "@@ -1,97 +1,97 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n                 revisionInfoClass \u003d pc.getMappedClass();\n                 Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()\n+                if (globalCfg.isTrackEntitiesChangedInRevision()\n                         || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n-                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n+                    globalCfg.setTrackEntitiesChangedInRevision(true);\n                 } else {\n                     revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n-            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n+            if (globalCfg.isTrackEntitiesChangedInRevision()) {\n                 revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n                                                                                 : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n                 revisionInfoEntityName \u003d revisionInfoClass.getName();\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n                                                                                 : SequenceIdRevisionEntity.class;\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n-                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n-                                                                    : null,\n+                globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n+                                                             : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6c6df695350f917fe707b4f830e29c8c52c3f5d0": {
      "type": "Ybodychange",
      "commitMessage": "refactor, remove redundant type cast\n",
      "commitDate": "2012-12-25, 6:25 a.m.",
      "commitName": "6c6df695350f917fe707b4f830e29c8c52c3f5d0",
      "commitAuthor": "Strong Liu",
      "commitDateOld": "2012-11-19, 1:03 p.m.",
      "commitNameOld": "c01dd40a6566b62e3ae85f6c0024c147cf2d78ff",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 35.72,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n                revisionInfoClass \u003d pc.getMappedClass();\n                Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()\n                        || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                        || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                        || modifiedEntityNamesFound.isSet()) {\n                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                    // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                            revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                            modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n                                                                                : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n                revisionInfoEntityName \u003d revisionInfoClass.getName();\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n            } else {\n                revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n                                                                                : SequenceIdRevisionEntity.class;\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                    : null,\n                revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 251,
      "functionName": "configure",
      "diff": "@@ -1,97 +1,97 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n-        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n+        Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n                 revisionInfoClass \u003d pc.getMappedClass();\n                 Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()\n                         || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n                                                                                 : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n                 revisionInfoEntityName \u003d revisionInfoClass.getName();\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n                                                                                 : SequenceIdRevisionEntity.class;\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                 globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                     : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "95ec3457af961c4116015509180dcca04967604f": {
      "type": "Ybodychange",
      "commitMessage": "HHH-7187 - Renaming and documenting enhanced revision entity\n",
      "commitDate": "2012-04-19, 5:49 p.m.",
      "commitName": "95ec3457af961c4116015509180dcca04967604f",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2012-04-19, 8:15 a.m.",
      "commitNameOld": "c4822556c19a6ea2d7be93b505548e834c83d955",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 0.4,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n                revisionInfoClass \u003d pc.getMappedClass();\n                Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()\n                        || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                        || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                        || modifiedEntityNamesFound.isSet()) {\n                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                    // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                            revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                            modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n                                                                                : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n                revisionInfoEntityName \u003d revisionInfoClass.getName();\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n            } else {\n                revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n                                                                                : SequenceIdRevisionEntity.class;\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                    : null,\n                revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 251,
      "functionName": "configure",
      "diff": "@@ -1,97 +1,97 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n                 revisionInfoClass \u003d pc.getMappedClass();\n                 Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()\n-                        || (!globalCfg.isUseEnhancedRevisionEntity() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n-                        || (globalCfg.isUseEnhancedRevisionEntity() \u0026\u0026 org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n+                        || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n+                        || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n-                revisionInfoClass \u003d globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class\n-                                                                            : DefaultTrackingModifiedEntitiesRevisionEntity.class;\n+                revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n+                                                                                : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n                 revisionInfoEntityName \u003d revisionInfoClass.getName();\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n-                revisionInfoClass \u003d globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultRevisionEntity.class\n-                                                                            : DefaultRevisionEntity.class;\n+                revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n+                                                                                : SequenceIdRevisionEntity.class;\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                 globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                     : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c4822556c19a6ea2d7be93b505548e834c83d955": {
      "type": "Ybodychange",
      "commitMessage": "HHH-7187 - Enhanced default revision entity\n",
      "commitDate": "2012-04-19, 8:15 a.m.",
      "commitName": "c4822556c19a6ea2d7be93b505548e834c83d955",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2012-01-28, 5:27 p.m.",
      "commitNameOld": "46b7a0d38e59e91d3c6b6b1e6a0200dd3118a1a6",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 81.58,
      "commitsBetweenForRepo": 214,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n                revisionInfoClass \u003d pc.getMappedClass();\n                Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()\n                        || (!globalCfg.isUseEnhancedRevisionEntity() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                        || (globalCfg.isUseEnhancedRevisionEntity() \u0026\u0026 org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                        || modifiedEntityNamesFound.isSet()) {\n                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                    // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                            revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                            modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                revisionInfoClass \u003d globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class\n                                                                            : DefaultTrackingModifiedEntitiesRevisionEntity.class;\n                revisionInfoEntityName \u003d revisionInfoClass.getName();\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n            } else {\n                revisionInfoClass \u003d globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultRevisionEntity.class\n                                                                            : DefaultRevisionEntity.class;\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                    : null,\n                revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 249,
      "functionName": "configure",
      "diff": "@@ -1,94 +1,97 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n                 revisionInfoClass \u003d pc.getMappedClass();\n                 Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n-                        DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n-                        modifiedEntityNamesFound.isSet()) {\n+                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()\n+                        || (!globalCfg.isUseEnhancedRevisionEntity() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n+                        || (globalCfg.isUseEnhancedRevisionEntity() \u0026\u0026 org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n+                        || modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n-                revisionInfoClass \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class;\n-                revisionInfoEntityName \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n+                revisionInfoClass \u003d globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class\n+                                                                            : DefaultTrackingModifiedEntitiesRevisionEntity.class;\n+                revisionInfoEntityName \u003d revisionInfoClass.getName();\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n-                revisionInfoClass \u003d DefaultRevisionEntity.class;\n+                revisionInfoClass \u003d globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultRevisionEntity.class\n+                                                                            : DefaultRevisionEntity.class;\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                 globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                     : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45f3ced6daf96f1a697f350e134512562b48d3fd": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6696 - RevisionListener class configuration parameter\n",
      "commitDate": "2011-09-29, 2:50 p.m.",
      "commitName": "45f3ced6daf96f1a697f350e134512562b48d3fd",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011-06-12, 7:55 a.m.",
      "commitNameOld": "13c9fd4f9d177fb7d022c72d674f1a23b909c443",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 109.29,
      "commitsBetweenForRepo": 345,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n                revisionInfoClass \u003d pc.getMappedClass();\n                Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                        DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                        modifiedEntityNamesFound.isSet()) {\n                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                    // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                            revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                            modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                revisionInfoClass \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class;\n                revisionInfoEntityName \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n            } else {\n                revisionInfoClass \u003d DefaultRevisionEntity.class;\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                    : null,\n                revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 243,
      "functionName": "configure",
      "diff": "@@ -1,92 +1,94 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n-\n                 revisionInfoClass \u003d pc.getMappedClass();\n+                Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                         DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                         modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n-                            revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n+                            revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n+                            revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n+        Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n+\n         if (revisionInfoGenerator \u003d\u003d null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class;\n                 revisionInfoEntityName \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass \u003d DefaultRevisionEntity.class;\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n+                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                 globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                     : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "13c9fd4f9d177fb7d022c72d674f1a23b909c443": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Persisting entity name by default\n",
      "commitDate": "2011-06-12, 7:55 a.m.",
      "commitName": "13c9fd4f9d177fb7d022c72d674f1a23b909c443",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011-05-28, 11:01 a.m.",
      "commitNameOld": "40225711963be4f38e961b2faef4a7ea545cba1a",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 14.87,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                        DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                        modifiedEntityNamesFound.isSet()) {\n                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                    // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                            revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n                            modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                revisionInfoClass \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class;\n                revisionInfoEntityName \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n            } else {\n                revisionInfoClass \u003d DefaultRevisionEntity.class;\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            }\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                    : null,\n                revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 243,
      "functionName": "configure",
      "diff": "@@ -1,92 +1,92 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n-                MutableBoolean modifiedEntityTypesFound \u003d new MutableBoolean();\n+                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n-                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n+                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n-                        DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n-                        modifiedEntityTypesFound.isSet()) {\n+                        DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n+                        modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n-                    // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityTypes annotation is used.\n-                    revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n+                    // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n+                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n-                            modifiedEntityTypesData);\n+                            modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n-                revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n-                revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n-                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n+                revisionInfoClass \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class;\n+                revisionInfoEntityName \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n+                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass \u003d DefaultRevisionEntity.class;\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n-                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityTypesReader(revisionInfoClass, modifiedEntityTypesData)\n+                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                     : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "403b15cae8d19f83c35c9490826d24b0bf5c2fa0": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Query refactoring\n",
      "commitDate": "2011-05-17, 5:14 p.m.",
      "commitName": "403b15cae8d19f83c35c9490826d24b0bf5c2fa0",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011-05-16, 1:18 p.m.",
      "commitNameOld": "1878b238503f3b52a6e7b31f849d7253206c7465",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 1.16,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                MutableBoolean modifiedEntityTypesFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                        DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                        modifiedEntityTypesFound.isSet()) {\n                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                    // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityTypes annotation is used.\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n                            revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n                            modifiedEntityTypesData);\n                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n                revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n            } else {\n                revisionInfoClass \u003d DefaultRevisionEntity.class;\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            }\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityTypesReader(revisionInfoClass, modifiedEntityTypesData)\n                                                                    : null,\n                revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 225,
      "functionName": "configure",
      "diff": "@@ -1,90 +1,92 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                 MutableBoolean modifiedEntityTypesFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                         DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                         modifiedEntityTypesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityTypes annotation is used.\n                     revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityTypesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n                 revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n             } else {\n                 revisionInfoClass \u003d DefaultRevisionEntity.class;\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n-                revisionInfoClass, revisionInfoTimestampData);\n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n+                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityTypesReader(revisionInfoClass, modifiedEntityTypesData)\n+                                                                    : null,\n+                revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1878b238503f3b52a6e7b31f849d7253206c7465": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Naming\n",
      "commitDate": "2011-05-16, 1:18 p.m.",
      "commitName": "1878b238503f3b52a6e7b31f849d7253206c7465",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011-05-14, 6:46 p.m.",
      "commitNameOld": "dd55a99b00c447e53fe97bdbc423f3e6d7d59557",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 1.77,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                MutableBoolean modifiedEntityTypesFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                        DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                        modifiedEntityTypesFound.isSet()) {\n                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                    // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityTypes annotation is used.\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n                            revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n                            modifiedEntityTypesData);\n                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n                revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n            } else {\n                revisionInfoClass \u003d DefaultRevisionEntity.class;\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            }\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 225,
      "functionName": "configure",
      "diff": "@@ -1,90 +1,90 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n-                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n+                MutableBoolean modifiedEntityTypesFound \u003d new MutableBoolean();\n \n-                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n+                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                         DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n-                        modifiedEntityNamesFound.isSet()) {\n+                        modifiedEntityTypesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n-                    // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n+                    // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityTypes annotation is used.\n                     revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n-                            modifiedEntityNamesData);\n+                            modifiedEntityTypesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n                 revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n             } else {\n                 revisionInfoClass \u003d DefaultRevisionEntity.class;\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dd55a99b00c447e53fe97bdbc423f3e6d7d59557": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Using Criteria API in RevisionInfoQueryCreator\n",
      "commitDate": "2011-05-14, 6:46 p.m.",
      "commitName": "dd55a99b00c447e53fe97bdbc423f3e6d7d59557",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011-05-14, 5:47 p.m.",
      "commitNameOld": "b36b095c3ce32d2981f5780463bbea8d48105f5a",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                        DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                        modifiedEntityNamesFound.isSet()) {\n                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                    // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n                            revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n                            modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n                revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n            } else {\n                revisionInfoClass \u003d DefaultRevisionEntity.class;\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            }\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 225,
      "functionName": "configure",
      "diff": "@@ -1,92 +1,90 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                         DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                         modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n                 revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass \u003d DefaultRevisionEntity.class;\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n-                        revisionInfoTimestampData.getName(), isTimestampAsDate(),\n-                        globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? modifiedEntityNamesData.getName()\n-                                                                            : null),\n+                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b36b095c3ce32d2981f5780463bbea8d48105f5a": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Refactoring\n",
      "commitDate": "2011-05-14, 5:47 p.m.",
      "commitName": "b36b095c3ce32d2981f5780463bbea8d48105f5a",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011-05-07, 1:06 p.m.",
      "commitNameOld": "53699cecac7477d64ac3dff6c3a24d5658bfc789",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 7.2,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                        DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                        modifiedEntityNamesFound.isSet()) {\n                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                    // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n                            revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n                            modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n                revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n            } else {\n                revisionInfoClass \u003d DefaultRevisionEntity.class;\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            }\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate(),\n                        globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? modifiedEntityNamesData.getName()\n                                                                            : null),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 225,
      "functionName": "configure",
      "diff": "@@ -1,90 +1,92 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                         DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                         modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n                 revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass \u003d DefaultRevisionEntity.class;\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n-                        revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()),\n+                        revisionInfoTimestampData.getName(), isTimestampAsDate(),\n+                        globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? modifiedEntityNamesData.getName()\n+                                                                            : null),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53699cecac7477d64ac3dff6c3a24d5658bfc789": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Modified EntityTrackingRevisionListener interface\n",
      "commitDate": "2011-05-07, 1:06 p.m.",
      "commitName": "53699cecac7477d64ac3dff6c3a24d5658bfc789",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011-04-27, 5:49 p.m.",
      "commitNameOld": "98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 9.8,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                        DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                        modifiedEntityNamesFound.isSet()) {\n                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                    // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n                            revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n                            modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n                revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n            } else {\n                revisionInfoClass \u003d DefaultRevisionEntity.class;\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            }\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 223,
      "functionName": "configure",
      "diff": "@@ -1,86 +1,90 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n-                    // If modified entities tracking parameter is enabled, custom revision info class is a subtype of DefaultTrackingModifiedTypesRevisionEntity, or @ModifiedEntityNames annotation is used.\n-                    revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n+                        DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n+                        modifiedEntityNamesFound.isSet()) {\n+                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n+                    // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n+                    revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n+                            revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n+                            modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n                 revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass \u003d DefaultRevisionEntity.class;\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Tracking entity names in revision\n",
      "commitDate": "2011-04-27, 5:49 p.m.",
      "commitName": "98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011-04-19, 1:19 p.m.",
      "commitNameOld": "86c15fd21234381e2cc713d07e9652f01078613d",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 8.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                    // If modified entities tracking parameter is enabled, custom revision info class is a subtype of DefaultTrackingModifiedTypesRevisionEntity, or @ModifiedEntityNames annotation is used.\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n                revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n            } else {\n                revisionInfoClass \u003d DefaultRevisionEntity.class;\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            }\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 223,
      "functionName": "configure",
      "diff": "@@ -1,71 +1,86 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n+                MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n \n-                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n+                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n+                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n+                    // If modified entities tracking parameter is enabled, custom revision info class is a subtype of DefaultTrackingModifiedTypesRevisionEntity, or @ModifiedEntityNames annotation is used.\n+                    revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n+                } else {\n+                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n+                }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n-            revisionInfoClass \u003d DefaultRevisionEntity.class;\n-            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                    RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n+            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n+                revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n+                revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n+                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+            } else {\n+                revisionInfoClass \u003d DefaultRevisionEntity.class;\n+                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n+            }\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n-                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n+                        revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "86c15fd21234381e2cc713d07e9652f01078613d": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5276 - Refactoring\n",
      "commitDate": "2011-04-19, 1:19 p.m.",
      "commitName": "86c15fd21234381e2cc713d07e9652f01078613d",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011-04-19, 1:19 p.m.",
      "commitNameOld": "ac49a906e8566f29767927a0dd8dc6b9328115ab",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 181,
      "functionName": "configure",
      "diff": "@@ -1,71 +1,71 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n-            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping(cfg);\n+            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ac49a906e8566f29767927a0dd8dc6b9328115ab": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5276 - REVINFO in different database schema creation\n",
      "commitDate": "2011-04-19, 1:19 p.m.",
      "commitName": "ac49a906e8566f29767927a0dd8dc6b9328115ab",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011-04-19, 11:27 a.m.",
      "commitNameOld": "d7cc102b008d1586b85f6f443dce90b531df3b71",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping(cfg);\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 179,
      "functionName": "configure",
      "diff": "@@ -1,71 +1,71 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n-            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n+            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping(cfg);\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, \n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e21fed8304935dc8a1efeee115a4e720b9d2667b": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5616 - Switch to Gradle for builds .. envers\n",
      "commitDate": "2010-10-11, 3:41 p.m.",
      "commitName": "e21fed8304935dc8a1efeee115a4e720b9d2667b",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010-10-11, 3:41 p.m.",
      "commitNameOld": "89298608b0ba18049272fc0f2784fb3d251da905",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, \n                revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 178,
      "functionName": "configure",
      "diff": "",
      "extendedDetails": {
        "oldPath": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
        "newPath": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java"
      }
    },
    "6c6e6ab193f48ed93d5b76f394e6bef78205921a": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5371 Support revend timestamp to enable audit table partioning by time\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20775 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-10-04, 2:11 p.m.",
      "commitName": "6c6e6ab193f48ed93d5b76f394e6bef78205921a",
      "commitAuthor": "Erik-Berndt Scheper",
      "commitDateOld": "2010-09-28, 7:50 p.m.",
      "commitNameOld": "558d9469e018962a2b3159561bcc0996ecfc62fc",
      "commitAuthorOld": "Erik-Berndt Scheper",
      "daysBetweenCommits": 5.76,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, \n                revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 178,
      "functionName": "configure",
      "diff": "@@ -1,70 +1,71 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, \n+                revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "558d9469e018962a2b3159561bcc0996ecfc62fc": {
      "type": "Ybodychange",
      "commitMessage": "HHH5371 - Rollback until after 3.6.0 release as per Adam\u0027s request via IM\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20745 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-09-28, 7:50 p.m.",
      "commitName": "558d9469e018962a2b3159561bcc0996ecfc62fc",
      "commitAuthor": "Erik-Berndt Scheper",
      "commitDateOld": "2010-09-28, 6:23 p.m.",
      "commitNameOld": "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09",
      "commitAuthorOld": "Erik-Berndt Scheper",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n    }",
      "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 180,
      "functionName": "configure",
      "diff": "@@ -1,71 +1,70 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, \n-                revisionInfoClass, revisionInfoTimestampData);\n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5371 - Add support for REVEND_TSTMP which will enable audit table partitioning\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20743 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-09-28, 6:23 p.m.",
      "commitName": "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09",
      "commitAuthor": "Erik-Berndt Scheper",
      "commitDateOld": "2009-12-07, 3:36 a.m.",
      "commitNameOld": "e9ff8cf3b6b7d10c13ad76de574047935373d38f",
      "commitAuthorOld": "Adam Warski",
      "daysBetweenCommits": 295.57,
      "commitsBetweenForRepo": 910,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, \n                revisionInfoClass, revisionInfoTimestampData);\n    }",
      "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 178,
      "functionName": "configure",
      "diff": "@@ -1,70 +1,71 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, \n+                revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f39550fff19a72faec27632409b50970d4d9d2da": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4540:\n- applying patch from Nicolas Roug\n- the revision timestamp can now be a j.u.Date or a j.s.Date, and be mapped to a Date in the DB\n- test\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18032 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-11-24, 10:21 a.m.",
      "commitName": "f39550fff19a72faec27632409b50970d4d9d2da",
      "commitAuthor": "Adam Warski",
      "commitDateOld": "2009-04-30, 1:47 a.m.",
      "commitNameOld": "1553578808ee052e41595da94952ea63f19af038",
      "commitAuthorOld": "Adam Warski",
      "daysBetweenCommits": 208.4,
      "commitsBetweenForRepo": 366,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n    }",
      "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 164,
      "functionName": "configure",
      "diff": "@@ -1,69 +1,70 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n+                revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        revisionEntity.value(), revisionInfoTimestampData);\n+                        revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                    RevisionListener.class, revisionInfoTimestampData);\n+                    RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n-                        revisionInfoTimestampData.getName()),\n+                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4603c8a4dd267aab345ec915b932f736d404daa7": {
      "type": "Ybodychange",
      "commitMessage": "HHH-3570: more renaming\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15517 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008-11-05, 4:13 a.m.",
      "commitName": "4603c8a4dd267aab345ec915b932f736d404daa7",
      "commitAuthor": "Adam Warski",
      "commitDateOld": "2008-11-05, 3:41 a.m.",
      "commitNameOld": "843d3c648f0d28ae921d701fd340656c27bb40f3",
      "commitAuthorOld": "Adam Warski",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t audited\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampData);\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampData);\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n    }",
      "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 158,
      "functionName": "configure",
      "diff": "@@ -1,69 +1,69 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n-                // Checking if custom revision entity isn\u0027t versioned\n+                // Checking if custom revision entity isn\u0027t audited\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampData);\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampData);\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc03033e59af53aeb49dbba8dd58bdf1fe3a8578": {
      "type": "Ybodychange",
      "commitMessage": "HHH-3565: adding support for field and property access types; changed the way properties are read. Now, instead of a sole property name, a special \"PropertyData\" object is passed around which encapsulates the  property name and access type information.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15481 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008-11-03, 6:24 a.m.",
      "commitName": "cc03033e59af53aeb49dbba8dd58bdf1fe3a8578",
      "commitAuthor": "Adam Warski",
      "commitDateOld": "2008-10-31, 8:23 a.m.",
      "commitNameOld": "a94515206db0eee8867d399bee6a87aa9e8cb074",
      "commitAuthorOld": "Adam Warski",
      "daysBetweenCommits": 2.96,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t versioned\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampData);\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampData);\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                        revisionInfoTimestampData.getName()),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n    }",
      "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 158,
      "functionName": "configure",
      "diff": "@@ -1,68 +1,69 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t versioned\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n-                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n+                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        revisionEntity.value(), revisionInfoTimestampName);\n+                        revisionEntity.value(), revisionInfoTimestampData);\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                    RevisionListener.class, revisionInfoTimestampName);\n+                    RevisionListener.class, revisionInfoTimestampData);\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n-                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n+                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n+                        revisionInfoTimestampData.getName()),\n                 generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a94515206db0eee8867d399bee6a87aa9e8cb074": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Removing unused Hiberntae 3.2.4.SP1 integration facilities (ReflectionManager)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15464 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008-10-31, 8:23 a.m.",
      "commitName": "a94515206db0eee8867d399bee6a87aa9e8cb074",
      "commitAuthor": "Adam Warski",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Removing unused Hiberntae 3.2.4.SP1 integration facilities (ReflectionManager)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15464 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2008-10-31, 8:23 a.m.",
          "commitName": "a94515206db0eee8867d399bee6a87aa9e8cb074",
          "commitAuthor": "Adam Warski",
          "commitDateOld": "2008-10-31, 7:42 a.m.",
          "commitNameOld": "90f70231c682e22693f85977497d2dc429ef29da",
          "commitAuthorOld": "Adam Warski",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t versioned\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampName);\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampName);\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n    }",
          "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
          "functionStartLine": 157,
          "functionName": "configure",
          "diff": "@@ -1,68 +1,68 @@\n-    public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n+    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n-            YClass clazz;\n+            XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t versioned\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampName);\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampName);\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[cfg-Configuration, reflectionManager-YReflectionManager]",
            "newValue": "[cfg-Configuration, reflectionManager-ReflectionManager]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Removing unused Hiberntae 3.2.4.SP1 integration facilities (ReflectionManager)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15464 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2008-10-31, 8:23 a.m.",
          "commitName": "a94515206db0eee8867d399bee6a87aa9e8cb074",
          "commitAuthor": "Adam Warski",
          "commitDateOld": "2008-10-31, 7:42 a.m.",
          "commitNameOld": "90f70231c682e22693f85977497d2dc429ef29da",
          "commitAuthorOld": "Adam Warski",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t versioned\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampName);\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampName);\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n    }",
          "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
          "functionStartLine": 157,
          "functionName": "configure",
          "diff": "@@ -1,68 +1,68 @@\n-    public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n+    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n-            YClass clazz;\n+            XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t versioned\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampName);\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampName);\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "90f70231c682e22693f85977497d2dc429ef29da": {
      "type": "Ybodychange",
      "commitMessage": "HHH-3570: renaming versioned to audited\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15459 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008-10-31, 7:42 a.m.",
      "commitName": "90f70231c682e22693f85977497d2dc429ef29da",
      "commitAuthor": "Adam Warski",
      "commitDateOld": "2008-10-29, 11:51 a.m.",
      "commitNameOld": "8cf6a823974ddfe74548da9913e0df7adf541ee8",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 1.83,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            YClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t versioned\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampName);\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampName);\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n    }",
      "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 157,
      "functionName": "configure",
      "diff": "@@ -1,68 +1,68 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n         Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n         boolean revisionEntityFound \u003d false;\n         RevisionInfoGenerator revisionInfoGenerator \u003d null;\n \n         Class\u003c?\u003e revisionInfoClass \u003d null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc \u003d classes.next();\n             YClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn\u0027t versioned\n-                if (clazz.getAnnotation(Versioned.class) !\u003d null) {\n+                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n                 }\n \n                 revisionEntityFound \u003d true;\n \n                 MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName \u003d pc.getEntityName();\n \n                 revisionInfoClass \u003d pc.getMappedClass();\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampName);\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping \u003d null;\n \n         if (revisionInfoGenerator \u003d\u003d null) {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampName);\n             revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dd35cf7b1461fc883148b148e5c81731d9c08a35": {
      "type": "Yfilerename",
      "commitMessage": "HHH-3351 : import envers as core module\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15434 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008-10-29, 11:17 a.m.",
      "commitName": "dd35cf7b1461fc883148b148e5c81731d9c08a35",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2008-10-29, 10:59 a.m.",
      "commitNameOld": "15ac9155d2798f5d797310a2fb5f67ef0809428e",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            YClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t versioned\n                if (clazz.getAnnotation(Versioned.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampName);\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampName);\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n    }",
      "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 161,
      "functionName": "configure",
      "diff": "",
      "extendedDetails": {
        "oldPath": "envers/src/main/java/org/jboss/envers/configuration/RevisionInfoConfiguration.java",
        "newPath": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java"
      }
    },
    "78e5d9fd89aa571f8ad5cf5b8a5046b9b74cb09b": {
      "type": "Yintroduced",
      "commitMessage": "HHH-3351 : import envers as core module\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15406 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008-10-27, 2:56 p.m.",
      "commitName": "78e5d9fd89aa571f8ad5cf5b8a5046b9b74cb09b",
      "commitAuthor": "Steve Ebersole",
      "diff": "@@ -0,0 +1,68 @@\n+    public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n+        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n+        boolean revisionEntityFound \u003d false;\n+        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n+\n+        Class\u003c?\u003e revisionInfoClass \u003d null;\n+\n+        while (classes.hasNext()) {\n+            PersistentClass pc \u003d classes.next();\n+            YClass clazz;\n+            try {\n+                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n+            } catch (ClassNotFoundException e) {\n+                throw new MappingException(e);\n+            }\n+\n+            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n+            if (revisionEntity !\u003d null) {\n+                if (revisionEntityFound) {\n+                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n+                }\n+\n+                // Checking if custom revision entity isn\u0027t versioned\n+                if (clazz.getAnnotation(Versioned.class) !\u003d null) {\n+                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n+                }\n+\n+                revisionEntityFound \u003d true;\n+\n+                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n+                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n+\n+                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n+\n+                if (!revisionNumberFound.isSet()) {\n+                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n+                            \"with @RevisionNumber!\");\n+                }\n+\n+                if (!revisionTimestampFound.isSet()) {\n+                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n+                            \"with @RevisionTimestamp!\");\n+                }\n+\n+                revisionInfoEntityName \u003d pc.getEntityName();\n+\n+                revisionInfoClass \u003d pc.getMappedClass();\n+                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                        revisionEntity.value(), revisionInfoTimestampName);\n+            }\n+        }\n+\n+        // In case of a custom revision info generator, the mapping will be null.\n+        Document revisionInfoXmlMapping \u003d null;\n+\n+        if (revisionInfoGenerator \u003d\u003d null) {\n+            revisionInfoClass \u003d DefaultRevisionEntity.class;\n+            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                    RevisionListener.class, revisionInfoTimestampName);\n+            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n+        }\n+\n+        return new RevisionInfoConfigurationResult(\n+                revisionInfoGenerator, revisionInfoXmlMapping,\n+                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n+                generateRevisionInfoRelationMapping(),\n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n        Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n        boolean revisionEntityFound \u003d false;\n        RevisionInfoGenerator revisionInfoGenerator \u003d null;\n\n        Class\u003c?\u003e revisionInfoClass \u003d null;\n\n        while (classes.hasNext()) {\n            PersistentClass pc \u003d classes.next();\n            YClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n\n            RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n\n                // Checking if custom revision entity isn\u0027t versioned\n                if (clazz.getAnnotation(Versioned.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n                }\n\n                revisionEntityFound \u003d true;\n\n                MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionNumber!\");\n                }\n\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                            \"with @RevisionTimestamp!\");\n                }\n\n                revisionInfoEntityName \u003d pc.getEntityName();\n\n                revisionInfoClass \u003d pc.getMappedClass();\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                        revisionEntity.value(), revisionInfoTimestampName);\n            }\n        }\n\n        // In case of a custom revision info generator, the mapping will be null.\n        Document revisionInfoXmlMapping \u003d null;\n\n        if (revisionInfoGenerator \u003d\u003d null) {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                    RevisionListener.class, revisionInfoTimestampName);\n            revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n        }\n\n        return new RevisionInfoConfigurationResult(\n                revisionInfoGenerator, revisionInfoXmlMapping,\n                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n                generateRevisionInfoRelationMapping(),\n                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n    }",
      "path": "envers/src/main/java/org/jboss/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 152,
      "functionName": "configure"
    }
  }
}